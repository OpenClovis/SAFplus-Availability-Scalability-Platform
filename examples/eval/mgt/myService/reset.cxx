/*
 * File reset.cxx
 * This file has been auto-generated by Y2CPP, the
 * plug-in of pyang.
 */

#include "MgtFactory.hxx"
#include "clMgtProv.hxx"
#include "clMgtContainer.hxx"
#include "clMgtRpc.hxx"
#include "clTransaction.hxx"
#include <string>
#include <boost/algorithm/string.hpp>
#include "myServiceCommon.hxx"
#include "MyServiceModule.hxx"
#include <cstdint>
#include <vector>
#include "reset.hxx"

extern void startHttpDaemon(int port);
extern void stopHttpDaemon(int port);
extern myService::MyServiceModule mgt;

namespace SAFplus
  {
  extern Handle           myHandle;
};

namespace myService
  {

    /* Apply MGT object factory */
    MGT_REGISTER_IMPL(reset, /myService/reset)

    reset::reset(): SAFplus::MgtRpc("reset"), port("port"), homeLocation("homeLocation")
    {
        this->addChildObject(&port, "port");
        this->addChildObject(&homeLocation, "homeLocation");
    };

    std::vector<std::string>* reset::getChildNames()
    {
        std::string childNames[] = { "port", "homeLocation" };
        return new std::vector<std::string> (childNames, childNames + sizeof(childNames) / sizeof(childNames[0]));
    };

    /*
     * XPATH: /myService/serviceCfg/port
     */
    ::uint16_t reset::getPort()
    {
        return this->port.value;
    };

    /*
     * XPATH: /myService/serviceCfg/port
     */
    void reset::setPort(::uint16_t portValue, SAFplus::Transaction &txn)
    {
        this->port.set(portValue,txn);
    };

    /*
     * XPATH: /myService/serviceCfg/homeLocation
     */
    std::string reset::getHomeLocation()
    {
        return this->homeLocation.value;
    };

    /*
     * XPATH: /myService/serviceCfg/homeLocation
     */
    void reset::setHomeLocation(std::string homeLocationValue, SAFplus::Transaction &txn)
    {
        this->homeLocation.set(homeLocationValue,txn);
    };

    ClRcT reset::doRpc(const std::string &attrs)
    {
        logInfo("APP","Reset","do RPC works, then reset the port %s", attrs.c_str());
        std::vector<std::string> strs;
        boost::split(strs, attrs, boost::is_any_of(","));
        //reset with the set port
        if (strs.size() <= 0)
          {
            uint16_t new_port = mgt.serviceCfg.getPort();
            uint16_t listening_port = getPort();
            if (new_port != listening_port)
              {
                stopHttpDaemon(listening_port);
                startHttpDaemon(new_port);
                setPort(new_port);
              }
          }
        else
          {
            for (auto attr : strs)
            {
              std::vector<std::string> s;
              boost::split(s, attr, boost::is_any_of("="));
              std::string key = s[0];
              std::string value = s[1];

              if (key == "port")
                {
                  uint16_t new_port = atoi(value.c_str());
                  if (new_port && new_port != getPort())
                    {
                      stopHttpDaemon(getPort());
                      startHttpDaemon(new_port);
                      setPort(new_port);
                      mgt.serviceCfg.setPort(new_port);
                    }
                }
            }
          }
        return CL_OK;
    }

    reset::~reset()
    {
    };

}
/* namespace ::reset */
