/******************************************************************************
 *
 * clProxyCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2008 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component.
 *
 * Template Version: 1.0
 *
 ***************************** Editor Commands ********************************
 * For vi/vim
 * :set shiftwidth=4
 * :set softtabstop=4
 * :set expandtab
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
 
#include <assert.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>
/*
 * Basic ASP Includes.
 */

#include <clCommon.h>

/*
 * ASP Client Includes.
 */

#include <clLogApi.h>

#include <clCpmApi.h>
#include <saAmf.h>

#include "./clProxyCompAppMain.h"

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This template has a few default clprintfs. These can be disabled by 
 * changing clprintf to a null function
 */

#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)
#define MAX_PATH_LEN 500

void userAppHealthCheckCb(SaInvocationT invocation, const SaNameT* compName, SaAmfHealthcheckKeyT* healthcheckKey);
void launchUserApp(const char* pathToApp);
//int isAppRunning(unsigned long thePid);
void sigchild_handler(int signum);
/******************************************************************************
 * Global Variables.
 *****************************************************************************/
char userAppProcessName[] = {"helloworld"};
char proxiedApp[] = {"proxiedI0"};
unsigned long userAppPid = 0;
pid_t mypid;
SaAmfHandleT amfHandle;

ClBoolT unblockNow = CL_FALSE;


/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/

/*
 * main
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

int main(int argc, char *argv[])
{
    SaNameT             appName = {0};
    SaAmfCallbacksT     callbacks;
    SaVersionT          version;
    ClIocPortT          iocPort;
    ClRcT               rc = SA_AIS_OK;

    SaSelectionObjectT dispatch_fd;
    fd_set read_fds;
    
    /*
     * Declare other local variables here.
     */

    
    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the version of
     * AMF with which this application would like to interface. 'callbacks'
     * is used to register the callbacks this component expects to receive.
     */

    version.releaseCode                         = 'B';
    version.majorVersion                        = 01;
    version.minorVersion                        = 01;
    
    //callbacks.saAmfHealthcheckCallback                    = userAppHealthCheckCb;
    callbacks.saAmfComponentTerminateCallback             = clCompAppTerminate;
    callbacks.saAmfCSISetCallback                         = clCompAppAMFCSISet;
    callbacks.saAmfCSIRemoveCallback                      = clCompAppAMFCSIRemove;
    callbacks.saAmfProtectionGroupTrackCallback           = NULL;
    callbacks.saAmfProxiedComponentInstantiateCallback    = clProxiedCompInstantiate;
    callbacks.saAmfProxiedComponentCleanupCallback        = clProxiedCompCleanup;
        
    /*
     * Get IOC Address, Port and Name. Register with AMF.
     */

    clEoMyEoIocPortGet(&iocPort);

    if ( (rc = saAmfInitialize(&amfHandle, &callbacks, &version)) != SA_AIS_OK) 
        goto errorexit;

    FD_ZERO(&read_fds);

    /*
     * Get the AMF dispatch FD for the callbacks
     */
    if ( (rc = saAmfSelectionObjectGet(amfHandle, &dispatch_fd)) != SA_AIS_OK)
        goto errorexit;
    
    FD_SET(dispatch_fd, &read_fds);
    
    /*
     * Do the application specific initialization here.
     */   
    /*int ret = prctl(PR_SET_PDEATHSIG, SIGUSR1);
    if (ret)
    {
    	clprintf (CL_LOG_SEV_ERROR, "prctl error [%d]", ret);
    }
    else
    	clprintf (CL_LOG_SEV_INFO, "prctl ok [%d]", ret);
    */
    /*
    SaNameT proxiedAppName;
    memcpy(&proxiedAppName.value, proxiedApp, strlen(proxiedApp));
    proxiedAppName.length = (int)strlen(proxiedApp)+1;
    SaAisErrorT saErr = saAmfHealthcheckStart(amfHandle, &proxiedAppName, NULL, SA_AMF_HEALTHCHECK_AMF_INVOKED, SA_AMF_NO_RECOMMENDATION);
    if (saErr != SA_AIS_OK)
    {
    	clprintf (CL_LOG_SEV_ERROR, "saAmfHealthCheckStart for user app failed. rc[%d]", saErr);
    }
    else
    {
    	clprintf (CL_LOG_SEV_INFO, "saAmfHealthCheckStart for user app OK");
    }    
    */
    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = saAmfComponentNameGet(amfHandle, &appName)) != SA_AIS_OK) 
        goto errorexit;
    if ( (rc = saAmfComponentRegister(amfHandle, &appName, NULL)) != SA_AIS_OK) 
        goto errorexit;

    /*
     * Print out standard information for this component.
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Initializing\n", appName.length, appName.value, mypid);
    clprintf (CL_LOG_SEV_INFO, "   IOC Address             : 0x%x\n", clIocLocalAddressGet());
    clprintf (CL_LOG_SEV_INFO, "   IOC Port                : 0x%x\n", iocPort);

    /*
     * Block on AMF dispatch file descriptor for callbacks
     */
    do
    {
        if( select(dispatch_fd + 1, &read_fds, NULL, NULL, NULL) < 0)
        {
            clprintf (CL_LOG_SEV_ERROR, "Error in select()");
            perror("");
            break;
        }
        clprintf (CL_LOG_SEV_INFO, "Calling saAmfDispatch\n");
        saAmfDispatch(amfHandle, SA_DISPATCH_ALL);
    }while(!unblockNow);      

    /*
     * Do the application specific finalization here.
     */

    
    if((rc = saAmfFinalize(amfHandle)) != SA_AIS_OK)
    {
        clprintf (CL_LOG_SEV_ERROR, "AMF finalization error[0x%X]", rc);
    }

    clprintf (CL_LOG_SEV_INFO, "AMF Finalized");
    
    return 0;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%.*s] : PID [%d]. Initialization error [0x%x]\n",
              appName.length, appName.value, mypid, rc);

    return -1;
}


/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

void
clCompAppTerminate(
    SaInvocationT       invocation,
    const SaNameT       *compName)
{
    SaAisErrorT rc = SA_AIS_OK;

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Terminating\n",
              compName->length, compName->value, mypid);
    /*
     * Application should figure out whether the termination request
     * was for the proxy itself or one of its proxied components.
     * 
     * In case the termination request was for a proxied component,
     * call the proxied specific termination function and unregister 
     * the proxied component. 
     * Otherwise, unregister the proxy component and 
     * call the client finalize function.
     */

        
    /*
     * Unregister with AMF and send back a response
     */

    if ( (rc = saAmfComponentUnregister(amfHandle, compName, NULL)) != SA_AIS_OK)
        goto errorexit;

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Terminated\n", compName->length, compName->value, mypid);

    unblockNow = CL_TRUE;
    
    return;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%.*s] : PID [%d]. Termination error [0x%x]\n",
              compName->length, compName->value, mypid, rc);

    return;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 */

ClRcT
clCompAppStateChange(
    ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            
            break;
        }

        case CL_EO_STATE_RESUME:
        {
            
            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT
clCompAppHealthCheck(
    ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The defaults
     * indicate EO is healthy and polling interval is unaltered.
     */

    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;

    
    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

void
clCompAppAMFCSISet(
    SaInvocationT       invocation,
    const SaNameT       *compName,
    SaAmfHAStateT       haState,
    SaAmfCSIDescriptorT csiDescriptor)
{
    
    /*
     * Print information about the CSI Set
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. CSI Set Received\n", 
              compName->length, compName->value, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case CL_AMS_HA_STATE_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
#if 1
            char* aspDir = getenv("ASP_DIR");
            char pathToApp[256];            
            if (aspDir)
            {
            	//signal(SIGCHLD, catch_child);
            	snprintf(pathToApp, 255, "%s/bin/%s", aspDir, userAppProcessName);
            	launchUserApp(pathToApp);
            }  
#endif
            //sleep(5);
            //userAppPid = getPid(userAppProcessName, NULL);
            //clprintf (CL_LOG_SEV_INFO,"CSISetCB: userAppPid [%lu]", userAppPid);
            break;
        }

        case CL_AMS_HA_STATE_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */
            
            
        	saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */

            
        	saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */

            
            saAmfCSIQuiescingComplete(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        default:
        {
            assert(0);
            break;
        }
    }

    return;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

void
clCompAppAMFCSIRemove(
    SaInvocationT       invocation,
    const SaNameT       *compName,
    const SaNameT       *csiName,
    SaAmfCSIFlagsT      csiFlags)
{
    /*
     * Print information about the CSI Remove
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. CSI Remove Received\n", 
              compName->length, compName->value, mypid);

    clprintf (CL_LOG_SEV_INFO, "   CSI                     : %.*s\n", csiName->length, csiName->value);
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : 0x%d\n", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    
    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;
}


/******************************************************************************
 * LCM functions for Proxied Components to be invoked on Proxy.
 * These are applicable only for a Proxy Component
 *****************************************************************************/

/*
 * clProxiedCompInstantiate
 * -------------------------
 * This function is invoked on a proxy component to instantiate the proxied 
 * components which are being proxied by this proxy.
 */

void
clProxiedCompInstantiate(
    SaInvocationT       invocation,
    const SaNameT       *proxiedCompName)
{
    SaNameT appName;
    ClRcT               rc = SA_AIS_OK; 

    /*
     * Add code for proxied component instatiation below. 
     * The code is specific to proxied component being instantiated 
     * and is defined by the protocol/interface between proxy and 
     * proxied component.
     */
#if 0
    char* aspDir = getenv("ASP_DIR");
    char pathToApp[256];
    if (aspDir)
    {
       	//signal(SIGCHLD, catch_child);
       	snprintf(pathToApp, 255, "%s/bin/%s", aspDir, userAppProcessName);
       	launchUserApp(pathToApp);
    }
#endif
    clprintf (CL_LOG_SEV_INFO, "clProxiedCompInstantiate: compName [%s]", proxiedCompName->value);

    /*
     * If the instantiation of the proxied component was successful,
     * then register the proxied component with the AMF.
     */

    if ( (rc = saAmfComponentNameGet(amfHandle, &appName)) != SA_AIS_OK) 
        goto errorexit;
    if ( (rc = saAmfComponentRegister(amfHandle, proxiedCompName, &appName)) != SA_AIS_OK) 
        goto errorexit;

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%.*s] : PID [%d]. Initialization error [0x%x]\n",
              appName.length, appName.value, mypid, rc);

    return;
}



/*
 * clProxiedCompCleanup
 * -------------------------
 * This function is invoked on a proxy component to cleanup the proxied 
 * components which are being proxied by this proxy.
 */

void
clProxiedCompCleanup(
    SaInvocationT       invocation,
    const SaNameT       *proxiedCompName)
{
    /*
     * Add code for cleaning up the proxied component below. 
     * The code is specific to proxied component for which the clean up 
     * request has been made and is defined by the protocol/interface 
     * between proxy and proxied component.
     */
	clprintf (CL_LOG_SEV_INFO, "clProxiedCompCleanup: compName [%s]", proxiedCompName->value);
    
    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;
}



/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

void clCompAppAMFPrintCSI(SaAmfCSIDescriptorT csiDescriptor,
                           SaAmfHAStateT haState)
{
    clprintf (CL_LOG_SEV_INFO,
              "CSI Flags : [%s]",
              STRING_CSI_FLAGS(csiDescriptor.csiFlags));

    if (SA_AMF_CSI_TARGET_ALL != csiDescriptor.csiFlags)
    {
        clprintf (CL_LOG_SEV_INFO, "CSI Name : [%s]", 
                  csiDescriptor.csiName.value);
    }

    if (SA_AMF_CSI_ADD_ONE == csiDescriptor.csiFlags)
    {
        ClUint32T i = 0;
        
        clprintf (CL_LOG_SEV_INFO, "   Name Value Pairs        : \n");
        for (i = 0; i < csiDescriptor.csiAttr.number; i++)
        {
            clprintf (CL_LOG_SEV_INFO, "Name : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrName);
            clprintf (CL_LOG_SEV_INFO, "Value : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrValue);
        }
    }
    
    clprintf (CL_LOG_SEV_INFO, "HA state : [%s]",
              STRING_HA_STATE(haState));

    if (SA_AMF_HA_ACTIVE == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Active Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Transition Descriptor : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.transitionDescriptor);
        clprintf (CL_LOG_SEV_INFO,
                  "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.activeCompName.value);
    }
    else if (SA_AMF_HA_STANDBY == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Standby Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Standby Rank : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.standbyRank);
        clprintf (CL_LOG_SEV_INFO, "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.activeCompName.value);
    }

}
#if 0
void userAppHealthCheckCb(SaInvocationT invocation, const SaNameT* compName, SaAmfHealthcheckKeyT* healthcheckKey)
{
	clprintf (CL_LOG_SEV_INFO, "userAppHealthCheckCb [%s]", compName->value);
	if (isAppRunning(userAppPid))	
	{
		clprintf (CL_LOG_SEV_INFO, "userAppHealthCheckCb: process [%lu] is up", userAppPid);
		saAmfResponse(amfHandle, invocation, SA_AIS_OK);
	}
	else
	{
		clprintf (CL_LOG_SEV_INFO, "userAppHealthCheckCb: process [%lu] is down. Quit the app by assert(0)", userAppPid);
		//saAmfResponse(amfHandle, invocation, SA_AIS_ERR_UNAVAILABLE);
		//kill(userAppPid, SIGTERM);
		//assert(0);
	}
}
#endif
void launchUserApp(const char* pathToApp)
{	
	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = sigchild_handler;
	sigaction(SIGCHLD, &sa, NULL);
	pid_t pid = fork();
	if (pid == 0) // child process
	{
		clprintf (CL_LOG_SEV_INFO, "This is child process, launching user app[%s]", pathToApp);
		//prctl(PR_SET_PDEATHSIG, SIGKILL);
		execl(pathToApp, pathToApp, (char*)0);
		//printf("from child: errno [%d]; errmsg [%s]\n", errno, strerror(errno));
		clprintf (CL_LOG_SEV_INFO, "Fail to launch user app. ErrNo=%d", errno);
	}
	else if (pid > 0)
	{
		clprintf (CL_LOG_SEV_INFO, "This is parent process, do nothing");
		userAppPid = pid;
		clprintf (CL_LOG_SEV_INFO, "Child pid [%lu]", userAppPid);
	}	
	else
	{
		clprintf (CL_LOG_SEV_ERROR, "Fork fail");
	}
}

#if 0
int isAppRunning(unsigned long thePid)
{	
	if (thePid > 0)
	{
		//test to see if this pid is valid, which means its process is alive; otherwise, it died 
		kill(thePid, 0);
		if (errno == ESRCH)
		{
			clprintf(CL_LOG_SEV_INFO, "isAppRunning(): pid [%lu] is invalid", thePid);
			return 0;
		}			
		return 1;
	}	
	return 0;
}
#endif
void sigchild_handler(int signum)
{
	pid_t p;
	int status;
	while((p = waitpid(-1, &status, WNOHANG)) != -1)
	{
		if (p == userAppPid)
		{
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WIFEXITED(status)=%d", WIFEXITED(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WIFSIGNALED(status)=%d", WIFSIGNALED(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WTERMSIG(status)=%d", WTERMSIG(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WCOREDUMP(status)=%d", WCOREDUMP(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WIFSTOPPED(status)=%d", WIFSTOPPED(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WSTOPSIG(status)=%d", WSTOPSIG(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WIFCONTINUED(status)=%d", WIFCONTINUED(status));
			clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): WEXITSTATUS(status)=%d", WEXITSTATUS(status));
			
			if (signum == SIGCHLD)
			{
				clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): received SIGCHLD");
				clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): user app terminated. The main app is AUTOMATICALLY terminated, too");
			}
			else
			{
				clprintf(CL_LOG_SEV_INFO, "sigchild_handler(): signum [%d]", signum);			
			}
			break;
		}
	}
}
