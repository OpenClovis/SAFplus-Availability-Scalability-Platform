#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <clCommon.h>
#include <clOsalApi.h>
#include <clOsalErrors.h>
#include <clBufferApi.h>
#include <clCntApi.h>
#include <clHeapApi.h>
#include <clEoApi.h>
#include <clIocApi.h>
#include <clIocApiExt.h>
#include <clIocErrors.h>
#include <clIocParseConfig.h>
#include <clIocLogicalAddresses.h>
#include "rmdExternalDefs.h"
#include "alarmClockLog.h"
#include "clRmdIpi.h"


#define __LOGICAL_ADDRESS(a) CL_IOC_LOGICAL_ADDRESS_FORM(CL_IOC_STATIC_LOGICAL_ADDRESS_START + (a))
#define __RPC_SERVER_ADDRESS __LOGICAL_ADDRESS(4)
#define LOCAL_ADDRESS 4
extern ClRcT clRmdLibInitialize(ClPtrT pConfig);
extern ClBoolT gIsNodeRepresentative;
static ClIocConfigT *gpClIocConfig;
extern ClInt32T clAspLocalId;
extern ClHeapConfigT *pHeapConfigUser;
static ClHeapConfigT heapConfig;
static ClEoMemConfigT memConfig;
static void
testEvtMainLoop();
static ClRcT clMemInitialize(void)
{
    ClRcT rc;

    if((rc = clMemStatsInitialize(&memConfig)) != CL_OK)
    {
        return rc;
    }
    pHeapConfigUser =  &heapConfig;
    if((rc = clHeapInit()) != CL_OK)
    {
        return rc;
    }
    return CL_OK;
}

ClRcT
Initialize ( ClInt32T ioc_address_local )
{
    ClRcT rc = CL_OK;    
    clAspLocalId = ioc_address_local;
    rc = clIocParseConfig(NULL, &gpClIocConfig);
    if(rc != CL_OK)
    {
        clOsalPrintf("Error : Failed to parse clIocConfig.xml file. error code = 0x%x\n",rc);
        exit(1);
    }

    if ((rc = clOsalInitialize(NULL)) != CL_OK)
    {
        printf("Error: OSAL initialization failed\n");
        return rc;
    }
    if ((rc = clMemInitialize()) != CL_OK)
    {
        printf("Error: Heap initialization failed\n");
        return rc;
    }
    if ((rc = clTimerInitialize(NULL)) != CL_OK)
    {
        printf("Error: Timer initialization failed\n");
        return rc;
    }
    if ((rc = clBufferInitialize(NULL)) != CL_OK)
    {
        printf("Error: Buffer initialization failed\n");
        return rc;
    }
    return rc;
}

int
main(int argc, char **argv)
{

    ClEoConfigT eoConfig =
    {
        CL_OSAL_THREAD_PRI_MEDIUM,    /* EO Thread Priority                       */
        2,                            /* No of EO thread needed                   */
        0,                            /* Required Ioc Port                        */
        (CL_EO_USER_CLIENT_ID_START + 0), 
        CL_EO_USE_THREAD_FOR_APP,     /* Thread Model                             */
        NULL,                         /* Application Initialize Callback          */
        NULL,                         /* Application Terminate Callback           */
        NULL,                         /* Application State Change Callback        */
        NULL                          /* Application Health Check Callback        */
    };    
    int ioc_address_local = LOCAL_ADDRESS;
    extern ClIocConfigT pAllConfig;
    int socket_type;
    ClRcT rc = CL_OK;
    socket_type = CL_IOC_RELIABLE_MESSAGING;
    heapConfig.mode = CL_HEAP_NATIVE_MODE;
    memConfig.memLimit = 0;
    rc = Initialize( ioc_address_local );
    if (rc != CL_OK)
    {
        printf("Error: failed to Initialize ASP libraries\n");
        exit(1);
    }
    pAllConfig.iocConfigInfo.isNodeRepresentative = CL_TRUE;
    gIsNodeRepresentative = CL_TRUE;
    if ((rc = clIocLibInitialize(NULL)) != CL_OK)
    {
        printf("Error: IOC initialization failed with rc = 0x%x\n", rc);
        exit(1);
    }
    if ((rc = clRmdLibInitialize(NULL)) != CL_OK)
    {
        printf("Error: RMD initialization failed with rc = 0x%x\n", rc);
        exit(1);
    }
    printf("Info: start rmd server\n");

    rc = rmdSeverInit(eoConfig);

    if(rc != CL_OK)
    {
        printf("Info: start rmd server ok\n");
    }
    else
    {
        sleep(10);
        rc = saEvtInitialize(&gTestInfo.evtInitHandle,
                       &evtCallbacks,
                       &gTestInfo.evtVersion);
        if (rc != SA_AIS_OK)
        {
        printf( "Failed to init event system[0x%x]\n",rc);
        return rc;
        }
    
        // Open an event channel so we can publish our events.
        rc = saEvtChannelOpen (gTestInfo.evtInitHandle,
                             &gTestInfo.evtChannelName,
                            (SA_EVT_CHANNEL_PUBLISHER |
                             SA_EVT_CHANNEL_CREATE),
                             (ClTimeT)SA_TIME_END,
                             &evtChannelHandle);
        if (rc != SA_AIS_OK)
        {
            printf( "Failed to open event channel [0x%x]\n",rc);
            return rc;
        }

        rc = saEvtEventAllocate(evtChannelHandle, &gTestInfo.eventHandle);
        if (rc != SA_AIS_OK)
        {
            printf( "%s\t:Failed to cllocate event [0x%x]\n",rc);
            return rc;
        }

        rc = saEvtEventAttributesSet(gTestInfo.eventHandle,
                NULL,
                1,
                0,
                &gTestInfo.publisherName);
        if (rc != SA_AIS_OK)
        {
            printf( "%s\t:Failed to set event attributes [0x%x]\n",rc);
            return rc;
        }
    testEvtMainLoop();
    }    
    do
    {
        sleep(20);
        printf("Info : running ....");
    }while(1);

}
static void
generate_time_of_day(char **data, ClSizeT *data_len)
{
    time_t t;

    // minimal error checking
    if (data == 0 || data_len == 0)
    {
        clprintf(CL_LOG_SEV_ERROR,
                "%s\t: generate_time_of_day passed null pointer\n", appname);
        return;
    }

    // magic number, but well, that's what ctime_r needs
    *data_len = 26;
    *data = (char*)clHeapAllocate(*data_len);
    if (*data == 0)
    {
        *data_len = 0;
        return;
    }
    time(&t);
    ctime_r(&t, *data);
    *(*data + 24) = 0;
    (*data_len) -= 1;
    return;
}

static void
generate_load_average(char **data, ClSizeT *data_len)
{
    int fd;
    char *tmp_ptr;
    char buf[500];                  //insane over doing it
    ssize_t num_read;

    // minimal error checking
    if (data == 0 || data_len == 0)
    {
        clprintf(CL_LOG_SEV_ERROR,
                "%s\t: generate_load_average passed null pointer\n ", appname);
        return;
    }

    // Now open the load average file in /proc, read the file into a local
    // buffer, allocate memory to hold the file contents, copy the contents
    // of the file into the newly allocated buffer.
    if ((fd = open("/proc/loadavg", O_RDONLY, 0)) == -1)
    {
        clprintf(CL_LOG_SEV_ERROR, "%s\t: failed to open /proc/loadavg\n", appname);
        return;
    }
    num_read = read(fd, buf, sizeof buf);
    if (num_read == 0 || num_read == -1)
    {
        clprintf(CL_LOG_SEV_ERROR, "%s\t: bogus result from read of loadavg\n",
                appname);
        return;
    }
    close(fd);
    *data_len = num_read + 1;
    *data = (char*)clHeapAllocate(*data_len);
    if (data == 0)
    {
        clprintf(CL_LOG_SEV_ERROR,
                "%s: failed to allocate memory for loadavg contents\n",
                appname);
        *data_len = 0;
        close(fd);
        return;
    }
    *(*data + (*data_len) - 1) = 0;     // preemptively null-terminate the line
    strncpy(*data, buf, *data_len);

    //
    // Do MINIMAL parsing in that we look for the third space in the buffer
    // (which comes after the load average information proper) and we replace
    // the space with a nul character to terminate the string.
    // If there is no third space character, just return the buffer unchanged.
    tmp_ptr = strchr(*data, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    tmp_ptr = strchr(tmp_ptr + 1, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    tmp_ptr = strchr(tmp_ptr + 1, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    *tmp_ptr = 0;
    return;
}


static ClRcT
appPublishEvent()
{
    ClEventIdT      eventId         = 0;
    static int      index           = 0;
    SaSizeT         data_len        = 0;
    SaAisErrorT	    saRc = SA_AIS_OK;
    char            *data           = 0;
    typedef void (*Generator)(char **, ClSizeT*);

    //
    // Note: to add a new generator, just define it above and then include
    // the new functions name in the generators list.
    // Next, maybe something that gets disk free info by way of getfsent
    // and statfs?
    static Generator generators[]   =
    {
        generate_time_of_day,
        generate_load_average
    };

    //
    // every time through increment index and then set index to
    // it's value modulo the number of entries in the generators
    // array.  This will cause us to cycle through the list of
    // generators as we're called to publish events.
    (*generators[index++])(&data, &data_len);
    index %= (int)(sizeof generators / sizeof generators[0]);
    if (data == 0 || data_len == 0)
    {
        logmsg(CL_LOG_ERROR, "%s: no event data generated\n", appname);
        return CL_ERR_NO_MEMORY;
    }
    printf("Publishing Event: %.*s\n", (int)data_len, data);
    saRc = saEvtEventPublish(gTestInfo.eventHandle, (void *)data, data_len, &eventId);
    clHeapFree(data);

    return CL_OK;
}

static void
testEvtMainLoop()
{
    
    printf("Waiting for CSI assignment...\n");
    /* Main loop: Keep printing and publishing unless we are suspended */
    while (1)
    {
        appPublishEvent();        
        sleep(10);
    }

    /* Letting the world know that we exited from mainloop */
    logmsg(CL_LOG_DEBUG, "%s exited main loop", appname);

    return NULL;
}    
