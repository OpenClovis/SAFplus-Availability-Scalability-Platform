/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "alarm_clock_EOAlarmClockopServer.h"
#include "alarm_clock_EOServer.h"

ClHandleDatabaseHandleT  alarm_clock_EOidlDatabaseHdl = 0;
ClUint32T                alarm_clock_EOidlSyncKey     = 0;



ClRcT GetTimeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    acTimeT_4_0_0  current;

    memset(&(current), 0, sizeof(acTimeT_4_0_0));


    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(alarm_clock_EOidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = GetTime_4_0_0(&(current));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallacTimeT_4_0_0(&(current), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

L1:    return rc;


    return rc;


L0:  clXdrMarshallacTimeT_4_0_0(&(current), 0, 1);

    return rc;
}

ClRcT GetTimeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  acTimeT_4_0_0  current)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(alarm_clock_EOidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallacTimeT_4_0_0(&(current), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L1:  clXdrMarshallacTimeT_4_0_0(&(current), 0, 1);

    clHandleCheckin(alarm_clock_EOidlDatabaseHdl, idlHdl);
    clHandleDestroy(alarm_clock_EOidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(alarm_clock_EOidlDatabaseHdl, idlHdl);
    clHandleDestroy(alarm_clock_EOidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT SetTimeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    acTimeT_4_0_0  time;

    memset(&(time), 0, sizeof(acTimeT_4_0_0));


    rc = clXdrUnmarshallacTimeT_4_0_0( inMsgHdl,&(time));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(alarm_clock_EOidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = SetTime_4_0_0(time);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L1:    return rc;

LL0:  clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);

    return rc;

L0:  clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);


    return rc;
}

ClRcT SetTimeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(alarm_clock_EOidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(alarm_clock_EOidlDatabaseHdl, idlHdl);
    clHandleDestroy(alarm_clock_EOidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT SetAlarmServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    alarmReactionT_4_0_0  effect;
    acTimeT_4_0_0  time;

    memset(&(effect), 0, sizeof(alarmReactionT_4_0_0));
    memset(&(time), 0, sizeof(acTimeT_4_0_0));


    rc = clXdrUnmarshallalarmReactionT_4_0_0( inMsgHdl,&(effect));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallacTimeT_4_0_0( inMsgHdl,&(time));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(alarm_clock_EOidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = SetAlarm_4_0_0(effect, time);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallalarmReactionT_4_0_0(&(effect), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);
LL0:  clXdrMarshallalarmReactionT_4_0_0(&(effect), 0, 1);

    return rc;

L0:  clXdrMarshallalarmReactionT_4_0_0(&(effect), 0, 1);
L1:  clXdrMarshallacTimeT_4_0_0(&(time), 0, 1);


    return rc;
}

ClRcT SetAlarmResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(alarm_clock_EOidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(alarm_clock_EOidlDatabaseHdl, idlHdl);
    clHandleDestroy(alarm_clock_EOidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

