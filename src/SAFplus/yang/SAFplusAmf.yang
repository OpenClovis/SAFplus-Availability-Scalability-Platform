// To generate code use: /code/git/mgt/3rdparty/pyang/bin/pyang --path=`pwd` -f y2cpp /code/git/SAFplus7/src/SAFplus/yang/SAFplusAmf.yang --y2cpp-output ~/tmp/ --y2cpp-mgt /code/git/mgt

module SAFplusAmf 
  {

  namespace "http://www.openclovis.org/ns/amf";
  prefix "SAFplusAmf";
  import ietf-yang-types { prefix "iyt"; }
  import SAFplusTypes { prefix "safplus"; }
  import ENTITY-STATE-TC-MIB { prefix "entity-state"; }

  organization
        "OpenClovis Solutions, Inc";

  contact
        "Andrew Stone <stone@openclovis.com>";

  description
        "Configuration and Statistics for the SAFplus Availability Management Service.  This document is released under the GNU General Public License V2.0 or OpenClovis Commerical license.";

  revision 2014-03-03 
    {
        description "Initial description";
        reference "Note, some of the description text is sourced from the Service Availability Forum Application Interface Specification document SAI-AIS-AMF-B.04.01.  The SAI-AIS-AMF document is released under the Artistic License 2.0 and within the context of this license this document can be considered a modified version.  This document adheres to Artistic License provision 4.b, allowing distribution of modified versions so long as the modified version bears a different name and does not prevent installation of the standard version.";
    }

    grouping EntityId
    {
      leaf name
      {
	type string ;
	description "Unique name of this entity";
      }

      leaf id
      {
	type uint16;
	description "Each SAFplus AMF entity gets a unique numerical identifier";

      }
    }

  
    grouping EscalationPolicy
    {
      leaf maximum
      {
	type uint64;
	description "The maximum number of events that can occur within that time period before escalation occurs.";
	safplus:ide "Number of events: ";
      }
      leaf duration
      {
	type safplus:SaTimeT;
	description "The time period (in milliseconds) involved.";
	safplus:ide "within time: ";
      }
    }

    grouping Capacity
    {
	leaf resource
	{
	  type string;
	}
	leaf value
	{
	  type int64;
	}      
    }

    typedef PresenceState
    {
      type enumeration
      {
	enum uninstantiated;
	enum instantiating;
	enum instantiated;
	enum terminating;
	enum restarting;
	enum instantiationFailed;
	enum terminationFailed;
      }
      default "uninstantiated";
    }

    typedef ReadinessState
    {
      description "This state indicates if a service unit is eligible to
take service instance assignments from an administrative and health status view-
point.  The operational, administrative, and presence states of a service unit, the operational state of its containing node, and the administrative states of its containing node, service group, application, and the cluster are combined to form this state.";
      type enumeration
      {
	enum outOfService;
        enum inService;
        enum stopping;
      }
      default outOfService;
    }

    typedef HighAvailabilityReadinessState
    {
      description "The HA readiness state is not used to reflect a failure of the component, but rather to reflect situations in which a healthy component is not ready to assume a particular assignment for a component service instance, either because the component is not in an internal state required for the assignment, or because some resources on which the assignment depends are not available.  If a component receives a new component service instance assignment request (see SaAmfCSISetCallbackT) for which it is not ready, it must set its HA readiness state for this component service instance accordingly (by invoking the saAmfHAReadinessStateSet() function), before it responds to the assignment request with the SA_AIS_ERR_NOT_READY error (by invoking the saAmfResponse_4() function) to prevent the Availability Management Framework from treating the error as a component failure.";
      type enumeration
      {
	enum readyForAssignment;
        enum readyForActiveDegrated;
        enum notReadyForActive;
        enum notReadyForAssignment;
      }
      default notReadyForAssignment;
    }



    typedef HighAvailabilityState
    {
      type enumeration
      {
	enum active
	{
	  description "The service unit is currently responsible for providing the service characterized by this service instance.";
	}
	enum standby
	{
	  description "The service unit acts as a standby for the service characterized by this service instance.";
	}
	enum quiescing
	{
	  description "This entity is in the process of stopping its active or standby activity.  This is a transitional state; when completed it will automatically change to idle.";
	}
	enum idle
	{
	  description "SA-Forum 'quiesced': this entity has no high availability assignments.";
	}
      }
    }


    typedef AdministrativeState
    {
      type enumeration
      {
        enum off
          {
	    safplus:alias "lockedInstantiation";
            description "SA-Forum 'lockedInstantiation': the administrator has prevented the service unit from being instantiated by the Availability Management Framework.";
	    value 0; 
	  }
        enum idle 
	{ 
	  safplus:alias "locked";
	  value 1;
	  description "SA-Forum 'locked': the administrator has prevented the service unit from taking service instance assignments.";
	}
        enum on
	{ 
	  safplus:alias "unlocked";
	  value 2;
	  description "SA-Forum 'unlocked': the service unit has not been directly prohibited from taking service instance assignments by the administrator.";
	}
      }
      default "on";  
    }

    
    grouping execution
    {
      leaf command
      {
	type string;
	description "Specify both name of the binary here";
	safplus:ide "Command: ";
	default "";
      }
      leaf args
      {
	type string;
	description "Specify the arguments as if you are writing them on the command line";
	safplus:ide "Arguments: ";
	default "";
      }
      leaf timeout
      {
	type uint64;
	description "The maximum time this operation should take before the AMF receives a response or the command completes.  Specified in milliseconds.";
	safplus:ide "Maximum Time: ";
	default 120000;
      }
    }
  
    // done
    list Cluster
    {
      key "name";
      uses EntityId;
      description "";
      // SA-Forum defined fields
      leaf adminState
      {
        type AdministrativeState;
	safplus:ide "Initial state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }
      leaf startupAssignmentDelay
      {
	safplus:alias saAmfClusterStartupTimeout; 
	type safplus:SaTimeT;
	description "When the cluster is first started, no work will be assigned until either ALL configured service units are instantiated or this time duration elapses.  By giving every node a chance to come up fully, this ensures that initial work assignments are as close as possible to preferred work assignments.";
      }
    }

    // done per spec
    list Node
    {
      key "name";
      uses EntityId;
      // SA-Forum defined fields
      leaf adminState
      {
        type AdministrativeState;
	safplus:ide "Initial node state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }
      leaf operState
      {
	type boolean;
	description "True is enabled, False is disabled.  To move from False to True a 'repair' action must occur.";
        config false;
      }

      list capacity
      {
        key "resource";
	leaf resource
	{
	  type string;
	}
	leaf value
	{
	  type int64;
	}
	description "An abstract definition of the amount of work this node can handle.  Nodes can be assigned capacities for arbitrarily chosen strings (MEM or CPU, for example).  Service Instances can be assigned 'weights' and the sum of the weights of service instances assigned active or standby on this node cannot exceed these values.";
      }

      container serviceUnitFailureEscalationPolicy
      {
	uses EscalationPolicy;
	description "The maximum Service Unit failure rate allowed before this node is faulted";
	safplus:ide-group "Service Unit Failure Escalation Policy";
      }

      leaf autoRepair
      {
	type boolean;
	safplus:ide "Auto-repair: ";
	description "Automatically attempt to bring this entity back into a healthy state if its operational state becomes disabled.";
      }
      leaf failFastOnInstantiationFailure
      {
	type boolean;
	description "If a component fails to instantiate on this node after potentially multiple attempts (as configured in the component) the AMF will reboot this node if this field is true";
	safplus:ide "Reboot node if component instantiation repeatedly fails? ";
      }
      leaf failFastOnCleanupFailure
      {
	type boolean;
	description "If a component's cleanup script fails on this node after potentially multiple attempts (as configured in the component) the AMF will reboot this node if this field is true";
	safplus:ide "Reboot node if component cleanup repeatedly fails? ";
      }
      
    }


    list ServiceGroup
    {
      key "name";
      uses EntityId;
      description "A Service Group is a Service Availability Forum defined concept that corresponds to a group of redundant processes that should fail over as a unit.";
 
      // SA-Forum defined fields
      leaf adminState
      {
        type AdministrativeState;
	safplus:alias saAmfSGAdminState;
	safplus:ide "Initial state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }

      // saAmfSGType { type string; }
      // saAmfSGSuHostNodeGroup { type string; }

      leaf autoRepair
      {
	type boolean;
	safplus:alias saAmfSGAutoRepair;
	safplus:ide "Auto-repair: ";
	description "Automatically attempt to bring this entity back into a healthy state if its operational state becomes disabled.  A 'false' value will cause the system to wait for operator intervention (via the repair API) before attempting to restart this entity.";
      }

      leaf autoAdjust
      {
	type boolean;
	safplus:alias saAmfSGAutoAdjust;
	safplus:ide "Auto-adjust: ";
        description "Match this service group as closely as possible to the preferred high availability configuration.  For example, if the preferred active comes online, 'fail-back' to it.  Another example is if a new work assignment is provisioned, the system could remove an existing standby assignment so the new active can be provisioned.";
      }
      leaf autoAdjustInterval
      {
	type safplus:SaTimeT;
	safplus:alias saAmfSGAutoAdjustProb;
	description "The time between checks to see if adjustment is needed.";
      }

      leaf preferredNumActiveServiceUnits
      {
	safplus:alias saAmfSGNumPrefActiveSUs;
	safplus:ide "Active: ";
	type uint32;
	description "";
      }
      leaf preferredNumStandbyServiceUnits
      {
	safplus:alias saAmfSGNumPrefStandbySUs;
	safplus:ide "Standby: ";
	type uint32;
	description "";
      }
      leaf preferredNumIdleServiceUnits
      {
	safplus:ide "Idle: ";
	type uint32;
	description "An idle service unit is running but is not assigned active or standby.  This concept is functionally equivalent to the saAmfSGNumPrefInserviceSUs since Active+Standby+Idle = Inservice";
      }

      // saAmfSGNumPrefAssignedSUs = preferredNumActiveServiceUnits + preferredNumStandbyServiceUnits so the field is unnecessary
      
      leaf maxActiveWorkAssignments
      {
	safplus:ide "Active workload: ";
	safplus:alias saAmfSGMaxActiveSIsperSU;
	type uint32;
	description "The maximum number of active work assignments that can be placed on a single service unit (and therefore component/process) simultaneously.";
      }
      leaf maxStandbyWorkAssignments
      {
	safplus:ide "Standby workload: ";
	safplus:alias saAmfSGMaxStandbySIsperSU;
	type uint32;
	description "The maximum number of standby work assignments that can be placed on a single service unit (and therefore component/process) simultaneously.";
      }

      container componentRestart
      {
	safplus:ide-group "Component fault escalation policy: ";
	uses EscalationPolicy;
	description "";
      }

      container serviceUnitRestart
      {
	safplus:ide-group "Service Unit fault escalation policy: ";
	uses EscalationPolicy;
	description "";
      }

     leaf-list serviceUnits
     {
       safplus:alias saAmfCompCurrProxiedNames;
       safplus:c-type "SAFplusAmf::ServiceUnit*";
       type instance-identifier;
       description "This component is the proxy for the components listed here.";
     }
      
      container numAssignedServiceUnits
      {
	safplus:alias saAmfSGNumCurrAssignedSUs;
	uses safplus:intStatistic;
        config false;
      }
      container numIdleServiceUnits
      {
	safplus:alias saAmfSGNumCurrInstantiatedSpareSUs;
	uses safplus:intStatistic;
        config false;	
      }	
      container numSpareServiceUnits
      {
	safplus:alias saAmfSGNumCurrNonInstantiatedSpareSUs;
	uses safplus:intStatistic;
        config false;	
      }	
      
     
    }

    list Component
    {
      key "name";
      description "";
      uses EntityId;
      leaf presence
      {
	type PresenceState;
        config false;
      }
 
      // No adminState; this is controlled by the ServiceUnit


      // SA-Forum defined fields

      leaf capabilityModel
      {
	type enumeration
	{
	  enum x_active_and_y_standby
	  {
	    description "For a certain component service type, the component supports all values of the HA state, and it can have the active HA state for x component service instances and the standby HA state for y component service instances at a time.";
	  }
	  enum x_active_or_y_standby
	  {
	    description "For a certain component service type, the component supports all values of the HA state. It can be assigned either the active HA state for x component service instances or the standby HA state for y component service instances at a time.";
	  }
	  enum one_active_or_y_standby
	  {
	    description "For a certain component service type, the component supports all values of the HA state. It can be assigned either the active HA state for only one component service instance or the standby HA state for y component service instances at a time.";
	  }
	  enum one_active_or_one_standby
	  {
	    description "For a certain component service type, the component supports all values of the HA state, and it can be assigned either the active HA state or the standby HA state for only one component service instance at a time.";
	  }
	  enum x_active
	  {
	    description "for a certain component service type, the component cannot be assigned the standby HA state for component service instances, but it can be assigned the active HA state for x component service instances at a time.";
	  }
	  enum one_active
	  {
	    description "for a certain component service type, the component cannot be assigned the standby HA state for component service instances, but it can be assigned the active HA state for only one component service instance at a time.";
	  }
	  enum non-pre-instantiable
	  {
	    description "For a certain component service type, the component provides service as soon as it is started.";
	  }
	}
	config false;
	description "This is defined by the SA-Forum AMF specificaion but is read-only because it is an emergent property based on values in saAmfCompNumMaxActiveCSIs and saAmfCompNumMaxStandbyCSIs.";
      }

      leaf maxActiveAssignments
      {
	safplus:alias saAmfCompNumMaxActiveCSIs;
	safplus:ide "maximum active work assignments";
	type uint32;
	default 1;
	description "Maximum number of active work assignments this component can handle.";
      }
      leaf maxStandbyAssignments
      {
	safplus:alias saAmfCompNumMaxStandbyCSIs;
	safplus:ide "maximum standby work assignments";
	type uint32;
	default 1;
	description "Maximum number of standby work assignments this component can handle.";
      }

      container activeAssignments
      {
	safplus:alias saAmfCompNumCurrActiveCSIs;
	uses safplus:intStatistic;
	description "Current number of active work assignments this component is handling.";
        config false;
      }
      container standbyAssignments
      {
	safplus:alias saAmfCompNumCurrStandbyCSIs;
	uses safplus:intStatistic;
	description "Current number of standby work assignments this component is handling.";
        config false;
      }
      leaf-list assignedWork
      {
	safplus:alias saAmfCompAssignedCsi;
	type instance-identifier;
	description "Currently assigned work.";
        config false;
      }


      leaf operState
      {
	type boolean;
	description "True is enabled, False is disabled.  To move from False to True a 'repair' action must occur.";
        config false;
      }

      leaf readinessState
      {
        type ReadinessState;
        config false;
      }
	
      leaf haReadinessState
      {
        type HighAvailabilityReadinessState;
        config false; // Application can change this, but not management interface
	description "This state field covers ALL work assignments...";
      }
    
      leaf haState
      {
	type HighAvailabilityState;
	config false;
      }

      leaf safVersion
      {
	type string;
	description "Compatible SA-Forum API version";
      }

      leaf compCategory
      {
	type uint32;
      }

      leaf swBundle
      {
	type string;
	description "What software installation bundle does this component come from";
	config false;
      }

      leaf-list commandEnvironment
      {
	type string;
	description "List of environment variables in the form '<VARIABLE>=<VALUE>\n<VARIABLE2>=<VALUE2>\n' the form the environment in which this component should be started";
	safplus:ide "Environment";
      }

      container instantiate
      {
	uses execution;
	description "How to start up this component";
	safplus:ide "Execution";
      }

      container terminate
      {
	uses execution;
	description "Optional: This will be run just before the component's process (if it exists) is told to terminate.";
	safplus:ide "Termination";
      }

      container cleanup
      {
	uses execution;
	description "Optional: This will be run after the component stops for any reason (terminate or fault) so long as the node (machine) is still running.";
      }

      leaf maxInstantInstantiations
      {
	safplus:alias saAmfCompNumMaxInstantiateWithoutDelay;
	type uint32;
	default 1;
	description "How many times to attempt to instantiate this entity without delay.  If the number of instantiation attempts exceeds both this and the max delayed instantiations field, the fault will be elevated to the Service Unit level.";
	safplus:ide "Max instant instantiations: ";
      }

      leaf maxDelayedInstantiations
      {
	safplus:alias saAmfCompNumMaxInstantiateWithoutDelay;
	type uint32;
	default 1;
	description "How many times to attempt to instantiate this entity after an initial delay.  If the number of instantiation attempts exceeds both this and the max instant instantiations field, the fault will be elevated to the Service Unit level.";
	safplus:ide "Max delayed instantiations: ";
      }

      leaf delayBetweenInstantiation
      {
	safplus:alias saAmfCompDelayBetweenInstantiationAttempts;
	type uint32;
	default 10000;
	description "How long to delay between instantiation attempts";
	safplus:ide "Delay between instantiations: ";
      }

      container timeouts
      {
	leaf quiescingComplete
	{
	  safplus:alias saAmfCompQuiescingCompleteTimeout;
	  safplus:ide "Quiescing complete";
	  type safplus:SaTimeT;
	  default 120000; // 2 minutes
	  description "How much time to give a component to gracefully finish handling its work before faulting it, in milliseconds.";
	}
	leaf workRemoval
	{
	  safplus:alias saAmfCompCSIRmvCallbackTimeout;
	  safplus:ide "Work removal";
	  type safplus:SaTimeT;
	  default 120000; // 2 minutes
	  description "How much time to give a component to executes its work (component service instance) removal callback before faulting the component.  Specified in milliseconds.";
	}

	leaf workAssignment
	{
	  safplus:alias saAmfCompCSISetCallbackTimeout;
	  safplus:ide "Work assignment";
	  type safplus:SaTimeT;
	  default 120000; // 2 minutes
	  description "How much time to give a component to executes its work (component service instance) removal callback before faulting the component.  Specified in milliseconds.";
	}


      }

      leaf recovery
      {
	type enumeration
	{
	  enum NoRecommendation { value 1; }
	  enum Restart 
	  { 
	    value 2; 
	    description "The erroneous component should be terminated and reinstantiated.";
	  }
	  enum Failover 
	  { 
	    value 3; 
	    description "Depending on the redundancy model used, either the component or the service unit containing the component should fail over to another node.";
	  }
	  enum NodeSwitchover 
	  { 
	    value 4; 
	    description "Service instances containing component service instances assigned to the failed component are failed over while other service instances
are switched over to other nodes (component service instances are not abruptly removed; instead, they are brought to the quiesced state before being removed).";
	  }
	  enum NodeFailover 
	  { 
	    value 5; 
	    description "No service instance should be assigned to service units on that node. All service instances assigned to service units contained in the node are failed over to other nodes (by an abrupt termination of all node-local components).";
	  }
	  enum NodeFailfast
	  {
	    value 6;
	    description "The node should be rebooted using a low-level interface.";
	  }
	  enum ClusterReset
	  {
	    value 7;
	    description "The cluster should be reset. In order to execute this function, the Availability Management Framework reboots all nodes that are part of the cluster by using a low level interface without trying to terminate the components individually.  All AMF nodes are first terminated before any of the AMF nodes starts to instantiate again.";
	  }
	  enum ApplicationRestart
	  {
	    value 8;
	    description "The application should be completely terminated and then started again by first terminating all of its service units and then starting them again, ensuring that during the termination phase of the restart procedure service instances of the application are not reassigned.";
	  }
	  enum ContainerRestart
	  {
	    value 9;
	    description "Terminate all contained components and the container component abruptly and then instantiate them again.";
	  }
	    
	}

      }

      leaf restartable
      {
	type boolean;
	default true;
	description "Set to true if this component can be restarted on failure, without this event registering as a fault";
      }

     container restartCount
      {
	safplus:alias saAmfCompRestartCount;
	uses safplus:intStatistic;
        config false;
      }

     // saAmfCompProxyCsi? and saAmfCompContainerCsi?

     leaf proxy
     {
       safplus:alias saAmfCompCurrProxyName;
       type instance-identifier;
       description "The component listed here is this component's proxy.";
     }

     leaf-list proxied
     {
       safplus:alias saAmfCompCurrProxiedNames;
       type instance-identifier;
       description "This component is the proxy for the components listed here.";
     }

    }




    list ComponentServiceInstance
    {
      key "name";
      uses EntityId;
      description "";

      leaf-list protectionGroup
      {
	description "A protection group for a specific component service instance is the group of components to which the component service instance has been assigned";
        type instance-identifier;
        safplus:c-decl "Entity* entity";
      }

      leaf-list dependencies
      {
	safplus:alias saAmfCSIDependencies;
	description "";
        type instance-identifier;
        safplus:c-type "SAFplusAmf::ComponentServiceInstance*";
      }

     }

    // done
    list ServiceInstance
    {
      key "name";
      uses EntityId;
      description "";

      // SA-Forum defined fields
      leaf adminState
      {
        type AdministrativeState;
	safplus:ide "Initial state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }
      
      leaf assignmentState
      {
	type enumeration 
	{
	  enum unassigned;
	  enum fullyAssigned;
	  enum partiallyAssigned;
	}
        description "The assignment state of a service instance indicates whether the service represented by this service instance is being provided or not by some service unit.";
      }

      // ?? AmfSIProtectedbySG

      leaf rank
      {
	safplus:alias saAmfSIRank;
	safplus:ide   "Rank";
	type uint32;
	description "Lower rank is instantiated before higher; but rank 0 means 'don't care'.";
      }

      list activeWeight
      {
	safplus:alias saAmfSIActiveWeight;
        key "resource";
	uses Capacity;
	description "An abstract definition of the amount of work this node can handle.  Nodes can be assigned capacities for arbitrarily chosen strings (MEM or CPU, for example).  Service Instances can be assigned 'weights' and the sum of the weights of service instances assigned active or standby on this node cannot exceed these values.";
      }

      list standbyWeight
      {
	safplus:alias saAmfSIStandbyWeight;
        key "resource";
	uses Capacity;
	description "An abstract definition of the amount of work this node can handle.  Nodes can be assigned capacities for arbitrarily chosen strings (MEM or CPU, for example).  Service Instances can be assigned 'weights' and the sum of the weights of service instances assigned active or standby on this node cannot exceed these values.";
      }


      // SAFplus extensions
      container activeAssignments
      {
	safplus:alias saAmfSINumCurrActiveAssignments;
	uses safplus:intStatistic;
	description "Number of active assignments";
        config false;
      }
      container standbyAssignments
      {
	safplus:alias saAmfSINumCurrStandbyAssignments;
	uses safplus:intStatistic;
	description "Number of standby assignments";
        config false;
      }

    }
 
    // done
    list ServiceUnit
    {
      key "name";
      uses EntityId;
      leaf adminState
      {
        type AdministrativeState;
	safplus:ide "Initial state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }
      // skipped saAmfSUType

      leaf rank
      {
	safplus:alias saAmfSURank;
	safplus:ide   "Rank";
	type uint32;
	description "Lower rank is instantiated before higher; but rank 0 means 'don't care'.";
      }

      leaf failover
      {
	safplus:alias saAmfSUFailover;
	type boolean;
	description "TODO";
      }

      // skipped Maintenance Campaign, string

      leaf preInstantiable
      {
	type boolean;
	config false;
	description "Can this service unit be instantiated before being assigned active?  True if ALL components are preinstantiable.";
      }

      leaf saAmfSUHostNodeOrNodeGroup
      {
	type instance-identifier;
	description "The service unit can only be instantiated on the node (if a node is specified) or on one of the nodes of the node group (if a node group is configured).";
      }

      // SA-Forum defined fields
      leaf presenceState
      {
	type PresenceState;
        config false;
      }
      leaf readinessState
      {
        type ReadinessState;
        config false;
      }

      leaf haReadinessState
      {
        type HighAvailabilityReadinessState;
        config false; // Application can change this, but not management interface
	description "This state field covers ALL work assignments...";
      }

      leaf haState
      {
	type HighAvailabilityState;
	config false;
      }
      leaf operState
      {
	type boolean;
	description "True is enabled, False is disabled.  To move from False to True a 'repair' action must occur.";
        config false;
      }

     leaf-list assignedServiceInstances
     {
        type instance-identifier;
        safplus:c-decl "Entity* entity";       
     }

     // ?? saAmfSUHostedByNode string
       

     container activeServiceInstances
      {
	safplus:alias saAmfSUNumCurrActiveSIs;
	uses safplus:intStatistic;
        config false;
      }
     container standbyServiceInstances
      {
	safplus:alias saAmfSUNumCurrStandbySIs;
	uses safplus:intStatistic;
        config false;
      }

     container restartCount
      {
	safplus:alias saAmfSURestartCount;
	uses safplus:intStatistic;
        config false;
      }


      description "";
    }

    // done
    list Application
    {
      key "name";
      uses EntityId;
      description "";
      // SA-Forum defined fields
      leaf adminState
      {
        type AdministrativeState;
	safplus:alias saAmfApplicationAdminState;
	safplus:ide "Initial state: ";
	description "Does the operator want this entity to be off, idle, or in service?";
      }
      // skipping SAF: app type 
      
      container NumServiceGroups  // Note, defined but never described in AMF spec
      {
	safplus:alias saAmfApplicationCurrNumSGs;
	uses safplus:intStatistic;
        config false;
      }

    }

    list EntityByName
    {
      description "Look up any entity by its string name";
      key "name";
      config false;
      leaf name
      {
	type string;
      }
      leaf entity
      {
	type instance-identifier;
      }
    }

    list EntityById
    {
      description "Look up any entity by its identifier";
      key "id";
      config false;
      leaf id
      {
	type uint16;
      }
      leaf entity
      {
	type instance-identifier;
      }
    }

    leaf healthCheckPeriod
    {
      description "This attribute indicates the interval at which the corresponding healthcheck should be initiated (in milliseconds).";
      type safplus:SaTimeT;
      safplus:ide "AMF health check period";
      default 0;
    }

    leaf healthCheckMaxSilence
    {
      description "This attribute indicates the maximum time allowable for components to not reply to the health check (in milliseconds).  After this time passes with no response from the component, it will be faulted";
      type safplus:SaTimeT;
      safplus:ide "Max health check response time";   
      default 0; // disabled
    }

  }
