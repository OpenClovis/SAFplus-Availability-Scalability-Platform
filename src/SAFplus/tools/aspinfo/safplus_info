#!/usr/bin/env python
###############################################################################
#
# Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
# 
# The source code for  this program is not published  or otherwise 
# divested of  its trade secrets, irrespective  of  what  has been 
# deposited with the U.S. Copyright office.
# 
# This program is  free software; you can redistribute it and / or
# modify  it under  the  terms  of  the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the  hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
# 
# You  should  have  received  a  copy of  the  GNU General Public
# License along  with  this program. If  not,  write  to  the 
# Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################
"""
Provides various status information about SAFplus running on this node and on the
cluster

Use the --help option or the help command to obtain more information
on available asp-info commands.

The plan is to provide info on many different things, such as (not all
of these are implemented yet):

Info                                                              Needs running
about:                                                                 SAFplus
---------------------------------------------------------------   -------------
- check if SAFplus is properly installed (approximation)                    N
- check the version (build number) of this installation                 N
- check if SAFplus is running and if so, what PID number                    N/A
- list all SAFplus middleware processes running                             Y
- list all SAFplus-based applications started by SAFplus and their status       Y
- list the tipc/gms parameters of this instance of SAFplus                  N
- list all other hosts in the cluster having same tipc netid            N
- list all other SAFplus nodes that are candidates for this cluster         N
- list all SGs in the cluster and their state                           Y
- list all SU in the cluster and their state (and node to run on)       Y

"""

import sys
import os
import time
import signal
import cmd
import pdb
import re
import xml.dom.minidom as minidom

def on_platform(p):
  return p in sys.platform

try: # Readline is optional, just gives up command completion and so forth
  if on_platform('linux'): import readline
except:
  pass

##
## Customizable constants
##
GMSCONFIGFILE           = '/etc/clGmsConfig.xml'
HISTORY_FILE            = '.asp-info.hist'
AMF_DB_CACHE_TIMEOUT    = 5.0  # cache aging for amf database [sec]
WELCOME_MSG             = 'SAFplus info utility -- OpenClovis, Inc., 2008'

##
## Internal variables and constants
##
_dblevel = 0 # default debug level
_asp_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
_exit_code = 0
try:
  _app_name = os.path.basename(__file__)
except NameError:  # __file__ is not defined if I'm in the pdb debugger
  _app_name = "safplus_info"
_asp_conf = None                    # caching asp.conf content
_asp_run_env = None                 # caching asp_run.env content
_amf_config_xml = None              # caching clAmfConfig.xml content as dot tree
_do_colors = sys.stderr.isatty()    # output coloring on if not a redirect
_amf_db = None                      # caching amf database
_amf_db_timestamp = None            # time.time of last amf_db cache refresh
_su_names = None                    # cached SU names
_sg_names = None                    # cached SU names
_node_names = None                  # cached Node names
_interactive_shell = False
_yesno_map = {
    'True':     'Y',
    'False':    'N'
}
_member_map = {
    'True':     'Y',
    'False':    'N',
    'Leaving':  'L'
}
_state_map = {
    'Locked Assignment':    'LA',
    'Unlocked':             'UL',
    'Locked Instantiation': 'LI'
}
_classtype_map = {
    'Class A':          'A',
    'Class B':          'B',
    'Class C':          'C',
    'Class D':          'D'
}
_redundancy_map = {
    'No Redundancy':    'None',
    '2N (1+1)':         '1+1',
    'M + N':            'M+N',
    'N-Way-Active':     'N-Way-A'
}
_presence_map = {
    'Uninstantiated':       'U',
    'Instantiating':        'i',
    'Instantiated':         'I',
    'Terminating':          'T',
    'Restarting':           'R',
    'Instantiation Failed': 'iF',
    'Termination Failed':   'tF',
    'Fault':                'F',
    'Fault WTR':            'Fr',
    'Fault WTC':            'Fc',
    'None':                 '-',
    'Unknown':              '?'
}
_operstate_map = {
    'Enabled':              'E',
    'Disabled':             'D',
    'None':                 '-',
    'Unknown':              '?'
}
_readiness_map = {
    'In Service':           'IS',
    'Stopping':             'S',
    'Out of Service':       'OOS',
    'None':                 '-'
}
_hastate_map = {
    'active':               'A',
    'standby':              'S',
    'quiesced':             'Q',
    'quiescing':            'q',
    'none':                 '-',
    'invalid':              '?'
}

NO_SUCH_FILE_OR_DIR     = 127
PROC_GOT_SIGKILL        = 137

USAGE_MSG = """
OpenClovis SAFplus run-time information utility

Usage:
    %(_app_name)s [options] [command(s)]

Options:
    -h, --help          This help page
    -v, --verbose       Be more verbose
    -c, --no-colors     Disables output coloring
""" % locals()


class AspError(Exception): pass
class UnknownError(AspError): pass
class CommandError(AspError): pass
class NotFoundError(AspError): pass
class DebugCliError(AspError): pass    


class Dot:
    """
    The dot class lets you access fields either through field notation (.)
    or dictionary notation ([]).
    """

    def __init__(self, dict):
        for (key, val) in dict.items():
            if type(val) == type({}): val = Dot(val)
            self.__dict__[key] = val

    def __str__(self):
        s=[]
        for (key, val) in self.__dict__.items():
            s.append("'%s':%s" % (str(key), str(val)))
        return "{ " + ", ".join(s) + " }"

    def __repr__(self): return 'Dot(%s)' % self.__str__()

    def has_key(self, key): return self.__dict__.has_key(key)

    def keys(self): return self.__dict__.keys()

    def values(self): return self.__dict__.values()

    def items(self): return self.__dict__.items()

    def clear(self): self.__dict__.clear()

    def get(self, key, default = None): return self.__dict__.get(key, default)

    def setdefault(self, key, default = None): return self.__dict__.setdefault(key, default)

    def pop(self, key, default = None): return self.__dict__.pop(key, default)

    def popitem(self): return self.__dict__.popitem()

    def iteritems(self): return self.__dict__.iteritems()

    def iterkeys(self): return self.__dict__.iterkeys()

    def itervalues(self): return self.__dict__.itervalues()

    def __getitem__(self, key): return self.__dict__[key]

    def __setitem__(self, key, val): self.__dict__[key] = val

    def __delitem__(self, key): del self.__dict__[key]

    def __len__(self): return self.__dict__.__len__()

    def __contains__(self, item): return item in self.__dict__

    def dot_print(self, prefix=None):
        s = []
        for (key, val) in self.__dict__.items():
            p = (prefix and prefix+'.' or '')+str(key)
            try:
                s.append(val.dot_print(p))
            except AttributeError:
                s.append(p + '=' + str(val)) 
        return '\n'.join(s)


def load_xml_file(filename, strip_root=None):
    """Parse given xml file and turn it into a nested dot object"""
    
    f = open(filename, "r")
    content = f.read()
    f.close()
    
    return load_xml_string(content, strip_root)
    

def load_xml_string(string, strip_root=None):
    """Parse given xml string and turn it into a nested dot object"""

    dom = minidom.parseString(string)
    
    def decode_dom(dom):
        d = {}
        str = ""
        if len(dom.childNodes) > 0:
            for n in dom.childNodes:
                if n.nodeType == minidom.Comment.nodeType: # Skip all comments
                    pass
                elif n.__dict__.has_key('nodeValue'):
                    str += n.nodeValue.strip()
                else:
                    if not d.has_key(n.tagName):
                        d[n.tagName] = []
                    d[n.tagName].append({})
                    
                    if len(n.childNodes) > 0:
                        d[n.tagName][-1] = decode_dom(n)
                        
                    if n._attrs.has_key('value'):
                        if d[n.tagName][-1]:
                            d[n.tagName][-1]['value'] = n._attrs['value'].nodeValue
                        else:
                            d[n.tagName][-1] = n._attrs['value'].nodeValue
                        
                    elif len(n._attrs.items())>0:
                        d2 = d[n.tagName][-1]
                        for (k, v) in n._attrs.items():
                            d2[k] = v.nodeValue
                        d[n.tagName][-1] = d2
        else:
            return dom.nodeValue.strip()

        if len(d)==0: return str
        elif len(str):
            d['value'] = str
        return Dot(d)
    
    d = decode_dom(dom)
    if strip_root:
        for t in strip_root:
            for tag in t:
                if not d.has_key(tag) or len(d[tag]) != 1:
                    break
                d = d[tag][0]

    return d

def color(code, string):
    """Return with the colorer string accroding to color code if coloring is
       enabled, or the original string otherwise. Color is one of the colors
       define in the following dictionary (using ANSI codes):
    """
    colors = {
        'normal':       '0',
        'bold':         '1',
        'cyan':         '0;36',
        'bold-cyan':    '1;36',
        'red':          '0;31',
        'bold-red':     '1;31',
        'green':        '0;32',
        'bold-green':   '1;32',
        'yellow':       '0;33',
        'bold-yellow':  '1;33',
        'blue':         '0;34',
        'bold-blue':    '1;34'
    }
    col = colors.get(code)
    if _do_colors and col:
        return '\033[%sm%s\033[0m' % (col, string)
    else:
        return string


def color_state(state):
    if state == 'active': return color('bold-red', state)
    elif state == 'standby': return color('bold-yellow', state)
    else: return state
    

def extend_path():
    """Inserts asp_dir/bin to the beginning of the PATH environment"""
    path = os.getenv('PATH')
    path = _asp_dir + '/bin:' + path
    os.putenv('PATH', path)
    

def dbmsg(level, *args):
    """ Level sensitive debug printing function """
    if _dblevel >= level:
        for s in args:
            print s,
        print ''


def error(msg):
    print '***Error: ' + msg
    global _exit_code
    _exit_code = 1


def system(cmd): return sys_asp['system'](cmd)

def assert_root():
    """Exits if the program is not run as root"""
    ec, res, s, c = system('whoami')
    if ec or len(res)==0:
        error('Could not run "whoami"')
        sys.exit(1)
    if not res[0].strip() == 'root':
        error('You need to be root to run %(_app_name)s' % globals())
        sys.exit(1)


def load_asp_run_env():
    """Returns the content of asp_run.env as a dictionary"""

    global _asp_run_env
    
    if _asp_run_env:
        return _asp_run_env
    
    f = file(_asp_dir + '/etc/asp_run.env')
    lines = f.readlines()
    f.close()
    try:
        d = dict([l.split('=') for l in [l.strip() for l in lines]
                                     if not l.startswith('#')])
    except:
        raise CommandError('Could not parse asp_run.env. Values are missing?')
    
    _asp_run_env = d
    return _asp_run_env


def load_asp_conf(quit_on_error=True):
    """Returns the content of asp.conf as a dictionary"""
    global _asp_conf

    if _asp_conf:
        return _asp_conf

    try:
        f = file(_asp_dir + '/etc/asp.conf')
    except IOError, e:
        if quit_on_error:
            error('%s:' % str(e))
            error('Directory [%s/bin] in which %s resides is not part of an SAFplus install' %
                  (_asp_dir, _app_name))
            sys.exit(1)
        else:
            raise

    lines = f.readlines()
    f.close()

    d = {}
    for line in lines:
        line = line.strip()
        if line.startswith('#'): continue
        if line.startswith('export '): line = line[len('export '):].strip()
        key_value = line.split('=')
        if len(key_value) == 2: d[key_value[0]] = key_value[1]
        else:                   d[key_value[0]] = None

    _asp_conf = Dot(d)
    return _asp_conf
    
    
def load_amf_config_xml():
    """Loads the clAmfConfig.xml file, and returns a dict structure with
       its content
    """
    global _amf_config_xml
    if not _amf_config_xml:
         _amf_config_xml = load_xml_file(_asp_dir + '/etc/clAmfConfig.xml',
                                         strip_root=(('amfConfig',),
                                                     ('openClovisAsp', 'version', 'amfConfig')))
    return _amf_config_xml
        
    
def load_amf_db():
    """Obtain a snapshot of the amf database from the debug cli and return
       it as a (nested) Dot object. The information is cached for up to
       AMF_DB_CACHE_TIMEOUT [sec]
    """
    
    global _amf_db, _amf_db_timestamp, _interactive_shell
    if _amf_db and not _interactive_shell: # and time.time() <= _amf_db_timestamp + AMF_DB_CACHE_TIMEOUT:
        dbmsg(1, 'working from cached AMF DB')
        return _amf_db

    dbmsg(1, 'Getting fresh AMF DB')
    s, res = asp_console_execute(
                    ['setc master', 'setc cpm', 'amsDbXMLPrint console'],
                    use_file=True)
    if s:
        raise DebugCliError('No access to active system controller')
    
    res = res[-1]
    t = res.find("<asp>")
    if t != -1:  # Strip off any debugging info
      res = res[t:]
    _amf_db = load_xml_string(res, strip_root=(('asp',),))
    
    _amf_db_timestamp = time.time()
    return _amf_db
    

def safe_remove(f):
    try:
        os.remove(f)
    except:
        os.system('rm -f %s' %f)
    
def asp_console_execute(cmds, use_file=False):
    """Executes the list of commands in SAFplus_console (debug cli) and
       returns with a tuple of the status of the last command and a list
       containing the stripped output of each command executed. If use_file
       is True, a temporary file will be used to hold the output of the
       command. This is advised to be used for commands with potentially
       long output, because long outputs have the risk to get popen4
       to create a deadlock.
    """
    prompt = r'cli\[[^[]+\]->\s+'
    out_file = None
    rex_cmdline = re.compile(prompt+r'(?P<cmd>.*)', re.M)
    
    cmd = '%s "%s" | %s/bin/safplus_console' % \
          (sys_asp['echo_cmd'], '\\n'.join(cmds + ['status', 'bye']), _asp_dir)
    if use_file:
        out_file = '%s/var/run/tmp.aspinfo_' % _asp_dir + str(os.getpid())
        cmd += '> %s' %out_file
        
    (ec, output, signal, core) = system(cmd)
    if ec == NO_SUCH_FILE_OR_DIR:
        if out_file:
            safe_remove(out_file)
        raise DebugCliError('Could not find safplus_console')
    if ec and ec != PROC_GOT_SIGKILL:
        if out_file:
            safe_remove(out_file)
        output = ' '.join(output)
        if output.find('instance is already running') >= 0:
            raise DebugCliError('Another safplus_console is already running on this node')
        else:
            raise DebugCliError('Could run safplus_console: %s' % output)
    
    if use_file:
        f = file(out_file, 'r')
        output = f.read()
        f.close()
        safe_remove(out_file)
 
    res = rex_cmdline.split(''.join(output))
    res2 = [res[res.index(c.strip())+1].strip() for c in cmds]
    trailer_res = res[res.index(cmds[-1].strip())+2:]
    if not trailer_res[0].strip() == 'status':
        raise DebugCliError('Got out of sync when parsing safplus_console output:' +
                            ''.join(output))
    status = trailer_res[1].strip()
    try:
        status = int(status)
    except ValueError:
        raise DebugCliError('safplus_console status command returned non-integer [%s]' %
                            status)
    return (status, res2)


def check_install():
    """Check SAFplus installation and return with 'OK' or 'incomplete/corrupt'
       accordingly. In the latter case, extra error messages may be printed
       while analyzing the install
    """
    file_check_list = [
        'bin/safplus_amf',
        'bin/safplus_gms',
        'bin/safplus_console',
        'etc/asp.conf',
        'etc/asp.py',
        'etc/init.d/safplus',
        'etc/safplus_watchdog.py'
    ]
    for f in file_check_list:
        path = _asp_dir + '/' + f
        all_ok = True
        if not os.access(path, os.F_OK):
            error(path + ' is not found')
            all_ok = False
    if all_ok:
        return 'OK'
    else:
        return 'incomplete/corrupt'
    

def get_status_info():
    """Returns with SAFplus running status, as a dict with following entries:
       Key:         Value(s):
       status       'down', 'up', 'booting/shutting down'
       pid          <pid> or 'N/A'
       nodeaddr     <nodeaddr> or 'N/A'
       nodename     <nodename>
    """

    d = Dot({})
    cmd = _asp_dir + '/etc/init.d/safplus status'
    (ec, output, signal, core) = system(cmd)
    if ec == NO_SUCH_FILE_OR_DIR:
        error('Could not run cmd [%s]:' % cmd)
        error('no such file or directory')
        error('Please check your SAFplus installation')
        raise NotFoundError(output)
    
    # need to parse 3 forms:
    #   INFO ASP is not running on node [1]
    #   INFO ASP is booting up/shutting down
    #   INFO ASP is running on node [1], pid [21548]
    res = ' '.join(output).strip()
    if res.find('not running') >= 0:
        d.status = 'down'
        d.pid    = d.nodeaddr = 'N/A'
        conf = load_asp_conf()
        d.nodename = conf.NODENAME
    elif res.find('booting up') >= 0:
        d.status = 'booting or shutting down'
    elif res.find('running on node') >= 0:
        d.status = 'up'
    else:
        raise CommandError('Unexpected output from asp status: [%s]' % res)
    
    if d.status in ['up', 'booting or shutting down']:
        asp_run_env = load_asp_run_env()
        d.nodeaddr = asp_run_env['ASP_NODEADDR']
        d.nodename = asp_run_env['ASP_NODENAME']
        amf_cmd_line = '%s/bin/safplus_amf' % (_asp_dir)
        cmd = sys_asp['grep_amf_cmd'](amf_cmd_line)
        (ec, output, signal, core) = system(cmd)
        if ec:
            raise CommandError('SAFplus is reported running, but could not retrieve PID')
        d.pid = output[0].split()[0].strip()
        # Sanity check: if 'up', same pid should have been in res message
        if d.status == 'up' and res.find(d.pid) == -1:
            raise UnknownError('PID mismatch beetween asp status and pgrep')
    
    return d


def get_tipc_live_node_info():
    """Returns with tipc live info, as a dict with following entries:
       Key:         Value(s):
       module       'loaded' or 'not loaded'
       netid        <netid> or 'unknown'
       addr         <addr> or 'unknown'
       ifaces       <list of interface names> or ['unknown']
    """
    d = {}
    ec, res, s, c = system('lsmod | grep -q tipc')
    d['module'] = (ec and 'not loaded' or 'loaded')

    ec, res, s, c = system('tipc-config -netid')
    if ec == NO_SUCH_FILE_OR_DIR:
        raise CommandError('tipc-config command not found')
    elif ec or len(res)!=1:
        d['netid'] = 'unknown'
    else:
        d['netid'] = res[0].strip().split()[-1]

    ec, res, s, c = system('tipc-config -addr')
    if ec or len(res)!=1:
        d['addr'] = 'unknown'
    else:
        d['addr'] = res[0].strip().split()[-1].strip('<>')

    ec, res, s, c = system('tipc-config -b')
    if ec or len(res)<2:
        d['ifaces'] = ['unknown']
    else:
        d['ifaces'] = [i.strip().split(':')[-1] for i in res[1:]]

    return d


def get_gms_info():
    """Returns with GMS config info, as a dict with following entries:
       Key:         Value(s):
       mip          <gms multicast IP address>
       mport        <gms multicast port>
    """
    d = {}

    fn = _asp_dir + GMSCONFIGFILE
    cmd = "grep [mM]ulticastAddress %s |sed 's/<[^>]*>//g'" % fn
    ec, res, s, c = system(cmd)
    if ec or len(res)!=1:
        error('Could not parse [%s] file' % fn)
        d['mip'] = 'unknown'
    else:
        d['mip'] = res[0].strip()

    cmd = "grep [mM]ulticastPort %s |sed 's/<[^>]*>//g'" % fn
    ec, res, s, c = system(cmd)
    if ec or len(res)!=1:
        error('Could not parse [%s] file' % fn)
        d['mport'] = 'unknown'
    else:
        d['mport'] = res[0].strip()

    return d


def get_node_info_from_cpm():
    """Returns with the node type as dot object with following data:
       Key:         Value(s):
       nodename     <nodename>
       nodetype     'controller' or 'worker'
       nodeclass    <classname>
       defnodeaddr  <DEFAULT_NODEADDR>
       assignmode   <AUTO_ASSIGN_NODEADDR> or 'default'
       netid        <tipc netid> (intended) or 'pre-configured'
       addr         <tipc address> (intended) or 'pre-configured'
       ifaces       <tipc ifaces> (intended)
       Does not require SAFplus to run.
    """
    d = Dot({})
    asp_conf = load_asp_conf()

    d.nodename = asp_conf.NODENAME
    cfg = load_amf_config_xml()

    try:
        d.nodeclass = str([i.type for i in cfg.nodeInstances[0].nodeInstance
                           if i.name==d.nodename][0])
        nodetype = [c.cpmType for c in cfg.cpmConfigs[0].cpmConfig
                    if c.nodeType==d.nodeclass][0]

        if nodetype == 'GLOBAL':
            d.nodetype = 'controller'
        else:
            d.nodetype = 'worker'
    except:
        d.nodeclass = ''
        d.nodetype = 'worker'

    d.defnodeaddr = asp_conf.DEFAULT_NODEADDR

    d.assignmode = asp_conf.AUTO_ASSIGN_NODEADDR or 'default'

    d.netid = asp_conf.TIPC_NETID or 'pre-configured'
    
    if d.assignmode == 'default':
        d.addr = '1.1.%s' % asp_conf.DEFAULT_NODEADDR
    elif d.netid == 'pre-configured':
        d.addr = 'pre-configured'
    else:
        d.addr = '1.1.<node-address> to be determined at startup time'
    
    d.ifaces = []
    d.ifaces.append(asp_conf.LINK_NAME or 'eth0')
    
    return d


def get_comps_info(nodeaddr, do_ps=True):
    """Obtain the component list from CPM and return it as list of dot objects
       with following fields:
            .compname       <compname>
            .running        'Y' or '-'
            .pid            <pid> or '-'
            .healthy        'Y' or 'N' or '-'
            .command        <command name> or '-'
            .cpu            <cpu util [%]> or '-'
            .mem            <mem util [%]> or '-'
            .threads        <# of threads> or '-'
            .rss            <rss in kb> or '-'
            .vsz            <vsz in KiB> or '-'
    """

    

    s, output = asp_console_execute(['setc %s' % nodeaddr,
                                     'setc cpm',
                                     'compList'], use_file=True)
    if s:
        raise DebugCliError('could not get component list (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))

    table = output[-1] # only care about last command
    tmp = re.split(r'=======*', table) # split up along header hline
    assert len(tmp)==2, 'Expected safplus_console compList response to contain "======*" header line, but got:\n%s' % output

    table_body = tmp[1]
    rows = re.split(r'------*', table_body.strip()) # split along divider lines

    comps = []
    for row in [r for r in rows if r]: # filter out empty rows (last)
        c = Dot({})
        cells = map(str.strip, re.split(r'[|]|\n', row.strip()))
        assert len(cells)>=6, 'Expected at least 6 fields, but got: %s' % str(cells)
        c.compname = cells[0]
        c.running = (cells[5] == 'INSTANTIATED' and 'Y' or '-')
        if c.running == 'Y':
            c.pid = cells[3]
            pid = int(c.pid)
            if not pid:
              c.pid = '-'
            assert len(cells)>=11, 'Expected >=11 fields for running component, got: %s' % str(cells)
            c.healthy = (cells[10] == 'ALIVE' and 'Y' or 'N')

            # get extra process information if on local node
            if pid > 0 and do_ps and nodeaddr == get_status_info().nodeaddr:
            
                cmd = sys_asp['proc_info_cmd'](c.pid)
                (ec, output, signal, core) = system(cmd)
                if ec or len(output)!=1:
                    raise CommandError('failed to run ps -p for pid [%s]' % c.pid)
                fields = output[0].split()
                c.command, c.cpu, c.threads, c.rss, c.vsz = fields
            else:
                c.command = c.cpu = c.threads = c.rss = c.vsz = '-'
        else:
            c.pid = c.healthy = c.command = c.cpu = c.threads = \
                c.rss = c.vsz = '-'
        comps.append(c)
    
    return comps


def get_cluster_info():
    """Obtain the cluster list from master CPM and return a list of dot objects
       with following keys:
            .nodename
            .nodeaddr
            .nodetype
            .hastate
    """
    info = get_status_info()

    s, output = asp_console_execute(['setc %(nodeaddr)s' % info,
                                     'setc gmsServer_%(nodename)s' % info,
                                     'memberList 0'], use_file=True)
    if s:
        raise DebugCliError('could not get cluster view (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))
    
    table = output[-1] # only care about last command
    tmp = re.split(r'-------*', table) # split up along hlines
    assert len(tmp)==4, 'Expected 3 hlines in safplus_console output, but got:\n%s' % output

    rows = tmp[-1].strip().split('\n')
    
    nodes = []
    for row in rows:
        n = Dot({})
        cells = row.split()
        assert len(cells)>=7, 'Unexpected cluster view line from safplus_console: %s' % row
        
        n.nodeaddr, n.nodename, addr, port, leader, credential = cells[0:6]
        if credential != '0':
            n.nodetype = 'controller'
            if leader == 'Yes':
                n.hastate = 'active'
            else:
              if leader == '(Pending)':
                n.hastate = 'unassigned'
              else:
                n.hastate = 'standby'
        else:
             n.nodetype = 'worker'
             assert leader == 'No', 'a worker node shall never be the cluster leader'
             n.hastate = '-'

        nodes.append(n)
    
    return nodes

def get_uptime():
    """Obtain node uptime"""

    info = get_status_info()

    s, output = asp_console_execute(['setc %(nodeaddr)s' % info,
                                     'setc cpm', 
                                     'uptime'], use_file=True)
    if s:
        raise DebugCliError('could not get node uptime (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))
    
    tmp = output[-1].strip() # only care about last command
    return tmp

#    amf_db = load_amf_db()
#    assert amf_db.ams[0].service_state[0] == 'Running'
#    amf_nodes = dict([(n.value, n) for n in amf_db.ams[0].entities[0].nodes[0].node])
#    cpm_nodes = dict([(n.value, n) for n in amf_db.cpm[0].node])
#    
#    s, output = asp_console_execute(['setc master', 'setc cpm', 'clusterList'])
#    if s:
#        raise DebugCliError('could not get cluster list (exit code of safplus_console: %d). Got: \n%s' %
#              (s, ''.join(output)))
#    table = output[-1].strip() # only care about last command
#    rows = [r.strip() for r in re.split(r'------*', table)]
#    assert len(rows)>1, 'Expected at least one hline, but got:\n%s' % output
#    del rows[0] # delete table header
#    def nodename_to_nodeaddr(row):
#        cells = [r.strip() for r in row.split('|')]
#        return cells[0], len(cells)>1 and cells[2] or '-'
#    node_addrs = dict([nodename_to_nodeaddr(r) for r in rows if r])
#    
#    nodes = []
#    for name, amf_node in amf_nodes.items():
#        # skip nodes that are not in cluster
#        if amf_node.status[0].is_cluster_member[0] != 'True':
#            continue
#
#        n = Dot({})
#        n.nodename = name
#        n.status = amf_node.status[0].presence_state[0] == 'Instantiated' and \
#                    'UP' or '-'
#        n.hastate = cpm_nodes.get(name) and cpm_nodes.get(name).ha_state[0] or '-'
#        
#        n.nodetype = cpm_nodes.get(name) and 'controller' or 'worker'
#
#        n.nodeaddr = node_addrs[name]
#
#        nodes.append(n)
#
#    return nodes

def get_sgs_info():
    """Obtain the sg list as a list of Dot objects with following info:
            .sgname         <name of sg>
            .redundancy     <redundancy mode>
            .astate         <admin state>
            .castate        <calculated admin state>
            .started        <if SG was started>
            .activesus      # of active SUs
            .stbysus        # of standby SUs
    """
    
    amf_db = load_amf_db()
    
    sgs = []
    for s in amf_db.ams[0].entities[0].sgs[0].sg:
        sg = Dot({})
        sg.sgname     = s.value
        #sg.pactive    = s.config[0].preferred_active_sus[0]
        #sg.pstandby   = s.config[0].preferred_standby_sus[0]
        #sg.pinservice = s.config[0].preferred_inservice_sus[0]
        try:
            sg.redundancy = _redundancy_map[s.config[0].redundancy_model[0]]
        except KeyError:
            sg.redundancy = s.config[0].redundancy_model[0]
        sg.astate     = _state_map[s.config[0].admin_state[0]]
        sg.castate    = _state_map[s.config[0].computed_admin_state[0]]
        sg.activesus  = s.status[0].current_active_sus[0]
        sg.stbysus    = s.status[0].current_standby_sus[0]
        sg.started    = s.status[0].is_started[0]

        sgs.append(sg)
        
    return sgs    


def get_nodes_info():
    """Obtain the su list as a list of Dot objects with following info:
    """
    
    amf_db = load_amf_db()
    
    nodes = []
    for n in amf_db.ams[0].entities[0].nodes[0].node:
        node = Dot({})
        node.nodename     = n.value
        node.classtype    = _classtype_map[n.config[0].class_type[0]]
        node.astate       = _state_map[n.config[0].admin_state[0]]
        node.castate      = _state_map[n.config[0].computed_admin_state[0]]
        node.presence     = _presence_map[n.status[0].presence_state[0]]
        node.operstate    = _operstate_map[n.status[0].operational_state[0]]
        node.instantiable = _yesno_map[n.status[0].is_instantiable[0]]
        node.member       = _member_map[n.status[0].is_cluster_member[0]]
        node.isu          = n.status[0].num_instantiated_sus[0]
        node.asu          = n.status[0].num_assigned_sus[0]

        nodes.append(node)

    return nodes

        
def get_sus_info(nodename=None):
    """Obtain the su list as a list of Dot objects with following info:
    """
    
    amf_db = load_amf_db()
    
    sus = []
    for s in amf_db.ams[0].entities[0].sus[0].su:
        this_nodename = s.config[0].member_of_node[0]
        if nodename and not nodename == this_nodename:
            continue
        su = Dot({})
        su.suname    = s.value
        su.sgname    = s.config[0].member_of_sg[0]
        su.nodename  = this_nodename
        su.astate    = _state_map[s.config[0].admin_state[0]]
        su.castate   = _state_map[s.config[0].computed_admin_state[0]]
        su.presence  = _presence_map[s.status[0].presence_state[0]]
        su.operstate = _operstate_map[s.status[0].operational_state[0]]
        su.readiness = _readiness_map[s.status[0].readiness_state[0]]
        su.comps     = s.status[0].num_instantiated_comps[0]

        if s.status[0].sis[0] == '0':
            su.sis   = '-'
        else:
            su.sis   = ''.join([ _hastate_map[si.ha_state[0]]
                               for si in s.status[0].sis[0].si ])
        
        sus.append(su)

    return sus

        
def get_sg_info(sgname):
    """Return with SG Dot object, straight from the AMF DB for given sg name"""
    
    amf_db = load_amf_db()
    
    for sg in amf_db.ams[0].entities[0].sgs[0].sg:
        if sg.value == sgname:
            return sg
    
    return None


def get_sg_names():
    """Return a list of all SG names in cluster (caching it too)"""

    global _sg_names
    
    if _sg_names:
        return _sg_names
    
    amf_db = load_amf_db()

    _sg_names = [sg.value for sg in amf_db.ams[0].entities[0].sgs[0].sg]
    
    return _sg_names
    
    
def get_su_info(suname):
    """Return with SU Dot object, straight from the AMF DB for given su name"""
    
    amf_db = load_amf_db()
    
    for su in amf_db.ams[0].entities[0].sus[0].su:
        if su.value == suname:
            return su
    
    return None


def get_comp_info(compname):
    """Return with Component Dot object, straight from the AMF DB"""
    
    amf_db = load_amf_db()
    
    for comp in amf_db.ams[0].entities[0].comps[0].comp:
        if comp.value == compname:
            return comp
    
    return None
    
def get_su_names():
    """Return a list of all SU names in cluster (caching it too)"""

    global _su_names
    
    if _su_names:
        return _su_names
    
    amf_db = load_amf_db()

    _su_names = [su.value for su in amf_db.ams[0].entities[0].sus[0].su]
    
    return _su_names
    
def get_si_names():
    """Return a list of all si names in cluster"""

    amf_db = load_amf_db()

    _si_names = [n.value for n in amf_db.ams[0].entities[0].sis[0].si]
    
    return _si_names
    
def get_node_names():
    """Return a list of all node names in cluster (caching it too)"""

    global _node_names
    
    if _node_names:
        return _node_names
    
    amf_db = load_amf_db()

    _node_names = [n.value for n in amf_db.ams[0].entities[0].nodes[0].node]
    
    return _node_names
    
    
class Cli(cmd.Cmd):
    """Command line handler class"""
    
    def __init__(self, histfile):
        self.doc_header = "Available commands (type help <topic> for more info):"
        cmd.Cmd.__init__(self)
        try:
            self.prompt = color('bold-blue', '[%s@' % _app_name) + \
                          color('bold-red', load_asp_conf(False).NODENAME) + \
                          color('bold-blue', ']==> ')
        except:
            self.prompt = color('bold-blue', '[%s]==> ' % _app_name)
            
        self.histfile = histfile

    def preloop(self):
        """ Load history file """
        cmd.Cmd.preloop(self) # call original preloop to activate completion
        
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

        print
        print color('bold', WELCOME_MSG)
        print '-'*len(WELCOME_MSG)

    def postloop(self):
        """ Save history file """
        cmd.Cmd.postloop(self) # call original postloop to deactivate completion
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

    def completenames(self, text, *ignored):
        """override cmd's builtin: sneak in a trailing space if cmd was fully
           resolved
        """
        dotext = 'do_'+text
        cmds = [a[3:] for a in self.get_names() if a.startswith(dotext)]
        if len(cmds) == 1:
            cmds[0] = cmds[0]+' '
        return cmds

    def do_exit(self, msg):
        """Exiting the asp-info utility"""
        if len(msg):
            print 'No arguments to exit command, please'
            return
        return(1) # will exit cmd loop (but call postloop() first)

    def do_bye(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)
      
    def do_quit(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)
   
    ##
    ## setup command
    ##
    def do_setup(self, msg):
        """Show various information on this SAFplus installation (does not need SAFplus running)"""

        install = check_install()
        print 'installation:            %s' % install
        
        # FIXME: implement build number retrieval [I'm on it -M.S.]
        
        info = get_node_info_from_cpm()
        print 'node instance name:      %(nodename)s' % info
        print 'node class:              %(nodeclass)s' % info
        print 'node type:               %(nodetype)s' % info
        
        conf = load_asp_conf()
        print 'default node address:    %(defnodeaddr)s' % info
        print 'node address assignment: %(assignmode)s' % info
        print 'tipc netid:              %(netid)s' % info
        print 'tipc address:            %(addr)s' % info
        print 'cluster interface(s):    %s' % \
              '\n                         '.join(info.ifaces)

        try: info = get_gms_info()
        except AspError, e:
            error(str(e))
            return 0
        print 'gms multicast ip:        %(mip)s' % info
        print 'gms multicast port:      %(mport)s' % info
    
    ##
    ## status command
    ##
    def do_status(self, msg):
        """Show SAFplus running status and some basic run-time information"""

        try:
            info = get_status_info()
        except AspError, e:
            error(str(e))
            return 0
        print 'SAFplus run status:          %s' % color('bold-red',
                                                    '%(status)s' % info)
        print 'pid of safplus_amf:          %(pid)s' % info
        # print 'node instance name:      %(nodename)s' % info

        print 'actual node address:     %(nodeaddr)s' % info
        try: tipc = get_tipc_live_node_info()
        except AspError, e:
            error(str(e))
            return 0
        print 'tipc kernel module:      %(module)s' % tipc
        print 'tipc network id:         %(netid)s' % tipc
        print 'tipc node address:       %(addr)s' % tipc
        print 'tipc interface(s):       %s' % \
            '\n                         '.join(tipc['ifaces'])
    
        d = {}
        try:
            s, output = asp_console_execute(['setc %(nodeaddr)s' % info])
        except AspError:
            d['console'] = 'not available'
        else:
            if s:
                d['console'] = 'not available'
            else:
                d['console'] = 'available'
        print 'SAFplus local console:       %(console)s' % d

        if info.status == 'down':
            return
        s, output = asp_console_execute(['setc master'])
        if s:
            d['master'] = 'not available'
        else:
            d['master'] = 'available'
            
        print 'SAFplus master console:      %(master)s' % d
    
    ##
    ## role command
    ##
    def do_role(self, msg):
        """Show role of this node in cluster"""
        
        try:
            info = get_status_info()
        except AspError, e:
            error(str(e))
            return 0
        print 'node instance name:      %(nodename)s' % info

        nodetype = get_node_info_from_cpm().nodetype
        print 'node type:               %s' % nodetype
        
        if nodetype == 'controller' and info.status == 'up':
            amf_db = load_amf_db()
            node = [n for n in amf_db.cpm[0].node if n.value == info.nodename]
            if len(node)!=1:
                error('could not find own name [%s] in amf xml dump file' % info.nodename)
                return 0
            ha_state = str(node[0].ha_state[0])
        else:
            ha_state = 'n/a'
        print 'controller ha state:     %s' % \
            color_state(ha_state)
    
    ##
    ## host command
    ##
    def do_host(self, msg):
        """Show various information on this host (OS/computer/blade)"""
        cmd = _asp_dir + '/bin/nodeinfo'
        (ec, res, s, c) = system(cmd)
        if ec == NO_SUCH_FILE_OR_DIR:
            error('Could not find nodeinfo command in %s' % _asp_dir+'/bin')
            return 0
        elif ec:
            error('nodeinfo command exited with error')
        print ''.join(res)

    ##
    ## network command
    ##
    def do_network(self, msg):
        """Show other nodes that can potentially belong to this cluster"""
        error('Not yet implemented')
        pass
    
    ##
    ## cluster command
    ##
    def do_cluster(self, msg):
        """Show cluster nodes and their state """

        try:
            nodes = get_cluster_info()
        except AspError, e:
            error(str(e))
            return 0
        
        len_nodename = max([len(n.nodename) for n in nodes]+[9])
        fmt = '%%(nodename)%ds  %%(nodetype)10s  %%(hastate)-8s  %%(nodeaddr)9s' % \
            (len_nodename)

        h = Dot({}) # table header
        h.nodename, h.nodetype, h.hastate,  h.nodeaddr = \
        'NODE-NAME', 'NODE-TYPE', 'HA-STATE', 'NODE-ADDR'

        nodes.sort(lambda x,y: cmp(int(x.nodeaddr), int(y.nodeaddr)))

        print color('bold', fmt % h)
        for n in nodes:
            line = n.hastate == 'active' and color('bold-red', fmt % n) or fmt % n
            if n.nodename == get_node_info_from_cpm().nodename:
                line += ' <-- this node'
            print line

    def do_uptime(self, msg):
        """Show node uptime """

        try:
            uptime = get_uptime()
        except AspError, e:
            error(str(e))
            return 0

        print uptime
    ##
    ## nodes command
    ##
    def do_nodes(self, msg):
        "Show list of node entities and their state\n" \
        "\n" \
        "Usage: nodes\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    ISU:        # of instantiated SUs\n" \
        "    ASU:        # of assigned SUs\n"
        try:
            nodes = get_nodes_info()
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_name = max([len(n.nodename) for n in nodes])
        fmt = '%%(nodename)%ds  %%(classtype)5s  %%(astate)2s  %%(castate)3s  %%(presence)2s  %%(operstate)2s  %%(instantiable)12s  %%(member)14s  %%(isu)3s  %%(asu)3s' % \
                (len_name)

        h = Dot({}) # table header
        h.nodename, h.classtype, h.astate,  h.castate, h.presence, h.operstate, h.instantiable, h.member,         h.isu, h.asu = \
        'NODE',     'CLASS',     'AS',      'CAS',     'PS',       'OS',        'INSTANTIABLE', 'CLUSTER-MEMBER', 'ISU', 'ASU'
        
        nodes.sort(lambda x,y: cmp(x.nodename, y.nodename))
        print color('bold', fmt % h)
        for n in nodes:
            if  n.castate == 'UL' and n.member == 'Y':
                print color('bold-red', fmt % n)
            elif n.castate == 'LA' and n.member == 'Y':
                print color('yellow', fmt % n)
            else:
                print fmt % n
        
    def print_components(self, asp=True):
        """Prints either the SAFplus components or the user components"""

        try:
            comps = get_comps_info(get_status_info().nodeaddr)
        except AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0

        # pdb.set_trace()
        len_compname = max([len(c.compname) for c in comps])
        len_pid = max([len(c.pid) for c in comps])
        len_command = max([len(c.command) for c in comps])
        len_rss = max([len(c.rss) for c in comps])
        len_vsz = max([len(c.vsz) for c in comps])
        fmt = '%%(compname)%ds  %%(running)s  %%(pid)-%ds  %%(healthy)s  %%(command)-%ds  %%(cpu)4s  %%(threads)2s  %%(rss)%ds  %%(vsz)%ds' % \
                (len_compname, len_pid, len_command, len_rss, len_vsz)

        h = Dot({}) # table header
        h.compname, h.running, h.pid, h.healthy, h.command, h.cpu = \
        'COMPNAME', 'R',       'PID', 'H',       'COMMAND', '%CPU'
        h.threads, h.rss, h.vsz = \
        'TH',    'RSS', 'VSZ'

        asp_comps = ['corServer', 'faultServer', 'eventServer',
                     'nameServer', 'txnServer', 'gmsServer',
                     'alarmServer', 'logServer', 'ckptServer',
                     'cmServer', 'msgServer']
        node_name = load_asp_conf().NODENAME
        asp_comps = ['_'.join([e, node_name]) for e in asp_comps]

        if asp:
            comps = filter(lambda c: c.compname in asp_comps, comps)
        else:
            comps = filter(lambda c: not c.compname in asp_comps, comps)
        
        comps.sort(lambda x,y: cmp(x.compname, y.compname))
        
        print color('bold', fmt % h)
        for c in comps:
            print c.running=='Y' and color('bold-red', fmt % c) or fmt % c

    ##
    ## asp command
    ##
    def do_safplus(self, msg):
        "Show SAFplus components running on this node\n" \
        "\n" \
        "Abbreviations:\n" \
        "    R:     Running?\n" \
        "    H:     Healthy?\n" \
        "    TH:    # of threads\n" \
        "    RSS:   Same as rss field in ps Unix command (see man ps)\n" \
        "    VSZ:   Same as vsz field in ps Unix command (see man ps)\n"
        self.print_components(asp=True)
    def do_asp(self, msg):
        "DEPRECATED: Use 'safplus' command instead"
        self.print_components(asp=True)

    ##
    ## components command
    ##
    def do_components(self, msg):
        "Show user components running on this node\n" \
        "\n" \
        "Abbreviations:\n" \
        "    R:     Running?\n" \
        "    H:     Healthy?\n" \
        "    TH:    # of threads\n" \
        "    RSS:   Same as rss field in ps Unix command (see man ps)\n" \
        "    VSZ:   Same as vsz field in ps Unix command (see man ps)\n"
        self.print_components(asp=False)
    
    ##
    ## sgs command
    ##
    def do_sgs(self, msg):
        "Show all defined service groups in cluster\n" \
        "\n" \
        "Abbreviations:\n" \
        "    REDUND:     Redundancy mode\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    A-SUS       # of active SUs\n" \
        "    S-SUS:      # of standby SUS\n" \
        "\n" \
        "Use the 'sg' command to get more information on a given SG\n"

        
        try:
            sgs = get_sgs_info()
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_name = max([len(s.sgname) for s in sgs])
        fmt = '%%(sgname)-%ds  %%(redundancy)7s  %%(astate)3s  %%(castate)3s  %%(started)7s %%(activesus)5s  %%(stbysus)5s' % \
                (len_name)

        h = Dot({}) # table header
        h.sgname,  h.redundancy, h.astate,  h.castate, h.activesus, h.stbysus, h.started = \
        'SG-NAME', 'REDUND',     'AS',      'CAS',     'A-SUS',     'S-SUS',   'STARTED'
        
        sgs.sort(lambda x,y: cmp(x.sgname, y.sgname))

        print color('bold', fmt % h)
        for sg in sgs:
            if  sg.castate == 'UL':
                print color('bold-red', fmt % sg)
            elif sg.castate == 'LA':
                print color('yellow', fmt % sg)
            else:
                print fmt % sg
    
    ##
    ## sg command
    ##
    def do_sg(self, msg):
        "Show various information on a specified service group\n" \
        "\n" \
        "Usage: sg <sg-name>\n" \
        "\n" \
        "where <sg-name> is one of the names listed by the 'sgs' command.\n"
        
        args = msg.split()
        if len(args)!=1:
            self.onecmd('help sg')
            return 0
            
        try:
            sg = get_sg_info(msg)
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not sg:
            error('Could not find SG [%s] in AMF database' % msg)
            return 0
            
        print 'sg name:                 %s' % color('bold', sg.value)
        print 'admin state:             %s' % color('bold-red', sg.config[0].admin_state[0])
        print 'computed admin state:    %s' % color('bold-red', sg.config[0].computed_admin_state[0])
        print 'redundancy model:        %s' % sg.config[0].redundancy_model[0]
        print 'failback option:         %s' % sg.config[0].failback_option[0]
        print 'autorepair:              %s' % sg.config[0].autorepair[0]
        print 'preferred active SUs:    %s' % sg.config[0].preferred_active_sus[0]
        print 'preferred standby SUs:   %s' % sg.config[0].preferred_standby_sus[0]
        print 'preferred inservice SUs: %s' % sg.config[0].preferred_inservice_sus[0]
        print 'preferred assigned SUs:  %s' % sg.config[0].preferred_assigned_sus[0]
        print 'collocation allowed:     %s' % sg.config[0].collocation_allowed[0]

        started = sg.status[0].is_started[0]
        if started == 'True':
            print 'started:                 %s' % color('bold-red', started)
        else:
            print 'started:                 %s' % started

        sus = sg.status[0].instantiable_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print 'instantiable SUs:        %s' % \
            '\n                         '.join(sus)
            
        sus = sg.status[0].instantiated_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print 'instantiated SUs:        %s' % \
            '\n                         '.join(sus)
            
        sus = sg.status[0].inservice_spare_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print 'inservice spare SUs:     %s' % \
            '\n                         '.join(sus)
            
        sus = sg.status[0].assigned_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print 'assigned SUs:            %s' % \
            '\n                         '.join(sus)
            
        print 'current active SUs       %s' % sg.status[0].current_active_sus[0]
        print 'current standby SUs      %s' % sg.status[0].current_standby_sus[0]

    def complete_sg(self, text, line, bidx, eidx):
        return [n for n in get_sg_names() if n.startswith(text)]
    
    ##
    ## sus command
    ##
    def do_sus(self, msg):
        "Show list of service units\n" \
        "\n" \
        "Usage: sus [ <nodename> | all ]\n" \
        "\n" \
        "Without argument, lists all SUS defined in the cluster. With the optional node\n" \
        "name, lists SUs dedicated to the given node.\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    RS:         Readiness state:\n" \
        "                FIXME add details here\n" \
        "    IC:         # of instantiated components\n" \
        "    SIS:        Assigned SIs ('A'=active, 'S'=standby, 'Q'=quiesced)\n"

        args = msg.split()
        if len(args)>1:
            self.onecmd('help sus')
            return 0
        elif len(args)==1:
            if msg == 'all':
                nodename = None
            else:
                nodename = msg
        else:
            nodename = get_node_info_from_cpm().nodename
            
        try:
            sus = get_sus_info(nodename=nodename)
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_suname = max([len(s.suname) for s in sus]+[7])
        len_sgname = max([len(s.sgname) for s in sus]+[13])
        len_nodename = max([len(s.nodename) for s in sus]+[7])
        fmt = '%%(suname)%ds  %%(sgname)-%ds  %%(nodename)-%ds %%(astate)2s %%(castate)-3s %%(presence)-2s %%(operstate)-2s %%(readiness)-3s %%(comps)2s %%(sis)s' % \
                (len_suname, len_sgname, len_nodename)

        h = Dot({}) # table header
        h.suname,  h.sgname,      h.nodename, h.astate,  h.castate, h.presence, h.operstate, h.readiness, h.comps, h.sis = \
        'SU-NAME','MEMBER-OF-SG', 'ON-NODE',  'AS',      'CAS',     'PS',       'OS',        'RS',        'IC',    'SIS'
        
        sus.sort(lambda x,y: cmp(x.suname, y.suname))
        
        print color('bold', fmt % h)
        for su in sus:
            if  su.castate == 'UL':
                print color('bold-red', fmt % su)
            elif su.castate == 'LA':
                print color('yellow', fmt % su)
            else:
                print fmt % su
    
    def complete_sus(self, text, line, bidx, eidx):
        names = get_node_names()
        names.append('all')
        return [n for n in names if n.startswith(text)]
        
    ##
    ## su command
    ##
    def do_su(self, msg):
        "Show various information on a specified service unit\n" \
        "\n" \
        "Usage: su <su-name>\n" \
        "\n" \
        "where <su-name> is one of the names listed by the 'sus' command.\n" \

        args = msg.split()
        if len(args)!=1:
            self.onecmd('help su')
            return 0
            
        try:
            su = get_su_info(msg)
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not su:
            error('Could not find SU [%s] in AMF database' % msg)
            return 0
        
        print 'su name:                 %s' % color('bold', su.value)
        print 'admin state:             %s' % color('bold-red', su.config[0].admin_state[0])
        print 'computed admin state:    %s' % color('bold-red', su.config[0].computed_admin_state[0])
        print 'member of sg:            %s' % su.config[0].member_of_sg[0]
        print 'member of node:          %s' % su.config[0].member_of_node[0]
        print 'restartable:             %s' % su.config[0].is_restartable[0]
        print 'presence state:          %s' % su.status[0].presence_state[0]
        print 'readiness state:         %s' % su.status[0].readiness_state[0]
        print 'operational state:       %s' % su.status[0].operational_state[0]
        print 'number of active SIs:    %s' % su.status[0].num_active_sis[0]
        print 'number of standby SIs:   %s' % su.status[0].num_standby_sis[0]
        print 'number of quiesced SIs:  %s' % su.status[0].num_quiesced_sis[0]
        print 'SU restart count:        %s' % su.status[0].su_restart_count[0]
        print 'component restart count: %s' % su.status[0].comp_restart_count[0]
        
        comps = su.config[0].components[0]
        if comps == '0': comps = ['-']
        else:            comps = comps.comp
        print 'component list:          %s' % \
            '\n                         '.join(comps)

        sis = su.status[0].sis[0]
        if sis == '0': sis = ['-']
        else:          sis = [si.value + '(%s)' % color_state(si.ha_state[0])
                              for si in sis.si]
        print 'SI list:                 %s' % \
            '\n                         '.join(sis)

    def complete_su(self, text, line, bidx, eidx):
        names = get_su_names()
        return [n for n in names if n.startswith(text)]
    
    def lock_unlock(self, msg, cli_cmd, console_cmd):
        """Common function for unlock, locki, and locka"""
        
        args = msg.split()
        
        if len(args)!=2:
            self.onecmd('help %s' %cli_cmd)
            return 0
        if cli_cmd == 'lock_i' and args[0] not in ['sg', 'su', 'node']:
            self.onecmd('help %s' %cli_cmd)
        elif args[0] not in ['sg', 'su', 'node', 'si']:
            self.onecmd('help %s' % cli_cmd)
            return 0
        
        e_type, e_name = args
        if e_type == 'sg' and not e_name in get_sg_names():
            error('SG name [%s] does not match any of the known SGs' % e_name)
            return 0
        elif e_type == 'su' and not e_name in get_su_names():
            error('SU name [%s] does not match any of the known SUs' % e_name)
            return 0
        elif e_type == 'node' and not e_name in get_node_names():
            error('NODE name [%s] does not match any of the known Nodes' % e_name)
            return 0
        elif e_type == 'si' and not e_name in get_si_names():
            error('SI name [%s] does not match any of the known SIs' % e_name)
            return 0

        s, res = asp_console_execute(
                    ['setc master',
                     'setc cpm',
                     '%s %s %s' % (console_cmd, e_type, e_name)])
        if s:
            error('Failed to %s %s [%s]: %s' % (cli_cmd, e_type, e_name, ''.join(res)))
        else:
            print 'OK'
        
    def lock_unlock_complete(self, text, line, bidx, eidx, cli_cmd):
        """Common command completer for unlock, locki, and locka"""
        
        args = line[:bidx].split()
        assert args[0]==cli_cmd

        if len(args)==3 and not text: # if all arguments are provided already
            return []

        names = []
        if len(args) > 1:
            if args[1] == 'sg':
                names = get_sg_names()
            elif  args[1] == 'su':
                names = get_su_names()
            elif args[1] == 'node':
                names = get_node_names()
            elif args[1] == 'si' and cli_cmd != 'lock_i':
                names = get_si_names()
        else:
            if cli_cmd != 'lock_i':          
                names = ['sg', 'su', 'node', 'si']
            else:
                names = ['sg', 'su', 'node' ]

        # self.dbg = (text, line, bidx, eidx) # FIXME only for debugging
        cmds = [n for n in names if n.startswith(text)]

        if len(cmds)==1: cmds[0]+=' '

        return cmds

    ##
    ## tree command
    ##
    def do_tree(self, msg):
        "Show a tree view of related HA entities containing the specified SG\n" \
        "\n" \
        "Usage: tree <sg-name>\n" \
        "\n" \
        "where\n" \
        "    <sg-name>       is one of the names listed by the 'sgs' command\n"

        args = msg.split()
        if len(args)!=1:
            self.onecmd('help tree')
            return 0
    
        sg_name = msg.strip()
        try:
            sg = get_sg_info(sg_name)
        except  AspError, e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not sg:
            error('Could not find SG [%s] in AMF database' % sg_name)
            return 0
        
        try: redundancy = _redundancy_map[sg.config[0].redundancy_model[0]]
        except KeyError: redundancy = sg.config[0].redundancy_model[0]
        print 'SG %s (redundancy:%s, state:%s/%s)' % \
            (color('bold', sg.value),
             redundancy,
             color('bold-red', _state_map[sg.config[0].admin_state[0]]),
             color('bold-red', _state_map[sg.config[0].computed_admin_state[0]]))

        instantiable_sus = sg.status[0].instantiable_sus[0]
        if instantiable_sus == '0': instantiable_sus = []
        else:                       instantiable_sus = instantiable_sus.su

        instantiated_sus = sg.status[0].instantiated_sus[0]
        if instantiated_sus == '0': instantiated_sus = []
        else:                       instantiated_sus = instantiated_sus.su

        spare_sus = sg.status[0].inservice_spare_sus[0]
        if spare_sus == '0': spare_sus = []
        else:                spare_sus = spare_sus.su
        
        assigned_sus = sg.status[0].assigned_sus[0]
        if assigned_sus == '0': assigned_sus = []
        else:                   assigned_sus = assigned_sus.su
        
        all_sus = instantiable_sus + instantiated_sus + spare_sus + assigned_sus
        # assert all_sus == list(set(all_sus)), 'Same SU in multiple lists'
        
        amf_db = load_amf_db()
        nodes = [su.config[0].member_of_node[0]
                 for su in amf_db.ams[0].entities[0].sus[0].su
                 if su.value in all_sus]
        nodes = dict([(n, 0) for n in nodes]).keys() # weeding out duplicates
        
        cluster_info = get_cluster_info()
        nodeaddrs = dict([(c.nodename, c.nodeaddr) for c in cluster_info])
        
        nodes.sort()
        for node in nodes:

            print '   Node %s' % color('bold', node)
            
            try:
                comps_info = get_comps_info(nodeaddrs[node], do_ps=False)
            except AspError, e:
                error('Command is not available while SAFplus is down (run "status"),')
                error('or if another safplus_console is running')
                return 0
            except KeyError, e:
                continue

            pids = dict([(c.compname, c.pid) for c in comps_info])
            
            sus = [su for su in amf_db.ams[0].entities[0].sus[0].su
                   if su.config[0].member_of_sg[0] == sg_name and
                      su.config[0].member_of_node[0] == node]
            
            sus.sort(lambda x,y: cmp(x.value, y.value))
            for su in sus:

                print '        SU %s (state:%s/%s)' % \
                    (color('bold', su.value),
                     color('bold-red', _state_map[su.config[0].admin_state[0]]),
                     color('bold-red', _state_map[su.config[0].computed_admin_state[0]]))

                sis = su.status[0].sis[0]
                if sis == '0': sis = []
                else:          sis = sis.si
                
                for si in sis:
                    print '           SI %s (state:%s)' % \
                        (si.value, color_state(si.ha_state[0]))
        
                compnames = su.config[0].components[0]
                if compnames == '0': compnames = []
                else:                 compnames = compnames.comp
                
                for compname in compnames:
                    
                    comp = get_comp_info(compname)
                    try:
                      print '           Comp %s (PS:%s OS:%s RS:%s PID:%s)' % \
                        (color('bold', compname),
                         comp.status[0].presence_state[0],
                         comp.status[0].operational_state[0],
                         _readiness_map[comp.status[0].readiness_state[0]],
                         color('bold-cyan', pids[compname]))
                    except KeyError, e: continue

                    csis = comp.status[0].csis[0]
                    if csis == '0': csis = []
                    else:           csis = csis.csi

                    for csi in csis:
                        print '                CSI %s (state:%s)' % \
                            (csi.value, color_state(csi.ha_state[0]))
                        
    def complete_tree(self, text, line, bidx, eidx):
        return [n for n in get_sg_names() if n.startswith(text)]
    
    ##
    ## forest command
    ##
    def do_forest(self, msg):
        """print the HA hierarchy for each SG in the cluster (call 'tree' for each SG)"""
        for sgname in get_sg_names():
            self.onecmd('tree %s' % sgname)

    ##  
    ## unlock command
    ##
    def do_unlock(self, msg):
        "Unlock an SG or SU\n" \
        "\n" \
        "Usage: unlock sg <sg-name> or\n" \
        "       unlock su <su-name>\n" \
        "       unlock node <node-name>\n" \
        "       unlock si <si-name>\n" 
        self.lock_unlock(msg, 'unlock', 'amsUnlock')
        
    def complete_unlock(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'unlock')
    
    ##
    ## locki command
    ##
    def do_lock_i(self, msg):
        "Lock-instantiation on an SG, SU or NODE\n" \
        "\n" \
        "Usage: lock_i sg <sg-name> or\n" \
        "       lock_i su <su-name>\n" \
        "       lock_i node <node-name>\n"
        self.lock_unlock(msg, 'lock_i', 'amsLockInstantiation')
        
    def complete_lock_i(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'lock_i')
    
    ##
    ## locki command
    ##
    def do_lock_a(self, msg):
        "Lock-assigment on an SG,SU,NODE or SI\n" \
        "\n" \
        "Usage: lock_a sg <sg-name> or\n" \
        "       lock_a su <su-name>\n" \
        "       lock_a node <node-name>\n" \
        "       lock_a si <si-name>\n"
        self.lock_unlock(msg, 'lock_a', 'amsLockAssignment')
        
    def complete_lock_a(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'lock_a')
    
    #def do_dbg(self, msg): # FIXME only for debugging
    #    print self.dbg
    
    ##
    ## raw command
    ##
    def do_raw(self, msg):
        "Run a batch of safplus_console commands and print status and output\n" \
        "\n" \
        "Usage: raw <cmd> [; <cmd> [; <cmd> ...]]\n" \
        "\n" \
        "Execute the safplus_console command(s) listed. The initial context for the first\n" \
        "command is the root context of the SAFplus console (debug CLI). A sequence of\n" \
        "commands can be composed using the semicolun as command separator.\n" \
        "\n" \
        "The numeric status of the last command together with the textual output of\n" \
        "all commands will be displayed.\n" \
        "\n" \
        "The SAFplus console context is not preserved between subsequent 'raw' commands.\n"
        
        if not msg:
            self.onecmd('help raw')
            return 0
            
        try:
            s, output = asp_console_execute(msg.split(';'), use_file=True)
        except DebugCliError, e:
            error(str(e))
            return 0
        print s
        print '\n'.join(output)

    ##
    ## version command
    ##
    def do_version(self, msg):

        # get a dict with path info
		# if asp is running, this will work
		try:
			asp_run_env = load_asp_run_env()
			version_loc = asp_run_env['ASP_CONFIG'] + "/VERSION"
		except:
			# otherwise, look for BASE_PATH/etc/BUILD
			version_loc = _asp_dir + "/etc/VERSION"

		if not os.path.isfile(version_loc):
			print "Version unknown" 
		else:
			fh = open(version_loc, "r")
			line = fh.readline()
			if len(line) > 1:
				print line.split("=")[1].strip()
			fh.close()
        
    def do_shell(self, msg):
        "Execute the argument(s) in a Unix shell and print the results\n" \
        "\n" \
        "Usage: shell <unix-command> or\n" \
        "       ! <unix-command>\n" \
        "\n" \
        "Examples:\n" \
        "    ! pwd\n" \
        "    ! killall bugs\n"
        
        stdin, stdout = os.popen2(msg)
        while True:
            line = stdout.readline()
            if not line:
                break
            print line,

    def do_EOF(self, msg):
        """Type 'exit' or press Ctrl-D to exit"""
        print # a new line before exiting
        return(self.do_exit(msg))    
    
    def help_help(self):
        """Print this help page"""
        pass

def init_sys_asp():
    linux_code = \
    '''\
import subprocess
import os
import time

def system(cmd):
    """Similar to the os.system call, except that both the output and
    return value is returned"""
    
    #print 'Executing command: %s' % cmd
    child = subprocess.Popen(cmd, shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
    output = []
    while True:
        pid, sts = os.waitpid(child.pid, os.WNOHANG)
        output += child.stdout.readlines() 
        if pid == child.pid:
            break
        else:
            time.sleep(0.00001)

    child.stdout.close()
    child.stderr.close()
    retval = sts
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    #print 'Command return value %s, Output: %s' % (str(retval),output)
    del child
    return (retval, output, signal, core)

def grep_amf_cmd(e):
    return 'ps -eo pid,cmd | grep %s | grep -v grep' % e

def proc_info_cmd(e):
    return 'ps h -p %s -ocomm,%%cpu,nlwp,rss,vsz' % e

echo_cmd = '/bin/echo -e'

'''

    qnx_code = \
    '''\
import popen2
import platform

def on_arch(arch_name):
    return arch_name in arch

def system(cmd):
    """Similar to the os.system call, except that both the output and return value is returned"""
    # WARNING: system will deadlock if command output exceeds ~64 KB!
    #print 'Executing command: [%s]' % cmd
    child = popen2.Popen4(cmd)
    retval = child.wait()
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    if on_arch("x86"):
        output = child.fromchild.readlines()
    else:
        output = child.fromchild.readlines()[3:]
        
    #print 'Command return value [%s], output:%s' % (str(retval), output)
    del child
    return (retval, output, signal, core)

def grep_amf_cmd(e):
    return 'pidin ar | grep %s' % e

def proc_info_cmd(e):
    return 'ps -p %s -ocomm,pcpu,threads,sz,vsz | grep -v COMMAND' % e

arch = platform.machine()
echo_cmd = '/bin/echo'

'''
    if on_platform("linux"):
      p = "linux"
      code = linux_code
    else:
      p = "qnx"
      code = qnx_code

    import imp
    s = imp.new_module("aspinfo_%s" % p)
    sys.modules['aspinfo_%s'%p] = s

    exec code in s.__dict__

    d = {}

    d['system'] = s.system
    d['echo_cmd'] = s.echo_cmd
    d['grep_amf_cmd'] = s.grep_amf_cmd
    d['proc_info_cmd'] = s.proc_info_cmd

    return d

##
## main function
##
def main(argv):
    global _interactive_shell
    extend_path()
    
    cli = Cli(HISTORY_FILE)
    
    def usage(exit_code=0):
        print USAGE_MSG
        cli.onecmd('help')
        sys.exit(exit_code)

    import getopt
    try:
        opts, args = getopt.getopt(argv[1:],'hvc',['help', 'verbose', 'no-colors'])
    except getopt.GetoptError:
        usage(1)
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
        if o in ("-v", "--verbose"):
            global _dblevel
            _dblevel += 1
        if o in ("-c", "--no-colors"):
            global _do_colors
            _do_colors = False
            
    if len(args):
        cli.onecmd(' '.join(args))
        sys.exit(_exit_code)
    else:
        _interactive_shell = True
        try:
            cli.cmdloop("Starting interactive prompt (type 'help' for help)")
        except KeyboardInterrupt:
            print 'Exiting on Ctrl-C'
    sys.exit(0)
    
sys_asp = init_sys_asp()
if __name__ == '__main__':
    main(sys.argv)
