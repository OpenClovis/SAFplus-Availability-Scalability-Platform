#!/usr/bin/env python3
###############################################################################
#
# Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
# 
# The source code for  this program is not published  or otherwise 
# divested of  its trade secrets, irrespective  of  what  has been 
# deposited with the U.S. Copyright office.
# 
# This program is  free software; you can redistribute it and / or
# modify  it under  the  terms  of  the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the  hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
# 
# You  should  have  received  a  copy of  the  GNU General Public
# License along  with  this program. If  not,  write  to  the 
# Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################
"""
Provides various status information about SAFplus running on this node and on the
cluster

Use the --help option or the help command to obtain more information
on available asp-info commands.

The plan is to provide info on many different things, such as (not all
of these are implemented yet):

Info                                                              Needs running
about:                                                                 SAFplus
---------------------------------------------------------------   -------------
- check if SAFplus is properly installed (approximation)                    N
- check the version (build number) of this installation                 N
- check if SAFplus is running and if so, what PID number                    N/A
- list all SAFplus middleware processes running                             Y
- list all SAFplus-based applications started by SAFplus and their status       Y
- list the tipc/gms parameters of this instance of SAFplus                  N
- list all other hosts in the cluster having same tipc netid            N
- list all other SAFplus nodes that are candidates for this cluster         N
- list all SGs in the cluster and their state                           Y
- list all SU in the cluster and their state (and node to run on)       Y

"""

import sys
import os
import time
import signal
import cmd
import pdb
import re
import subprocess
from functools import cmp_to_key

windowed = False
wxInstalled = False
cli = None

try:
    from lxml import etree as et
    import xml.dom.minidom as minidom
    hasLxml = False
except ImportError:
    import xml.dom.minidom as minidom
    hasLxml = False

try:
    import wx
    wxInstalled = True
except ImportError:
    #print ('Running safplus_info in commandline mode')
    pass

def on_platform(p):
  return p in sys.platform

def cmp(a, b):
    return (a > b) - (a < b)

try: # Readline is optional, just gives up command completion and so forth
  if on_platform('linux'): import readline
except:
  pass

##
## Customizable constants
##
GMSCONFIGFILE           = '/etc/clGmsConfig.xml'
HISTORY_FILE            = '.asp-info.hist'
AMF_DB_CACHE_TIMEOUT    = 5.0  # cache aging for amf database [sec]
WELCOME_MSG             = 'SAFplus info utility -- OpenClovis, Inc., 2008'
AMF_NAME                = "safplus_amf"
##
## Internal variables and constants
##
_dblevel = 0 # default debug level
_asp_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
_exit_code = 0
try:
  _app_name = os.path.basename(__file__)
except NameError:  # __file__ is not defined if I'm in the pdb debugger
  _app_name = "safplus_info"
_asp_conf = None                    # caching asp.conf content
_asp_run_env = None                 # caching asp_run.env content
_amf_config_xml = None              # caching clAmfConfig.xml content as dot tree
_do_colors = sys.stderr.isatty()    # output coloring on if not a redirect
_amf_db = None                      # caching amf database
_amf_db_timestamp = None            # time.time of last amf_db cache refresh
_su_names = None                    # cached SU names
_sg_names = None                    # cached SU names
_node_names = None                  # cached Node names
_interactive_shell = False
_yesno_map = {
    'True':     'Y',
    'False':    'N'
}
_member_map = {
    'True':     'Y',
    'False':    'N',
    'Leaving':  'L'
}
_state_map = {
    'Locked Assignment':    'LA',
    'Unlocked':             'UL',
    'Locked Instantiation': 'LI'
}
_classtype_map = {
    'Class A':          'A',
    'Class B':          'B',
    'Class C':          'C',
    'Class D':          'D'
}
_redundancy_map = {
    'No Redundancy':    'None',
    '2N (1+1)':         '1+1',
    'M + N':            'M+N',
    'N-Way-Active':     'N-Way-A'
}
_presence_map = {
    'Uninstantiated':       'U',
    'Instantiating':        'i',
    'Instantiated':         'I',
    'Terminating':          'T',
    'Restarting':           'R',
    'Instantiation Failed': 'iF',
    'Termination Failed':   'tF',
    'Fault':                'F',
    'Fault WTR':            'Fr',
    'Fault WTC':            'Fc',
    'None':                 '-',
    'Unknown':              '?'
}
_operstate_map = {
    'Enabled':              'E',
    'Disabled':             'D',
    'None':                 '-',
    'Unknown':              '?'
}
_readiness_map = {
    'In Service':           'IS',
    'Stopping':             'S',
    'Out of Service':       'OOS',
    'None':                 '-'
}
_hastate_map = {
    'active':               'A',
    'standby':              'S',
    'quiesced':             'Q',
    'quiescing':            'q',
    'none':                 '-',
    'invalid':              '?'
}

NO_SUCH_FILE_OR_DIR     = 127
PROC_GOT_SIGKILL        = 137

USAGE_MSG = """
OpenClovis SAFplus run-time information utility

Usage:
    %(_app_name)s [options] [command(s)]

Options:
    -h, --help          This help page
    -v, --verbose       Be more verbose
    -c, --no-colors     Disables output coloring
""" % locals()


class AspError(Exception): pass
class UnknownError(AspError): pass
class CommandError(AspError): pass
class NotFoundError(AspError): pass
class DebugCliError(AspError): pass    


class Dot:
    """
    The dot class lets you access fields either through field notation (.)
    or dictionary notation ([]).
    """

    def __init__(self, dict):
        for (key, val) in list(dict.items()):
            if type(val) == type({}): val = Dot(val)
            self.__dict__[key] = val

    def __str__(self):
        s=[]
        for (key, val) in list(self.__dict__.items()):
            s.append("'%s':%s" % (str(key), str(val)))
        return "{ " + ", ".join(s) + " }"

    def __repr__(self): return 'Dot(%s)' % self.__str__()

    def has_key(self, key): return key in self.__dict__

    def keys(self): return list(self.__dict__.keys())

    def values(self): return list(self.__dict__.values())

    def items(self): return list(self.__dict__.items())

    def clear(self): self.__dict__.clear()

    def get(self, key, default = None): return self.__dict__.get(key, default)

    def setdefault(self, key, default = None): return self.__dict__.setdefault(key, default)

    def pop(self, key, default = None): return self.__dict__.pop(key, default)

    def popitem(self): return self.__dict__.popitem()

    def iteritems(self): return iter(self.__dict__.items())

    def iterkeys(self): return iter(self.__dict__.keys())

    def itervalues(self): return iter(self.__dict__.values())

    def __getitem__(self, key): return self.__dict__[key]

    def __setitem__(self, key, val): self.__dict__[key] = val

    def __delitem__(self, key): del self.__dict__[key]

    def __len__(self): return self.__dict__.__len__()

    def __contains__(self, item): return item in self.__dict__

    def dot_print(self, prefix=None):
        s = []
        for (key, val) in list(self.__dict__.items()):
            p = (prefix and prefix+'.' or '')+str(key)
            try:
                s.append(val.dot_print(p))
            except AttributeError:
                s.append(p + '=' + str(val)) 
        return '\n'.join(s)


def load_xml_file(filename, strip_root=None):
    """Parse given xml file and turn it into a nested dot object"""
    
    f = open(filename, "r")
    content = f.read()
    f.close()
    
    return load_xml_string(content, strip_root)
    

def load_xml_string(string, strip_root=None):
    """Parse given xml string and turn it into a nested dot object"""

    """Using lxml to parse"""
    def decode_tree(node):
        d = {}
        if len(node):
            for n in list(node):
                tag = n.tag
                text = n.text
                if tag is et.Comment:
                    continue
                else:
                    if tag not in d:
                        d[tag] = []
                    d[tag].append({})

                    if len(n):
                        d[tag][-1] = decode_tree(n)

                    if 'value' in n.attrib:
                        if d[tag][-1]:
                            d[tag][-1]['value'] = n.attrib.get('value').strip()
                        else:
                            d[tag][-1] = n.attrib.get('value').strip()
                    else:
                        if list(n):
                            d2 = d[tag][-1]
                            for n2 in list(n):
                              if n2.tag is et.Comment:
                                  continue
                              if 'value' in n2.attrib:
                                  pass
                              else:
                                  d2[n2.tag][-1] =  decode_tree(n2)
                            d[tag][-1] = d2
                        else:
                            d[tag][-1] = text

        else:
            if 'value' in node.attrib:
                return node.attrib.get('value').strip()
            else:
                return node.text

        return Dot(d)

    """Using minidom to parse"""
    def decode_dom(dom):
        d = {}
        str = ""
        if len(dom.childNodes) > 0:
            for n in dom.childNodes:
                if n.nodeType == minidom.Comment.nodeType: # Skip all comments
                    pass
                elif n.hasChildNodes() == False and n.nodeValue != None:
                    str += n.nodeValue.strip()
                else:
                    if n.tagName not in d:
                        d[n.tagName] = []
                    d[n.tagName].append({})
                    
                    if len(n.childNodes) > 0:
                        d[n.tagName][-1] = decode_dom(n)
                        
                    if n._attrs != None and 'value' in n._attrs:
                        if d[n.tagName][-1]:
                            d[n.tagName][-1]['value'] = n._attrs['value'].nodeValue
                        else:
                            d[n.tagName][-1] = n._attrs['value'].nodeValue
                        
                    elif n._attrs != None and len(list(n._attrs.items()))>0:
                        d2 = d[n.tagName][-1]
                        for (k, v) in list(n._attrs.items()):
                            d2[k] = v.nodeValue
                        d[n.tagName][-1] = d2
        else:
            return dom.nodeValue.strip()

        if len(d)==0: return str
        elif len(str):
            d['value'] = str
        return Dot(d)

    d = None
    if hasLxml:
        tree = et.fromstring(string)
        d = decode_tree(tree)
    else:
        dom = minidom.parseString(string)
        d = decode_dom(dom)

    if strip_root:
        for t in strip_root:
            for tag in t:
                if tag not in d or len(d[tag]) != 1:
                    break
                d = d[tag][0]

    return d

def color(code, string):
    """Return with the colorer string accroding to color code if coloring is
       enabled, or the original string otherwise. Color is one of the colors
       define in the following dictionary (using ANSI codes):
    """
    colors = {
        'normal':       '0',
        'bold':         '1',
        'cyan':         '0;36',
        'bold-cyan':    '1;36',
        'red':          '0;31',
        'bold-red':     '1;31',
        'green':        '0;32',
        'bold-green':   '1;32',
        'yellow':       '0;33',
        'bold-yellow':  '1;33',
        'blue':         '0;34',
        'bold-blue':    '1;34'
    }
    col = colors.get(code)
    if _do_colors and col:
        return '\033[%sm%s\033[0m' % (col, string)
    else:
        return string


def color_state(state):
    if state == 'active': return color('bold-red', state)
    elif state == 'standby': return color('bold-yellow', state)
    else: return state
    

def extend_path():
    """Inserts asp_dir/bin to the beginning of the PATH environment"""
    path = os.getenv('PATH')
    path = _asp_dir + '/bin:' + path
    os.putenv('PATH', path)
    

def dbmsg(level, *args):
    """ Level sensitive debug printing function """
    if _dblevel >= level:
        for s in args:
            print(s, end=' ')
        print('')


def error(msg):
    print('***Error: ' + msg)
    global _exit_code
    _exit_code = 1


def system(cmd): return sys_asp['system'](cmd)

def assert_root():
    """Exits if the program is not run as root"""
    ec, res, s, c = system('whoami')
    if ec or len(res)==0:
        error('Could not run "whoami"')
        sys.exit(1)
    if not res[0].strip() == 'root':
        error('You need to be root to run %(_app_name)s' % globals())
        sys.exit(1)


def load_asp_run_env():
    """Returns the content of asp_run.env as a dictionary"""

    global _asp_run_env
    
    if _asp_run_env:
        return _asp_run_env
    
    f = open(_asp_dir + '/etc/asp_run.env', 'r')
    lines = f.readlines()
    f.close()
    try:
        d = dict([l.split('=') for l in [l.strip() for l in lines]
                                     if not l.startswith('#')])
    except:
        raise CommandError('Could not parse asp_run.env. Values are missing?')
    
    _asp_run_env = d
    return _asp_run_env


def load_asp_conf(quit_on_error=True):
    """Returns the content of asp.conf as a dictionary"""
    global _asp_conf

    if _asp_conf:
        return _asp_conf

    try:
        f = open(_asp_dir + '/etc/asp.conf', 'r')
    except IOError as e:
        if quit_on_error:
            error('%s:' % str(e))
            error('Directory [%s/bin] in which %s resides is not part of an SAFplus install' %
                  (_asp_dir, _app_name))
            sys.exit(1)
        else:
            raise

    lines = f.readlines()
    f.close()

    d = {}
    for line in lines:
        line = line.strip()
        if line.startswith('#'): continue
        if line.startswith('export '): line = line[len('export '):].strip()
        key_value = line.split('=')
        if len(key_value) == 2: d[key_value[0]] = key_value[1]
        else:                   d[key_value[0]] = None

    _asp_conf = Dot(d)
    return _asp_conf
    
    
def load_amf_config_xml():
    """Loads the clAmfConfig.xml file, and returns a dict structure with
       its content
    """
    global _amf_config_xml
    if not _amf_config_xml:
         _amf_config_xml = load_xml_file(_asp_dir + '/etc/clAmfConfig.xml',
                                         strip_root=(('amfConfig',),
                                                     ('openClovisAsp', 'version', 'amfConfig')))
    return _amf_config_xml
        
    
def load_amf_db():
    """Obtain a snapshot of the amf database from the debug cli and return
       it as a (nested) Dot object. The information is cached for up to
       AMF_DB_CACHE_TIMEOUT [sec]
    """
    
    global _amf_db, _amf_db_timestamp, _interactive_shell
    if _amf_db and not _interactive_shell: # and time.time() <= _amf_db_timestamp + AMF_DB_CACHE_TIMEOUT:
        dbmsg(1, 'working from cached AMF DB')
        return _amf_db

    dbmsg(1, 'Getting fresh AMF DB')
    s, res = asp_console_execute(
                    ['setc master', 'setc cpm', 'amsDbXMLPrint console'],
                    use_file=True)
    if s:
        raise DebugCliError('No access to active system controller')
    
    res = res[-1]
    t = res.find("<asp>")
    if t != -1:  # Strip off any debugging info
      res = res[t:]
    _amf_db = load_xml_string(res, strip_root=(('asp',),))
    
    _amf_db_timestamp = time.time()
    return _amf_db
    

def safe_remove(f):
    try:
        os.remove(f)
    except:
        os.system('rm -f %s' %f)
    
def asp_console_execute(cmds, use_file=False):
    """Executes the list of commands in SAFplus_console (debug cli) and
       returns with a tuple of the status of the last command and a list
       containing the stripped output of each command executed. If use_file
       is True, a temporary file will be used to hold the output of the
       command. This is advised to be used for commands with potentially
       long output, because long outputs have the risk to get popen4
       to create a deadlock.
    """
    prompt = r'cli\[[^[]+\]->\s+'
    out_file = None
    rex_cmdline = re.compile(prompt+r'(?P<cmd>.*)', re.M)
    
    cmd = '%s "%s" | %s/bin/safplus_console' % \
          (sys_asp['echo_cmd'], '\\n'.join(cmds + ['status', 'bye']), _asp_dir)
    if use_file:
        out_file = '%s/var/run/tmp.aspinfo_' % _asp_dir + str(os.getpid())
        cmd += '> %s' %out_file
        
    (ec, output, signal, core) = system(cmd)
    if ec == NO_SUCH_FILE_OR_DIR:
        if out_file:
            safe_remove(out_file)
        raise DebugCliError('Could not find safplus_console')
    if ec and ec != PROC_GOT_SIGKILL:
        if out_file:
            safe_remove(out_file)
        output = ' '.join(output)
        if output.find('instance is already running') >= 0:
            raise DebugCliError('Another safplus_console is already running on this node')
        else:
            raise DebugCliError('Could not run safplus_console: %s' % output)
    
    if use_file:
        f = open(out_file, 'r')
        output = f.read()
        f.close()
        safe_remove(out_file)
 
    res = rex_cmdline.split(''.join(output))
    res2 = [res[res.index(c.strip())+1].strip() for c in cmds]
    trailer_res = res[res.index(cmds[-1].strip())+2:]
    if not trailer_res[0].strip() == 'status':
        raise DebugCliError('Got out of sync when parsing safplus_console output:' +
                            ''.join(output))
    status = trailer_res[1].strip()
    try:
        status = int(status)
    except ValueError:
        raise DebugCliError('safplus_console status command returned non-integer [%s]' %
                            status)
    return (status, res2)


def check_install():
    """Check SAFplus installation and return with 'OK' or 'incomplete/corrupt'
       accordingly. In the latter case, extra error messages may be printed
       while analyzing the install
    """
    file_check_list = [
        'bin/safplus_amf',
        'bin/safplus_gms',
        'bin/safplus_console',
        'etc/asp.conf',
        'etc/asp.py',
        'etc/init.d/safplus',
        'etc/safplus_watchdog.py'
    ]
    for f in file_check_list:
        path = _asp_dir + '/' + f
        all_ok = True
        if not os.access(path, os.F_OK):
            error(path + ' is not found')
            all_ok = False
    if all_ok:
        return 'OK'
    else:
        return 'incomplete/corrupt'

def get_amf_pid(watchdog_pid = False):
    while True:
        valid = subprocess.getstatusoutput("pidof %s" % AMF_NAME);
        if valid[0] == 0:
            if len(valid[1].split())==1:
                return int(valid[1])
        else:
            break
        log.warning('There is more than one AMF pid. Try again...')
        time.sleep(0.25)
    if watchdog_pid:
         valid = subprocess.getstatusoutput("pidof safplus_watchdog.py");
         if valid[0] == 0:
            return int(valid[1])
    return 0;

def is_asp_running(watchdog_pid = False):
    '''
    Return value meaning :
    0 -> running
    1 -> not running,
    2 -> booting/shutting down
    3 -> running without status file, this is a bug.
    '''

    amf_pid = get_amf_pid(watchdog_pid)

    if amf_pid == 0:
        return 1

    asp_status_file = asp_run_env['ASP_RUNDIR'] + '/aspstate-%s' % asp_run_env['ASP_NODEADDR']

    if os.path.exists(asp_status_file):
        (ec, t, signal, core) = system('cat %s' % asp_status_file)
        asp_up = bool(int(t[0]))
        if asp_up:
            return 0
        else:
            return 2
    else:
        return 3

def get_asp_status():
    v = is_asp_running(watchdog_pid = True)

    if v == 0:
        return ('SAFplus is running on node [%s], pid [%s]' % (asp_run_env['ASP_NODEADDR'], get_amf_pid(True)))
    elif v == 1:
        return ('SAFplus is not running on node [%s]' % asp_run_env['ASP_NODEADDR'])
    elif v == 2:
        return ('SAFplus is booting up/shutting down')
    elif v == 3:
        return ('SAFplus is running with pid [%s], but it was not started from this sandbox [%s].' % (get_amf_pid(True), asp_run_env['ASP_DIR']))
    return ""

def get_status_info():
    """Returns with SAFplus running status, as a dict with following entries:
       Key:         Value(s):
       status       'down', 'up', 'booting/shutting down'
       pid          <pid> or 'N/A'
       nodeaddr     <nodeaddr> or 'N/A'
       nodename     <nodename>
    """

    d = Dot({})
    # need to parse 3 forms:
    #   INFO ASP is not running on node [1]
    #   INFO ASP is booting up/shutting down
    #   INFO ASP is running on node [1], pid [21548]
    res = get_asp_status().strip()
    if res.find('not running') >= 0:
        d.status = 'down'
        d.pid    = d.nodeaddr = 'N/A'
        conf = load_asp_conf()
        d.nodename = conf.NODENAME
    elif res.find('booting up') >= 0:
        d.status = 'booting or shutting down'
    elif res.find('running on node') >= 0:
        d.status = 'up'
    else:
        raise CommandError('Unexpected output from asp status: [%s]' % res)
    
    if d.status in ['up', 'booting or shutting down']:
        d.nodeaddr = asp_run_env['ASP_NODEADDR']
        d.nodename = asp_run_env['ASP_NODENAME']
        amf_cmd_line = '%s/bin/safplus_amf' % (_asp_dir)
        cmd = sys_asp['grep_amf_cmd'](amf_cmd_line)
        (ec, output, signal, core) = system(cmd)
        if ec:
            raise CommandError('SAFplus is reported running, but could not retrieve PID')
        d.pid = output[0].split()[0].strip()
        # Sanity check: if 'up', same pid should have been in res message
        if d.status == 'up' and res.find(d.pid) == -1:
            raise UnknownError('PID mismatch beetween asp status and pgrep')
    
    return d

def get_tipc_config_tool_exist():

    child = subprocess.Popen("tipc-config|grep -c tipc-config", shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
    output = []
    output += child.stdout.readlines()
    child.stdout.close()
    child.stderr.close()
    if int(output[0]) > 0:
        return 1
    else:
        currentpath=os.path.abspath(os.path.join(os.path.dirname(__file__),".."))
        tipc_config_cmd = currentpath + os.sep + os.sep +'bin' + os.sep + os.sep + "tipc-config"
        if os.path.exists(tipc_config_cmd):
            return 1
    return 0

def get_tipc_live_node_info():
    """Returns with tipc live info, as a dict with following entries:
       Key:         Value(s):
       module       'loaded' or 'not loaded'
       netid        <netid> or 'unknown'
       addr         <addr> or 'unknown'
       ifaces       <list of interface names> or ['unknown']
    """
    d = {}
    ec, res, s, c = system('lsmod | grep -q tipc')
    d['module'] = (ec and 'not loaded' or 'loaded')

    if get_tipc_config_tool_exist() == 1:
        ec, res, s, c = system('tipc-config -netid')
        if ec == NO_SUCH_FILE_OR_DIR:
            raise CommandError('tipc-config command not found')
        elif ec or len(res)!=1:
            d['netid'] = 'unknown'
        else:
            d['netid'] = res[0].strip().split()[-1]

        ec, res, s, c = system('tipc-config -addr')
        if ec or len(res)!=1:
            d['addr'] = 'unknown'
        else:
            d['addr'] = res[0].strip().split()[-1].strip('<>')

        ec, res, s, c = system('tipc-config -b')
        if ec or len(res)<2:
            d['ifaces'] = ['unknown']
        else:
            d['ifaces'] = [i.strip().split(':')[-1] for i in res[1:]]
    else:
        ec, res, s, c = system('tipc node get netid')
        if ec == NO_SUCH_FILE_OR_DIR:
            raise CommandError('tipc command not found')
        elif ec or len(res)!=1:
            d['netid'] = 'unknown'
        else:
            d['netid'] = res[0].strip('\n')

        ec, res, s, c = system('tipc node get address')
        if ec or len(res)!=1:
            d['addr'] = 'unknown'
        else:
            d['addr'] = res[0].strip().split()[-1].strip('<>')

        ec, res, s, c = system('tipc bearer list')
        if ec:
            d['ifaces'] = ['unknown']
        else:
            d['ifaces'] = [i.strip().split(':')[-1] for i in res[0:]]

    return d


def get_gms_info():
    """Returns with GMS config info, as a dict with following entries:
       Key:         Value(s):
       mip          <gms multicast IP address>
       mport        <gms multicast port>
    """
    d = {}

    fn = _asp_dir + GMSCONFIGFILE
    cmd = "grep [mM]ulticastAddress %s |sed 's/<[^>]*>//g'" % fn
    ec, res, s, c = system(cmd)
    if ec or len(res)!=1:
        error('Could not parse [%s] file' % fn)
        d['mip'] = 'unknown'
    else:
        d['mip'] = res[0].strip()

    cmd = "grep [mM]ulticastPort %s |sed 's/<[^>]*>//g'" % fn
    ec, res, s, c = system(cmd)
    if ec or len(res)!=1:
        error('Could not parse [%s] file' % fn)
        d['mport'] = 'unknown'
    else:
        d['mport'] = res[0].strip()

    return d


def get_node_info_from_cpm():
    """Returns with the node type as dot object with following data:
       Key:         Value(s):
       nodename     <nodename>
       nodetype     'controller' or 'worker'
       nodeclass    <classname>
       defnodeaddr  <DEFAULT_NODEADDR>
       assignmode   <AUTO_ASSIGN_NODEADDR> or 'default'
       netid        <tipc netid> (intended) or 'pre-configured'
       addr         <tipc address> (intended) or 'pre-configured'
       ifaces       <tipc ifaces> (intended)
       Does not require SAFplus to run.
    """
    d = Dot({})
    asp_conf = load_asp_conf()

    d.nodename = asp_conf.NODENAME
    cfg = load_amf_config_xml()

    try:
        d.nodeclass = str([i.type for i in cfg.nodeInstances[0].nodeInstance
                           if i.name==d.nodename][0])
        nodetype = [c.cpmType for c in cfg.cpmConfigs[0].cpmConfig
                    if c.nodeType==d.nodeclass][0]

        if nodetype == 'GLOBAL':
            d.nodetype = 'controller'
        else:
            d.nodetype = 'worker'
    except:
        d.nodeclass = ''
        d.nodetype = 'worker'

    d.defnodeaddr = asp_conf.DEFAULT_NODEADDR

    d.assignmode = asp_conf.AUTO_ASSIGN_NODEADDR or 'default'

    d.netid = asp_conf.TIPC_NETID or 'pre-configured'
    
    if d.assignmode == 'default':
        d.addr = '1.1.%s' % asp_conf.DEFAULT_NODEADDR
    elif d.netid == 'pre-configured':
        d.addr = 'pre-configured'
    else:
        d.addr = '1.1.<node-address> to be determined at startup time'
    
    d.ifaces = []
    d.ifaces.append(asp_conf.LINK_NAME or 'eth0')
    
    return d


def get_comps_info(nodeaddr, do_ps=True):
    """Obtain the component list from CPM and return it as list of dot objects
       with following fields:
            .compname       <compname>
            .running        'Y' or '-'
            .pid            <pid> or '-'
            .healthy        'Y' or 'N' or '-'
            .command        <command name> or '-'
            .cpu            <cpu util [%]> or '-'
            .mem            <mem util [%]> or '-'
            .threads        <# of threads> or '-'
            .rss            <rss in kb> or '-'
            .vsz            <vsz in KiB> or '-'
    """

    

    s, output = asp_console_execute(['setc %s' % nodeaddr,
                                     'setc cpm',
                                     'compList'], use_file=True)
    if s:
        raise DebugCliError('could not get component list (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))

    table = output[-1] # only care about last command
    tmp = re.split(r'=======*', table) # split up along header hline
    assert len(tmp)==2, 'Expected safplus_console compList response to contain "======*" header line, but got:\n%s' % output

    table_body = tmp[1]
    rows = re.split(r'------*', table_body.strip()) # split along divider lines

    comps = []
    for row in [r for r in rows if r]: # filter out empty rows (last)
        c = Dot({})
        cells = list(map(str.strip, re.split(r'[|]|\n', row.strip())))
        assert len(cells)>=6, 'Expected at least 6 fields, but got: %s' % str(cells)
        c.compname = cells[0]
        c.running = (cells[5] == 'INSTANTIATED' and 'Y' or '-')
        if c.running == 'Y':
            c.pid = cells[3]
            pid = int(c.pid)
            if not pid:
              c.pid = '-'
            assert len(cells)>=11, 'Expected >=11 fields for running component, got: %s' % str(cells)
            c.healthy = (cells[9] == 'ALIVE' and 'Y' or 'N')

            # get extra process information if on local node
            if pid > 0 and do_ps and nodeaddr == get_status_info().nodeaddr:
            
                cmd = sys_asp['proc_info_cmd'](c.pid)
                (ec, output, signal, core) = system(cmd)
                if ec or len(output)!=1:
                    raise CommandError('failed to run ps -p for pid [%s]' % c.pid)
                fields = output[0].split()
                c.command, c.cpu, c.threads, c.rss, c.vsz = fields
            else:
                c.command = c.cpu = c.threads = c.rss = c.vsz = '-'
        else:
            c.pid = c.healthy = c.command = c.cpu = c.threads = \
                c.rss = c.vsz = '-'
        comps.append(c)
    
    return comps


def get_cluster_info():
    """Obtain the cluster list from master CPM and return a list of dot objects
       with following keys:
            .nodename
            .nodeaddr
            .nodetype
            .hastate
    """
    info = get_status_info()

    s, output = asp_console_execute(['setc %(nodeaddr)s' % info,
                                     'setc gmsServer_%(nodename)s' % info,
                                     'memberList 0'], use_file=True)
    if s:
        raise DebugCliError('could not get cluster view (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))
    
    table = output[-1] # only care about last command
    tmp = re.split(r'-------*', table) # split up along hlines
    assert len(tmp)==4, 'Expected 3 hlines in safplus_console output, but got:\n%s' % output

    rows = tmp[-1].strip().split('\n')
    
    nodes = []
    for row in rows:
        n = Dot({})
        cells = row.split()
        assert len(cells)>=7, 'Unexpected cluster view line from safplus_console: %s' % row
        
        n.nodeaddr, n.nodename, addr, port, leader, credential = cells[0:6]
        if credential != '0':
            n.nodetype = 'controller'
            if leader == 'Yes':
                n.hastate = 'active'
            else:
              if leader == '(Pending)':
                n.hastate = 'unassigned'
              else:
                n.hastate = 'standby'
        else:
             n.nodetype = 'worker'
             assert leader == 'No', 'a worker node shall never be the cluster leader'
             n.hastate = '-'

        nodes.append(n)
    
    return nodes

def get_uptime():
    """Obtain node uptime"""

    info = get_status_info()

    s, output = asp_console_execute(['setc %(nodeaddr)s' % info,
                                     'setc cpm', 
                                     'uptime'], use_file=True)
    if s:
        raise DebugCliError('could not get node uptime (exit code of safplus_console: %d). Got: \n%s' %
              (s, ''.join(output)))
    
    tmp = output[-1].strip() # only care about last command
    return tmp

#    amf_db = load_amf_db()
#    assert amf_db.ams[0].service_state[0] == 'Running'
#    amf_nodes = dict([(n.value, n) for n in amf_db.ams[0].entities[0].nodes[0].node])
#    cpm_nodes = dict([(n.value, n) for n in amf_db.cpm[0].node])
#    
#    s, output = asp_console_execute(['setc master', 'setc cpm', 'clusterList'])
#    if s:
#        raise DebugCliError('could not get cluster list (exit code of safplus_console: %d). Got: \n%s' %
#              (s, ''.join(output)))
#    table = output[-1].strip() # only care about last command
#    rows = [r.strip() for r in re.split(r'------*', table)]
#    assert len(rows)>1, 'Expected at least one hline, but got:\n%s' % output
#    del rows[0] # delete table header
#    def nodename_to_nodeaddr(row):
#        cells = [r.strip() for r in row.split('|')]
#        return cells[0], len(cells)>1 and cells[2] or '-'
#    node_addrs = dict([nodename_to_nodeaddr(r) for r in rows if r])
#    
#    nodes = []
#    for name, amf_node in amf_nodes.items():
#        # skip nodes that are not in cluster
#        if amf_node.status[0].is_cluster_member[0] != 'True':
#            continue
#
#        n = Dot({})
#        n.nodename = name
#        n.status = amf_node.status[0].presence_state[0] == 'Instantiated' and \
#                    'UP' or '-'
#        n.hastate = cpm_nodes.get(name) and cpm_nodes.get(name).ha_state[0] or '-'
#        
#        n.nodetype = cpm_nodes.get(name) and 'controller' or 'worker'
#
#        n.nodeaddr = node_addrs[name]
#
#        nodes.append(n)
#
#    return nodes

def get_sgs_info():
    """Obtain the sg list as a list of Dot objects with following info:
            .sgname         <name of sg>
            .redundancy     <redundancy mode>
            .astate         <admin state>
            .castate        <calculated admin state>
            .started        <if SG was started>
            .activesus      # of active SUs
            .stbysus        # of standby SUs
    """
    
    amf_db = load_amf_db()
    
    sgs = []
    for s in amf_db.ams[0].entities[0].sgs[0].sg:
        sg = Dot({})
        sg.sgname     = s.value
        #sg.pactive    = s.config[0].preferred_active_sus[0]
        #sg.pstandby   = s.config[0].preferred_standby_sus[0]
        #sg.pinservice = s.config[0].preferred_inservice_sus[0]
        try:
            sg.redundancy = _redundancy_map[s.config[0].redundancy_model[0]]
        except KeyError:
            sg.redundancy = s.config[0].redundancy_model[0]
        sg.astate     = _state_map[s.config[0].admin_state[0]]
        sg.castate    = _state_map[s.config[0].computed_admin_state[0]]
        sg.activesus  = s.status[0].current_active_sus[0]
        sg.stbysus    = s.status[0].current_standby_sus[0]
        sg.started    = s.status[0].is_started[0]

        sgs.append(sg)
        
    return sgs    


def get_nodes_info():
    """Obtain the su list as a list of Dot objects with following info:
    """
    
    amf_db = load_amf_db()
    
    nodes = []
    for n in amf_db.ams[0].entities[0].nodes[0].node:
        node = Dot({})
        node.nodename     = n.value
        node.classtype    = _classtype_map[n.config[0].class_type[0]]
        node.astate       = _state_map[n.config[0].admin_state[0]]
        node.castate      = _state_map[n.config[0].computed_admin_state[0]]
        node.presence     = _presence_map[n.status[0].presence_state[0]]
        node.operstate    = _operstate_map[n.status[0].operational_state[0]]
        node.instantiable = _yesno_map[n.status[0].is_instantiable[0]]
        node.member       = _member_map[n.status[0].is_cluster_member[0]]
        node.isu          = n.status[0].num_instantiated_sus[0]
        node.asu          = n.status[0].num_assigned_sus[0]

        nodes.append(node)

    return nodes

        
def get_sus_info(nodename=None):
    """Obtain the su list as a list of Dot objects with following info:
    """
    
    amf_db = load_amf_db()
    
    sus = []
    for s in amf_db.ams[0].entities[0].sus[0].su:
        this_nodename = s.config[0].member_of_node[0]
        if nodename and not nodename == this_nodename:
            continue
        su = Dot({})
        su.suname    = s.value
        su.sgname    = s.config[0].member_of_sg[0]
        su.nodename  = this_nodename
        su.astate    = _state_map[s.config[0].admin_state[0]]
        su.castate   = _state_map[s.config[0].computed_admin_state[0]]
        su.presence  = _presence_map[s.status[0].presence_state[0]]
        su.operstate = _operstate_map[s.status[0].operational_state[0]]
        su.readiness = _readiness_map[s.status[0].readiness_state[0]]
        su.comps     = s.status[0].num_instantiated_comps[0]

        if s.status[0].sis[0] == '0':
            su.sis   = '-'
        else:
            su.sis   = ''.join([ _hastate_map[si.ha_state[0]]
                               for si in s.status[0].sis[0].si ])
        
        sus.append(su)

    return sus

        
def get_sg_info(sgname):
    """Return with SG Dot object, straight from the AMF DB for given sg name"""
    
    amf_db = load_amf_db()
    
    for sg in amf_db.ams[0].entities[0].sgs[0].sg:
        if sg.value == sgname:
            return sg
    
    return None


def get_sg_names():
    """Return a list of all SG names in cluster (caching it too)"""

    global _sg_names
    
    if _sg_names:
        return _sg_names
    
    amf_db = load_amf_db()

    _sg_names = [sg.value for sg in amf_db.ams[0].entities[0].sgs[0].sg]
    
    return _sg_names
    
    
def get_su_info(suname):
    """Return with SU Dot object, straight from the AMF DB for given su name"""
    
    amf_db = load_amf_db()
    
    for su in amf_db.ams[0].entities[0].sus[0].su:
        if su.value == suname:
            return su
    
    return None


def get_comp_info(compname):
    """Return with Component Dot object, straight from the AMF DB"""
    
    amf_db = load_amf_db()
    
    for comp in amf_db.ams[0].entities[0].comps[0].comp:
        if comp.value == compname:
            return comp
    
    return None
    
def get_su_names():
    """Return a list of all SU names in cluster (caching it too)"""

    global _su_names
    
    if _su_names:
        return _su_names
    
    amf_db = load_amf_db()

    _su_names = [su.value for su in amf_db.ams[0].entities[0].sus[0].su]
    
    return _su_names
    
def get_si_names():
    """Return a list of all si names in cluster"""

    amf_db = load_amf_db()

    _si_names = [n.value for n in amf_db.ams[0].entities[0].sis[0].si]
    
    return _si_names
    
def get_node_names():
    """Return a list of all node names in cluster (caching it too)"""

    global _node_names
    
    if _node_names:
        return _node_names
    
    amf_db = load_amf_db()

    _node_names = [n.value for n in amf_db.ams[0].entities[0].nodes[0].node]
    
    return _node_names
    
    
class Cli(cmd.Cmd):
    """Command line handler class"""
    
    def __init__(self, histfile):
        self.doc_header = "Available commands (type help <topic> for more info):"
        cmd.Cmd.__init__(self)
        try:
            self.prompt = color('bold-blue', '[%s@' % _app_name) + \
                          color('bold-red', load_asp_conf(False).NODENAME) + \
                          color('bold-blue', ']==> ')
        except:
            self.prompt = color('bold-blue', '[%s]==> ' % _app_name)
            
        self.histfile = histfile

    def preloop(self):
        """ Load history file """
        cmd.Cmd.preloop(self) # call original preloop to activate completion
        
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

        print()
        print(color('bold', WELCOME_MSG))
        print('-'*len(WELCOME_MSG))

    def postloop(self):
        """ Save history file """
        cmd.Cmd.postloop(self) # call original postloop to deactivate completion
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

    def completenames(self, text, *ignored):
        """override cmd's builtin: sneak in a trailing space if cmd was fully
           resolved
        """
        dotext = 'do_'+text
        cmds = [a[3:] for a in self.get_names() if a.startswith(dotext)]
        if len(cmds) == 1:
            cmds[0] = cmds[0]+' '
        return cmds

    def do_exit(self, msg):
        """Exiting the asp-info utility"""
        if len(msg):
            print('No arguments to exit command, please')
            return
        return(1) # will exit cmd loop (but call postloop() first)

    def do_bye(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)
      
    def do_quit(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)
   
    ##
    ## setup command
    ##
    def do_setup(self, msg):
        """Show various information on this SAFplus installation (does not need SAFplus running)"""

        install = check_install()
        print('installation:            %s' % install)
        
        # FIXME: implement build number retrieval [I'm on it -M.S.]
        
        info = get_node_info_from_cpm()
        print('node instance name:      %(nodename)s' % info)
        print('node class:              %(nodeclass)s' % info)
        print('node type:               %(nodetype)s' % info)
        
        conf = load_asp_conf()
        print('default node address:    %(defnodeaddr)s' % info)
        print('node address assignment: %(assignmode)s' % info)
        print('tipc netid:              %(netid)s' % info)
        print('tipc address:            %(addr)s' % info)
        print('cluster interface(s):    %s' % \
              '\n                         '.join(info.ifaces))

        try: info = get_gms_info()
        except AspError as e:
            error(str(e))
            return 0
        print('gms multicast ip:        %(mip)s' % info)
        print('gms multicast port:      %(mport)s' % info)
    
    ##
    ## status command
    ##
    def do_status(self, msg):
        """Show SAFplus running status and some basic run-time information"""

        try:
            info = get_status_info()
        except AspError as e:
            error(str(e))
            return 0
        print('SAFplus run status:          %s' % color('bold-red',
                                                    '%(status)s' % info))
        print('pid of safplus_amf:          %(pid)s' % info)
        # print 'node instance name:      %(nodename)s' % info

        print('actual node address:     %(nodeaddr)s' % info)
        try: tipc = get_tipc_live_node_info()
        except AspError as e:
            error(str(e))
            return 0
        print('tipc kernel module:      %(module)s' % tipc)
        print('tipc network id:         %(netid)s' % tipc)
        print('tipc node address:       %(addr)s' % tipc)
        print('tipc interface(s):       %s' % \
            '\n                         '.join(tipc['ifaces']))
    
        d = {}
        try:
            s, output = asp_console_execute(['setc %(nodeaddr)s' % info])
        except AspError:
            d['console'] = 'not available'
        else:
            if s:
                d['console'] = 'not available'
            else:
                d['console'] = 'available'
        print('SAFplus local console:       %(console)s' % d)

        if info.status == 'down':
            return
        s, output = asp_console_execute(['setc master'])
        if s:
            d['master'] = 'not available'
        else:
            d['master'] = 'available'
            
        print('SAFplus master console:      %(master)s' % d)
    
    ##
    ## role command
    ##
    def do_role(self, msg):
        """Show role of this node in cluster"""
        
        try:
            info = get_status_info()
        except AspError as e:
            error(str(e))
            return 0
        print('node instance name:      %(nodename)s' % info)

        nodetype = get_node_info_from_cpm().nodetype
        print('node type:               %s' % nodetype)
        
        if nodetype == 'controller' and info.status == 'up':
            amf_db = load_amf_db()
            node = [n for n in amf_db.cpm[0].node if n.value == info.nodename]
            if len(node)!=1:
                error('could not find own name [%s] in amf xml dump file' % info.nodename)
                return 0
            ha_state = str(node[0].ha_state[0])
        else:
            ha_state = 'n/a'
        print('controller ha state:     %s' % \
            color_state(ha_state))
    
    ##
    ## host command
    ##
    def do_host(self, msg):
        """Show various information on this host (OS/computer/blade)"""
        cmd = _asp_dir + '/bin/nodeinfo'
        (ec, res, s, c) = system(cmd)
        if ec == NO_SUCH_FILE_OR_DIR:
            error('Could not find nodeinfo command in %s' % _asp_dir+'/bin')
            return 0
        elif ec:
            error('nodeinfo command exited with error')
        print(''.join(res))

    ##
    ## network command
    ##
    def do_network(self, msg):
        """Show other nodes that can potentially belong to this cluster"""
        error('Not yet implemented')
        pass
    
    ##
    ## cluster command
    ##
    def do_cluster(self, msg):
        """Show cluster nodes and their state """

        try:
            nodes = get_cluster_info()
        except AspError as e:
            error(str(e))
            return 0
        
        len_nodename = max([len(n.nodename) for n in nodes]+[9])
        fmt = '%%(nodename)%ds  %%(nodetype)10s  %%(hastate)-8s  %%(nodeaddr)9s' % \
            (len_nodename)

        h = Dot({}) # table header
        h.nodename, h.nodetype, h.hastate,  h.nodeaddr = \
        'NODE-NAME', 'NODE-TYPE', 'HA-STATE', 'NODE-ADDR'

        nodes.sort(key=cmp_to_key(lambda x,y: cmp(int(x.nodeaddr), int(y.nodeaddr))))

        print(color('bold', fmt % h))
        for n in nodes:
            line = n.hastate == 'active' and color('bold-red', fmt % n) or fmt % n
            if n.nodename == get_node_info_from_cpm().nodename:
                line += ' <-- this node'
            print(line)

    def do_uptime(self, msg):
        """Show node uptime """

        try:
            uptime = get_uptime()
        except AspError as e:
            error(str(e))
            return 0

        print(uptime)
    ##
    ## nodes command
    ##
    def do_nodes(self, msg):
        "Show list of node entities and their state\n" \
        "\n" \
        "Usage: nodes\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    ISU:        # of instantiated SUs\n" \
        "    ASU:        # of assigned SUs\n"
        try:
            nodes = get_nodes_info()
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_name = max([len(n.nodename) for n in nodes])
        fmt = '%%(nodename)%ds  %%(classtype)5s  %%(astate)2s  %%(castate)3s  %%(presence)2s  %%(operstate)2s  %%(instantiable)12s  %%(member)14s  %%(isu)3s  %%(asu)3s' % \
                (len_name)

        h = Dot({}) # table header
        h.nodename, h.classtype, h.astate,  h.castate, h.presence, h.operstate, h.instantiable, h.member,         h.isu, h.asu = \
        'NODE',     'CLASS',     'AS',      'CAS',     'PS',       'OS',        'INSTANTIABLE', 'CLUSTER-MEMBER', 'ISU', 'ASU'
        
        nodes.sort(key=cmp_to_key(lambda x,y: cmp(x.nodename, y.nodename)))
        print(color('bold', fmt % h))
        for n in nodes:
            if  n.castate == 'UL' and n.member == 'Y':
                print(color('bold-red', fmt % n))
            elif n.castate == 'LA' and n.member == 'Y':
                print(color('yellow', fmt % n))
            else:
                print(fmt % n)
        
    def print_components(self, asp=True):
        """Prints either the SAFplus components or the user components"""

        try:
            comps = get_comps_info(get_status_info().nodeaddr)
        except AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0

        # pdb.set_trace()
        len_compname = max([len(c.compname) for c in comps])
        len_pid = max([len(c.pid) for c in comps])
        len_command = max([len(c.command) for c in comps])
        len_rss = max([len(c.rss) for c in comps])
        len_vsz = max([len(c.vsz) for c in comps])
        fmt = '%%(compname)%ds  %%(running)s  %%(pid)-%ds  %%(healthy)s  %%(command)-%ds  %%(cpu)4s  %%(threads)2s  %%(rss)%ds  %%(vsz)%ds' % \
                (len_compname, len_pid, len_command, len_rss, len_vsz)

        h = Dot({}) # table header
        h.compname, h.running, h.pid, h.healthy, h.command, h.cpu = \
        'COMPNAME', 'R',       'PID', 'H',       'COMMAND', '%CPU'
        h.threads, h.rss, h.vsz = \
        'TH',    'RSS', 'VSZ'

        asp_comps = ['corServer', 'faultServer', 'eventServer',
                     'nameServer', 'txnServer', 'gmsServer',
                     'alarmServer', 'logServer', 'ckptServer',
                     'cmServer', 'msgServer']
        node_name = load_asp_conf().NODENAME
        asp_comps = ['_'.join([e, node_name]) for e in asp_comps]

        if asp:
            comps = [c for c in comps if c.compname in asp_comps]
        else:
            comps = [c for c in comps if not c.compname in asp_comps]
        
        comps.sort(key=cmp_to_key(lambda x,y: cmp(x.compname, y.compname)))
        
        print(color('bold', fmt % h))
        for c in comps:
            print(c.running=='Y' and color('bold-red', fmt % c) or fmt % c)

    ##
    ## asp command
    ##
    def do_safplus(self, msg):
        "Show SAFplus components running on this node\n" \
        "\n" \
        "Abbreviations:\n" \
        "    R:     Running?\n" \
        "    H:     Healthy?\n" \
        "    TH:    # of threads\n" \
        "    RSS:   Same as rss field in ps Unix command (see man ps)\n" \
        "    VSZ:   Same as vsz field in ps Unix command (see man ps)\n"
        self.print_components(asp=True)
    def do_asp(self, msg):
        "DEPRECATED: Use 'safplus' command instead"
        self.print_components(asp=True)

    ##
    ## components command
    ##
    def do_components(self, msg):
        "Show user components running on this node\n" \
        "\n" \
        "Abbreviations:\n" \
        "    R:     Running?\n" \
        "    H:     Healthy?\n" \
        "    TH:    # of threads\n" \
        "    RSS:   Same as rss field in ps Unix command (see man ps)\n" \
        "    VSZ:   Same as vsz field in ps Unix command (see man ps)\n"
        self.print_components(asp=False)
    
    ##
    ## sgs command
    ##
    def do_sgs(self, msg):
        "Show all defined service groups in cluster\n" \
        "\n" \
        "Abbreviations:\n" \
        "    REDUND:     Redundancy mode\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    A-SUS       # of active SUs\n" \
        "    S-SUS:      # of standby SUS\n" \
        "\n" \
        "Use the 'sg' command to get more information on a given SG\n"

        
        try:
            sgs = get_sgs_info()
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_name = max([len(s.sgname) for s in sgs])
        fmt = '%%(sgname)-%ds  %%(redundancy)7s  %%(astate)3s  %%(castate)3s  %%(started)7s %%(activesus)5s  %%(stbysus)5s' % \
                (len_name)

        h = Dot({}) # table header
        h.sgname,  h.redundancy, h.astate,  h.castate, h.activesus, h.stbysus, h.started = \
        'SG-NAME', 'REDUND',     'AS',      'CAS',     'A-SUS',     'S-SUS',   'STARTED'
        
        sgs.sort(key=cmp_to_key(lambda x,y: cmp(x.sgname, y.sgname)))

        print(color('bold', fmt % h))
        for sg in sgs:
            if  sg.castate == 'UL':
                print(color('bold-red', fmt % sg))
            elif sg.castate == 'LA':
                print(color('yellow', fmt % sg))
            else:
                print(fmt % sg)
    
    ##
    ## sg command
    ##
    def do_sg(self, msg):
        "Show various information on a specified service group\n" \
        "\n" \
        "Usage: sg <sg-name>\n" \
        "\n" \
        "where <sg-name> is one of the names listed by the 'sgs' command.\n"
        
        args = msg.split()
        if len(args)!=1:
            self.onecmd('help sg')
            return 0
            
        try:
            sg = get_sg_info(msg)
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not sg:
            error('Could not find SG [%s] in AMF database' % msg)
            return 0
            
        print('sg name:                 %s' % color('bold', sg.value))
        print('admin state:             %s' % color('bold-red', sg.config[0].admin_state[0]))
        print('computed admin state:    %s' % color('bold-red', sg.config[0].computed_admin_state[0]))
        print('redundancy model:        %s' % sg.config[0].redundancy_model[0])
        print('failback option:         %s' % sg.config[0].failback_option[0])
        print('autorepair:              %s' % sg.config[0].autorepair[0])
        print('preferred active SUs:    %s' % sg.config[0].preferred_active_sus[0])
        print('preferred standby SUs:   %s' % sg.config[0].preferred_standby_sus[0])
        print('preferred inservice SUs: %s' % sg.config[0].preferred_inservice_sus[0])
        print('preferred assigned SUs:  %s' % sg.config[0].preferred_assigned_sus[0])
        print('collocation allowed:     %s' % sg.config[0].collocation_allowed[0])

        started = sg.status[0].is_started[0]
        if started == 'True':
            print('started:                 %s' % color('bold-red', started))
        else:
            print('started:                 %s' % started)

        sus = sg.status[0].instantiable_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print('instantiable SUs:        %s' % \
            '\n                         '.join(sus))
            
        sus = sg.status[0].instantiated_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print('instantiated SUs:        %s' % \
            '\n                         '.join(sus))
            
        sus = sg.status[0].inservice_spare_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print('inservice spare SUs:     %s' % \
            '\n                         '.join(sus))
            
        sus = sg.status[0].assigned_sus[0]
        if sus == '0':  sus = ['-']
        else:           sus = sus.su
        print('assigned SUs:            %s' % \
            '\n                         '.join(sus))
            
        print('current active SUs       %s' % sg.status[0].current_active_sus[0])
        print('current standby SUs      %s' % sg.status[0].current_standby_sus[0])

    def complete_sg(self, text, line, bidx, eidx):
        return [n for n in get_sg_names() if n.startswith(text)]
    
    ##
    ## sus command
    ##
    def do_sus(self, msg):
        "Show list of service units\n" \
        "\n" \
        "Usage: sus [ <nodename> | all ]\n" \
        "\n" \
        "Without argument, lists all SUS defined in the cluster. With the optional node\n" \
        "name, lists SUs dedicated to the given node.\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    CAS:        Computed administrative state (same values as AS)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    RS:         Readiness state:\n" \
        "                FIXME add details here\n" \
        "    IC:         # of instantiated components\n" \
        "    SIS:        Assigned SIs ('A'=active, 'S'=standby, 'Q'=quiesced)\n"

        args = msg.split()
        if len(args)>1:
            self.onecmd('help sus')
            return 0
        elif len(args)==1:
            if msg == 'all':
                nodename = None
            else:
                nodename = msg
        else:
            nodename = get_node_info_from_cpm().nodename
            
        try:
            sus = get_sus_info(nodename=nodename)
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        len_suname = max([len(s.suname) for s in sus]+[7])
        len_sgname = max([len(s.sgname) for s in sus]+[13])
        len_nodename = max([len(s.nodename) for s in sus]+[7])
        fmt = '%%(suname)%ds  %%(sgname)-%ds  %%(nodename)-%ds %%(astate)2s %%(castate)-3s %%(presence)-2s %%(operstate)-2s %%(readiness)-3s %%(comps)2s %%(sis)s' % \
                (len_suname, len_sgname, len_nodename)

        h = Dot({}) # table header
        h.suname,  h.sgname,      h.nodename, h.astate,  h.castate, h.presence, h.operstate, h.readiness, h.comps, h.sis = \
        'SU-NAME','MEMBER-OF-SG', 'ON-NODE',  'AS',      'CAS',     'PS',       'OS',        'RS',        'IC',    'SIS'
        
        sus.sort(key=cmp_to_key(lambda x,y: cmp(x.suname, y.suname)))
        
        print(color('bold', fmt % h))
        for su in sus:
            if  su.castate == 'UL':
                print(color('bold-red', fmt % su))
            elif su.castate == 'LA':
                print(color('yellow', fmt % su))
            else:
                print(fmt % su)
    
    def complete_sus(self, text, line, bidx, eidx):
        names = get_node_names()
        names.append('all')
        return [n for n in names if n.startswith(text)]
        
    ##
    ## su command
    ##
    def do_su(self, msg):
        "Show various information on a specified service unit\n" \
        "\n" \
        "Usage: su <su-name>\n" \
        "\n" \
        "where <su-name> is one of the names listed by the 'sus' command.\n" \

        args = msg.split()
        if len(args)!=1:
            self.onecmd('help su')
            return 0
            
        try:
            su = get_su_info(msg)
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not su:
            error('Could not find SU [%s] in AMF database' % msg)
            return 0
        
        print('su name:                 %s' % color('bold', su.value))
        print('admin state:             %s' % color('bold-red', su.config[0].admin_state[0]))
        print('computed admin state:    %s' % color('bold-red', su.config[0].computed_admin_state[0]))
        print('member of sg:            %s' % su.config[0].member_of_sg[0])
        print('member of node:          %s' % su.config[0].member_of_node[0])
        print('restartable:             %s' % su.config[0].is_restartable[0])
        print('presence state:          %s' % su.status[0].presence_state[0])
        print('readiness state:         %s' % su.status[0].readiness_state[0])
        print('operational state:       %s' % su.status[0].operational_state[0])
        print('number of active SIs:    %s' % su.status[0].num_active_sis[0])
        print('number of standby SIs:   %s' % su.status[0].num_standby_sis[0])
        print('number of quiesced SIs:  %s' % su.status[0].num_quiesced_sis[0])
        print('SU restart count:        %s' % su.status[0].su_restart_count[0])
        print('component restart count: %s' % su.status[0].comp_restart_count[0])
        
        comps = su.config[0].components[0]
        if comps == '0': comps = ['-']
        else:            comps = comps.comp
        print('component list:          %s' % \
            '\n                         '.join(comps))

        sis = su.status[0].sis[0]
        if sis == '0': sis = ['-']
        else:          sis = [si.value + '(%s)' % color_state(si.ha_state[0])
                              for si in sis.si]
        print('SI list:                 %s' % \
            '\n                         '.join(sis))

    def complete_su(self, text, line, bidx, eidx):
        names = get_su_names()
        return [n for n in names if n.startswith(text)]
    
    def lock_unlock(self, msg, cli_cmd, console_cmd):
        """Common function for unlock, locki, and locka"""
        
        args = msg.split()
        
        if len(args)!=2:
            self.onecmd('help %s' %cli_cmd)
            return 0
        if cli_cmd == 'lock_i' and args[0] not in ['sg', 'su', 'node']:
            self.onecmd('help %s' %cli_cmd)
        elif args[0] not in ['sg', 'su', 'node', 'si']:
            self.onecmd('help %s' % cli_cmd)
            return 0
        
        e_type, e_name = args
        if e_type == 'sg' and not e_name in get_sg_names():
            error('SG name [%s] does not match any of the known SGs' % e_name)
            return 0
        elif e_type == 'su' and not e_name in get_su_names():
            error('SU name [%s] does not match any of the known SUs' % e_name)
            return 0
        elif e_type == 'node' and not e_name in get_node_names():
            error('NODE name [%s] does not match any of the known Nodes' % e_name)
            return 0
        elif e_type == 'si' and not e_name in get_si_names():
            error('SI name [%s] does not match any of the known SIs' % e_name)
            return 0

        s, res = asp_console_execute(
                    ['setc master',
                     'setc cpm',
                     '%s %s %s' % (console_cmd, e_type, e_name)])
        if s:
            error('Failed to %s %s [%s]: %s' % (cli_cmd, e_type, e_name, ''.join(res)))
        else:
            print('OK')
        
    def lock_unlock_complete(self, text, line, bidx, eidx, cli_cmd):
        """Common command completer for unlock, locki, and locka"""
        
        args = line[:bidx].split()
        assert args[0]==cli_cmd

        if len(args)==3 and not text: # if all arguments are provided already
            return []

        names = []
        if len(args) > 1:
            if args[1] == 'sg':
                names = get_sg_names()
            elif  args[1] == 'su':
                names = get_su_names()
            elif args[1] == 'node':
                names = get_node_names()
            elif args[1] == 'si' and cli_cmd != 'lock_i':
                names = get_si_names()
        else:
            if cli_cmd != 'lock_i':          
                names = ['sg', 'su', 'node', 'si']
            else:
                names = ['sg', 'su', 'node' ]

        # self.dbg = (text, line, bidx, eidx) # FIXME only for debugging
        cmds = [n for n in names if n.startswith(text)]

        if len(cmds)==1: cmds[0]+=' '

        return cmds

    ##
    ## tree command
    ##
    def do_tree(self, msg):
        "Show a tree view of related HA entities containing the specified SG\n" \
        "\n" \
        "Usage: tree <sg-name>\n" \
        "\n" \
        "where\n" \
        "    <sg-name>       is one of the names listed by the 'sgs' command\n"

        args = msg.split()
        if len(args)!=1:
            self.onecmd('help tree')
            return 0
    
        sg_name = msg.strip()
        try:
            sg = get_sg_info(sg_name)
        except  AspError as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            return 0
        
        if not sg:
            error('Could not find SG [%s] in AMF database' % sg_name)
            return 0
        
        try: redundancy = _redundancy_map[sg.config[0].redundancy_model[0]]
        except KeyError: redundancy = sg.config[0].redundancy_model[0]
        print('SG %s (redundancy:%s, state:%s/%s)' % \
            (color('bold', sg.value),
             redundancy,
             color('bold-red', _state_map[sg.config[0].admin_state[0]]),
             color('bold-red', _state_map[sg.config[0].computed_admin_state[0]])))

        instantiable_sus = sg.status[0].instantiable_sus[0]
        if instantiable_sus == '0': instantiable_sus = []
        else:                       instantiable_sus = instantiable_sus.su

        instantiated_sus = sg.status[0].instantiated_sus[0]
        if instantiated_sus == '0': instantiated_sus = []
        else:                       instantiated_sus = instantiated_sus.su

        spare_sus = sg.status[0].inservice_spare_sus[0]
        if spare_sus == '0': spare_sus = []
        else:                spare_sus = spare_sus.su
        
        assigned_sus = sg.status[0].assigned_sus[0]
        if assigned_sus == '0': assigned_sus = []
        else:                   assigned_sus = assigned_sus.su
        
        all_sus = instantiable_sus + instantiated_sus + spare_sus + assigned_sus
        # assert all_sus == list(set(all_sus)), 'Same SU in multiple lists'
        
        amf_db = load_amf_db()
        nodes = [su.config[0].member_of_node[0]
                 for su in amf_db.ams[0].entities[0].sus[0].su
                 if su.value in all_sus]
        nodes = list(dict([(n, 0) for n in nodes]).keys()) # weeding out duplicates
        
        cluster_info = get_cluster_info()
        nodeaddrs = dict([(c.nodename, c.nodeaddr) for c in cluster_info])
        
        nodes.sort()
        for node in nodes:

            print('   Node %s' % color('bold', node))
            
            try:
                comps_info = get_comps_info(nodeaddrs[node], do_ps=False)
            except AspError as e:
                error('Command is not available while SAFplus is down (run "status"),')
                error('or if another safplus_console is running')
                return 0
            except KeyError as e:
                continue

            pids = dict([(c.compname, c.pid) for c in comps_info])
            
            sus = [su for su in amf_db.ams[0].entities[0].sus[0].su
                   if su.config[0].member_of_sg[0] == sg_name and
                      su.config[0].member_of_node[0] == node]
            
            sus.sort(key=cmp_to_key(lambda x,y: cmp(x.value, y.value)))
            for su in sus:

                print('        SU %s (state:%s/%s)' % \
                    (color('bold', su.value),
                     color('bold-red', _state_map[su.config[0].admin_state[0]]),
                     color('bold-red', _state_map[su.config[0].computed_admin_state[0]])))

                sis = su.status[0].sis[0]
                if sis == '0': sis = []
                else:          sis = sis.si
                
                for si in sis:
                    print('           SI %s (state:%s)' % \
                        (si.value, color_state(si.ha_state[0])))
        
                compnames = su.config[0].components[0]
                if compnames == '0': compnames = []
                else:                 compnames = compnames.comp
                
                for compname in compnames:
                    
                    comp = get_comp_info(compname)
                    try:
                      print('           Comp %s (PS:%s OS:%s RS:%s PID:%s)' % \
                        (color('bold', compname),
                         comp.status[0].presence_state[0],
                         comp.status[0].operational_state[0],
                         _readiness_map[comp.status[0].readiness_state[0]],
                         color('bold-cyan', pids[compname])))
                    except KeyError as e: continue

                    csis = comp.status[0].csis[0]
                    if csis == '0': csis = []
                    else:           csis = csis.csi

                    for csi in csis:
                        print('                CSI %s (state:%s)' % \
                            (csi.value, color_state(csi.ha_state[0])))
                        
    def complete_tree(self, text, line, bidx, eidx):
        return [n for n in get_sg_names() if n.startswith(text)]
    
    ##
    ## forest command
    ##
    def do_forest(self, msg):
        """print the HA hierarchy for each SG in the cluster (call 'tree' for each SG)"""
        for sgname in get_sg_names():
            self.onecmd('tree %s' % sgname)

    ##  
    ## unlock command
    ##
    def do_unlock(self, msg):
        "Unlock an SG or SU\n" \
        "\n" \
        "Usage: unlock sg <sg-name> or\n" \
        "       unlock su <su-name>\n" \
        "       unlock node <node-name>\n" \
        "       unlock si <si-name>\n" 
        self.lock_unlock(msg, 'unlock', 'amsUnlock')
        
    def complete_unlock(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'unlock')
    
    ##
    ## locki command
    ##
    def do_lock_i(self, msg):
        "Lock-instantiation on an SG, SU or NODE\n" \
        "\n" \
        "Usage: lock_i sg <sg-name> or\n" \
        "       lock_i su <su-name>\n" \
        "       lock_i node <node-name>\n"
        self.lock_unlock(msg, 'lock_i', 'amsLockInstantiation')
        
    def complete_lock_i(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'lock_i')
    
    ##
    ## locki command
    ##
    def do_lock_a(self, msg):
        "Lock-assigment on an SG,SU,NODE or SI\n" \
        "\n" \
        "Usage: lock_a sg <sg-name> or\n" \
        "       lock_a su <su-name>\n" \
        "       lock_a node <node-name>\n" \
        "       lock_a si <si-name>\n"
        self.lock_unlock(msg, 'lock_a', 'amsLockAssignment')
        
    def complete_lock_a(self, text, line, bidx, eidx):
        return self.lock_unlock_complete(text, line, bidx, eidx, 'lock_a')
    
    #def do_dbg(self, msg): # FIXME only for debugging
    #    print self.dbg
    
    ##
    ## raw command
    ##
    def do_raw(self, msg):
        "Run a batch of safplus_console commands and print status and output\n" \
        "\n" \
        "Usage: raw <cmd> [; <cmd> [; <cmd> ...]]\n" \
        "\n" \
        "Execute the safplus_console command(s) listed. The initial context for the first\n" \
        "command is the root context of the SAFplus console (debug CLI). A sequence of\n" \
        "commands can be composed using the semicolun as command separator.\n" \
        "\n" \
        "The numeric status of the last command together with the textual output of\n" \
        "all commands will be displayed.\n" \
        "\n" \
        "The SAFplus console context is not preserved between subsequent 'raw' commands.\n"
        
        if not msg:
            self.onecmd('help raw')
            return 0
            
        try:
            s, output = asp_console_execute(msg.split(';'), use_file=True)
        except DebugCliError as e:
            error(str(e))
            return 0
        print(s)
        print('\n'.join(output))

    ##
    ## version command
    ##
    def do_version(self, msg):

        # get a dict with path info
                # if asp is running, this will work
                try:
                        asp_run_env = load_asp_run_env()
                        version_loc = asp_run_env['ASP_CONFIG'] + "/VERSION"
                except:
                        # otherwise, look for BASE_PATH/etc/BUILD
                        version_loc = _asp_dir + "/etc/VERSION"

                if not os.path.isfile(version_loc):
                        print("Version unknown") 
                else:
                        fh = open(version_loc, "r")
                        line = fh.readline()
                        if len(line) > 1:
                                print(line.split("=")[1].strip())
                        fh.close()
        
    def do_shell(self, msg):
        "Execute the argument(s) in a Unix shell and print the results\n" \
        "\n" \
        "Usage: shell <unix-command> or\n" \
        "       ! <unix-command>\n" \
        "\n" \
        "Examples:\n" \
        "    ! pwd\n" \
        "    ! killall bugs\n"
        
        child = subprocess.Popen(msg, shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
        while True:
            line = child.stdout.readline().decode()
            if not line:
                break
            print(line, end=' ')

    def do_EOF(self, msg):
        """Type 'exit' or press Ctrl-D to exit"""
        print() # a new line before exiting
        return(self.do_exit(msg))    
    
    def help_help(self):
        """Print this help page"""
        pass

def init_sys_asp():
    linux_code = \
    '''\
import subprocess
import os
import time

def system(cmd):
    """Similar to the os.system call, except that both the output and
    return value is returned"""
    
    #print 'Executing command: %s' % cmd
    child = subprocess.Popen(cmd, shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
    output = []
    while True:
        pid, sts = os.waitpid(child.pid, os.WNOHANG)
        output += child.stdout.readlines() 
        if pid == child.pid:
            break
        else:
            time.sleep(0.00001)

    output2 = []
    for c in output:
        d = c.decode()
        output2.append(d)

    child.stdout.close()
    child.stderr.close()
    retval = sts
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    #print 'Command return value %s, Output: %s' % (str(retval),output)
    del child
    return (retval, output2, signal, core)

def grep_amf_cmd(e):
    return 'ps -eo pid,cmd | grep %s | grep -v grep' % e

def proc_info_cmd(e):
    return 'ps h -p %s -ocomm,%%cpu,nlwp,rss,vsz' % e

echo_cmd = '/bin/echo -e'

'''

    qnx_code = \
    '''\
import popen2
import platform

def on_arch(arch_name):
    return arch_name in arch

def system(cmd):
    """Similar to the os.system call, except that both the output and return value is returned"""
    # WARNING: system will deadlock if command output exceeds ~64 KB!
    #print 'Executing command: [%s]' % cmd
    child = popen2.Popen4(cmd)
    retval = child.wait()
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    if on_arch("x86"):
        output = child.fromchild.readlines()
    else:
        output = child.fromchild.readlines()[3:]
        
    #print 'Command return value [%s], output:%s' % (str(retval), output)
    del child
    return (retval, output, signal, core)

def grep_amf_cmd(e):
    return 'pidin ar | grep %s' % e

def proc_info_cmd(e):
    return 'ps -p %s -ocomm,pcpu,threads,sz,vsz | grep -v COMMAND' % e

arch = platform.machine()
echo_cmd = '/bin/echo'

'''
    if on_platform("linux"):
      p = "linux"
      code = linux_code
    else:
      p = "qnx"
      code = qnx_code

    import importlib.util
    import importlib.machinery

    d = {}
    modName = "aspinfo_%s" %p
    spec = importlib.machinery.ModuleSpec(modName,None)
    if spec:
      s = importlib.util.module_from_spec(spec)
      sys.modules[modName] = s

      exec(code, s.__dict__)

      d['system'] = s.system
      d['echo_cmd'] = s.echo_cmd
      d['grep_amf_cmd'] = s.grep_amf_cmd
      d['proc_info_cmd'] = s.proc_info_cmd
    else:
      raise AspError('Module name [%s] could not be created'%modeName)
    return d

if wxInstalled:
    import wx
    import wx.lib.mixins.listctrl as listmix
    import wx.lib.scrolledpanel as scrolled
    import wx.richtext as rt
    import wx.lib.agw.pygauge as pg
    import threading
    import math

    kSplitterId = -1

    def get_setup():
        """Show various information on this SAFplus installation (does not need SAFplus running)"""
       
        d={}
        install = check_install()       
        d['installation'] = install
               
        # FIXME: implement build number retrieval [I'm on it -M.S.]
        
        info = get_node_info_from_cpm()
        d['node instance name']=info.nodename
        d['node class']=info.nodeclass
        d['node type']=info.nodetype
        
        #conf = load_asp_conf()
        d['default node address']=info.defnodeaddr
        d['node address assignment']=info.assignmode
        d['tipc netid']=info.netid
        d['tipc address']=info.addr
        d['cluster interface(s)']='\n                         '.join(info.ifaces)

        try: info = get_gms_info()
        except AspError as e:
            MessageBox(str(e),"Error", wx.OK|wx.ICON_ERROR)
            return {}
        d['gms multicast ip']=info['mip']
        d['gms multicast port']=info['mport']
        return d

    def get_status():
        try:
            info = get_status_info()
        except AspError as e:
            wx.MessageBox(str(e), "Error when getting SAFplus info", wx.OK | wx.ICON_ERROR)
            return {}
        nodeStatus = {}
        nodeStatus["SAFplus run status"] = info.status
        nodeStatus["pid of safplus_amf"] = info.pid
        nodeStatus["actual node address"] = info.nodeaddr
        try: tipc = get_tipc_live_node_info()
        except AspError as e:
            wx.MessageBox(str(e), "Error when getting tipc info", wx.OK | wx.ICON_ERROR)
            return nodeStatus
        nodeStatus["tipc kernel module"] = tipc["module"]
        nodeStatus["tipc network id"] = tipc["netid"]
        nodeStatus["tipc node address"] = tipc["addr"]
        nodeStatus["tipc interface(s)"] = ', '.join(tipc["ifaces"])

        localConsoleStatus = "available"
        masterConsoleStatus = "available"
        try:
            s, output = asp_console_execute(['setc %(nodeaddr)s' % info])
        except AspError:
            localConsoleStatus = "not available"
        else:
            if s: localConsoleStatus = "not available"
        nodeStatus["SAFplus local console"] = localConsoleStatus

        if info.status == "down":
            return nodeStatus
        s, output = asp_console_execute(['setc master'])
        if s: masterConsoleStatus = "not available"
        nodeStatus["SAFplus master console"] = masterConsoleStatus
        return nodeStatus

    def clear_db_cache():
        global _amf_db
        _amf_db = None

    from io import StringIO 
    import sys

    class Capturing(list):
        def __enter__(self):
            self._stdout = sys.stdout
            sys.stdout = self._stringio = StringIO()
            return self
        def __exit__(self, *args):
            self.extend(self._stringio.getvalue().splitlines())
            del self._stringio    # free up some memory
            sys.stdout = self._stdout

    class MyTreeCtrl(wx.TreeCtrl):
        def __init__(self, parent, id, pos, size, style):
            wx.TreeCtrl.__init__(self, parent, id, pos, size, style)
        
    def OnCompareItems(self, item1, item2):
        t1 = self.GetItemText(item1)
        t2 = self.GetItemText(item2)
        self.log.WriteText('compare: ' + t1 + ' <> ' + t2 + '\n')
        if t1 < t2: return -1
        if t1 == t2: return 0
        return 1

    class StatusCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.HORIZONTAL)
            data = get_status()
            headers = ["Status", "Value"]
            self.StatusInfo = ListCtrlPanel(self, headers, data)
            self.StatusInfo.list.SetItemTextColour(0, wx.RED)

            self.box.Add(self.StatusInfo, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)

    class NodesCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.HORIZONTAL)
            data = self.getNodesData()
            headers = ["NODE", "CLASS", "AS", "CAS", "PS", "OS", "INSTANTIABLE", "CLUSTER-MEMBER", "ISU", "ASU"]
            self.nodeList = ListCtrlPanel(self, headers, data, True, False)

            for column in range(0, len(headers)):
                self.nodeList.list.SetColumnWidth(column, wx.LIST_AUTOSIZE_USEHEADER)

            for rowIdx in range(0, len(data)):
                CAS_IDX = 3
                NEMBER_IDX = 7
                isMember = self.nodeList.list.GetItem(rowIdx, NEMBER_IDX).GetText()
                computedAdminState = self.nodeList.list.GetItem(rowIdx, CAS_IDX).GetText()
                if isMember != 'Y':
                    continue
                else:
                    if computedAdminState == 'UL':
                        self.nodeList.list.SetItemTextColour(rowIdx, wx.RED)
                    elif computedAdminState == 'LA':
                        self.nodeList.list.SetItemTextColour(rowIdx, wx.YELLOW)

            self.box.Add(self.nodeList, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)

        def getNodesData(self):
            # Turn node info dot obj into a dict suitable for ListCtrlPanel
            result = {}
            try:
                nodeInfo = get_nodes_info()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return result
            clear_db_cache()
            for node in nodeInfo:
                result[node.nodename] = [value for attrib, value in node.items() if attrib != "nodename"]
            return result

    class ClusterCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.HORIZONTAL)
            data = self.getClusterData()
            headers = ["NODE-NAME", "NODE-ADDR", "NODE-TYPE", "HA-STATE", "NOTE"]
            self.clusterInfo = ListCtrlPanel(self, headers, data, True, False)

            for column in range(0, len(headers)):
                self.clusterInfo.list.SetColumnWidth(column, wx.LIST_AUTOSIZE_USEHEADER)

            for rowIdx in range(0, len(data)):
                HA_STATE_IDX = 3
                haState = self.clusterInfo.list.GetItem(rowIdx, HA_STATE_IDX).GetText()
                if haState == "active":
                    self.clusterInfo.list.SetItemTextColour(rowIdx, wx.RED)

            self.box.Add(self.clusterInfo, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)

        def getClusterData(self):
            # Turn cluster info dot obj into a dict suitable for ListCtrlPanel
            result = {}
            try:
                clusterInfo = get_cluster_info()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return result
            clear_db_cache()
            for node in clusterInfo:
                nodeData = [value for attrib, value in node.items() if attrib != "nodename"]
                if node.nodename == get_node_info_from_cpm().nodename:
                    nodeData.append("This node")
                result[node.nodename] = nodeData
            return result

    class ForestCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.VERTICAL)
            self.forest = ForestScrolledPanel(self)
            self.amfDb = None

            self.LoadDb()
            if not self.amfDb:
                return

            sgNames = [sg.value for sg in self.amfDb.ams[0].entities[0].sgs[0].sg]
            self.forest.LoadManySgAsync(sgNames, self.amfDb)

            self.box.Add(self.forest, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)

        def LoadDb(self):
            try:
                self.amfDb = load_amf_db()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return
            clear_db_cache()

    class TreeCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.VERTICAL)
            self.forest = ForestScrolledPanel(self)
            self.currentSg = None
            self.amfDb = None

            self.LoadDb()
            if not self.amfDb:
                return

            sgNames = [sg.value for sg in self.amfDb.ams[0].entities[0].sgs[0].sg]
            self.sgChoice = wx.Choice(self, wx.ID_ANY, size = (300, 40),  choices = sgNames)
            self.sgText = wx.StaticText(self, wx.ID_ANY)
            self.sgText.SetLabel("Tree view for service group: ")

            self.sgBox = wx.BoxSizer(wx.HORIZONTAL)
            self.sgBox.Add(self.sgText, 0, wx.LEFT | wx.ALIGN_CENTER_VERTICAL, 10)
            self.sgBox.Add(self.sgChoice, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 10)

            self.box.Add(self.sgBox, 0, wx.ALL | wx.EXPAND, 0)
            self.box.Add(self.forest, 1, wx.ALL | wx.EXPAND, 0)

            self.SetSizer(self.box)
            self.Bind(wx.EVT_CHOICE, self.OnChoose)

        def LoadDb(self):
            try:
                self.amfDb = load_amf_db()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return
            clear_db_cache()

        def OnChoose(self, event):
            chosenSg = event.GetString()
            if chosenSg != self.currentSg:
                self.currentSg = chosenSg
                self.LoadDb()
                self.forest.LoadSgAsync(sgName = chosenSg, amfDb = self.amfDb)

    class ForestScrolledPanel(scrolled.ScrolledPanel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize)
            self.vBox = wx.BoxSizer(wx.VERTICAL)    # To manage the size of each tree's children's richTextCtrl widgets
            self.SetSizer(self.vBox)
            self.SetBackgroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_DESKTOP))

            self.gauge = None
            self.gaugeBox = None
            self.gaugeCreated = False
            self.gaugeUpdating = False
            self.gaugeFinished = False
            self.gaugeMut = threading.Lock()
            self.gaugeCreateConVar = threading.Condition(self.gaugeMut)
            self.gaugeUpdateConVar = threading.Condition(self.gaugeMut)
            self.gaugeFinishConVar = threading.Condition(self.gaugeMut)

            self.loadThread = None
            self.shouldAbort = False

            global kSplitterId
            splitter = wx.FindWindowById(kSplitterId)
            cmdTreePanel = splitter.GetWindow1()
            self.cmdTree = cmdTreePanel.tree
            self.cmdTree.Bind(wx.EVT_LEFT_DCLICK, self.OnWindowClose)

            self.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseScroll)
            self.SetupScrolling()

        def LoadManyCallback(self, sgNames, amfDb):
            entCountAccum = 0
            hierarchies = []

            try:
                wx.CallAfter(self.ShowGauge)
                for sgName in sgNames:
                    (hierarchy, count) = self.GetSgHierarchy(sgName, amfDb)
                    hierarchies.append(hierarchy)
                    entCountAccum += count
                wx.CallAfter(self.gauge.SetRange, entCountAccum)
                for hierarchy in hierarchies:
                    self.AddSg(hierarchy)
            except self.AbortException:
                return

            with self.gaugeMut:
                if not self.gaugeFinished:
                    self.gaugeFinishConVar.wait()
                wx.CallAfter(self.DestroyGauge)
            wx.CallAfter(self.RefreshDisplay)
            wx.CallAfter(self.ShowChildren)
            self.loadThread = None

        def LoadSgCallback(self, sgName, amfDb):
            wx.CallAfter(self.vBox.Clear, delete_windows = True)

            try:
                wx.CallAfter(self.ShowGauge)
                (hierarchy, count) = self.GetSgHierarchy(sgName, amfDb)
                wx.CallAfter(self.gauge.SetRange, count)
                self.AddSg(hierarchy)
            except self.AbortException:
                return

            with self.gaugeMut:
                if not self.gaugeFinished:
                    self.gaugeFinishConVar.wait()
                wx.CallAfter(self.DestroyGauge)
            wx.CallAfter(self.RefreshDisplay)
            wx.CallAfter(self.ShowChildren)
            self.loadThread = None

        def LoadManySgAsync(self, sgNames, amfDb):
            self.loadThread = threading.Thread(target = self.LoadManyCallback, args = (sgNames, amfDb))
            self.loadThread.start()

        def LoadSgAsync(self, sgName, amfDb):
            self.loadThread = threading.Thread(target = self.LoadSgCallback, args = (sgName, amfDb))
            self.loadThread.start()

        def AddSg(self, sgHierarchy):
            self.CreateEntityTc(
                self.SgTextCtrl,
                parentWidget = self,
                sgName = sgHierarchy.sgName,
                redundancy = sgHierarchy.redundancy,
                adminState = sgHierarchy.adminState,
                computedAdminState = sgHierarchy.computedAdminState
            )

            dotNodes = sgHierarchy.nodes
            for dotNode in dotNodes:
                self.CreateEntityTc(self.NodeTextCtrl, parentWidget = self, nodeName = dotNode.nodeName)

                dotSus = dotNode.sus
                for dotSu in dotSus:
                    self.CreateEntityTc(
                        self.SuTextCtrl,
                        parentWidget = self,
                        suName = dotSu.suName,
                        adminState = dotSu.adminState,
                        computedAdminState = dotSu.computedAdminState
                    )

                    dotSis = dotSu.assignedSis
                    for dotSi in dotSis:
                        self.CreateEntityTc(
                            self.SiTextCtrl,
                            parentWidget = self,
                            siName = dotSi.siName,
                            haState = dotSi.haState
                        )

                    dotComps = dotSu.comps
                    for dotComp in dotComps:
                        self.CreateEntityTc(
                            self.CompTextCtrl,
                            parentWidget = self,
                            compName = dotComp.compName,
                            presenceState = dotComp.presenceState,
                            operState = dotComp.operState,
                            readinessState = dotComp.readinessState,
                            pid = dotComp.pid
                        )

                        dotCis = dotComp.assignedCsis
                        for dotCsi in dotCis:
                            self.CreateEntityTc(
                                self.CsiTextCtrl,
                                parentWidget = self,
                                csiName = dotCsi.csiName,
                                haState = dotCsi.haState
                            )

        def GetSgHierarchy(self, sgName, amfDb):
            entCount = 1
            sgEnt = self.NameToEntity(sgName, amfDb.ams[0].entities[0].sgs[0].sg)

            sgHierarchy = Dot({
                "sgName": sgEnt.value,
                "redundancy": sgEnt.config[0].redundancy_model[0],
                "adminState": sgEnt.config[0].admin_state[0],
                "computedAdminState": sgEnt.config[0].computed_admin_state[0],
                "nodes": []
            })

            sgStatus = sgEnt.status[0]
            suTypes = ["instantiable_sus", "instantiated_sus", "inservice_spare_sus", "assigned_sus"]
            allSus = []
            for suType in suTypes:
                sgSuStatus = getattr(sgStatus, suType)
                allSus += sgSuStatus[0].su if sgSuStatus[0] != "0" else []

            nodeSuLut = {}  # nodeName - su entity dict
            for su in amfDb.ams[0].entities[0].sus[0].su:
                if su.value in allSus:
                    nodeName = su.config[0].member_of_node[0]
                    suList = nodeSuLut.get(nodeName)
                    if suList:
                        suList.append(su)
                    else:
                        nodeSuLut[nodeName] = [su]

            nodeAddrs = self.GetNodeAddresses()

            for node, suList in nodeSuLut.items():
                dotNode = Dot({"nodeName": node, "sus": []})
                sgHierarchy.nodes.append(dotNode)
                entCount += 1

                pids = self.GetCompPids(nodeAddrs[node])
                if not pids: continue

                for suEnt in suList:
                    dotSu = Dot({
                        "suName": suEnt.value,
                        "adminState": suEnt.config[0].admin_state[0],
                        "computedAdminState": suEnt.config[0].computed_admin_state[0],
                        "assignedSis": [],
                        "comps": []
                    })
                    dotNode.sus.append(dotSu)
                    entCount += 1

                    assignedSis = []
                    suSisStatus = suEnt.status[0].sis[0]
                    if suSisStatus != "0":
                        assignedSis += suSisStatus.si

                    for si in assignedSis:
                        dotSi = Dot({"siName": si.value, "haState": si.ha_state[0]})
                        dotSu.assignedSis.append(dotSi)
                        entCount += 1

                    compNameList = []
                    compConfig = suEnt.config[0].components[0]
                    if compConfig.value != "0":
                        compNameList += compConfig.comp

                    for compName in compNameList:
                        compEnt = self.NameToEntity(compName, amfDb.ams[0].entities[0].comps[0].comp)

                        dotComp = Dot({
                            "compName": compName,
                            "presenceState": compEnt.status[0].presence_state[0],
                            "operState": compEnt.status[0].operational_state[0],
                            "readinessState": compEnt.status[0].readiness_state[0],
                            "pid": pids[compName],
                            "assignedCsis": []
                        })
                        dotSu.comps.append(dotComp)
                        entCount += 1

                        assignedCsi = []
                        compCsiStatus = compEnt.status[0].csis[0]
                        if compCsiStatus != "0":
                            assignedCsi += compCsiStatus.csi

                        for csi in assignedCsi:
                            DotCsi = Dot({"csiName": csi.value, "haState": csi.ha_state[0]})
                            dotComp.assignedCsis.append(DotCsi)
                            entCount += 1

            return (sgHierarchy, entCount)

        def CreateEntityTc(self, tcClass, **kwargs):
            if self.shouldAbort:
                raise self.AbortException

            with self.gaugeMut:
                if not self.gaugeCreated:
                    self.gaugeCreateConVar.wait()
                if self.gaugeUpdating:
                    self.gaugeUpdateConVar.wait()

                wx.CallAfter(tcClass, **kwargs)
                wx.CallAfter(self.AdvanceGauge)
                self.gaugeUpdating = True

        def ShowChildren(self):
            children = self.GetChildren()
            for child in children:
                child.Thaw()

        def GetNodeAddresses(self):
            if self.shouldAbort:
                raise self.AbortException

            clusterInfo = get_cluster_info()
            nodeAddrs = dict([(entry.nodename, entry.nodeaddr) for entry in clusterInfo])
            return nodeAddrs

        def GetCompPids(self, nodeAddr):
            if self.shouldAbort:
                raise self.AbortException

            try:
                cpmCompList = get_comps_info(nodeAddr, do_ps=False)
            except AspError as e:
                error = """Command is not available while SAFplus is down (run "status"),
                or if another safplus_console is running."""
                wx.CallAfter(wx.MessageBox, error, "Error", wx.OK | wx.ICON_ERROR, self)
                raise self.AbortException
            except KeyError as e:
                return None

            pids = dict([(entry.compname, entry.pid) for entry in cpmCompList])
            return pids

        def NameToEntity(self, name, entities):
            for ent in entities:
                if ent.value == name:
                    return ent
            return None

        def RefreshDisplay(self):
            self.vBox.Layout()   # force the sizer to reposition children
            self.SetupScrolling()   # refresh scroll bar

        def ShowGauge(self):
            with self.gaugeMut:
                self.gauge = pg.PyGauge(self, wx.ID_ANY, style = wx.GA_TEXT)
                self.gauge.SetDrawValue(draw=True, drawPercent=True, font=None, colour=wx.BLACK, formatString=None)
                self.gauge.SetBackgroundColour(wx.WHITE)
                gradient = (wx.TheColourDatabase.Find("CADET BLUE"), wx.TheColourDatabase.Find("LIGHT BLUE"))
                self.gauge.SetBarGradient(gradient)

                self.gaugeBox = wx.BoxSizer(wx.HORIZONTAL)
                self.gaugeBox.AddStretchSpacer()
                self.gaugeBox.Add(self.gauge, 1, wx.ALIGN_CENTER, 0)
                self.gaugeBox.AddStretchSpacer()

                self.gauge.Bind(wx.EVT_PAINT, self.OnGaugePaint)

                self.vBox.Add(self.gaugeBox, 1, wx.EXPAND, 0)
                self.vBox.Layout()
                self.gaugeCreated = True
                self.gaugeCreateConVar.notify()

        def AdvanceGauge(self):
            with self.gaugeMut:
                curr = self.gauge.GetValue()
                self.gauge.SetValue(curr + 1)
                self.gaugeUpdating = False
                self.gaugeUpdateConVar.notify()

        def DestroyGauge(self):
            self.gauge.Destroy()
            self.vBox.Remove(self.gaugeBox)
            self.gauge = None
            self.gaugeBox = None
            self.gaugeCreated = False

        def OnMouseScroll(self, event):
            rotation = event.GetWheelRotation()
            direction = - int(rotation / abs(rotation))
            self.ScrollLines(direction)

        def OnWindowClose(self, event):
            # Abort my thread
            if self.loadThread:
                self.shouldAbort = True
                self.loadThread.join()
            self.cmdTree.Unbind(wx.EVT_LEFT_DCLICK, handler = self.OnWindowClose)
            event.Skip()

        def OnGaugePaint(self, event):
            with self.gaugeMut:
                if self.gauge.GetValue() == self.gauge.GetRange():
                    self.gaugeFinished = True
                    self.gaugeFinishConVar.notify()
            event.Skip()

        ##
        ##  Inner classes
        ##

        class AbortException(Exception):
            pass

        class GenericForestTc(rt.RichTextCtrl):
            def __init__(self, parentWidget, indentLevel):
                self.parent = parentWidget
                super().__init__(parentWidget, wx.ID_ANY, size = (1000, 30), style = wx.NO_BORDER | rt.RE_READONLY)

                parentWidget.vBox.Add(self, 0, wx.LEFT | wx.EXPAND, 50 * indentLevel) # vBox of ForestScrolledPanel
                self.SetBackgroundColour(wx.Colour(0, 0, 0, 0)) # transparent textCtrl background
                self.EnableVerticalScrollbar(False)
                self.Freeze()   # Show widget later
                self.Bind(wx.EVT_MOUSEWHEEL, self.parent.OnMouseScroll) # redirect event to the ForestScrolledPanel

            def WriteAdminState(self, adminState, computedAdminState):
                self.WriteText("state: ")
                self.BeginTextColour(wx.RED)
                self.WriteText("{0}/{1}".format(_state_map[adminState], _state_map[computedAdminState]))
                self.EndTextColour()

            def WriteHaState(self, haState):
                self.WriteText("state: ")
                colour = wx.RED if haState == "active" else wx.YELLOW
                self.BeginTextColour(colour)
                self.WriteText(haState)
                self.EndTextColour()

            def WritePid(self, pid):
                pid = str(pid)
                self.WriteText("PID: ")
                self.BeginTextColour(wx.TheColourDatabase.Find("FOREST GREEN"))
                self.WriteText(pid)
                self.EndTextColour()

            def WriteBold(self, text):
                self.BeginBold()
                self.WriteText(text)
                self.EndBold()

            def WriteItalic(self, text):
                self.BeginItalic()
                self.WriteText(text)
                self.EndItalic()

        class SgTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, sgName, redundancy, adminState, computedAdminState):
                super().__init__(parentWidget, indentLevel = 0)
                try: outRedundancy = _redundancy_map[redundancy]
                except KeyError: outRedundancy = redundancy
                self.WriteText("SG ")
                self.WriteBold(sgName)
                self.WriteText("(redundancy: {0}, ".format(outRedundancy))
                self.WriteAdminState(adminState, computedAdminState)
                self.WriteText(")")

        class NodeTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, nodeName):
                super().__init__(parentWidget, indentLevel = 1)
                self.WriteText("Node ")
                self.WriteBold(nodeName)

        class SuTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, suName, adminState, computedAdminState):
                super().__init__(parentWidget, indentLevel = 2)
                self.WriteText("SU ")
                self.WriteBold(suName)
                self.WriteText(" (")
                self.WriteAdminState(adminState, computedAdminState)
                self.WriteText(")")

        class SiTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, siName, haState):
                super().__init__(parentWidget, indentLevel = 3)
                self.WriteText("SI {0}(".format(siName))
                self.WriteHaState(haState)
                self.WriteText(")")

        class CompTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, compName, presenceState, operState, readinessState, pid):
                super().__init__(parentWidget, indentLevel = 3)
                self.WriteText("Comp ")
                self.WriteBold(compName)
                self.WriteText(" (PS: ")
                self.WriteItalic(presenceState)
                self.WriteText(", OS: ")
                self.WriteItalic(operState)
                self.WriteText(", RS: ")
                self.WriteItalic(_readiness_map[readinessState])
                self.WriteText(", ")
                self.WritePid(pid)
                self.WriteText(")")

        class CsiTextCtrl(GenericForestTc):
            def __init__(self, parentWidget, csiName, haState):
                super().__init__(parentWidget, indentLevel = 4)
                self.WriteText("CSI {0}(".format(csiName))
                self.WriteHaState(haState)
                self.WriteText(")")

    class RoleCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.HORIZONTAL)
            data = self.GetMyRole()
            headers = ["Status", "Value"]
            self.myStatus = ListCtrlPanel(self, headers, data, False)
            haState = data["controller ha state"]
            if haState == "active":
                self.myStatus.list.SetItemTextColour(0, wx.RED)
            elif haState == "standby":
                self.myStatus.list.SetItemTextColour(0, wx.YELLOW)

            self.box.Add(self.myStatus, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)

        def GetMyRole(self):
            result = {}
            try:
                info = get_status_info()
            except AspError as e:
                error(str(e))
                return 0

            nodetype = get_node_info_from_cpm().nodetype
            haState = "n/a"

            if nodetype == 'controller' and info.status == 'up':
                amf_db = load_amf_db()
                clear_db_cache()
                thisNode = None
                for node in amf_db.cpm[0].node:
                    if node.value == info.nodename:
                        thisNode = node
                if not thisNode:
                    wx.MessageBox("could not find own name [{0}] in amf xml dump file".format(info.nodename), "Error", wx.OK | wx.ICON_ERROR, self)
                    return result
                haState = node.ha_state[0]

            result["node instance name"] = info.nodename
            result["node type"] = nodetype
            result["controller ha state"] = haState
            return result

    class SgsCmdPanel(wx.Panel):
        def __init__(self, parent):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.box = wx.BoxSizer(wx.HORIZONTAL)
            data = self.getSgsData()
            headers = ["SG-NAME", "REDUND", "AS", "CAS", "A-SUS", "S-SUS", "STARTED"]
            self.sgList = ListCtrlPanel(self, headers, data, True, False)

            self.sgList.list.SetColumnWidth(0, wx.LIST_AUTOSIZE)
            for column in range(1, len(headers)):
                self.sgList.list.SetColumnWidth(column, wx.LIST_AUTOSIZE_USEHEADER)

            for rowIdx in range(0, len(data)):
                CAS_IDX = 3
                computedAdminState = self.sgList.list.GetItem(rowIdx, CAS_IDX).GetText()
                if computedAdminState == 'UL':
                    self.sgList.list.SetItemTextColour(rowIdx, wx.RED)
                elif computedAdminState == 'LA':
                    self.sgList.list.SetItemTextColour(rowIdx, wx.YELLOW)
            self.sgList.list.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.onItemClicked)
            self.box.Add(self.sgList, 1, wx.ALL | wx.EXPAND, 0)
            self.SetSizer(self.box)
            
        def onItemClicked(self, event):
            treePanel = self.Parent.GetWindow1()
            itemToSelect = treePanel.getItemByLabel('sg')
            if itemToSelect:
                tree = self.Parent.GetWindow1().tree
                treePanel.sgToSelect = event.GetText()
                wx.PostEvent(tree, wx.TreeEvent(wx.wxEVT_TREE_ITEM_ACTIVATED, tree, itemToSelect))


        def getSgsData(self):
            result = {}
            try:
                sgs = get_sgs_info()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return result
            except AspError as e:
                wx.MessageBox("Command is not available while SAFplus is down (run 'status'), or if another safplus_console is running", "Error", wx.OK | wx.ICON_ERROR, self)
                return result
            clear_db_cache()
            for sg in sgs:
                result[sg.sgname] = [value for attrib, value in sg.items() if attrib != "sgname"]
            return result

    class SgCmdPanel(wx.Panel):
        def __init__(self, parent, itemToSelect=None):
            super().__init__(parent, wx.ID_ANY, style=wx.WANTS_CHARS)
            self.amfDb = None
            self.LoadDb()

            self.box = wx.BoxSizer(wx.VERTICAL)
            headers = ["Status", "Value"]
            self.sgInfo = ListCtrlPanel(self, headers, {})
            self.currentSg = None

            sgNames = [sg.value for sg in self.amfDb.ams[0].entities[0].sgs[0].sg] if self.amfDb else []
            self.sgChoice = wx.Choice(self, wx.ID_ANY, size = (300, 40),  choices = sgNames)
            self.sgText = wx.StaticText(self, wx.ID_ANY)
            self.sgText.SetLabel("Details for service group: ")

            self.sgBox = wx.BoxSizer(wx.HORIZONTAL)
            self.sgBox.Add(self.sgText, 0, wx.LEFT | wx.ALIGN_CENTER_VERTICAL, 10)
            self.sgBox.Add(self.sgChoice, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 10)

            self.box.Add(self.sgBox, 0, wx.ALL | wx.EXPAND, 0)
            self.box.Add(self.sgInfo, 1, wx.ALL | wx.EXPAND, 0)

            self.SetSizer(self.box)
            #self.Bind(wx.EVT_COMBOBOX, self.OnChoose)
            self.sgChoice.Bind(wx.EVT_CHOICE, self.OnChoose)

            if itemToSelect:
                idx = self.sgChoice.FindString(itemToSelect)
                if idx != wx.NOT_FOUND:
                    self.sgChoice.Selection = idx
                    wx.PostEvent(self.sgChoice, wx.CommandEvent(wx.wxEVT_CHOICE))

        def LoadDb(self):
            try:
                self.amfDb = load_amf_db()
            except DebugCliError as e:
                wx.MessageBox(str(e), "Error in debug cli", wx.OK | wx.ICON_ERROR, self)
                return
            clear_db_cache()

        def GetSgEntity(self, sgName):
            for sg in self.amfDb.ams[0].entities[0].sgs[0].sg:
                if sgName == sg.value:
                    return sg
            return None

        def GetSgInfo(self, sgName):
            self.LoadDb()
            sg = self.GetSgEntity(sgName)
            if not sg:
                wx.MessageBox("Entity: %s not found"%sgName, "Error", wx.OK | wx.ICON_ERROR, self)
                return

            data = {
                "sg name" : sg.value,
                "admin state" : sg.config[0].admin_state[0],
                "computed admin state" : sg.config[0].computed_admin_state[0],
                "redundancy model" : sg.config[0].redundancy_model[0],
                "failback option" : sg.config[0].failback_option[0],
                "autorepair" : sg.config[0].autorepair[0],
                "preferred active SUs" : sg.config[0].preferred_active_sus[0],
                "preferred standby SUs" : sg.config[0].preferred_standby_sus[0],
                "preferred inservice SUs" : sg.config[0].preferred_inservice_sus[0],
                "preferred assigned SUs" : sg.config[0].preferred_assigned_sus[0],
                "collocation allowed" : sg.config[0].collocation_allowed[0],
                "started" : sg.status[0].is_started[0]
            }

            suLut = [
                ("instantiable SUs", sg.status[0].instantiable_sus[0]),
                ("instantiated SUs", sg.status[0].instantiated_sus[0]),
                ("inservice spare SUs", sg.status[0].inservice_spare_sus[0]),
                ("assigned SUs", sg.status[0].assigned_sus[0])
            ]

            for entry in suLut:
                (suType, suList) = entry
                if suList != "0":
                    data[suType] = suList.su[0]
                    for otherSu in suList.su[1:]:
                        data[""] = otherSu  # put other sus in diffrent rows
                else:
                    data[suType] = "-"

            data["current active SUs"] = sg.status[0].current_active_sus[0]
            data["current standby SUs"] = sg.status[0].current_standby_sus[0]
            return data

        def DisplaySgInfo(self, sgData):
            self.sgInfo.data.clear()
            self.sgInfo.list.DeleteAllItems()
            self.sgInfo.data = sgData
            self.sgInfo.PopulateList()

            for rowIdx in range(0, len(sgData)):
                attrib = self.sgInfo.list.GetItem(rowIdx, 0).GetText()
                if "admin state" in attrib:
                    self.sgInfo.list.SetItemTextColour(rowIdx, wx.RED)
                elif attrib == "sg name":
                    self.sgInfo.list.SetItemFont(rowIdx, wx.Font(wx.FontInfo(12).Bold()))
                elif attrib == "started":
                    value = self.sgInfo.list.GetItem(rowIdx, 1).GetText()
                    if value == "True":
                        self.sgInfo.list.SetItemTextColour(rowIdx, wx.RED)

            valColWidth = self.sgInfo.list.GetColumnWidth(1)
            self.sgInfo.list.SetColumnWidth(1, math.ceil(valColWidth + valColWidth * 0.3))
            self.sgInfo.list.Update()

        def OnChoose(self, event):
            chosenSg = self.sgChoice.GetStringSelection()
            if chosenSg != self.currentSg:
                self.currentSg = chosenSg
                data = self.GetSgInfo(chosenSg)
                self.DisplaySgInfo(data)

    class TreeCtrlPanel(wx.Panel):
        def __init__(self, parent, rightPane):
            # Use the WANTS_CHARS style so the panel doesn't eat the Return key.
            wx.Panel.__init__(self, parent, -1, style=wx.WANTS_CHARS)
            self.Bind(wx.EVT_SIZE, self.OnSize)
            self.rightPane = rightPane
            self.splitter = parent
            tID = wx.NewIdRef()

            self.tree = MyTreeCtrl(self, tID, wx.DefaultPosition, wx.DefaultSize,
                               wx.TR_HAS_BUTTONS
                               #| wx.TR_EDIT_LABELS
                               #| wx.TR_MULTIPLE
                               #| wx.TR_HIDE_ROOT
                               )

            isz = (16,16)
            il = wx.ImageList(isz[0], isz[1])
            fldridx     = il.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER,      wx.ART_OTHER, isz))
            fldropenidx = il.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER_OPEN, wx.ART_OTHER, isz))
            fileidx     = il.Add(wx.ArtProvider.GetBitmap(wx.ART_NORMAL_FILE, wx.ART_OTHER, isz))
            #smileidx    = il.Add(images.Smiles.GetBitmap())

            self.tree.SetImageList(il)
            self.il = il

            # NOTE:  For some reason tree items have to have a data object in
            #        order to be sorted.  Since our compare just uses the labels
            #        we don't need any real data, so we'll just use None below for
            #        the item data.

            self.root = self.tree.AddRoot("Safplus commands")
            self.tree.SetItemData(self.root, None)
            self.tree.SetItemImage(self.root, fldridx, wx.TreeItemIcon_Normal)
            self.tree.SetItemImage(self.root, fldropenidx, wx.TreeItemIcon_Expanded)

            cmds = ['status','nodes','cluster','forest','role','sg','sgs','su','sus','tree','safplus','components','lock_i','lock_a','unlock','host','setup','uptime','shell']
            for c in cmds:
                child = self.tree.AppendItem(self.root, c)
                self.tree.SetItemData(child, None)
                self.tree.SetItemImage(child, fldridx, wx.TreeItemIcon_Normal)
                self.tree.SetItemImage(child, fldropenidx, wx.TreeItemIcon_Expanded)

            self.tree.Expand(self.root)

            #self.tree.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
            self.tree.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.OnLeftDClick)
            self.sgToSelect = None

        def getItemByLabel(self, label):
            item,cookie = self.tree.GetFirstChild(self.root)
            while item.IsOk():
                if self.tree.GetItemText(item) == label:
                    return item
                item,cookie = self.tree.GetNextChild(self.root, cookie)
            return None

        def OnSize(self, event):
            w,h = self.GetClientSize()
            self.tree.SetSize(0, 0, w, h)

        def OnLeftDClick(self, event):
            #pt = event.GetPosition();
            #item, flags = self.tree.HitTest(pt)
            item = event.GetItem()
            if item:
                itemText = self.tree.GetItemText(item)
                p = None
                if itemText == 'setup':
                    data = get_setup()
                    headers = ['Name','Value']
                    p = ListCtrlPanel(self.splitter, headers, data)                    
                elif itemText=='host':
                    p = HostPanel(self.splitter)
                elif itemText=='uptime':
                    try:
                        uptime = get_uptime()
                        wx.MessageBox(uptime,"Uptime", wx.OK|wx.ICON_INFORMATION)
                    except AspError as e:
                        wx.MessageBox('Error getting uptime: %s'%str(e),"Error", wx.OK|wx.ICON_ERROR)
                elif itemText in ['lock_a','lock_i','unlock']:  
                    p = AdminCmdsPanel(self.splitter, itemText)
                elif itemText=='forest':
                    p = ForestCmdPanel(self.splitter)
                elif itemText=='tree':
                    p = TreeCmdPanel(self.splitter)
                elif itemText in ['components','safplus']:  
                    p = ComponentsPanel(self.splitter, itemText)
                elif itemText =='shell':  
                    p = ShellPanel(self.splitter)
                elif itemText =='sus':  
                    p = SusPanel(self.splitter, itemText)
                elif itemText =='status':
                    p = StatusCmdPanel(self.splitter)
                elif itemText =='nodes':
                    p = NodesCmdPanel(self.splitter)
                elif itemText =='cluster':
                    p = ClusterCmdPanel(self.splitter)
                elif itemText =='role':
                    p = RoleCmdPanel(self.splitter)
                elif itemText =='sgs':
                    p = SgsCmdPanel(self.splitter)
                elif itemText =='sg':
                    p = SgCmdPanel(self.splitter, self.sgToSelect)
                    self.sgToSelect = None
                if p:
                    self.splitter.ReplaceWindow(self.rightPane, p)
                    self.rightPane.Destroy()
                    self.rightPane = p
            event.Skip()

    class MyListCtrl(wx.ListCtrl, listmix.ListCtrlAutoWidthMixin):
        def __init__(self, parent, ID, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0):
            wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
            listmix.ListCtrlAutoWidthMixin.__init__(self)


    class ListCtrlPanel(wx.Panel, listmix.ColumnSorterMixin):
        def __init__(self, parent, headers=[], data={}, noAutoColSize=False, noSort=True):
            wx.Panel.__init__(self, parent, -1, style=wx.WANTS_CHARS)
            self.noAutoColSize = noAutoColSize
            self.noSort = noSort
            #scrolled.ScrolledPanel.__init__(self, parent, -1)
            tID = wx.NewIdRef()

            sizer = wx.BoxSizer(wx.VERTICAL)

            self.list = MyListCtrl(self, tID,
                                 style=wx.LC_REPORT
                                 #| wx.BORDER_SUNKEN
                                 | wx.BORDER_NONE
                                 #| wx.LC_EDIT_LABELS
                                 #| wx.LC_SORT_ASCENDING    # disabling initial auto sort gives a
                                 #| wx.LC_NO_HEADER         # better illustration of col-click sorting
                                 #| wx.LC_VRULES
                                 #| wx.LC_HRULES
                                 #| wx.LC_SINGLE_SEL
                                 )
            self.headers = headers
            self.data = data
            sizer.Add(self.list, 1, wx.EXPAND)
            self.populateHeaders()
            if len(self.data)>0:
                self.PopulateList()

            # Now that the list exists we can init the other base class,
            # see wx/lib/mixins/listctrl.py
            self.SetSizer(sizer)
            self.SetAutoLayout(True)            
            #self.SetupScrolling()
            #self.SetVirtualSize(self.GetBestSize())
            #self.SetScrollRate(5,5)
            
        def populateHeaders(self):
            #for normal, simple columns, you can add them like this:
            i=0
            for col in self.headers:
                self.list.InsertColumn(i, col)
                i+=1
                #self.list.InsertColumn(1, e", wx.LIST_FORMAT_LEFT)
                #self.list.InsertColumn(2, "Genre")

        def PopulateList(self):           
            dictKeys = list(self.data.keys())
            if not self.noSort:
                dictKeys.sort()
            _data = {i: self.data[i] for i in dictKeys}
 
            items = _data.items()
            for key, data in items:
                index = self.list.InsertItem(self.list.GetItemCount(), key)
                if isinstance(data,list):
                    i=1
                    for item in data:
                        self.list.SetItem(index, i, item)
                        i+=1
                else:
                    self.list.SetItem(index, 1, data)
                if index%2:
                    self.list.SetItemBackgroundColour(index,wx.LIGHT_GREY)
            if not self.noAutoColSize:
                for j in range(self.list.GetColumnCount()):
                    self.list.SetColumnWidth(j, wx.LIST_AUTOSIZE)           
        
    class HostPanel(scrolled.ScrolledPanel):
        def __init__(self, parent):
            #wx.Panel.__init__(self, parent, -1, style=wx.WANTS_CHARS)
            scrolled.ScrolledPanel.__init__(self, parent,-1, #size=(350, 100),
                                 style = wx.TAB_TRAVERSAL|wx.SUNKEN_BORDER, name="hostPanel")
            sizer = wx.BoxSizer(wx.VERTICAL)
            #1. Host info ListCtrl
            hostInfoBox = wx.StaticBox(self, -1, "Host Info")
            (ec, res, s, c) = system('hostid')
            d = {}
            if ec:
                wx.MessageBox('hostid command exited with error',"Error", wx.OK|wx.ICON_ERROR)                
            else:
                d['hostid'] = ''.join(res)
            (ec, res, s, c) = system('hostname')            
            if ec:
                wx.MessageBox('hostname command exited with error',"Error", wx.OK|wx.ICON_ERROR)
            else:
                d['hostname'] = ''.join(res)
            headers = ['Name','Value']
            hostInfoListCtrl = ListCtrlPanel(hostInfoBox, headers,d)
            sizer.Add(hostInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
            hostInfoBox.SetSizer(sizer)
            border = wx.BoxSizer(wx.VERTICAL)
            border.Add(hostInfoBox, 0, wx.EXPAND|wx.ALL, 5)
            #2. CPU info ListCtrl
            d.clear()
            (ec, res, s, c) = system('uname')
            _os = res
            if _os != 'SunOS':
                f = open('/proc/cpuinfo','r')
                if f:
                    cinfo = f.read()
                    f.close()
                    clines = cinfo.split('\n')
                    for l in clines:
                        l.strip()
                        if l: 
                            ll = l.split(':')
                            d[ll[0]] = ll[1]
                    cinfoBox = wx.StaticBox(self, -1, "CPU Info")
                    cpuInfoListCtrl = ListCtrlPanel(cinfoBox, headers,d)
                    cpuSizer = wx.BoxSizer(wx.VERTICAL)
                    cpuSizer.Add(cpuInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    cinfoBox.SetSizer(cpuSizer)
                    border.Add(cinfoBox, 4, wx.EXPAND|wx.ALL, 5)
            #3. Kernel Info ListCtrl
            d.clear()
            (ec, res, s, c) = system('uname -a')
            if ec:
                wx.MessageBox('uname command exited with error',"Error", wx.OK|wx.ICON_ERROR)                
            else:
                d['uname'] = ''.join(res)
            f = open('/proc/cmdline','r')
            if f:
                cmdline = f.read()
                f.close()
                d['cmdline'] = cmdline.split('\n')[0]
                kernelInfoBox = wx.StaticBox(self, -1, "Kernel Info")
                kernelInfoListCtrl = ListCtrlPanel(kernelInfoBox, headers,d)
                kernelInfoSizer = wx.BoxSizer(wx.VERTICAL)
                kernelInfoSizer.Add(kernelInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                kernelInfoBox.SetSizer(kernelInfoSizer)
                border.Add(kernelInfoBox, 0, wx.EXPAND|wx.ALL, 5)
                
            #4. Misc system info
            d.clear()
            if os.path.exists('/etc/motd'):
                f = open('/etc/motd','r')
                if f:
                    motd = f.read()
                    f.close()
                    d['motd'] = motd
                    miscInfoBox = wx.StaticBox(self, -1, "Misc System Info")
                    miscInfoListCtrl = ListCtrlPanel(miscInfoBox, headers,d)
                    miscInfoSizer = wx.BoxSizer(wx.VERTICAL)
                    miscInfoSizer.Add(miscInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    miscInfoBox.SetSizer(miscInfoSizer)
                    border.Add(miscInfoBox, 0, wx.EXPAND|wx.ALL, 5)
            
            #5. meminfo
            d.clear()            
            if _os != 'SunOS':
                f = open('/proc/meminfo','r')
                if f:
                    meminfo = f.read()
                    f.close()
                    mlines = meminfo.split('\n')
                    for l in mlines:
                        l.strip()
                        if l: 
                            ll = l.split(':')
                            d[ll[0].strip()] = ll[1].strip()
                    memInfoBox = wx.StaticBox(self, -1, "Memory Info")
                    memInfoListCtrl = ListCtrlPanel(memInfoBox, headers,d)
                    memInfoSizer = wx.BoxSizer(wx.VERTICAL)
                    memInfoSizer.Add(memInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    memInfoBox.SetSizer(memInfoSizer)
                    border.Add(memInfoBox, 4, wx.EXPAND|wx.ALL, 5)
            
            #6. Disk info
            d.clear()
            if _os != 'SunOS':
                ec2 = -1  # unknown error
                (ec, res, s, c) = system('fdisk -l')            
                if ec == 127:
                    (ec2, res, s, c) = system('/usr/sbin/fdisk -l')
                    if ec2:
                        wx.MessageBox('/usr/sbin/fdisk command exited with error %d'%ec2,"Error", wx.OK|wx.ICON_ERROR)                    
                if ec==0 or ec2==0:
                    diskInfoBox = wx.StaticBox(self, -1, "Disk Info")
                    diskInfoText = wx.StaticText(diskInfoBox,-1,''.join(res))
                    diskInfoSizer = wx.BoxSizer(wx.VERTICAL)
                    diskInfoSizer.Add(diskInfoText, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    diskInfoBox.SetSizer(diskInfoSizer)
                    border.Add(diskInfoBox, 2, wx.EXPAND|wx.ALL, 5)
                elif ec:
                    wx.MessageBox('fdisk command exited with error %d'%ec,"Error", wx.OK|wx.ICON_ERROR)
                    
            #7. Filesystem info
            d.clear()
            (ec, res, s, c) = system('df -h')
            _os = res
            if not ec:                
                if 1:
                    dflines = ''.join(res).split('\n')
                    i=0
                    for l in dflines:
                        l.strip()
                        if l:
                            if i==0: # first line is the header
                                temp = l.split() #Filesystem      Size  Used Avail Use% Mounted on
                                headers = temp[:len(temp)-2]                                
                                headers.append(' '.join(temp[-2:]))
                            else:
                                ll = l.split() #tmpfs           1,6G  2,1M  1,6G   1% /run                                
                                d[ll[0]] = ll[1:]
                        i+=1
                    fsInfoBox = wx.StaticBox(self, -1, "Filesystem Info")
                    fsInfoListCtrl = ListCtrlPanel(fsInfoBox, headers,d)
                    fsInfoSizer = wx.BoxSizer(wx.VERTICAL)
                    fsInfoSizer.Add(fsInfoListCtrl, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    fsInfoBox.SetSizer(fsInfoSizer)
                    border.Add(fsInfoBox, 2, wx.EXPAND|wx.ALL, 5)
            
            #8. Network info
            d.clear()
            ec2 = -1 # Unknown error
            if _os == 'SunOS':
                (ec, res, s, c) = system('ifconfig -a')
            else:
                 (ec, res, s, c) = system('ifconfig')
            if ec == 127:
               (ec2, res, s, c) = system('ip a')
               if ec2:
                   wx.MessageBox('ip command exited with error %d'%ec2,"Error", wx.OK|wx.ICON_ERROR)
            if ec==0 or ec2 ==0:
                networkInfoBox = wx.StaticBox(self, -1, "Network Info")
                networkInfoText = wx.StaticText(networkInfoBox,-1,''.join(res))
                networkInfoSizer = wx.BoxSizer(wx.VERTICAL)
                networkInfoSizer.Add(networkInfoText, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                networkInfoBox.SetSizer(networkInfoSizer)
                border.Add(networkInfoBox, 2, wx.EXPAND|wx.ALL, 5)
            elif ec:
                wx.MessageBox('ifconfig command exited with error %d'%ec,"Error", wx.OK|wx.ICON_ERROR)   
                
            #9. Blade info
            d.clear()
            bladeInfoPath = _asp_dir+'/bin/bladeinfo'
            if os.path.exists(bladeInfoPath):
                (ec, res, s, c) = system(bladeInfoPath+' -c')
                if not ec:
                    (ec, res, s, c) = system(bladeInfoPath+' -a')
                    bladeInfoBox = wx.StaticBox(self, -1, "Blade Info")
                    bladeInfoText = wx.StaticText(bladeInfoBox,-1,''.join(res))
                    bladeInfoSizer = wx.BoxSizer(wx.VERTICAL)
                    bladeInfoSizer.Add(bladeInfoText, 1, wx.EXPAND|wx.BOTTOM|wx.LEFT|wx.RIGHT)
                    bladeInfoBox.SetSizer(bladeInfoSizer)
                    border.Add(bladeInfoBox, 1, wx.EXPAND|wx.ALL, 5)
                else:
                    wx.MessageBox('Note: no IPMI driver, so we cannot gather blade info',"Error", wx.OK|wx.ICON_ERROR)
            else:
                wx.MessageBox('Note: cannot find bladeinfo script, so cannot extract blade info',"Error", wx.OK|wx.ICON_ERROR)
                
            self.SetSizer(border)
            self.SetAutoLayout(True)            
            #self.SetupScrolling()
            self.SetVirtualSize(self.GetBestSize())
            self.SetScrollRate(10,10)

    class AdminCmdsPanel(scrolled.ScrolledPanel):
        def __init__(self, parent, panelName):
            scrolled.ScrolledPanel.__init__(self, parent,-1,
                                 style = wx.TAB_TRAVERSAL|wx.SUNKEN_BORDER, name=panelName)
            border = wx.BoxSizer(wx.VERTICAL)
            entTypeSizer = wx.BoxSizer(wx.HORIZONTAL)
            entTypeText = wx.StaticText(self,-1,'Entity type')
            if self.Name == 'lock_a' or self.Name == 'unlock':
                entTypeList = ['sg', 'su', 'node', 'si']
            else: #lock_i
                entTypeList = ['sg', 'su', 'node']                            
            self.entTypesCb = wx.ComboBox(self, choices=entTypeList, style=wx.CB_DROPDOWN|wx.CB_READONLY)
            entNameSizer = wx.BoxSizer(wx.HORIZONTAL)
            entNameText = wx.StaticText(self,-1,'Entity name')
            self.entNamesCb = wx.ComboBox(self,style=wx.CB_DROPDOWN|wx.CB_READONLY)
            self.btnOK = wx.Button(self,label='OK')
            entTypeSizer.Add(entTypeText, 1, wx.EXPAND|wx.ALL, 5)
            entTypeSizer.Add(self.entTypesCb, 3, wx.EXPAND|wx.ALL, 5)
            entNameSizer.Add(entNameText, 1, wx.EXPAND|wx.ALL, 5)
            entNameSizer.Add(self.entNamesCb, 3, wx.EXPAND|wx.ALL, 5)
                        
            self.Bind(wx.EVT_COMBOBOX, self.evtComboBox, self.entTypesCb)
            self.Bind(wx.EVT_BUTTON, self.OnClick, self.btnOK)
            
            border.Add(entTypeSizer, 0, wx.EXPAND|wx.ALL, 5)
            border.Add(entNameSizer, 0, wx.EXPAND|wx.ALL, 5)
            border.AddStretchSpacer()
            border.Add(self.btnOK, 0, wx.RIGHT|wx.ALIGN_RIGHT, 10)
            border.AddSpacer(10)
            
            self.SetSizer(border)
            self.SetAutoLayout(True)            
            self.SetVirtualSize(self.GetBestSize())
            self.SetScrollRate(10,10)
        
        def fillEntNames(self,ents):
            self.entNamesCb.Clear()
            for e in ents:
                self.entNamesCb.Append(e)
                
        def evtComboBox(self, evt):
            #cb = evt.GetEventObject()
            #data = cb.GetClientData(evt.GetSelection())
            #self.log.WriteText('EvtComboBox: %s\nClientData: %s\n' % (evt.GetString(), data))
            try:
                if evt.GetString() == 'sg':
                    ents = get_sg_names()                
                elif evt.GetString() == 'node':
                    ents = get_node_names().copy()           
                elif evt.GetString() == 'su':                
                    ents = get_su_names()
                elif evt.GetString() == 'si':
                    ents = get_si_names()                   
            except DebugCliError as ex:
                wx.MessageBox(str(ex),self.Name, wx.OK|wx.ICON_ERROR)
                ents = []
            self.fillEntNames(ents)
                
                
        def OnClick(self, event):
            global cli, _exit_code
            entName = self.entNamesCb.GetStringSelection()
            if entName and cli:                
                funcName = 'do_%s'%self.Name
                args = self.entTypesCb.GetStringSelection()+' '+entName
                with Capturing() as output:
                    getattr(cli,funcName)(args)
                msgIcon = wx.ICON_INFORMATION
                if _exit_code!=0:
                    msgIcon = wx.ICON_ERROR
                wx.MessageBox(''.join(output),self.Name, wx.OK|msgIcon)
 
    class ComponentsPanel(scrolled.ScrolledPanel):
        def __init__(self, parent, panelName):
            scrolled.ScrolledPanel.__init__(self, parent,-1,
                                 style = wx.TAB_TRAVERSAL|wx.SUNKEN_BORDER, name=panelName)
            sizer = wx.BoxSizer(wx.VERTICAL)
            headers = ['COMPNAME','RUNNING','PID','HEALTHY','COMMAND','%CPU','THREADS','RSS','VSZ']            
            try:
                comps = get_comps_info(get_status_info().nodeaddr)
            except AspError as e:
                wx.MessageBox('Command is not available while SAFplus is down (run "status")\n or if another safplus_console is running', 'Error', wx.OK|wx.ICON_ERROR)
                return
            asp_comps = ['corServer', 'faultServer', 'eventServer',
                     'nameServer', 'txnServer', 'gmsServer',
                     'alarmServer', 'logServer', 'ckptServer',
                     'cmServer', 'msgServer']
            node_name = load_asp_conf().NODENAME
            asp_comps = ['_'.join([e, node_name]) for e in asp_comps]
            if self.Name == 'safplus':
                comps = [c for c in comps if c.compname in asp_comps]
            else:
                comps = [c for c in comps if not c.compname in asp_comps]
            d={}
            for c in comps:
                d[c.compname]=[c.running,c.pid,c.healthy,c.command,c.cpu,c.threads,c.rss,c.vsz]
            compsInfoListCtrl = ListCtrlPanel(self, headers,d,True,False)
            self.formatListCtrl(compsInfoListCtrl.list)
            sizer.Add(compsInfoListCtrl, 5, wx.EXPAND|wx.ALL, 5)
            self.SetSizer(sizer)
            self.SetAutoLayout(True)            
            self.SetVirtualSize(self.GetBestSize())
            self.SetScrollRate(10,10)
        
        def formatListCtrl(self, listCtrl):
            #print('DBG: items count:%d, col count:%d'%(listCtrl.GetItemCount(), listCtrl.GetColumnCount()))
            #font_bold = wx.Font(wx.FontInfo(12).Bold())
            #head_txt_colr = wx.Colour('BLACK')
            #head_bac_colr = wx.Colour('DARK GREY')
   
            # Currently it is implemented only for wxMSW and
            # does nothing in the other ports       
            #listCtrl.SetHeaderAttr(wx.ItemAttr(head_txt_colr,
            #                                   head_bac_colr,
            #                                   font_bold))
            #hdrAttr = wx.ItemAttr()
            #hdrAttr.SetFont(wx.Font(wx.FontInfo(12).Bold()))
            #listCtrl.SetHeaderAttr(hdrAttr)
            for i in range(0, listCtrl.GetColumnCount()):
                if i==0 or i==4:
                    listCtrl.SetColumnWidth(i, 250)
                else:
                    listCtrl.SetColumnWidth(i, 100)                            
            for i in range(0,listCtrl.GetItemCount()):
                listItem = listCtrl.GetItem(i)
                #print(listCtrl.GetItem(i,1).GetText())
                if listCtrl.GetItem(i,1).GetText()=='Y':
                    #print('comp is running')
                    #font = listItem.GetFont()
                    #listItem.SetFont(font.Bold)
                    listCtrl.SetItemFont(i, wx.Font(wx.FontInfo(12).Bold()))
                    listCtrl.SetItemTextColour(i, wx.RED)
                  
    class SusPanel(wx.Panel):
        def __init__(self, parent, panelName):
            wx.Panel.__init__(self, parent, -1, style=wx.WANTS_CHARS, name=panelName)
            sizer = wx.BoxSizer(wx.VERTICAL)
            nodeSizer = wx.BoxSizer(wx.HORIZONTAL)
            nodeText = wx.StaticText(self,-1,'Node')
            self.nodesCb = wx.ComboBox(self, style=wx.CB_DROPDOWN|wx.CB_READONLY)
            nodeSizer.Add(nodeText, 1, wx.EXPAND|wx.ALL, 5)
            nodeSizer.Add(self.nodesCb, 3, wx.EXPAND|wx.ALL, 5)
            sizer.Add(nodeSizer, 0, wx.EXPAND|wx.ALL, 5)
            self.fillNodes()
            self.nodesCb.Bind(wx.EVT_COMBOBOX, self.evtComboBox)
            
            headers = ['SU NAME','MEMBER OF SG','ON NODE','ADMIN STATE','COMPUTED ADMIN STATE','PRESENCE STATE','OPERATIONAL STATE','READINESS STATE','# OF INSTANTIATED COMP','ASSIGNED SIS']
            self.susListCtrl = ListCtrlPanel(self, headers,{},True,False)
            self.formatListCtrl(self.susListCtrl.list, False)
            sizer.Add(self.susListCtrl, 3, wx.EXPAND|wx.ALL, 5)
            self.SetSizer(sizer)
            
        def fillNodes(self):
            try:
                ents = get_node_names().copy()
                ents.append('all')
            except DebugCliError as ex:
                wx.MessageBox(str(ex),self.Name, wx.OK|wx.ICON_ERROR)
                ents = []
            for e in ents:
                self.nodesCb.Append(e)
            idx = self.nodesCb.FindString(get_node_info_from_cpm().nodename)
            if idx != wx.NOT_FOUND:
                self.nodesCb.Selection = idx
                wx.PostEvent(self.nodesCb, wx.CommandEvent(wx.wxEVT_COMMAND_COMBOBOX_SELECTED)) 
                
        def evtComboBox(self, evt):
            nodeName = self.nodesCb.GetStringSelection()
            if nodeName == 'all':
                nodeName = None
            try:
                sus = get_sus_info(nodename=nodeName)
            except AspError as e:
                wx.MessageBox('Command is not available while SAFplus is down (run "status"),\nor if another safplus_console is running', self.Name, wx.OK|wx.ICON_ERROR)
                return
            self.susListCtrl.data.clear()
            for su in sus:
                self.susListCtrl.data[su.suname]=[su.sgname,su.nodename,su.astate,su.castate,su.presence,su.operstate,su.readiness,su.comps,su.sis]
            self.susListCtrl.list.DeleteAllItems()
            self.susListCtrl.PopulateList()
            self.formatListCtrl(self.susListCtrl.list, True)

        def formatListCtrl(self, listCtrl, colorOnly):
            if not colorOnly:
                for i in range(0, listCtrl.GetColumnCount()):
                    if i in [0,1,2]:
                        listCtrl.SetColumnWidth(i, 250)
                    else:
                        listCtrl.SetColumnWidth(i, 150)
            if colorOnly:
                for i in range(0,listCtrl.GetItemCount()):
                    listItem = listCtrl.GetItem(i)
                    #print(listCtrl.GetItem(i,1).GetText())
                    if listCtrl.GetItem(i,4).GetText()=='UL':
                        #print('comp is running')
                        #font = listItem.GetFont()
                        #listItem.SetFont(font.Bold)
                        listCtrl.SetItemFont(i, wx.Font(wx.FontInfo(12).Bold()))
                        listCtrl.SetItemTextColour(i, wx.RED)
                    elif listCtrl.GetItem(i,4).GetText()=='LA':
                        listCtrl.SetItemFont(i, wx.Font(wx.FontInfo(12).Bold()))
                        listCtrl.SetItemTextColour(i, wx.YELLOW)

    class ShellPanel(wx.Panel):
        def __init__(self, parent):
            wx.Panel.__init__(self, parent, -1, style=wx.WANTS_CHARS)
            sizer = wx.BoxSizer(wx.VERTICAL)
            #prompt = ''
            self.shellText = wx.TextCtrl(self,-1,style=wx.TE_MULTILINE|wx.TE_PROCESS_ENTER)
            self.Bind(wx.EVT_TEXT_ENTER, self.EvtTextEnter, self.shellText)
            sizer.Add(self.shellText, 5, wx.EXPAND|wx.ALL, 5)
            self.fromSel = 0# len(prompt)
            self.toSel = 0
            self.SetSizer(sizer)
            
        def EvtTextEnter(self, event):            
            global cli
            self.toSel = self.shellText.GetLastPosition()            
            funcName = 'do_shell'
            args = self.shellText.GetRange(self.fromSel,self.toSel)
            with Capturing() as output:
                getattr(cli,funcName)(args)           
            self.shellText.AppendText('\n'+'\n'.join(output))
            self.fromSel = self.shellText.GetLastPosition()
            event.Skip()
    

    class MainFrame(wx.Frame):
        def __init__(self, *args, **kwargs):
            wx.Frame.__init__(self, *args, **kwargs)
            global kSplitterId

            #Adding the SplitterWindow
            splitter = wx.SplitterWindow(self, id = wx.ID_ANY, style=wx.SP_LIVE_UPDATE|wx.SP_3D, size = (1000,600))
            kSplitterId = splitter.GetId()
            rightPane = wx.Panel(splitter)
            # add the left Panel
            cmdsTreePanel = TreeCtrlPanel(splitter, rightPane)

            # set up the Splitter
            sash_Position = 300
            splitter.SplitVertically(cmdsTreePanel, rightPane, sash_Position)
            min_Pan_size = 40
            splitter.SetMinimumPaneSize(min_Pan_size)

            self.Fit()

    class MainApp(wx.App):
        def OnInit(self):
            frame = MainFrame(None, title='Safplus commands')
            frame.Show(True)
            self.SetTopWindow(frame)
            return True

#app = MyApp(0)
#app.MainLoop()
##
## main function
##
def main(argv):
    global _interactive_shell, wxInstalled, windowed, cli
    extend_path()
    
    cli = Cli(HISTORY_FILE)
    
    def usage(exit_code=0):
        print(USAGE_MSG)
        cli.onecmd('help')
        sys.exit(exit_code)

    import getopt
    try:
        opts, args = getopt.getopt(argv[1:],'hvc',['help', 'verbose', 'no-colors','ui'])
    except getopt.GetoptError:
        usage(1)
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
        if o in ("-v", "--verbose"):
            global _dblevel
            _dblevel += 1
        if o in ("-c", "--no-colors"):
            global _do_colors
            _do_colors = False
        if o in ('-u', '--ui'):
            if not wxInstalled:
                print ('wxPython(Phoenix) is not installed. Please install it to run safplus_info in the UI mode')
            else:
                windowed = True
    if not windowed:
        if len(args):
            t = ' '.join(args)
            cmds = t.split(",")
            for c in cmds:
                cli.onecmd(c)
            sys.exit(_exit_code)
        else:
            _interactive_shell = True
            try:
                cli.cmdloop("Starting interactive prompt (type 'help' for help)")
            except KeyboardInterrupt:
                print('Exiting on Ctrl-C')
        sys.exit(0)
    else:
        _interactive_shell = True
        app = MainApp(0)
        app.MainLoop()

asp_run_env = load_asp_run_env()
sys_asp = init_sys_asp()
if __name__ == '__main__':
    main(sys.argv)
