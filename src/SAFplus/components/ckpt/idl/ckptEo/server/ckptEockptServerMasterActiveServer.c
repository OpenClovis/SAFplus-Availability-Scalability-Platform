/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "ckptEockptServerMasterActiveServer.h"
#include "ckptEoServer.h"

extern ClUint32T  ckptEoidlSyncKey;
extern ClHandleDatabaseHandleT  ckptEoidlDatabaseHdl;



ClRcT clCkptDeputyCkptCreateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptMastHdl;
    ClHandleT  ckptClntHdl;
    SaNameT  pCkptName;
    ClCkptCheckpointCreationAttributesT_4_0_0  pCkptCreatAtrr;
    ClUint32T  localAddr;
    ClUint32T  portId;
    ClVersionT  pVersion;

    memset(&(ckptMastHdl), 0, sizeof(ClHandleT));
    memset(&(ckptClntHdl), 0, sizeof(ClHandleT));
    memset(&(pCkptName), 0, sizeof(SaNameT));
    memset(&(pCkptCreatAtrr), 0, sizeof(ClCkptCheckpointCreationAttributesT_4_0_0));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptMastHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptClntHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pCkptName));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClCkptCheckpointCreationAttributesT_4_0_0( inMsgHdl,&(pCkptCreatAtrr));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyCkptCreate_4_0_0(ckptMastHdl, ckptClntHdl, &(pCkptName), &(pCkptCreatAtrr), localAddr, portId, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaNameT(&(pCkptName), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreatAtrr), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

L7:    return rc;

LL6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL5:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL4:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL3:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreatAtrr), 0, 1);
LL2:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
LL1:  clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
L1:  clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
L2:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
L3:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreatAtrr), 0, 1);
L4:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
L5:  clXdrMarshallClUint32T(&(portId), 0, 1);

L6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptDeputyCkptCreateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L7:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyCkptOpenServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptMastHdl;
    ClHandleT  ckptClntHdl;
    ClUint32T  localAddr;
    ClUint32T  portId;
    ClVersionT  pVersion;

    memset(&(ckptMastHdl), 0, sizeof(ClHandleT));
    memset(&(ckptClntHdl), 0, sizeof(ClHandleT));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptMastHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptClntHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyCkptOpen_4_0_0(ckptMastHdl, ckptClntHdl, localAddr, portId, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

L5:    return rc;

LL4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL3:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL2:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL1:  clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
L1:  clXdrMarshallClHandleT(&(ckptClntHdl), 0, 1);
L2:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
L3:  clXdrMarshallClUint32T(&(portId), 0, 1);

L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptDeputyCkptOpenResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyCkptInfoUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClUint32T  numOfCkpts;
    CkptInfoT_4_0_0*  pCkptInfo;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(numOfCkpts), 0, sizeof(ClUint32T));
    memset(&(pCkptInfo), 0, sizeof(CkptInfoT_4_0_0*));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(numOfCkpts));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallPtrCkptInfoT_4_0_0( inMsgHdl,(void**)&(pCkptInfo), numOfCkpts);
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyCkptInfoUpdate_4_0_0(&(pVersion), numOfCkpts, pCkptInfo);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallPtrCkptInfoT_4_0_0(pCkptInfo, numOfCkpts, 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallPtrCkptInfoT_4_0_0(pCkptInfo, numOfCkpts, 0, 1);
LL0:  clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);
L1:  clXdrMarshallPtrCkptInfoT_4_0_0(pCkptInfo, numOfCkpts, 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptDeputyCkptInfoUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyCkptInfoUpdateServer_5_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClUint32T  numOfCkpts;
    CkptInfoT_5_0_0*  pCkptInfo;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(numOfCkpts), 0, sizeof(ClUint32T));
    memset(&(pCkptInfo), 0, sizeof(CkptInfoT_5_0_0*));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(numOfCkpts));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallPtrCkptInfoT_5_0_0( inMsgHdl,(void**)&(pCkptInfo), numOfCkpts);
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyCkptInfoUpdate_5_0_0(&(pVersion), numOfCkpts, pCkptInfo);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallPtrCkptInfoT_5_0_0(pCkptInfo, numOfCkpts, 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallPtrCkptInfoT_5_0_0(pCkptInfo, numOfCkpts, 0, 1);
LL0:  clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(numOfCkpts), 0, 1);
L1:  clXdrMarshallPtrCkptInfoT_5_0_0(pCkptInfo, numOfCkpts, 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptDeputyCkptInfoUpdateResponseSend_5_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptCreateInfoDeputyUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    CkptOpenInfoT_4_0_0  openInfo;
    CkptCreateInfoT_4_0_0  pCreateInfo;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(openInfo), 0, sizeof(CkptOpenInfoT_4_0_0));
    memset(&(pCreateInfo), 0, sizeof(CkptCreateInfoT_4_0_0));


    rc = clXdrUnmarshallCkptOpenInfoT_4_0_0( inMsgHdl,&(openInfo));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallCkptCreateInfoT_4_0_0( inMsgHdl,&(pCreateInfo));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptCreateInfoDeputyUpdate_4_0_0(&(pVersion), &(openInfo), &(pCreateInfo));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallCkptOpenInfoT_4_0_0(&(openInfo), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallCkptCreateInfoT_4_0_0(&(pCreateInfo), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallCkptCreateInfoT_4_0_0(&(pCreateInfo), 0, 1);
LL0:  clXdrMarshallCkptOpenInfoT_4_0_0(&(openInfo), 0, 1);

    return rc;

L0:  clXdrMarshallCkptOpenInfoT_4_0_0(&(openInfo), 0, 1);
L1:  clXdrMarshallCkptCreateInfoT_4_0_0(&(pCreateInfo), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptCreateInfoDeputyUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptActiveCkptOpenServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  ckptMastHdl;
    SaNameT  pCkptName;
    ClUint32T  ckptOpenFlags;
    ClCkptCheckpointCreationAttributesT_4_0_0  pCkptCreateAttr;
    ClUint32T  peerAddr;
    ClUint32T  portId;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(ckptMastHdl), 0, sizeof(ClHandleT));
    memset(&(pCkptName), 0, sizeof(SaNameT));
    memset(&(ckptOpenFlags), 0, sizeof(ClUint32T));
    memset(&(pCkptCreateAttr), 0, sizeof(ClCkptCheckpointCreationAttributesT_4_0_0));
    memset(&(peerAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptMastHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pCkptName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(ckptOpenFlags));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClCkptCheckpointCreationAttributesT_4_0_0( inMsgHdl,&(pCkptCreateAttr));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptActiveCkptOpen_4_0_0(&(pVersion), ckptMastHdl, &(pCkptName), ckptOpenFlags, &(pCkptCreateAttr), peerAddr, portId);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaNameT(&(pCkptName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(ckptOpenFlags), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreateAttr), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

L7:    return rc;

LL6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL5:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL4:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
LL3:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreateAttr), 0, 1);
LL2:  clXdrMarshallClUint32T(&(ckptOpenFlags), 0, 1);
LL1:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
L1:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
L2:  clXdrMarshallClUint32T(&(ckptOpenFlags), 0, 1);
L3:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCkptCreateAttr), 0, 1);
L4:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
L5:  clXdrMarshallClUint32T(&(portId), 0, 1);

L6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptActiveCkptOpenResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L7:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptReplicaNotifyServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  ckptMastHdl;
    ClUint32T  ckptActiveAddr;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(ckptMastHdl), 0, sizeof(ClHandleT));
    memset(&(ckptActiveAddr), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptMastHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(ckptActiveAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptReplicaNotify_4_0_0(&(pVersion), ckptMastHdl, ckptActiveAddr);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(ckptActiveAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(ckptActiveAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
L1:  clXdrMarshallClUint32T(&(ckptActiveAddr), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptReplicaNotifyResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyReplicaListUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  ckptMastHdl;
    ClUint32T  peerAddr;
    ClUint32T  addToList;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(ckptMastHdl), 0, sizeof(ClHandleT));
    memset(&(peerAddr), 0, sizeof(ClUint32T));
    memset(&(addToList), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptMastHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(addToList));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyReplicaListUpdate_4_0_0(&(pVersion), ckptMastHdl, peerAddr, addToList);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(addToList), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L4:    return rc;

LL3:  clXdrMarshallClUint32T(&(addToList), 0, 1);
LL2:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
LL1:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
LL0:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(ckptMastHdl), 0, 1);
L2:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
L3:  clXdrMarshallClUint32T(&(addToList), 0, 1);


    return rc;
}

ClRcT clCkptDeputyReplicaListUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptActiveCkptDeleteServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  inVersion;
    ClHandleT  ckptActiveHdl;

    memset(&(inVersion), 0, sizeof(ClVersionT));
    memset(&(ckptActiveHdl), 0, sizeof(ClHandleT));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(inVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptActiveHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptActiveCkptDelete_4_0_0(inVersion, ckptActiveHdl);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(inVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
LL0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);


    return rc;
}

ClRcT clCkptActiveCkptDeleteResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptActiveAddrSetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  inVersion;
    ClHandleT  masterHdl;
    ClUint32T  prevActiveAddr;

    memset(&(inVersion), 0, sizeof(ClVersionT));
    memset(&(masterHdl), 0, sizeof(ClHandleT));
    memset(&(prevActiveAddr), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(inVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(masterHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(prevActiveAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptActiveAddrSet_4_0_0(inVersion, masterHdl, prevActiveAddr);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(inVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(masterHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(prevActiveAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClUint32T(&(prevActiveAddr), 0, 1);
LL1:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);
LL0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);
L2:  clXdrMarshallClUint32T(&(prevActiveAddr), 0, 1);


    return rc;
}

ClRcT clCkptActiveAddrSetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptActiveAddrInformServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  inVersion;
    ClHandleT  masterHdl;
    ClUint32T  activeAddr;

    memset(&(inVersion), 0, sizeof(ClVersionT));
    memset(&(masterHdl), 0, sizeof(ClHandleT));
    memset(&(activeAddr), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(inVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(masterHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(activeAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptActiveAddrInform_4_0_0(inVersion, masterHdl, activeAddr);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(inVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(masterHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(activeAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClUint32T(&(activeAddr), 0, 1);
LL1:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);
LL0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);
L2:  clXdrMarshallClUint32T(&(activeAddr), 0, 1);


    return rc;
}

ClRcT clCkptActiveAddrInformResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyDynamicUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    CkptDynamicSyncupT_4_0_0  updateFlag;
    CkptDynamicInfoT_4_0_0  pDynamicInfo;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(updateFlag), 0, sizeof(CkptDynamicSyncupT_4_0_0));
    memset(&(pDynamicInfo), 0, sizeof(CkptDynamicInfoT_4_0_0));


    rc = clXdrUnmarshallCkptDynamicSyncupT_4_0_0( inMsgHdl,&(updateFlag));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallCkptDynamicInfoT_4_0_0( inMsgHdl,&(pDynamicInfo));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyDynamicUpdate_4_0_0(&(pVersion), updateFlag, &(pDynamicInfo));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallCkptDynamicSyncupT_4_0_0(&(updateFlag), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallCkptDynamicInfoT_4_0_0(&(pDynamicInfo), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallCkptDynamicInfoT_4_0_0(&(pDynamicInfo), 0, 1);
LL0:  clXdrMarshallCkptDynamicSyncupT_4_0_0(&(updateFlag), 0, 1);

    return rc;

L0:  clXdrMarshallCkptDynamicSyncupT_4_0_0(&(updateFlag), 0, 1);
L1:  clXdrMarshallCkptDynamicInfoT_4_0_0(&(pDynamicInfo), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptDeputyDynamicUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptDeputyPeerListUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  version;
    ClUint32T  peerAddr;
    ClUint8T  credential;

    memset(&(version), 0, sizeof(ClVersionT));
    memset(&(peerAddr), 0, sizeof(ClUint32T));
    memset(&(credential), 0, sizeof(ClUint8T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(version));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint8T( inMsgHdl,&(credential));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptDeputyPeerListUpdate_4_0_0(version, peerAddr, credential);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(version), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint8T(&(credential), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClUint8T(&(credential), 0, 1);
LL1:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
LL0:  clXdrMarshallClVersionT(&(version), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(version), 0, 1);
L1:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
L2:  clXdrMarshallClUint8T(&(credential), 0, 1);


    return rc;
}

ClRcT clCkptDeputyPeerListUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

