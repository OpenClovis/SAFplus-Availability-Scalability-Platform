/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "ckptEockptServerCliServerFuncServer.h"
#include "ckptEoServer.h"

extern ClUint32T  ckptEoidlSyncKey;
extern ClHandleDatabaseHandleT  ckptEoidlDatabaseHdl;



ClRcT clCkptMasterCkptOpenServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  ckptSvcHdl;
    SaNameT  pCkptName;
    ClCkptCheckpointCreationAttributesT_4_0_0  pCheckpointCreationAtrributes;
    ClUint32T  checkpointOpenFlags;
    ClUint32T  localAddr;
    ClUint32T  portId;
    CkptHdlDbT_4_0_0  pHdlInfo;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(ckptSvcHdl), 0, sizeof(ClHandleT));
    memset(&(pCkptName), 0, sizeof(SaNameT));
    memset(&(pCheckpointCreationAtrributes), 0, sizeof(ClCkptCheckpointCreationAttributesT_4_0_0));
    memset(&(checkpointOpenFlags), 0, sizeof(ClUint32T));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(pHdlInfo), 0, sizeof(CkptHdlDbT_4_0_0));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptSvcHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pCkptName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClCkptCheckpointCreationAttributesT_4_0_0( inMsgHdl,&(pCheckpointCreationAtrributes));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(checkpointOpenFlags));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterCkptOpen_4_0_0(&(pVersion), ckptSvcHdl, &(pCkptName), &(pCheckpointCreationAtrributes), checkpointOpenFlags, localAddr, portId, &(pHdlInfo));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptSvcHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaNameT(&(pCkptName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCheckpointCreationAtrributes), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(checkpointOpenFlags), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clXdrMarshallCkptHdlDbT_4_0_0(&(pHdlInfo), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L8;
    }

L8:    return rc;

LL6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL5:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL4:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL3:  clXdrMarshallClUint32T(&(checkpointOpenFlags), 0, 1);
LL2:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCheckpointCreationAtrributes), 0, 1);
LL1:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptSvcHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptSvcHdl), 0, 1);
L1:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
L2:  clXdrMarshallClCkptCheckpointCreationAttributesT_4_0_0(&(pCheckpointCreationAtrributes), 0, 1);
L3:  clXdrMarshallClUint32T(&(checkpointOpenFlags), 0, 1);
L4:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
L5:  clXdrMarshallClUint32T(&(portId), 0, 1);

L6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L7:  clXdrMarshallCkptHdlDbT_4_0_0(&(pHdlInfo), 0, 1);

    return rc;
}

ClRcT clCkptMasterCkptOpenResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion,CL_OUT  CkptHdlDbT_4_0_0  pHdlInfo)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clXdrMarshallCkptHdlDbT_4_0_0(&(pHdlInfo), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L8;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L7:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L8:  clXdrMarshallCkptHdlDbT_4_0_0(&(pHdlInfo), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterCkptCloseServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint32T  localAddr;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterCkptClose_4_0_0(ckptHandle, localAddr, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptMasterCkptCloseResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterCkptUnlinkServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    SaNameT  pCkptName;
    ClUint32T  localAddr;
    ClVersionT  pVersion;

    memset(&(pCkptName), 0, sizeof(SaNameT));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pCkptName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterCkptUnlink_4_0_0(&(pCkptName), localAddr, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallSaNameT(&(pCkptName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL0:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);

    return rc;

L0:  clXdrMarshallSaNameT(&(pCkptName), 0, 1);
L1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptMasterCkptUnlinkResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptCheckpointStatusGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClCkptCheckpointDescriptorT_4_0_0  ckptStatusGet;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(ckptStatusGet), 0, sizeof(ClCkptCheckpointDescriptorT_4_0_0));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptCheckpointStatusGet_4_0_0(ckptHandle, &(ckptStatusGet), &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClCkptCheckpointDescriptorT_4_0_0(&(ckptStatusGet), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL1:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

L1:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L2:  clXdrMarshallClCkptCheckpointDescriptorT_4_0_0(&(ckptStatusGet), 0, 1);

    return rc;
}

ClRcT _ckptCheckpointStatusGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClCkptCheckpointDescriptorT_4_0_0  ckptStatusGet,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClCkptCheckpointDescriptorT_4_0_0(&(ckptStatusGet), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L3:  clXdrMarshallClCkptCheckpointDescriptorT_4_0_0(&(ckptStatusGet), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptSectionCreateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptActHandle;
    ClUint16T  srcClient;
    ClCkptSectionCreationAttributesT_4_0_0  pSecCreationAttr;
    ClUint8T*  pData;
    ClUint64T  dataSize;
    ClVersionT  pVersion;
    ClUint32T  index;

    memset(&(ckptActHandle), 0, sizeof(ClHandleT));
    memset(&(srcClient), 0, sizeof(ClUint16T));
    memset(&(pSecCreationAttr), 0, sizeof(ClCkptSectionCreationAttributesT_4_0_0));
    memset(&(pData), 0, sizeof(ClUint8T*));
    memset(&(dataSize), 0, sizeof(ClUint64T));
    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(index), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptActHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint16T( inMsgHdl,&(srcClient));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClCkptSectionCreationAttributesT_4_0_0( inMsgHdl,&(pSecCreationAttr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint64T( inMsgHdl,&(dataSize));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallPtrClUint8T( inMsgHdl,(void**)&(pData), dataSize);
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(index));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptSectionCreate_4_0_0(ckptActHandle, srcClient, &(pSecCreationAttr), pData, dataSize, &(pVersion), &(index));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptActHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint16T(&(srcClient), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClCkptSectionCreationAttributesT_4_0_0(&(pSecCreationAttr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint64T(&(dataSize), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClUint32T(&(index), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

L7:    return rc;

LL6:  clXdrMarshallClUint32T(&(index), 0, 1);
LL5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL4:  clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);
LL3:  clXdrMarshallClUint64T(&(dataSize), 0, 1);
LL2:  clXdrMarshallClCkptSectionCreationAttributesT_4_0_0(&(pSecCreationAttr), 0, 1);
LL1:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptActHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptActHandle), 0, 1);
L1:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
L2:  clXdrMarshallClCkptSectionCreationAttributesT_4_0_0(&(pSecCreationAttr), 0, 1);
L3:  clXdrMarshallClUint64T(&(dataSize), 0, 1);
L4:  clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);

L5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L6:  clXdrMarshallClUint32T(&(index), 0, 1);

    return rc;
}

ClRcT _ckptSectionCreateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion,CL_INOUT  ClUint32T  index)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClUint32T(&(index), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L7:  clXdrMarshallClUint32T(&(index), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptSectionDeleteServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint16T  srcClient;
    ClCkptSectionIdT_4_0_0  sectionId;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(srcClient), 0, sizeof(ClUint16T));
    memset(&(sectionId), 0, sizeof(ClCkptSectionIdT_4_0_0));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint16T( inMsgHdl,&(srcClient));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClCkptSectionIdT_4_0_0( inMsgHdl,&(sectionId));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptSectionDelete_4_0_0(ckptHandle, srcClient, &(sectionId), &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint16T(&(srcClient), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClCkptSectionIdT_4_0_0(&(sectionId), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

L4:    return rc;

LL3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL2:  clXdrMarshallClCkptSectionIdT_4_0_0(&(sectionId), 0, 1);
LL1:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
L2:  clXdrMarshallClCkptSectionIdT_4_0_0(&(sectionId), 0, 1);

L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT _ckptSectionDeleteResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptCheckpointWriteServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint32T  nodeAddr;
    ClUint32T  portId;
    ClUint32T  numberOfElements;
    ClCkptIOVectorElementT_4_0_0*  pIoVector;
    ClUint32T  pError;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(nodeAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(numberOfElements), 0, sizeof(ClUint32T));
    memset(&(pIoVector), 0, sizeof(ClCkptIOVectorElementT_4_0_0*));
    memset(&(pError), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(nodeAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(numberOfElements));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallPtrClCkptIOVectorElementT_4_0_0( inMsgHdl,(void**)&(pIoVector), numberOfElements);
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptCheckpointWrite_4_0_0(ckptHandle, nodeAddr, portId, numberOfElements, pIoVector, &(pError), &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClUint32T(&(pError), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

L7:    return rc;

LL5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL4:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);
LL3:  clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
LL2:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL1:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
L2:  clXdrMarshallClUint32T(&(portId), 0, 1);
L3:  clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
L4:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);

L5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L6:  clXdrMarshallClUint32T(&(pError), 0, 1);

    return rc;
}

ClRcT _ckptCheckpointWriteResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClUint32T  pError,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClUint32T(&(pError), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L6:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L7:  clXdrMarshallClUint32T(&(pError), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptSectionOverwriteServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint32T  nodeAddr;
    ClUint32T  portId;
    ClUint16T  srcClient;
    ClCkptSectionIdT_4_0_0  pSecId;
    ClInt64T  expryTime;
    ClUint64T  dataSize;
    ClUint8T*  pData;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(nodeAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(srcClient), 0, sizeof(ClUint16T));
    memset(&(pSecId), 0, sizeof(ClCkptSectionIdT_4_0_0));
    memset(&(expryTime), 0, sizeof(ClInt64T));
    memset(&(dataSize), 0, sizeof(ClUint64T));
    memset(&(pData), 0, sizeof(ClUint8T*));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(nodeAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint16T( inMsgHdl,&(srcClient));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClCkptSectionIdT_4_0_0( inMsgHdl,&(pSecId));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(expryTime));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClUint64T( inMsgHdl,&(dataSize));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    rc = clXdrUnmarshallPtrClUint8T( inMsgHdl,(void**)&(pData), dataSize);
    if (CL_OK != rc)
    {
        goto LL7;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL8;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptSectionOverwrite_4_0_0(ckptHandle, nodeAddr, portId, srcClient, &(pSecId), expryTime, dataSize, pData, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint16T(&(srcClient), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClInt64T(&(expryTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClUint64T(&(dataSize), 0, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);
    if (CL_OK != rc)
    {
        goto L8;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L9;
    }

L9:    return rc;

LL8:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL7:  clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);
LL6:  clXdrMarshallClUint64T(&(dataSize), 0, 1);
LL5:  clXdrMarshallClInt64T(&(expryTime), 0, 1);
LL4:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);
LL3:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
LL2:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL1:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
L2:  clXdrMarshallClUint32T(&(portId), 0, 1);
L3:  clXdrMarshallClUint16T(&(srcClient), 0, 1);
L4:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);
L5:  clXdrMarshallClInt64T(&(expryTime), 0, 1);
L6:  clXdrMarshallClUint64T(&(dataSize), 0, 1);
L7:  clXdrMarshallPtrClUint8T(pData, dataSize, 0, 1);

L8:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT _ckptSectionOverwriteResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L9;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L9:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptCheckpointReadServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClCkptIOVectorElementT_4_0_0*  pInIOVector;
    ClUint32T  numberOfElements;
    ClCkptIOVectorElementT_4_0_0*  pIoVector;
    ClUint32T  pError;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(pInIOVector), 0, sizeof(ClCkptIOVectorElementT_4_0_0*));
    memset(&(numberOfElements), 0, sizeof(ClUint32T));
    memset(&(pIoVector), 0, sizeof(ClCkptIOVectorElementT_4_0_0*));
    memset(&(pError), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(numberOfElements));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallPtrClCkptIOVectorElementT_4_0_0( inMsgHdl,(void**)&(pInIOVector), numberOfElements);
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIoVector = (ClCkptIOVectorElementT_4_0_0*)clHeapAllocate(sizeof(ClCkptIOVectorElementT_4_0_0) * numberOfElements);
    if (NULL == pIoVector)
    {
        goto LL5;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptCheckpointRead_4_0_0(ckptHandle, pInIOVector, numberOfElements, pIoVector, &(pError), &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pInIOVector, numberOfElements, 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(pError), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

L6:    return rc;

LL5:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);
LL3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL2:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pInIOVector, numberOfElements, 0, 1);
LL1:  clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(numberOfElements), 0, 1);
L2:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pInIOVector, numberOfElements, 0, 1);

L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L4:  clXdrMarshallClUint32T(&(pError), 0, 1);
L5:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);

    return rc;
}

ClRcT _ckptCheckpointReadResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_IN ClUint32T numberOfElements,CL_OUT ClCkptIOVectorElementT_4_0_0*  pIoVector,CL_OUT  ClUint32T  pError,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(pError), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L5:  clXdrMarshallClUint32T(&(pError), 0, 1);
L6:  clXdrMarshallPtrClCkptIOVectorElementT_4_0_0(pIoVector, numberOfElements, 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptSvrIterationInitializeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  ckptHandle;
    ClInt32T  secChosen;
    ClInt64T  exprTime;
    ClUint32T  pSecCount;
    ClCkptSectionIdT_4_0_0*  pSecId;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(secChosen), 0, sizeof(ClInt32T));
    memset(&(exprTime), 0, sizeof(ClInt64T));
    memset(&(pSecCount), 0, sizeof(ClUint32T));
    memset(&(pSecId), 0, sizeof(ClCkptSectionIdT_4_0_0*));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClInt32T( inMsgHdl,&(secChosen));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(exprTime));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL3;
    }


    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptSvrIterationInitialize_4_0_0(&(pVersion), ckptHandle, secChosen, exprTime, &(pSecCount), &pSecId);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClInt32T(&(secChosen), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClInt64T(&(exprTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(pSecCount), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallPtrClCkptSectionIdT_4_0_0(pSecId, pSecCount, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

L6:    return rc;

LL3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL2:  clXdrMarshallClInt64T(&(exprTime), 0, 1);
LL1:  clXdrMarshallClInt32T(&(secChosen), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClInt32T(&(secChosen), 0, 1);
L2:  clXdrMarshallClInt64T(&(exprTime), 0, 1);

L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L4:  clXdrMarshallClUint32T(&(pSecCount), 0, 1);
L5:  clXdrMarshallPtrClCkptSectionIdT_4_0_0(pSecId, pSecCount, 0, 1);

    return rc;
}

ClRcT clCkptSvrIterationInitializeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion,CL_OUT  ClUint32T  pSecCount,ClCkptSectionIdT_4_0_0*  pSecId)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(pSecCount), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallPtrClCkptSectionIdT_4_0_0(pSecId, pSecCount, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L5:  clXdrMarshallClUint32T(&(pSecCount), 0, 1);
L6:  clXdrMarshallPtrClCkptSectionIdT_4_0_0(pSecId, pSecCount, 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptIterationNextGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClCkptSectionIdT_4_0_0  pSecId;
    ClCkptSectionDescriptorT_4_0_0  pSecDescriptor;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(pSecId), 0, sizeof(ClCkptSectionIdT_4_0_0));
    memset(&(pSecDescriptor), 0, sizeof(ClCkptSectionDescriptorT_4_0_0));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClCkptSectionIdT_4_0_0( inMsgHdl,&(pSecId));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptIterationNextGet_4_0_0(ckptHandle, &(pSecId), &(pSecDescriptor), &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClCkptSectionDescriptorT_4_0_0(&(pSecDescriptor), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

L4:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSecId), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L3:  clXdrMarshallClCkptSectionDescriptorT_4_0_0(&(pSecDescriptor), 0, 1);

    return rc;
}

ClRcT _ckptIterationNextGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClCkptSectionDescriptorT_4_0_0  pSecDescriptor,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClCkptSectionDescriptorT_4_0_0(&(pSecDescriptor), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L4:  clXdrMarshallClCkptSectionDescriptorT_4_0_0(&(pSecDescriptor), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterActiveReplicaSetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint32T  localAddr;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterActiveReplicaSet_4_0_0(ckptHandle, localAddr, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptMasterActiveReplicaSetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterActiveReplicaSetSwitchOverServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClUint32T  localAddr;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(localAddr), 0, sizeof(ClUint32T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(localAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterActiveReplicaSetSwitchOver_4_0_0(ckptHandle, localAddr, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(localAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClUint32T(&(localAddr), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptMasterActiveReplicaSetSwitchOverResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterCkptRetentionDurationSetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClInt64T  retentionDuration;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(retentionDuration), 0, sizeof(ClInt64T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(retentionDuration));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterCkptRetentionDurationSet_4_0_0(ckptHandle, retentionDuration, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClInt64T(&(retentionDuration), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClInt64T(&(retentionDuration), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClInt64T(&(retentionDuration), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptMasterCkptRetentionDurationSetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptCheckpointSynchronizeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClInt64T  timeout;
    ClUint16T  flag;
    ClHandleT  ckptLocalHandle;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(timeout), 0, sizeof(ClInt64T));
    memset(&(flag), 0, sizeof(ClUint16T));
    memset(&(ckptLocalHandle), 0, sizeof(ClHandleT));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint16T( inMsgHdl,&(flag));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptLocalHandle));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptCheckpointSynchronize_4_0_0(ckptHandle, timeout, flag, ckptLocalHandle, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint16T(&(flag), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClHandleT(&(ckptLocalHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

L5:    return rc;

LL4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL3:  clXdrMarshallClHandleT(&(ckptLocalHandle), 0, 1);
LL2:  clXdrMarshallClUint16T(&(flag), 0, 1);
LL1:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClInt64T(&(timeout), 0, 1);
L2:  clXdrMarshallClUint16T(&(flag), 0, 1);
L3:  clXdrMarshallClHandleT(&(ckptLocalHandle), 0, 1);

L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT _ckptCheckpointSynchronizeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L5:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT _ckptSectionExpirationTimeSetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptHandle;
    ClCkptSectionIdT_4_0_0  pSectionId;
    ClInt64T  expryTime;
    ClVersionT  pVersion;

    memset(&(ckptHandle), 0, sizeof(ClHandleT));
    memset(&(pSectionId), 0, sizeof(ClCkptSectionIdT_4_0_0));
    memset(&(expryTime), 0, sizeof(ClInt64T));
    memset(&(pVersion), 0, sizeof(ClVersionT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClCkptSectionIdT_4_0_0( inMsgHdl,&(pSectionId));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(expryTime));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = _ckptSectionExpirationTimeSet_4_0_0(ckptHandle, &(pSectionId), expryTime, &(pVersion));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClCkptSectionIdT_4_0_0(&(pSectionId), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClInt64T(&(expryTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

L4:    return rc;

LL3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL2:  clXdrMarshallClInt64T(&(expryTime), 0, 1);
LL1:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSectionId), 0, 1);
LL0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptHandle), 0, 1);
L1:  clXdrMarshallClCkptSectionIdT_4_0_0(&(pSectionId), 0, 1);
L2:  clXdrMarshallClInt64T(&(expryTime), 0, 1);

L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT _ckptSectionExpirationTimeSetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L4:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterActiveAddrGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClHandleT  masterHdl;
    ClUint32T  pNodeAddr;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(masterHdl), 0, sizeof(ClHandleT));
    memset(&(pNodeAddr), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(masterHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterActiveAddrGet_4_0_0(&(pVersion), masterHdl, &(pNodeAddr));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(masterHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(pNodeAddr), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL1:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL0:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(masterHdl), 0, 1);

L1:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L2:  clXdrMarshallClUint32T(&(pNodeAddr), 0, 1);

    return rc;
}

ClRcT clCkptMasterActiveAddrGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion,CL_OUT  ClUint32T  pNodeAddr)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(pNodeAddr), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L3:  clXdrMarshallClUint32T(&(pNodeAddr), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptServerFinalizeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClUint32T  nodeAddr;
    ClUint32T  iocPort;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(nodeAddr), 0, sizeof(ClUint32T));
    memset(&(iocPort), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(nodeAddr));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(iocPort));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptServerFinalize_4_0_0(&(pVersion), nodeAddr, iocPort);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(iocPort), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint32T(&(iocPort), 0, 1);
LL0:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(nodeAddr), 0, 1);
L1:  clXdrMarshallClUint32T(&(iocPort), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptServerFinalizeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

