/*
 * Copyright (C) 2002-2012 OpenClovis Solutions Inc.  All Rights Reserved.
 *
 * This file is available  under  a  commercial  license  from  the
 * copyright  holder or the GNU General Public License Version 2.0.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * For more  information, see  the file  COPYING provided with this
 * material.
 */
/*******************************************************************************
 * ModuleName  : gms                                                           
 * File        : clGmsRmdClient.c
 *******************************************************************************/

/*******************************************************************************
 * Description :                                                                
 *
 * High-level RMD functions for the GMS client side.  These should be
 * eventually autogenerated, but for now written by hand.
 *
 *
 *****************************************************************************/

#include <clCommon.h>
#include <clCommonErrors.h>
#include <clDebugApi.h>
#include <clBufferApi.h>

#include <clGmsErrors.h>
#include <clGmsCommon.h>
#include <clGmsRmdClient.h>
#include <clHandleApi.h>
#include <clGmsApiClient.h>
#include <string.h>
#include <unistd.h>
#include <clXdrApi.h>
// added for using job queue for call backs
#include "clJobQueue.h"

/******************************************************************************
 * Common RMD Call Wrapper
 *****************************************************************************/

#define GMS_LOG_CTX_CLM_RMD	"RMD"

//#define CL_GMS_EMULATE_RMD_CALLS /* Defining this allows emulating RMD calls */

#ifdef CL_GMS_EMULATE_RMD_CALLS
static ClRcT emulate_rmd_call(
        CL_IN       ClUint32T fn_id,
        CL_IN       ClBufferHandleT in_buffer,
        CL_OUT      ClBufferHandleT out_buffer);
#endif /* CL_GMS_EMULATE_RMD_CALLS */

/*
 * The common RMD call
 */
static ClRcT
__cl_gms_call_rmd(
        CL_IN const ClUint32T  fn_id,            /* RMD function identifier */
        CL_IN  void* const     req,              /* Pointer to input argument root */
        CL_IN ClRcT    (*const marshal_req)(void*, ClBufferHandleT),
        /* Marshaling function pointer */
        CL_OUT void**    const res,              /* Pointer to response argument root */
        CL_IN  ClRcT  (*const unmarshal_res)(ClBufferHandleT, void**),
        /* Unmarshaling function pointer */
        CL_IN const ClUint32T  timeout,          /* [ms]; if 0, use default value */
        CL_IN ClBoolT nodeLocal)
{
    ClRcT                       rc = CL_OK;
    ClBufferHandleT      in_buffer = {0};
    ClBufferHandleT      out_buffer = {0};
    ClIocAddressT               dest_addr = {{0}} ;
    ClUint32T                   rmd_flags = 0x0U;
    ClRmdOptionsT               rmd_options = CL_RMD_DEFAULT_OPTIONS;
    ClUint32T                   retries = 3;

    /* Argument (sanity) checking */

    CL_ASSERT(req!=NULL);
    CL_ASSERT(res!=NULL);

    /* Prepare the input data */

    rc = clBufferCreate(&in_buffer);
    if (rc != CL_OK)
    {
        return rc;
    }

    if ((marshal_req == NULL) || (unmarshal_res == NULL))
    {
        clLogError(GEN,NA,
                   "marshal_req or unmarshal_res ptr is NULL");
        return CL_ERR_NULL_POINTER;
    }

    /* Call the marshaling function to marshal the request data */
    rc = (*marshal_req)(req, in_buffer);
    if (rc != CL_OK)
    {
        goto error_free_inbuffer;
    }

    /* Allocate the output buffer */

    rc = clBufferCreate(&out_buffer);
    if (rc != CL_OK)
    {
        goto error_free_inbuffer;
    }

    /*
     * FIXME: This now uses the physical address, instead of a logical
     * address.
     */
    if(nodeLocal)
    {
        dest_addr.iocPhyAddress.nodeAddress = clIocLocalAddressGet();
    }
    else
    {
        dest_addr.iocPhyAddress.nodeAddress = CL_IOC_BROADCAST_ADDRESS;
    }
    dest_addr.iocPhyAddress.portId = CL_IOC_GMS_PORT;
    rmd_options.timeout = (timeout > 0) ? timeout: CL_GMS_RMD_DEFAULT_TIMEOUT;
    rmd_options.retries = CL_GMS_RMD_DEFAULT_RETRIES;

    /* FIXME: This is specific to the cluster member call */
    if( fn_id == CL_GMS_CLIENT_CLUSTER_MEMBER_GET_ASYNC){
        rmd_flags = CL_RMD_CALL_ASYNC;
        out_buffer = (ClBufferHandleT)NULL;
    }
    else {
        rmd_flags = CL_RMD_CALL_NEED_REPLY;
    }

#ifndef CL_GMS_EMULATE_RMD_CALLS
    /* CL_ERR_TRY_AGAIN should be handled inside the library itself so we will
     *  issue the call again until retries before declaring failure to the
     *  application*/
    do{
        rc = clRmdWithMsg(
                dest_addr, 
                fn_id, 
                in_buffer, 
                out_buffer,
                rmd_flags,
                &rmd_options,
                NULL
                );
        if( CL_GET_ERROR_CODE(rc)== CL_ERR_TRY_AGAIN ){
            retries--;
            if (sleep(1) != 0)
            {
                clLogError(GEN,NA,
                           "Failure in sleep system call: %s",strerror(errno));
            }
        }
        else{
            break;
        }
    }while(retries);

#else
    rc = emulate_rmd_call(fn_id, in_buffer, out_buffer);
#endif /* CL_GMS_EMULATE_RMD_CALLS */

    if (rc != CL_OK)
    {
        goto error_free_both_buffers;
    }

    /* Process returned data */

    if(out_buffer)
    {
        rc = (*unmarshal_res)(out_buffer, res);
    }

error_free_both_buffers:
    if(out_buffer)
    {
        if (clBufferDelete(&out_buffer) != CL_OK)
        {
            clLogError(GEN,NA,
                       "Error in clBufferDelete out_buffer");
        }
    }

error_free_inbuffer:
    if (clBufferDelete(&in_buffer) != CL_OK)
    {
        clLogError(GEN,NA,
                   "Error in clBufferDelete in_buffer");
    }

    return rc;
}

static ClRcT
cl_gms_call_rmd(
        CL_IN const ClUint32T  fn_id,            /* RMD function identifier */
        CL_IN  void* const     req,              /* Pointer to input argument root */
        CL_IN ClRcT    (*const marshal_req)(void*, ClBufferHandleT),
        /* Marshaling function pointer */
        CL_OUT void**    const res,              /* Pointer to response argument root */
        CL_IN  ClRcT  (*const unmarshal_res)(ClBufferHandleT, void**),
        /* Unmarshaling function pointer */
        CL_IN const ClUint32T  timeout)          /* [ms]; if 0, use default value */
{
    return __cl_gms_call_rmd(fn_id, req, marshal_req, res, unmarshal_res, timeout, CL_TRUE);
}

/******************************************************************************
 * "Cluster Track" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterTrackRequest(
        CL_IN    void* const ptr,
        CL_INOUT const ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterTrackRequestT* const req = (ClGmsClusterTrackRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*) req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterTrackResponse(
        CL_IN    const  ClBufferHandleT     buf,
        CL_INOUT void** const                      pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterTrackResponseT** const res = (ClGmsClusterTrackResponseT**)pptr;
    ClUint32T len = 0x0U;
    ClUint32T len2 = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterTrackResponseT */

    *res = (ClGmsClusterTrackResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    /* Extract notification array also, if one is provided */
    if ((*res)->buffer.numberOfItems > 0)
    {
        /* expect this many bytes */
        len = (*res)->buffer.numberOfItems * sizeof(ClGmsClusterNotificationT);

        (*res)->buffer.notification = (ClGmsClusterNotificationT*)
            clHeapAllocate(len);
        if ((*res)->buffer.notification == NULL)
        {
            rc = CL_GMS_RC(CL_ERR_NO_MEMORY);
            goto error_exit;
        }

        len2 = len;
        rc = clBufferNBytesRead(buf, (ClUint8T*)(*res)->buffer.notification,&len2);
        if ((rc != CL_OK) || (len2 != len))
        {
            clHeapFree((void*)(*res)->buffer.notification);
            rc = CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
            goto error_exit;
        }
    }        
    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_track_rmd(
        CL_IN   ClGmsClusterTrackRequestT* const req,
        CL_IN   const ClUint32T                    timeout, /* [ms] */
        CL_OUT  ClGmsClusterTrackResponseT** const res)
{
    return cl_gms_call_rmd((ClUint32T)CL_GMS_CLIENT_CLUSTER_TRACK,
            (void*)req, &marshalClGmsClusterTrackRequest,
            (void**)res, &unmarshalClGmsClusterTrackResponse,
            timeout);
}

/******************************************************************************
 * "Cluster Track Stop" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterTrackStopRequest(
        CL_IN    void*        const               ptr,
        CL_INOUT const ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterTrackStopRequestT* const req = (ClGmsClusterTrackStopRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterTrackStopResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**  const                    pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterTrackStopResponseT** const res =
        (ClGmsClusterTrackStopResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterTrackStopResponseT */

    *res = (ClGmsClusterTrackStopResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_track_stop_rmd(
        CL_IN   ClGmsClusterTrackStopRequestT* const req,
        CL_IN   const ClUint32T                  timeout, /* [ms] */
        CL_OUT  ClGmsClusterTrackStopResponseT** const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_TRACK_STOP,
            (void*)req, &marshalClGmsClusterTrackStopRequest,
            (void**)res, &unmarshalClGmsClusterTrackStopResponse,
            timeout);
}

/******************************************************************************
 * "Cluster Member Get" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterMemberGetRequest(
        CL_IN    void*       const                ptr,
        CL_INOUT const ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberGetRequestT* const req = 
        (ClGmsClusterMemberGetRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterMemberGetResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**     const                 pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberGetResponseT**const res =
        (ClGmsClusterMemberGetResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterMemberGetResponseT */

    *res = (ClGmsClusterMemberGetResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_member_get_rmd(
        CL_IN   ClGmsClusterMemberGetRequestT* const  req,
        CL_IN   const ClUint32T                       timeout, /* [ms] */
        CL_OUT  ClGmsClusterMemberGetResponseT**const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_MEMBER_GET,
            (void*)req, &marshalClGmsClusterMemberGetRequest,
            (void**)res, &unmarshalClGmsClusterMemberGetResponse,
            timeout);
}

/******************************************************************************
 * "Cluster Member Get Async" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterMemberGetAsyncRequest(
        CL_IN    void*     const                  ptr,
        CL_INOUT const ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberGetAsyncRequestT*const req =
        (ClGmsClusterMemberGetAsyncRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterMemberGetAsyncResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**   const                   pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberGetAsyncResponseT**const  res =
        (ClGmsClusterMemberGetAsyncResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterMemberGetAsyncResponseT */

    *res = (ClGmsClusterMemberGetAsyncResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_member_get_async_rmd(
        CL_IN   ClGmsClusterMemberGetAsyncRequestT*const req,
        CL_IN   const ClUint32T                          timeout, /* [ms] */
        CL_OUT  ClGmsClusterMemberGetAsyncResponseT**const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_MEMBER_GET_ASYNC,
            (void*)req, &marshalClGmsClusterMemberGetAsyncRequest,
            (void**)res, &unmarshalClGmsClusterMemberGetAsyncResponse,
            timeout);
}

/******************************************************************************
 * "Group Track" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupTrackRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupTrackRequestT *req = (ClGmsGroupTrackRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupTrackResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupTrackResponseT **res = (ClGmsGroupTrackResponseT**)pptr;
    ClUint32T len = 0x0;
    ClUint32T len2 = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupTrackResponseT */

    *res = (ClGmsGroupTrackResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    /* Extract notification array also, if one is provided */
    if ((*res)->buffer.numberOfItems > 0)
    {
        /* expect this many bytes */
        len = (*res)->buffer.numberOfItems * sizeof(ClGmsGroupNotificationT);

        (*res)->buffer.notification = (ClGmsGroupNotificationT*)
            clHeapAllocate(len);
        if ((*res)->buffer.notification == NULL)
        {
            rc = CL_GMS_RC(CL_ERR_NO_MEMORY);
            goto error_exit;
        }

        len2 = len;
        rc = clBufferNBytesRead(buf, (ClUint8T*)(*res)->buffer.notification, &len2);
        if (rc != CL_OK || len2 != len)
        {
            clHeapFree((void*)(*res)->buffer.notification);
            rc = CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
            goto error_exit;
        }
    }        
    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_track_rmd(
        CL_IN   ClGmsGroupTrackRequestT         *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupTrackResponseT       **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_TRACK,
            (void*)req, &marshalClGmsGroupTrackRequest,
            (void**)res, &unmarshalClGmsGroupTrackResponse,
            timeout);
}

/******************************************************************************
 * "Group Track Stop" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupTrackStopRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupTrackStopRequestT *req = (ClGmsGroupTrackStopRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupTrackStopResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupTrackStopResponseT **res = (ClGmsGroupTrackStopResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupTrackStopResponseT */

    *res = (ClGmsGroupTrackStopResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_track_stop_rmd(
        CL_IN   ClGmsGroupTrackStopRequestT     *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupTrackStopResponseT   **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_TRACK_STOP,
            (void*)req, &marshalClGmsGroupTrackStopRequest,
            (void**)res, &unmarshalClGmsGroupTrackStopResponse,
            timeout);
}

/******************************************************************************
 * "Group Member Get" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupMemberGetRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberGetRequestT *req = (ClGmsGroupMemberGetRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupMemberGetResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberGetResponseT **res = (ClGmsGroupMemberGetResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupMemberGetResponseT */

    *res = (ClGmsGroupMemberGetResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_member_get_rmd(
        CL_IN   ClGmsGroupMemberGetRequestT     *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupMemberGetResponseT   **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_MEMBER_GET,
            (void*)req, &marshalClGmsGroupMemberGetRequest,
            (void**)res, &unmarshalClGmsGroupMemberGetResponse,
            timeout);
}

/******************************************************************************
 * "Group Member Get Async" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupMemberGetAsyncRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberGetAsyncRequestT *req =
        (ClGmsGroupMemberGetAsyncRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupMemberGetAsyncResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberGetAsyncResponseT **res =
        (ClGmsGroupMemberGetAsyncResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupMemberGetAsyncResponseT */

    *res = (ClGmsGroupMemberGetAsyncResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_member_get_async_rmd(
        CL_IN   ClGmsGroupMemberGetAsyncRequestT     *req,
        CL_IN   ClUint32T                    timeout, /* [ms] */
        CL_OUT  ClGmsGroupMemberGetAsyncResponseT   **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_MEMBER_GET_ASYNC,
            (void*)req, &marshalClGmsGroupMemberGetAsyncRequest,
            (void**)res, &unmarshalClGmsGroupMemberGetAsyncResponse,
            timeout);
}
/******************************************************************************
 * "Cluster Join" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterJoinRequest(
        CL_IN    void*    const                 ptr,
        CL_INOUT const ClBufferHandleT   buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterJoinRequestT*const req = (ClGmsClusterJoinRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterJoinResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**    const                  pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterJoinResponseT**const res = (ClGmsClusterJoinResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterJoinResponseT */

    *res = (ClGmsClusterJoinResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_join_rmd(
        CL_IN   ClGmsClusterJoinRequestT* const req,
        CL_IN   const ClUint32T                 timeout, /* [ms] */
        CL_OUT  ClGmsClusterJoinResponseT**const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_JOIN,
            (void*)req, &marshalClGmsClusterJoinRequest,
            (void**)res, &unmarshalClGmsClusterJoinResponse,
            timeout);
}

/******************************************************************************
 * "Cluster Leave" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterLeaveRequest(
        CL_IN    void*   const              ptr,
        CL_INOUT const ClBufferHandleT  buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterLeaveRequestT* const req = (ClGmsClusterLeaveRequestT*)ptr;

    CL_ASSERT(req!=NULL);
    rc |= clXdrMarshallClVersionT(&req->clientVersion, buf, 0);
    rc |= clXdrMarshallClUint32T(&req->groupId, buf, 0);
    rc |= clXdrMarshallClUint32T(&req->nodeId, buf, 0);
    rc |= clXdrMarshallClUint16T(&req->sync, buf, 0);

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterLeaveResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**   const                   pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterLeaveResponseT** const res = (ClGmsClusterLeaveResponseT**)pptr;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    /* ... we have at least a full ClGmsClusterLeaveResponseT */

    *res = (ClGmsClusterLeaveResponseT*)clHeapCalloc(1, sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    rc |= clXdrUnmarshallClVersionT(buf, &(*res)->serverVersion);
    rc |= clXdrUnmarshallClUint32T(buf, &(*res)->rc);

    if (rc != CL_OK)
    {
        goto error_exit;
    }

    return rc;

error_exit:
    clHeapFree((void*)*res);
    *res = NULL;

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_leave_rmd(
        CL_IN   ClGmsClusterLeaveRequestT* const req,
        CL_IN   const ClUint32T                  timeout, /* [ms] */
        CL_OUT  ClGmsClusterLeaveResponseT**const res)
{
    return __cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_LEAVE,
            (void*)req, &marshalClGmsClusterLeaveRequest,
            (void**)res, &unmarshalClGmsClusterLeaveResponse,
            timeout, CL_TRUE);
}

ClRcT
cl_gms_cluster_leave_rmd_native(
        CL_IN   ClGmsClusterLeaveRequestT* const req,
        CL_IN   const ClUint32T                  timeout, /* [ms] */
        CL_OUT  ClGmsClusterLeaveResponseT**const res)
{
    return __cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_LEAVE,
            (void*)req, &marshalClGmsClusterLeaveRequest,
            (void**)res, &unmarshalClGmsClusterLeaveResponse,
            timeout, CL_FALSE);
}

/******************************************************************************
 * "Cluster Leader Elect" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterLeaderElectRequest(
        CL_IN    void*        const             ptr,
        CL_INOUT const ClBufferHandleT   buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterLeaderElectRequestT*const req =
        (ClGmsClusterLeaderElectRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterLeaderElectResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**    const                  pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterLeaderElectResponseT** const res =
        (ClGmsClusterLeaderElectResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterLeaderElectResponseT */

    *res = (ClGmsClusterLeaderElectResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_leader_elect_rmd(
        CL_IN   ClGmsClusterLeaderElectRequestT* const req,
        CL_IN   const ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsClusterLeaderElectResponseT** const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_LEADER_ELECT,
            (void*)req, &marshalClGmsClusterLeaderElectRequest,
            (void**)res, &unmarshalClGmsClusterLeaderElectResponse,
            timeout);
}

/******************************************************************************
 * "Cluster Member Eject" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsClusterMemberEjectRequest(
        CL_IN    void*  const                 ptr,
        CL_INOUT const ClBufferHandleT  buf)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberEjectRequestT* const req =
        (ClGmsClusterMemberEjectRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsClusterMemberEjectResponse(
        CL_IN    const ClBufferHandleT     buf,
        CL_INOUT void**   const                   pptr)
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberEjectResponseT** const res =
        (ClGmsClusterMemberEjectResponseT**)pptr;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterMemberEjectResponseT */

    *res = (ClGmsClusterMemberEjectResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_cluster_member_eject_rmd(
        CL_IN   ClGmsClusterMemberEjectRequestT* const req,
        CL_IN   const ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsClusterMemberEjectResponseT** const res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_CLUSTER_MEMBER_EJECT,
            (void*)req, &marshalClGmsClusterMemberEjectRequest,
            (void**)res, &unmarshalClGmsClusterMemberEjectResponse,
            timeout);
}

/******************************************************************************
 * "Group Create" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupCreateRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupCreateRequestT *req = (ClGmsGroupCreateRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupCreateResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupCreateResponseT **res = (ClGmsGroupCreateResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupCreateResponseT */

    *res = (ClGmsGroupCreateResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_create_rmd(
        CL_IN   ClGmsGroupCreateRequestT          *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupCreateResponseT        **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_CREATE,
            (void*)req, &marshalClGmsGroupCreateRequest,
            (void**)res, &unmarshalClGmsGroupCreateResponse,
            timeout);
}

/******************************************************************************
 * "Group Destroy" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupDestroyRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupDestroyRequestT *req = (ClGmsGroupDestroyRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupDestroyResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupDestroyResponseT **res = (ClGmsGroupDestroyResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupDestroyResponseT */

    *res = (ClGmsGroupDestroyResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_destroy_rmd(
        CL_IN   ClGmsGroupDestroyRequestT         *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupDestroyResponseT       **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_DESTROY,
            (void*)req, &marshalClGmsGroupDestroyRequest,
            (void**)res, &unmarshalClGmsGroupDestroyResponse,
            timeout);
}

/******************************************************************************
 * "Group Join" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupJoinRequest(
        CL_IN    void* const                    ptr,
        CL_INOUT const ClBufferHandleT   buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupJoinRequestT *req = (ClGmsGroupJoinRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupJoinResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupJoinResponseT **res = (ClGmsGroupJoinResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupJoinResponseT */

    *res = (ClGmsGroupJoinResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_join_rmd(
        CL_IN   ClGmsGroupJoinRequestT          *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupJoinResponseT        **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_JOIN,
            (void*)req, &marshalClGmsGroupJoinRequest,
            (void**)res, &unmarshalClGmsGroupJoinResponse,
            timeout);
}

/******************************************************************************
 * "Group Leave" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupLeaveRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupLeaveRequestT *req = (ClGmsGroupLeaveRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupLeaveResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupLeaveResponseT **res = (ClGmsGroupLeaveResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupLeaveResponseT */

    *res = (ClGmsGroupLeaveResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_leave_rmd(
        CL_IN   ClGmsGroupLeaveRequestT          *req,
        CL_IN   ClUint32T                         timeout, /* [ms] */
        CL_OUT  ClGmsGroupLeaveResponseT        **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_LEAVE,
            (void*)req, &marshalClGmsGroupLeaveRequest,
            (void**)res, &unmarshalClGmsGroupLeaveResponse,
            timeout);
}

/******************************************************************************
 * "Group List Get" Request and Response Handling
 *****************************************************************************/

static ClRcT
marshalClGmsGroupInfoListGetRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupsInfoListGetRequestT *req = (ClGmsGroupsInfoListGetRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupInfoListGetResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupsInfoListGetResponseT **res = (ClGmsGroupsInfoListGetResponseT**)pptr;
    ClUint32T len = 0x0;
    ClUint32T len2 = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    *res = (ClGmsGroupsInfoListGetResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    if ((*res)->groupsList.noOfGroups > 0)
    {
        /* expect this many bytes */
        len = (*res)->groupsList.noOfGroups * sizeof(ClGmsGroupInfoT);

        (*res)->groupsList.groupInfoList = (ClGmsGroupInfoT*)
            clHeapAllocate(len);
        if ((*res)->groupsList.groupInfoList == NULL)
        {
            rc = CL_ERR_NO_MEMORY;
            goto error_exit;
        }

        len2 = len;
        rc = clBufferNBytesRead(buf, (ClUint8T*)(*res)->groupsList.groupInfoList, &len2);
        if (rc != CL_OK || len2 != len)
        {
            clHeapFree((void*)(*res)->groupsList.groupInfoList);
            rc = CL_GMS_ERR_UNMARSHALING_FAILED;
            goto error_exit;
        }
    }

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_list_get_rmd(
        CL_IN   ClGmsGroupsInfoListGetRequestT          *req,
        CL_IN   ClUint32T                         timeout, /* [ms] */
        CL_OUT  ClGmsGroupsInfoListGetResponseT        **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_LIST_GET,
            (void*)req, &marshalClGmsGroupInfoListGetRequest,
            (void**)res, &unmarshalClGmsGroupInfoListGetResponse,
            timeout);
}

/******************************************************************************
 * "Group Info Get" Request and Response Handling
 *****************************************************************************/

static ClRcT
marshalClGmsGroupInfoGetRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupInfoGetRequestT *req = (ClGmsGroupInfoGetRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupInfoGetResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupInfoGetResponseT **res = (ClGmsGroupInfoGetResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    *res = (ClGmsGroupInfoGetResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }
    memset(*res,0,sizeof(**res));

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

error_exit:

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_info_get_rmd(
        CL_IN   ClGmsGroupInfoGetRequestT          *req,
        CL_IN   ClUint32T                           timeout, /* [ms] */
        CL_OUT  ClGmsGroupInfoGetResponseT        **res)
{
    ClRcT   rc = CL_OK;
    rc = cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_INFO_GET,
            (void*)req, &marshalClGmsGroupInfoGetRequest,
            (void**)res, &unmarshalClGmsGroupInfoGetResponse,
            timeout);
    return rc;
}

/******************************************************************************
 * "Group Mcast Send" Request and Response Handling
 *****************************************************************************/

static ClRcT
marshalClGmsGroupMcastRequest(
        CL_IN    void               *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMcastRequestT *req = (ClGmsGroupMcastRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(ClGmsGroupMcastRequestT));
    if (rc != CL_OK)
        return rc;

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req->data, req->dataSize);

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupMcastResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void              **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMcastResponseT **res = (ClGmsGroupMcastResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    *res = (ClGmsGroupMcastResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }
    memset(*res,0,sizeof(**res));

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

error_exit:

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_mcast_send_rmd(
        CL_IN   ClGmsGroupMcastRequestT          *req,
        CL_IN   ClUint32T                         timeout, /* [ms] */
        CL_OUT  ClGmsGroupMcastResponseT        **res)
{
    ClRcT   rc = CL_OK;
    rc = cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_MCAST_SEND,
            (void*)req, &marshalClGmsGroupMcastRequest,
            (void**)res, &unmarshalClGmsGroupMcastResponse,
            timeout);
    return rc;
}
/******************************************************************************
 * Component UP notification from CPM
 *****************************************************************************/

static ClRcT
marshalClGmsCompUpNotifyRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsCompUpNotifyRequestT *req = (ClGmsCompUpNotifyRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsCompUpNotifyResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsCompUpNotifyResponseT **res = (ClGmsCompUpNotifyResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    *res = (ClGmsCompUpNotifyResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }
    memset(*res,0,sizeof(**res));

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
error_exit:

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_comp_up_notify_rmd(
        CL_IN   ClGmsCompUpNotifyRequestT          *req,
        CL_IN   ClUint32T                           timeout, /* [ms] */
        CL_OUT  ClGmsCompUpNotifyResponseT        **res)
{
    ClRcT   rc = CL_OK;
    rc = cl_gms_call_rmd(
            (ClUint32T)CL_GMS_COMP_UP_NOTIFY,
            (void*)req, &marshalClGmsCompUpNotifyRequest,
            (void**)res, &unmarshalClGmsCompUpNotifyResponse,
            timeout);
    return rc;
}

/******************************************************************************
 * "Group Leader Elect" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupLeaderElectRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupLeaderElectRequestT *req = (ClGmsGroupLeaderElectRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupLeaderElectResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupLeaderElectResponseT **res =
        (ClGmsGroupLeaderElectResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupLeaderElectResponseT */

    *res = (ClGmsGroupLeaderElectResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_leader_elect_rmd(
        CL_IN   ClGmsGroupLeaderElectRequestT   *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupLeaderElectResponseT **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_LEADER_ELECT,
            (void*)req, &marshalClGmsGroupLeaderElectRequest,
            (void**)res, &unmarshalClGmsGroupLeaderElectResponse,
            timeout);
}

/******************************************************************************
 * "Group Member Eject" Request and Response Handling
 *****************************************************************************/
static ClRcT
marshalClGmsGroupMemberEjectRequest(
        CL_IN    void                      *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberEjectRequestT *req = (ClGmsGroupMemberEjectRequestT*)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (ClUint8T*)req, sizeof(*req));

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
unmarshalClGmsGroupMemberEjectResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberEjectResponseT **res =
        (ClGmsGroupMemberEjectResponseT**)pptr;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupMemberEjectResponseT */

    *res = (ClGmsGroupMemberEjectResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
cl_gms_group_member_eject_rmd(
        CL_IN   ClGmsGroupMemberEjectRequestT   *req,
        CL_IN   ClUint32T                        timeout, /* [ms] */
        CL_OUT  ClGmsGroupMemberEjectResponseT **res)
{
    return cl_gms_call_rmd(
            (ClUint32T)CL_GMS_CLIENT_GROUP_MEMBER_EJECT,
            (void*)req, &marshalClGmsGroupMemberEjectRequest,
            (void**)res, &unmarshalClGmsGroupMemberEjectResponse,
            timeout);
}

/******************************************************************************
 * RMD Async Callback Function Handler for Cluster Track Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsClusterTrackCallbackData(
        CL_IN    const ClBufferHandleT          buf,
        CL_INOUT ClGmsClusterTrackCallbackDataT**const res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0U;
    ClUint32T len2 = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterTrackCallbackDataT */

    *res = (ClGmsClusterTrackCallbackDataT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    /* Extract notification array also, if one is provided */

    if ((*res)->buffer.numberOfItems > 0)
    {
        /* expect this many bytes */
        len = (*res)->buffer.numberOfItems * sizeof(ClGmsClusterNotificationT);

        (*res)->buffer.notification = (ClGmsClusterNotificationT*)
            clHeapAllocate(len);
        if ((*res)->buffer.notification == NULL)
        {
            rc = CL_GMS_RC(CL_ERR_NO_MEMORY);
            goto error_exit;
        }

        len2 = len;
        rc = clBufferNBytesRead(buf, (ClUint8T*)(*res)->buffer.notification, &len2);
        if ((rc != CL_OK) || (len2 != len))
        {
            clHeapFree((void*)(*res)->buffer.notification);
            rc = CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
            goto error_exit;
        }
    }        
    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
VDECL (cl_gms_cluster_track_callback_rmd) (
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   const ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsClusterTrackCallbackDataT *res = NULL;
    ClGmsLibInstanceT *gmsInstance = NULL;
    ClGmsHandleT gmsHandle = CL_HANDLE_INVALID_VALUE;
    
    rc = unmarshalClGmsClusterTrackCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    if (res == NULL)
    {
        return CL_ERR_UNSPECIFIED;
    }

    rc = clHandleCheckout( handle_database , res->gmsHandle, (void**)&gmsInstance);
    if(rc){
        return CL_ERR_INVALID_HANDLE;
    }

    gmsHandle = res->gmsHandle;
    /* 
     * Before invoking the callback, set gmsHandle as a thread specific data.
     * This will be used in SAF wrapper to keep the context. In other callbacks
     * this will be ignored.
     */
    rc = clOsalTaskDataSet(clGmsPrivateDataKey, &gmsHandle);
    if (rc != CL_OK)
    {
        clLogError(CLM,GMS_LOG_CTX_CLM_RMD,
                   "clOsalTaskDataSet on handle failed with rc 0x%x\n",rc);
    }

    /* if the library is in saf mode then queue the data in the callback queue
     *  and return , dispatch api will dequeue the callback data and will call
     *  the callback from the application thread 
     */

    #if 1
    // Instead of directly invoking the call back handler invoke through job queue
    // TODO Have to migrate the functionality to IPI rather than calling API
    #define CL_NUM_JOB_QUEUES CL_IOC_MAX_PRIORITIES
    extern ClJobQueueT gEoJobQueues[CL_NUM_JOB_QUEUES];

    // response contents are already heap allocated by unmarhall function

    rc = clJobQueuePush (&gEoJobQueues[CL_IOC_LOW_PRIORITY], (ClCallbackT) clGmsClusterTrackCallbackHandler, res);
    clLogInfo(CLM,NA,"clJobQueuePush rc [0x%x]\n",rc);

    return rc;
    #endif

    //return clGmsClusterTrackCallbackHandler(res);
}
/******************************************************************************
 * RMD Async Callback Function Handler for Cluster Member Get Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsClusterMemberGetCallbackData(
        CL_IN    const ClBufferHandleT                buf,
        CL_INOUT ClGmsClusterMemberGetCallbackDataT** const  res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterTrackCallbackDataT */

    *res = (ClGmsClusterMemberGetCallbackDataT*) clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
VDECL (cl_gms_cluster_member_get_callback_rmd) (
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   const ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberGetCallbackDataT *res = NULL;
    ClGmsLibInstanceT *gmsInstance = NULL;
    ClGmsHandleT gmsHandle = CL_HANDLE_INVALID_VALUE;

    rc = unmarshalClGmsClusterMemberGetCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    if (res == NULL)
    {
        return CL_ERR_UNSPECIFIED;
    }

    rc = clHandleCheckout( handle_database , res->gmsHandle, (void **)&gmsInstance);
    if(rc){
        return CL_ERR_INVALID_HANDLE;
    }

    gmsHandle = res->gmsHandle;
    /*
     * Before invoking the callback, set gmsHandle as a thread specific data.
     * This will be used in SAF wrapper to keep the context. In other callbacks
     * this will be ignored.
     */
    rc = clOsalTaskDataSet(clGmsPrivateDataKey, &gmsHandle);
    if (rc != CL_OK)
    {
        clLogError(CLM,NA,
                   "clOsalTaskDataSet on handle failed with rc 0x%x\n",rc);
    }


    return clGmsClusterMemberGetCallbackHandler(res);
}

/******************************************************************************
 * RMD Async Callback Function Handler for Group Track Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsGroupTrackCallbackData(
        CL_IN    ClBufferHandleT          buf,
        CL_INOUT ClGmsGroupTrackCallbackDataT  **res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0;
    ClUint32T len2 = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupTrackCallbackDataT */

    *res = (ClGmsGroupTrackCallbackDataT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    /* Extract notification array also, if one is provided */
    if ((*res)->buffer.numberOfItems > 0)
    {
        /* expect this many bytes */
        len = (*res)->buffer.numberOfItems * sizeof(ClGmsGroupNotificationT);

        (*res)->buffer.notification = (ClGmsGroupNotificationT*) clHeapAllocate(len);
        if ((*res)->buffer.notification == NULL)
        {
            rc = CL_GMS_RC(CL_ERR_NO_MEMORY);
            goto error_exit;
        }

        len2 = len;
        rc = clBufferNBytesRead(buf, (ClUint8T*)(*res)->buffer.notification, &len2);
        if (rc != CL_OK || len2 != len)
        {
            clHeapFree((void*)(*res)->buffer.notification);
            rc = CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
            goto error_exit;
        }
    }        
    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/

ClRcT
VDECL (cl_gms_group_track_callback_rmd) (
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsGroupTrackCallbackDataT *res = NULL;

    // added code for cluster callback handle in queue
    ClGmsLibInstanceT *gmsInstance = NULL;
    ClGmsHandleT gmsHandle = CL_HANDLE_INVALID_VALUE;

    rc = unmarshalClGmsGroupTrackCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    if (res == NULL)
    {
        return CL_ERR_UNSPECIFIED;
    }

    rc = clHandleCheckout(handle_database ,res->gmsHandle, (void **)&gmsInstance);
    if(rc)
    {
        return CL_ERR_INVALID_HANDLE;
    }

    gmsHandle = res->gmsHandle;

    #if 1
    // instead of directly invking the call back handler invoke through job queue
    #define CL_NUM_JOB_QUEUES CL_IOC_MAX_PRIORITIES
    extern ClJobQueueT gEoJobQueues[CL_NUM_JOB_QUEUES];

    // response contents are already heap allocated by unmarhall func

    rc = clJobQueuePush (&gEoJobQueues[CL_IOC_LOW_PRIORITY], (ClCallbackT) clTmsGroupTrackCallbackHandler, res);
    clLogInfo(GROUPS,NA,"clJobQueuePush rc [0x%x]\n",rc);

    return rc;
    #endif

    #if 0
    // Start
    /* 
     * Before invoking the callback, set gmsHandle as a thread specific data.
     * This will be used in SAF wrapper to keep the context. In other callbacks
     * this will be ignored.
     */
    rc = clOsalTaskDataSet(clGmsPrivateDataKey, &gmsHandle);
    if (rc != CL_OK)
    {
        clLogError(GRP,GMS_LOG_CTX_CLM_RMD,
                   "clOsalTaskDataSet on handle failed with rc 0x%x\n",rc);
    }

    /* if the library is in saf mode then queue the data in the callback queue
     *  and return , dispatch api will dequeue the callback data and will call
     *  the callback from the application thread 
     */
    // End

    return clTmsGroupTrackCallbackHandler(res);
    #endif
}

#ifdef GMS_GROUP_SUPPORT
/******************************************************************************
 * RMD Async Callback Function Handler for Group Member Get Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsGroupMemberGetCallbackData(
        CL_IN    ClBufferHandleT              buf,
        CL_INOUT ClGmsGroupMemberGetCallbackDataT  **res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupMemberGetCallbackDataT */

    *res = (ClGmsGroupMemberGetCallbackDataT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
cl_gms_group_member_get_callback_rmd(
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberGetCallbackDataT *res = NULL;
    extern ClRcT clGmsGroupMemberGetCallbackHandler(
            ClGmsGroupMemberGetCallbackDataT *);

    rc = unmarshalClGmsGroupMemberGetCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    // Start
    /*  
     * Before invoking the callback, set gmsHandle as a thread specific data.
     * This will be used in SAF wrapper to keep the context. In other callbacks
     * this will be ignored.
     */
    rc = clOsalTaskDataSet(clGmsPrivateDataKey, &res->gmsHandle);
    if (rc != CL_OK)
    {
        clLogError(GROUPS,GMS_LOG_CTX_CLM_RMD,
                   "clOsalTaskDataSet on handle failed with rc 0x%x\n",rc);
    }
    // End


    return clGmsGroupMemberGetCallbackHandler(res);
}
#endif 
/******************************************************************************
 * RMD Async Callback Function Handler for Cluster Member Eject Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsClusterMemberEjectCallbackData(
        CL_IN    const ClBufferHandleT               buf,
        CL_INOUT ClGmsClusterMemberEjectCallbackDataT**const res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsClusterMemberEjectCallbackDataT */

    *res = (ClGmsClusterMemberEjectCallbackDataT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
ClRcT
VDECL (cl_gms_cluster_member_eject_callback_rmd) (
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   const ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsClusterMemberEjectCallbackDataT *res = NULL;

    rc = unmarshalClGmsClusterMemberEjectCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    return clGmsClusterMemberEjectCallbackHandler(res);
}

/******************************************************************************
 * RMD Async Callback Function Handler for Group Mcast Callback
 *****************************************************************************/
static ClRcT
unmarshalClGmsGroupMcastCallbackData(
        CL_IN    const ClBufferHandleT                buf,
        CL_INOUT ClGmsGroupMcastCallbackDataT** const res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0U;

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc = clBufferLengthGet(buf, &len);
    if ((rc != CL_OK) || (len < sizeof(**res)))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    *res = (ClGmsGroupMcastCallbackDataT*)clHeapCalloc(1,sizeof(ClGmsGroupMcastCallbackDataT));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(ClGmsGroupMcastCallbackDataT);
    rc = clBufferNBytesRead(buf, (ClUint8T*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }

    len = (*res)->dataSize;
    (*res)->data = clHeapAllocate(len);
    if ((*res)->data == NULL)
    {
        goto error_exit;
    }

    rc = clBufferNBytesRead(buf,(ClUint8T*) (*res)->data,&len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

ClRcT
VDECL (cl_gms_group_mcast_callback_rmd) (
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   const ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsGroupMcastCallbackDataT *res = NULL;

    rc = unmarshalClGmsGroupMcastCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    return clTmsGroupMcastCallbackHandler(res);
}
/******************************************************************************
 * RMD Async Callback Function Handler for Group Member Eject Callback
 *****************************************************************************/
#ifdef GMS_GROUP_SUPPORT
static ClRcT
unmarshalClGmsGroupMemberEjectCallbackData(
        CL_IN    ClBufferHandleT               buf,
        CL_INOUT ClGmsGroupMemberEjectCallbackDataT **res)
{
    ClRcT rc = CL_OK;
    ClUint32T len = 0x0;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_GMS_RC(CL_GMS_ERR_UNMARSHALING_FAILED);
    }

    /* ... we have at least a full ClGmsGroupMemberEjectCallbackDataT */

    *res = (ClGmsGroupMemberEjectCallbackDataT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */

    return rc;

error_exit:
    clHeapFree((void*)*res);

    return rc;
}

/*---------------------------------------------------------------------------*/
static ClRcT
cl_gms_group_member_eject_callback_rmd(
        CL_IN   ClEoDataT               c_data,     /* Unused */
        CL_IN   ClBufferHandleT  in_buffer,  /* Input data from server */
        CL_OUT  ClBufferHandleT  out_buffer) /* Never used in callbacks */
{
    ClRcT rc = CL_OK;
    ClGmsGroupMemberEjectCallbackDataT *res = NULL;
    extern ClRcT clGmsGroupMemberEjectCallbackHandler(
            ClGmsGroupMemberEjectCallbackDataT *);

    rc = unmarshalClGmsGroupMemberEjectCallbackData(in_buffer, &res);
    if (rc != CL_OK)
    {
        return rc;
    }

    return clGmsGroupMemberEjectCallbackHandler(res);
}
#endif 

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Client library initialization RMD                                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

static ClRcT 
marshal_clientlib_initialize_data( 
        void* const req, 
        const ClBufferHandleT msgHandle 
        )
{
    ClRcT rc = CL_OK;
    ClGmsClientInitRequestT* const data = (ClGmsClientInitRequestT*)req;
    rc = clBufferNBytesWrite( msgHandle , (ClUint8T*)data , sizeof(ClGmsClientInitRequestT));
    return rc;
}


static ClRcT 
unmarshal_clientlib_initialize_data( 
        const ClBufferHandleT msgHandle ,
        void**  const  res 
        )
{
    ClRcT rc = CL_OK;
    ClUint32T msgLen = 0x0U;
    ClUint32T size = sizeof(ClGmsClientInitResponseT);

    if (res == NULL)
    {
        return CL_ERR_NULL_POINTER;
    }

    rc=clBufferLengthGet(msgHandle, &msgLen);
    if (rc != CL_OK)
    {
        return rc;
    }

    *res = clHeapAllocate(sizeof(ClGmsClientInitResponseT));
    if(*res == NULL ){
        return CL_GMS_RC(CL_ERR_NO_MEMORY);
    }

    rc = clBufferNBytesRead( msgHandle,(ClUint8T*) *res, &size);
    if(rc != CL_OK ){
        clHeapFree(*res);
        return rc;
    }

    return rc;
}



ClRcT 
cl_gms_clientlib_initialize_rmd ( 
        CL_IN   ClGmsClientInitRequestT* const req,  /* Input data from server */
        CL_IN   ClUint32T timeout ,
        CL_OUT  ClGmsClientInitResponseT** const res /* Never used in callbacks */
        ){
    return cl_gms_call_rmd(
            (ClUint32T) CL_GMS_CLIENT_INITIALIZE,
            (void*) req, 
            marshal_clientlib_initialize_data ,
            (void**)res,
            unmarshal_clientlib_initialize_data,
            0x0
            );
}


/******************************************************************************
 * RMD Call Emulation for testing client library
 *****************************************************************************/
#ifdef CL_GMS_EMULATE_RMD_CALLS
static ClRcT
emulate_rmd_call(
        CL_IN       ClUint32T fn_id,
        CL_IN       ClBufferHandleT in_buffer,
        CL_OUT      ClBufferHandleT out_buffer)
{
    ClRcT                   rc = CL_OK;
    ClBufferHandleT  callback_buffer;
    ClUint32T               len = 0x0;

    switch (fn_id) {

        case CL_GMS_CLIENT_CLUSTER_TRACK:
            {
                ClGmsClusterNotificationT fake_notification[2] = {
                    {{ .nodeId = 1,
                         .nodeName = {.length = 5, .value = "node1" },
                         .memberActive = CL_TRUE },
                         CL_GMS_MEMBER_NO_CHANGE},
                         {{ .nodeId = 2,
                              .nodeName = {.length = 5, .value = "node2" },
                              .memberActive = CL_TRUE },
                              CL_GMS_MEMBER_NO_CHANGE}
                };
                ClGmsClusterTrackResponseT fake_resp_with_buf = {
                    .rc     = CL_OK,
                    .buffer = {
                        .viewNumber       = 1234,
                        .numberOfItems    = 2,
                    }
                };
                ClGmsClusterTrackRequestT req;
                ClGmsClusterTrackCallbackDataT fake_callback_data = {
                    .rc = CL_OK,
                    .buffer = {
                        .viewNumber       = 1234,
                        .numberOfItems    = 2,
                    },
                    .numberOfMembers = 2
                };

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp_with_buf,
                        sizeof(fake_resp_with_buf));
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)fake_notification,
                        sizeof(fake_notification));
                CL_ASSERT(rc == CL_OK);

                /*
                 * If it is an async call, lets give a call to the tracking callback.
                 */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                if (req.sync == CL_TRUE)
                    break;

                fake_callback_data.gmsHandle = req.gmsHandle;
                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)fake_notification,
                        sizeof(fake_notification));
                CL_ASSERT(rc == CL_OK);

                rc = cl_gms_cluster_track_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);

                break;
            }

        case CL_GMS_CLIENT_CLUSTER_TRACK_STOP:
            {
                ClGmsClusterTrackStopResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_MEMBER_GET:
            {
                ClGmsClusterMemberGetResponseT fake_resp = {
                    .rc     = CL_OK,
                    .member = {
                        .nodeId = 12
                    }
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_MEMBER_GET_ASYNC:
            {
                ClGmsClusterMemberGetAsyncResponseT fake_resp = {
                    .rc     = CL_OK
                };
                ClGmsClusterMemberGetAsyncRequestT req;
                ClGmsClusterMemberGetCallbackDataT fake_callback_data = {
                    .rc = CL_OK,
                    .member = {
                        .nodeId = 12
                    }
                };

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);

                /* Before returning, lets call the callback with a node info */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                fake_callback_data.gmsHandle = req.gmsHandle;
                fake_callback_data.invocation = req.invocation;
                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);
                rc = cl_gms_cluster_member_get_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);

                break;
            }

        case CL_GMS_CLIENT_GROUP_TRACK:
            {
                ClGmsGroupNotificationT fake_notification[2] = {
                    {{ .memberActive = CL_TRUE }, CL_GMS_MEMBER_NO_CHANGE},
                    {{ .memberActive = CL_TRUE }, CL_GMS_MEMBER_NO_CHANGE}
                };
                ClGmsGroupTrackResponseT fake_resp_with_buf = {
                    .rc     = CL_OK,
                    .buffer = {
                        .viewNumber       = 1234,
                        .numberOfItems    = 2,
                    }
                };
                ClGmsGroupTrackRequestT req;
                ClGmsGroupTrackCallbackDataT fake_callback_data = {
                    .rc = CL_OK,
                    .buffer = {
                        .viewNumber       = 1234,
                        .numberOfItems    = 2,
                    },
                    .numberOfMembers = 2
                };

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp_with_buf,
                        sizeof(fake_resp_with_buf));
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)fake_notification,
                        sizeof(fake_notification));
                CL_ASSERT(rc == CL_OK);

                /*
                 * If it is an async call, lets give a call to the tracking callback.
                 */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                if (req.sync == CL_TRUE)
                    break;

                fake_callback_data.gmsHandle = req.gmsHandle;
                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)fake_notification,
                        sizeof(fake_notification));
                CL_ASSERT(rc == CL_OK);

                rc = cl_gms_group_track_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);

                break;
            }

        case CL_GMS_CLIENT_GROUP_TRACK_STOP:
            {
                ClGmsGroupTrackStopResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_MEMBER_GET:
            {
                ClGmsGroupMemberGetResponseT fake_resp = {
                    .rc     = CL_OK,
                    .member = {
                        .memberName = {
                            .length = 8,
                            .value = "ABCDEFGH"
                        }
                    }
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_MEMBER_GET_ASYNC:
            {
                ClGmsGroupMemberGetAsyncResponseT fake_resp = {
                    .rc     = CL_OK,
                    .member = {
                        .memberName = {
                            .length = 8,
                            .value = "ABCDEFGH"
                        }
                    }
                };
                ClGmsGroupMemberGetAsyncRequestT req;
                ClGmsGroupMemberGetCallbackDataT fake_callback_data = {
                    .rc = CL_OK,
                    .member = {
                        .memberId = 12
                    }
                };

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);

                /* Before returning, lets call the callback with a member info */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                fake_callback_data.gmsHandle = req.gmsHandle;
                fake_callback_data.invocation = req.invocation;
                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);
                rc = cl_gms_group_member_get_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_JOIN:
            {
                ClGmsClusterJoinResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);            
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_LEAVE:
            {
                ClGmsClusterLeaveResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);            
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_LEADER_ELECT:
            {
                ClGmsClusterLeaderElectResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);            
                break;
            }

        case CL_GMS_CLIENT_CLUSTER_MEMBER_EJECT:
            {
                ClGmsClusterMemberEjectResponseT fake_resp = {
                    .rc     = CL_OK
                };
                ClGmsClusterMemberEjectRequestT req;
                ClGmsClusterMemberEjectCallbackDataT fake_callback_data;

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);            

                /* Before returning, lets call the eject callback of the caller.
                 * This is not technically correct, becase the caller is typically
                 * not the node that needs to be ejected, but we do this for testing
                 * the API functions
                 */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                fake_callback_data.gmsHandle = req.gmsHandle;
                fake_callback_data.reason = req.reason;

                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);
                rc = cl_gms_cluster_member_eject_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);
                break;
            }

        case CL_GMS_CLIENT_GROUP_OPEN:
            {
                ClGmsGroupCreateResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_CLOSE:
            {
                ClGmsGroupDestroyResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_JOIN:
            {
                ClGmsGroupJoinResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_LEAVE:
            {
                ClGmsGroupLeaveResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_LEADER_ELECT:
            {
                ClGmsGroupLeaderElectResponseT fake_resp = {
                    .rc     = CL_OK
                };
                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);
                break;
            }

        case CL_GMS_CLIENT_GROUP_MEMBER_EJECT:
            {
                ClGmsGroupMemberEjectResponseT fake_resp = {
                    .rc     = CL_OK
                };
                ClGmsGroupMemberEjectRequestT req;
                ClGmsGroupMemberEjectCallbackDataT fake_callback_data;

                rc = clBufferNBytesWrite(out_buffer,
                        (void*)&fake_resp,
                        sizeof(fake_resp));
                CL_ASSERT(rc == CL_OK);            

                /* Before returning, lets call the eject callback of the caller.
                 * This is not technically correct, becase the caller is typically
                 * not the node that needs to be ejected, but we do this for testing
                 * the API functions
                 */
                len = sizeof(req);
                rc = clBufferNBytesRead(in_buffer, (void*)&req, &len);
                CL_ASSERT(rc == CL_OK);
                CL_ASSERT(len == sizeof(req));

                fake_callback_data.gmsHandle = req.gmsHandle;
                fake_callback_data.reason = req.reason;

                rc = clBufferCreate(&callback_buffer);
                CL_ASSERT(rc == CL_OK);

                rc = clBufferNBytesWrite(callback_buffer,
                        (void*)&fake_callback_data,
                        sizeof(fake_callback_data));
                CL_ASSERT(rc == CL_OK);
                rc = cl_gms_group_member_eject_callback_rmd(0,
                        callback_buffer,
                        (ClBufferHandleT)NULL);
                break;
            }

        default:
            CL_ASSERT(0); /* should never get here */
    }
    return rc;
}
#endif /* CL_GMS_EMULATE_RMD_CALLS */

