"""@namespace asplog
Logging routines
"""
import pdb

import types
from misc import *

try:
  import asp
  hasAsp=True
except ImportError:
  hasAsp=False

if hasAsp:
## @var LogLevelError
# A synonym for asp.CL_LOG_SEV_ERROR
  LogLevelError = asp.CL_LOG_SEV_ERROR

## @var LogLevelWarn
# A synonym for asp.CL_LOG_SEV_WARNING
  LogLevelWarn  = asp.CL_LOG_SEV_WARNING

## @var LogLevelInfo
# A synonym for asp.CL_LOG_SEV_INFO
  LogLevelInfo  = asp.CL_LOG_SEV_INFO

## @var LogLevelDebug
# A synonym for asp.CL_LOG_SEV_DEBUG
  LogLevelDebug = asp.CL_LOG_SEV_DEBUG

else:
  LogLevelError = 1
  LogLevelWarn  = 2
  LogLevelInfo  = 3
  LogLevelDebug = 4

## @var loglvl
# A translation table between log level integer and a string.  Use @ref misc.LogLvl2Str function instead of this table.
loglvl = ["undefined", "EMERGENCY","ALERT","CRITICAL","ERROR","warning", "notice", "info", "debug","trace"]

def LogLvl2Str(x):
  """Convert an ASP log level integer into a string
  @param x The log level integer
  @returns string log level
  """
  if x < 10: return loglvl[x]
  else: return "undefined"

class SubLog:
  """Internal (use Hierarchial Log). A logging system that allows logs to be organised in a hierarchial fashion.
  """
  def __init__(self,indent=0):
    self.log=[]
    self.indent = indent
  
  def Log(self,s,loglvl=None,logunwind=1):
    """Output a message to the openclovis system log and to stderr (if uncommented)
    @param s   The log message.  Do not \n terminate
    @param loglvl Optional log level (on of asp.CL_LOG_SEV_xxx values).  If not passed, the "info" level is used.
    @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    if loglvl is None: loglvl = LogLevelInfo
    fl = (thisFile(logunwind),thisLine(logunwind))
    tim = time.time()
    self.log.append((str(s),loglvl,fl,tim));
    Log(s,loglvl,logunwind+1)

  __call__ = Log

  def __str__(self):
    ret = []
    for l in self.log:
      if type(l) is types.TupleType:
        ret.append("%s%s %s %s:%d %s" % (" "*self.indent, time.ctime(l[3]), LogLvl2Str(l[1]), l[2][0],l[2][1], l[0]))
      elif type(l) is types.InstanceType:
        ret.append(str(l))
    return "\n".join(ret)
 

class HierarchialLog:

  def __init__(self):
    """A logging system that allows logs to be organised in a hierarchial fashion."""
    self.parent = None
    self.listeners = []
    self.log    = SubLog(0)
    self.curlog = [self.log]

  def AddListener(self,listener):
    self.listeners.append(listener)

  def SubLog(self,op):
    """Put all logs generated by calling op under SubLog.
    This is just a convenience function for SubLogStart(); op(); SubLogEnd();
    @param op A function requiring no parameters.
    """
    self.SubLogStart()
    result = op()
    self.SubLogEnd()
    return result

  def SubLogStart(self):
    """Put subsequent logs down in a hierarchy
    """
    newlog = SubLog(self.curlog[-1].indent+2)
    self.curlog[-1].log.append(newlog)
    self.curlog.append(newlog)

  def SubLogEnd(self):
    """Go back to the parent log level
    """
    self.curlog.pop()
   
  def Log(self,s,**kw):  # loglvl=None,logunwind=1,listeners=False):
    """Write out a log
    @param s   The log message.  Do not \n terminate
    @param loglvl Optional log level (one of asp.CL_LOG_SEV_xxx values).  If not passed, the "info" level is used.
    @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    if kw.has_key('loglvl'):
      lvl = kw['loglvl']
      del kw['loglvl']
    else: lvl = LogLevelInfo

    if kw.has_key('logunwind'):
      lvl = kw['logunwind']
      del kw['logunwind']
    else: unwind = 2

    self.curlog[-1].Log(T(str(s),**kw),lvl,unwind+1);

    # Forward the log to any listeners
    # But skip doing so if listeners=False -- this is here to avoid infinite recursion when logs are being forwarded and relogged.
    if not kw.has_key('listeners') or kw['listeners']==True:
      if self.listeners:
        for listen in self.listeners:
          listen(s,lvl,fl,tim)


  __call__ = Log

  def info(self,s,**kw):
    """convenience function to output info logs
      loglvl and logunwind parameters must be specified in name=value format
      @param s   The log message.  Do not terminate with a \n
      @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    logkw = {}
    logkw['loglvl'] = LogLevelInfo
    logkw['logunwind'] = kw.get('logunwind',1)+1
    self.curlog[-1].Log(T(str(s),**kw),**logkw);

  def warn(self,s,**kw):
    """convenience function to output warning logs
      loglvl and logunwind parameters must be specified in name=value format
      @param s   The log message.  Do not \n terminate
      @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    logkw = {}
    logkw['loglvl'] = LogLevelWarn
    logkw['logunwind'] = kw.get('logunwind',1)+1
    self.curlog[-1].Log(T(str(s),**kw),**logkw);

  def error(self,s,**kw):
    """convenience function to output error logs
      loglvl and logunwind parameters must be specified in name=value format
      @param s   The log message.  Do not \n terminate
      @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    logkw = {}
    logkw['loglvl'] = LogLevelError
    logkw['logunwind'] = kw.get('logunwind',1)+1
    self.curlog[-1].Log(T(str(s),**kw),**logkw);

  def debug(self,s,**kw):
    """convenience function to output debug logs
      loglvl and logunwind parameters must be specified in name=value format
      @param s   The log message.  Do not terminate with a \n
      @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    logkw = {}
    logkw['loglvl'] = LogLevelDebug
    logkw['logunwind'] = kw.get('logunwind',1)+1
    self.curlog[-1].Log(T(str(s),**kw),**logkw);

  def __str__(self):
    return self.log.__str__()
  
 

class LogClass:
  """ A simple, non hierarchial log that outputs to the OpenClovis default application log"""
  def debug(self,obj):
    Log(obj,LogLevelDebug,2)
  def info(self,obj):
    Log(obj,LogLevelInfo,2)
  def error(self,obj):
    Log(obj,LogLevelError,2)

## @var log
# A global log object that sends its output to the OpenClovis default application log
#log = LogClass()

def Log(s, loglvl=None,logunwind=1):
    """Output a message to the openclovis system log and to stderr (if uncommented)
    @param s   The log message.  Do not <cr> terminate
    @param loglvl Optional log level (on of asp.CL_LOG_SEV_xxx values).  If not passed, the "info" level is used.
    @param logunwind Optional stack location of the original log producer.  Useful if you wrap this Log function (1 is you, 2 is your parent, etc) 
    """
    if loglvl is None:
      loglvl = LogLevelInfo
    if type(logunwind) is types.IntType:
      fil = thisFile(logunwind)
      lin = thisLine(logunwind)
    else:
      fil = logunwind[0]
      lin = logunwind[1]      

    s = str(s)
    if hasAsp:
      asp.clLogMsgWrite(asp.cvar.CL_LOG_HANDLE_APP,loglvl,10, asp.CL_LOG_AREA_UNSPECIFIED,asp.CL_LOG_CONTEXT_UNSPECIFIED, fil,lin,"%s",s)
    else:
      sys.stderr.write("[%s:%d] %s\n" % (fil,lin,s))
      sys.stderr.flush()

log = HierarchialLog()

def Test():
  T("The $animal jumped over the $adj $color $animal2", animal='fox', adj='lazy', color='brown', animal2='dog')
  log = HierarchialLog()

  log.info("Deleting [$ent] and children.  Entities: $entlst",ent="test", entlst=["lst1","lst2"])

  log("test log 1")
  log.SubLog(lambda l=log: l("sublog test"))
 
  print log

  return log
