/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "msgIdlClientGroupCallsFromClientServer.h"
#include "msgIdlServer.h"

extern ClUint32T  msgIdlidlSyncKey;
extern ClHandleDatabaseHandleT  msgIdlidlDatabaseHdl;



ClRcT clMsgQueueGroupCreateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    SaNameT  pGroupName;
    SaMsgQueueGroupPolicyT_4_0_0  groupPolicy;

    memset(&(pGroupName), 0, sizeof(SaNameT));
    memset(&(groupPolicy), 0, sizeof(SaMsgQueueGroupPolicyT_4_0_0));


    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaMsgQueueGroupPolicyT_4_0_0( inMsgHdl,&(groupPolicy));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupCreate_4_0_0(&(pGroupName), groupPolicy);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(groupPolicy), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(groupPolicy), 0, 1);
LL0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);

    return rc;

L0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
L1:  clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(groupPolicy), 0, 1);


    return rc;
}

ClRcT clMsgQueueGroupCreateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueGroupDeleteServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    SaNameT  pGroupName;

    memset(&(pGroupName), 0, sizeof(SaNameT));


    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupDelete_4_0_0(&(pGroupName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L1:    return rc;

LL0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);

    return rc;

L0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);


    return rc;
}

ClRcT clMsgQueueGroupDeleteResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueGroupInsertServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    SaNameT  pGroupName;
    SaNameT  pQueueName;

    memset(&(pGroupName), 0, sizeof(SaNameT));
    memset(&(pQueueName), 0, sizeof(SaNameT));


    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pQueueName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupInsert_4_0_0(&(pGroupName), &(pQueueName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaNameT(&(pQueueName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallSaNameT(&(pQueueName), 0, 1);
LL0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);

    return rc;

L0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
L1:  clXdrMarshallSaNameT(&(pQueueName), 0, 1);


    return rc;
}

ClRcT clMsgQueueGroupInsertResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueGroupRemoveServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    SaNameT  pGroupName;
    SaNameT  pQueueName;

    memset(&(pGroupName), 0, sizeof(SaNameT));
    memset(&(pQueueName), 0, sizeof(SaNameT));


    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pQueueName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupRemove_4_0_0(&(pGroupName), &(pQueueName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaNameT(&(pQueueName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallSaNameT(&(pQueueName), 0, 1);
LL0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);

    return rc;

L0:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
L1:  clXdrMarshallSaNameT(&(pQueueName), 0, 1);


    return rc;
}

ClRcT clMsgQueueGroupRemoveResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueGroupTrackServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  clientHandle;
    ClHandleT  msgHandle;
    SaNameT  pGroupName;
    ClUint8T  trackFlag;
    SaMsgQueueGroupNotificationBufferT_4_0_0  pNotificationBuffer;

    memset(&(clientHandle), 0, sizeof(ClHandleT));
    memset(&(msgHandle), 0, sizeof(ClHandleT));
    memset(&(pGroupName), 0, sizeof(SaNameT));
    memset(&(trackFlag), 0, sizeof(ClUint8T));
    memset(&(pNotificationBuffer), 0, sizeof(SaMsgQueueGroupNotificationBufferT_4_0_0));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(clientHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint8T( inMsgHdl,&(trackFlag));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallSaMsgQueueGroupNotificationBufferT_4_0_0( inMsgHdl,&(pNotificationBuffer));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupTrack_4_0_0(clientHandle, msgHandle, &(pGroupName), trackFlag, &(pNotificationBuffer));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(clientHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint8T(&(trackFlag), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallSaMsgQueueGroupNotificationBufferT_4_0_0(&(pNotificationBuffer), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

L5:    return rc;

LL4:  clXdrMarshallSaMsgQueueGroupNotificationBufferT_4_0_0(&(pNotificationBuffer), 0, 1);
LL3:  clXdrMarshallClUint8T(&(trackFlag), 0, 1);
LL2:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
LL1:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
LL0:  clXdrMarshallClHandleT(&(clientHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(clientHandle), 0, 1);
L1:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
L2:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
L3:  clXdrMarshallClUint8T(&(trackFlag), 0, 1);

L4:  clXdrMarshallSaMsgQueueGroupNotificationBufferT_4_0_0(&(pNotificationBuffer), 0, 1);

    return rc;
}

ClRcT clMsgQueueGroupTrackResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  SaMsgQueueGroupNotificationBufferT_4_0_0  pNotificationBuffer)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallSaMsgQueueGroupNotificationBufferT_4_0_0(&(pNotificationBuffer), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L5:  clXdrMarshallSaMsgQueueGroupNotificationBufferT_4_0_0(&(pNotificationBuffer), 0, 1);

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueGroupTrackStopServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  msgHandle;
    SaNameT  pGroupName;

    memset(&(msgHandle), 0, sizeof(ClHandleT));
    memset(&(pGroupName), 0, sizeof(SaNameT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueGroupTrackStop_4_0_0(msgHandle, &(pGroupName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);
LL0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
L1:  clXdrMarshallSaNameT(&(pGroupName), 0, 1);


    return rc;
}

ClRcT clMsgQueueGroupTrackStopResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

