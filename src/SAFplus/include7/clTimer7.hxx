
/*******************************************************************************
*
* This headerfile is auto-generated by OpenClovis IDE
*
* clCompPorts.h
*
********************************************************************************/
#ifndef clTimer7H
#define clTimer7H

// Standard includes
#include <string>
#include <boost/unordered_map.hpp>
#include <boost/intrusive/rbtree.hpp>
#include <boost/noncopyable.hpp>
#include <functional>
// SAFplus includes
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>

#include <clTimerApi.h>
#include <clTimerErrors.h>
#include <clList.h>
#include <clRbTree.h>
#include <clCommon.hxx>
#include <clThreadPool.hxx>




#define CL_TIMER_RUNNING  (0x1)
#define CL_TIMER_STOPPED  (0x2)
#define CL_TIMER_DELETED  (0x4)
#define CL_TIMER_CLUSTER  (0x8)
#define CL_TIMER_FREQUENCY (10)  /*10 millisecs*/
#define CL_TIMER_CLUSTER_FREQUENCY_USEC (10000000L)
#define CL_TIMER_CLUSTER_VERSION (0x1)
#ifndef VXWORKS_BUILD
#define CL_TIMER_MAX_PARALLEL_TASKS (0x20)
#else
#define CL_TIMER_MAX_PARALLEL_TASKS (0x2)
#endif


namespace SAFplus
{
    ClRcT timerInitialize(ClPtrT config, ClInt32T maxTimer=3000);
    ClRcT timerFinalize(void);
    class TimerPoolable: public Poolable
    {
      public:
        TimerPoolable(UserCallbackT fn=NULL, void* arg=NULL, uint32_t timeLimit=300000, bool deleteWhenComplete=false): Poolable(fn, arg, timeLimit, deleteWhenComplete) {}
        virtual void wake(int amt, void* cookie)
        {
            if (fn)
            {
                fn(arg);
            }
        }
        ~TimerPoolable()
         {

         }
    };
    class Timer : public boost::intrusive::set_base_hook<boost::intrusive::optimize_size<true>>
    {
      public:
        //ClRbTreeT timerList;
        ClTimerTypeT timerType;
        ClTimerContextT timerContext;
        ClTimeT timerTimeOut;
        ClTimeT timerExpiry;
        ClTimerCallBackT timerCallback;
        ClPtrT timerData;
        ClBoolT timerFlags;
        ClInt32T timerRefCnt; /*reference count of inflight separate task timers*/
        ClTimeT startTime;
        ClTimeT startRepTime;
        ClTimeT endTime;
        ClOsalTaskIdT callbackTaskIds[CL_TIMER_MAX_PARALLEL_TASKS];
        ClInt16T freeCallbackTaskIndex;
        ClInt16T freeCallbackTaskIndexPool[CL_TIMER_MAX_PARALLEL_TASKS];
        TimerPoolable *timerPool;
        void timerDelCallbackTask(ClInt16T freeIndex);
        ClInt16T timerAddCallbackTask();
        void timerInitCallbackTask();
        ClRcT timerStartInternal(ClTimeT expiry,ClBoolT locked);
        ClRcT timerStop();
        ClRcT timerState(ClBoolT flags, ClBoolT *pState);
        ClRcT timerStart();
        ClRcT timerUpdate(ClTimerTimeOutT newTimeOut);
        ClRcT timerRestart (ClTimerHandleT  timerHandle);
        ClRcT timerIsStopped(ClBoolT *pState);
        ClRcT timerIsRunning(ClTimerHandleT timerHandle, ClBoolT *pState);
        ClRcT timerCreate(ClTimerTimeOutT timeOut,
                            ClTimerTypeT timerType,
                            ClTimerContextT timerContext,
                            ClTimerCallBackT timerCallback,
                            void *timerData);
        ClRcT timerCreateAndStart(ClTimerTimeOutT timeOut,
                                    ClTimerTypeT timerType,
                                    ClTimerContextT timerContext,
                                    ClTimerCallBackT timerCallback,
                                    void *timerData);
        Timer()
        {

        }
        Timer(ClTimerTimeOutT timeOut,
                        ClTimerTypeT timerType,
                        ClTimerContextT timerContext,
                        ClTimerCallBackT timerCallback,
                        void *timerData)
        {
            timerCreate(timeOut,timerType,timerContext,timerCallback,timerData);
        }
        ~Timer();
        friend bool operator< (const Timer &a, const Timer &b)
           {  return a.timerExpiry < b.timerExpiry;  }
        friend bool operator> (const Timer &a, const Timer &b)
           {  return a.timerExpiry > b.timerExpiry;  }
        friend bool operator== (const Timer &a, const Timer &b)
           {  return a.timerExpiry == b.timerExpiry;  }





    };

    class TimerBase
    {
      public:
        ClBoolT initialized;
        ClBoolT timerRunning;
        ClOsalMutexT timerListLock;
        ClTimeT now;
        //ClRbTreeRootT timerTree;
        boost::intrusive::rbtree<Timer> timerTree;
        ClOsalTaskIdT timerId;
        ClUint32T runningTimers;
        ClTimeT frequency;
        ThreadPool pool;
        /*
         * Cluster timer replicate method registered
         */
        TimerBase();
        ClRcT TimerBaseInitialize();
        ClRcT timerRun(void);
        void timerSpawn(Timer *pTimer);
        void timeUpdate(void);
        ~TimerBase()
        {

        }
        Timer *get_rbtree_min()
        {
           boost::intrusive::rbtree<Timer>::iterator it = timerTree.begin();
//           if( it == timerTree.end())  return 0;
           return &*it;
        }
    };
    static ClInt32T timerCompare(ClRbTreeT *refTimer, ClRbTreeT *timer);
}

#endif
