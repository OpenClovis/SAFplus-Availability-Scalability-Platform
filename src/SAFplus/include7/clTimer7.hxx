
/*******************************************************************************
*
* This headerfile is auto-generated by OpenClovis IDE
*
* clCompPorts.h
*
********************************************************************************/
#ifndef clTimer7H
#define clTimer7H

// Standard includes
#include <string>
#include <boost/unordered_map.hpp>
#include <functional>
// SAFplus includes
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>

#include <clTimerApi.h>
#include <clTimerErrors.h>
#include <clList.h>
#include <clRbTree.h>
#include <clCommon.hxx>
#include <clThreadPool.hxx>



#define CL_TIMER_RUNNING  (0x1)
#define CL_TIMER_STOPPED  (0x2)
#define CL_TIMER_DELETED  (0x4)
#define CL_TIMER_CLUSTER  (0x8)
#define CL_TIMER_MIN_PARALLEL_THREAD 1
#define CL_TIMER_MAX_PARALLEL_THREAD 20
#define CL_TIMER_FREQUENCY (10)  /*10 millisecs*/
#define CL_TIMER_CLUSTER_FREQUENCY_USEC (10000000L)
#define CL_TIMER_CLUSTER_VERSION (0x1)
#ifndef VXWORKS_BUILD
#define CL_TIMER_MAX_PARALLEL_TASKS (0x20)
#else
#define CL_TIMER_MAX_PARALLEL_TASKS (0x2)
#endif


namespace SAFplus
{

    ClRcT clTimer7Initialize(ClPtrT config);
    ClRcT clTimer7Finalize(void);
    class Timer7Poolable: public Poolable
    {
      public:
        Timer7Poolable(UserCallbackT fn=NULL, void* arg=NULL, uint32_t timeLimit=30000, bool deleteWhenComplete=false): Poolable(fn, arg, timeLimit, deleteWhenComplete) {}
        virtual void wake(int amt, void* cookie)
        {
            if (fn)
            {
                fn(arg);
            }
        }
        ~Timer7Poolable()
         {

         }
    };
    class clTimer
    {
      public:
        ClRbTreeT timerList;
        ClTimerTypeT timerType;
        ClTimerContextT timerContext;
        ClTimeT timerTimeOut;
        ClTimeT timerExpiry;
        ClTimerCallBackT timerCallback;
        ClPtrT timerData;
        ClBoolT timerFlags;
        ClInt32T timerRefCnt; /*reference count of inflight separate task timers*/
        ClTimeT startTime;
        ClTimeT startRepTime;
        ClTimeT endTime;
        ClOsalTaskIdT callbackTaskIds[CL_TIMER_MAX_PARALLEL_TASKS];
        ClInt16T freeCallbackTaskIndex;
        ClInt16T freeCallbackTaskIndexPool[CL_TIMER_MAX_PARALLEL_TASKS];
        Timer7Poolable *timerPool;
        void timerDelCallbackTask(ClInt16T freeIndex);
        ClInt16T timerAddCallbackTask();
        void timerInitCallbackTask();
        ClBoolT timerMatchCallbackTask(ClOsalTaskIdT *pSelfId);
        ClRcT timerStart(ClTimeT expiry,ClBoolT locked);
        ClRcT timerStop();
        ClRcT timerDeleteLocked(ClBoolT asyncFlag, ClBoolT *pFreeTimer);
        ClRcT timerDelete(ClBoolT asyncFlag);
        ClRcT timerState(ClBoolT flags, ClBoolT *pState);
        ClRcT clTimerStart();
        ClRcT clTimerStop();
        ClRcT clTimerUpdate(ClTimerTimeOutT newTimeOut);
        ClRcT clTimerRestart (ClTimerHandleT  timerHandle);
        ClRcT clTimerIsStopped(ClBoolT *pState);
        ClRcT clTimerIsRunning(ClTimerHandleT timerHandle, ClBoolT *pState);
        ClRcT clTimerCheckAndDelete();
        ClRcT clTimerCreate(ClTimerTimeOutT timeOut,
                            ClTimerTypeT timerType,
                            ClTimerContextT timerContext,
                            ClTimerCallBackT timerCallback,
                            void *timerData);
        ClRcT clTimerCreateAndStart(ClTimerTimeOutT timeOut,
                                    ClTimerTypeT timerType,
                                    ClTimerContextT timerContext,
                                    ClTimerCallBackT timerCallback,
                                    void *timerData);
        ClRcT clTimerDelete();
        ClRcT clTimerDeleteAsync();
        clTimer()
        {
            timerPool=new Timer7Poolable();
        }
        clTimer(ClTimerTimeOutT timeOut,
                        ClTimerTypeT timerType,
                        ClTimerContextT timerContext,
                        ClTimerCallBackT timerCallback,
                        void *timerData)
        {
            clTimerCreate(timeOut,timerType,timerContext,timerCallback,timerData);
        }
        ~clTimer();



    };

    class ClTimerBase
    {
      public:
        ClBoolT initialized;
        ClBoolT timerRunning;
        ClOsalMutexT timerListLock;
        ClTimeT now;
        ClRbTreeRootT timerTree;
        ClOsalTaskIdT timerId;
        ClUint32T runningTimers;
        ClTimeT frequency;
        ThreadPool pool;
        /*
         * Cluster timer replicate method registered
         */
        ClTimerBase();
        ClRcT clTimerBaseInitialize();
        ClRcT clTimerRun(void);
        void clTimerSpawn(clTimer *pTimer);
        void clTimeUpdate(void);
        ~ClTimerBase()
        {

        }
    };
    static ClInt32T clTimerCompare(ClRbTreeT *refTimer, ClRbTreeT *timer);
}

#endif
