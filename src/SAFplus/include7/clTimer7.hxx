
/*******************************************************************************
*
* This headerfile is auto-generated by OpenClovis IDE
*
* clCompPorts.h
*
********************************************************************************/
#ifndef clTimer7H
#define clTimer7H

// Standard includes
#include <string>
#include <boost/unordered_map.hpp>
#include <functional>
// SAFplus includes
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>

#include <clTimerApi.h>
#include <clTimerErrors.h>
#include <clList.h>
#include <clRbTree.h>
#include <clCommon.hxx>
#include <clThreadPool.hxx>



#define CL_TIMER_RUNNING  (0x1)
#define CL_TIMER_STOPPED  (0x2)
#define CL_TIMER_DELETED  (0x4)
#define CL_TIMER_CLUSTER  (0x8)
#define CL_TIMER_MIN_PARALLEL_THREAD 1
#define CL_TIMER_MAX_PARALLEL_THREAD 20
#define CL_TIMER_FREQUENCY (10)  /*10 millisecs*/
#define CL_TIMER_CLUSTER_FREQUENCY_USEC (10000000L)
#define CL_TIMER_CLUSTER_VERSION (0x1)
#ifndef VXWORKS_BUILD
#define CL_TIMER_MAX_PARALLEL_TASKS (0x20)
#else
#define CL_TIMER_MAX_PARALLEL_TASKS (0x2)
#endif


namespace SAFplus
{

    ClRcT timerInitialize(ClPtrT config);
    ClRcT timerFinalize(void);
    class TimerPoolable: public Poolable
    {
      public:
        TimerPoolable(UserCallbackT fn=NULL, void* arg=NULL, uint32_t timeLimit=300000, bool deleteWhenComplete=false): Poolable(fn, arg, timeLimit, deleteWhenComplete) {}
        virtual void wake(int amt, void* cookie)
        {
            if (fn)
            {
                fn(arg);
            }
        }
        ~TimerPoolable()
         {

         }
    };
    class Timer
    {
      public:
        ClRbTreeT timerList;
        ClTimerTypeT timerType;
        ClTimerContextT timerContext;
        ClTimeT timerTimeOut;
        ClTimeT timerExpiry;
        ClTimerCallBackT timerCallback;
        ClPtrT timerData;
        ClBoolT timerFlags;
        ClInt32T timerRefCnt; /*reference count of inflight separate task timers*/
        ClTimeT startTime;
        ClTimeT startRepTime;
        ClTimeT endTime;
        ClOsalTaskIdT callbackTaskIds[CL_TIMER_MAX_PARALLEL_TASKS];
        ClInt16T freeCallbackTaskIndex;
        ClInt16T freeCallbackTaskIndexPool[CL_TIMER_MAX_PARALLEL_TASKS];
        TimerPoolable *timerPool;
        void timerDelCallbackTask(ClInt16T freeIndex);
        ClInt16T timerAddCallbackTask();
        void timerInitCallbackTask();
        ClBoolT timerMatchCallbackTask(ClOsalTaskIdT *pSelfId);
        ClRcT timerStartInternal(ClTimeT expiry,ClBoolT locked);
        ClRcT timerStop();
        ClRcT timerDeleteLocked(ClBoolT asyncFlag, ClBoolT *pFreeTimer);
        ClRcT timerDeleteInternal(ClBoolT asyncFlag);
        ClRcT timerState(ClBoolT flags, ClBoolT *pState);
        ClRcT timerStart();
        ClRcT timerUpdate(ClTimerTimeOutT newTimeOut);
        ClRcT timerRestart (ClTimerHandleT  timerHandle);
        ClRcT timerIsStopped(ClBoolT *pState);
        ClRcT timerIsRunning(ClTimerHandleT timerHandle, ClBoolT *pState);
        ClRcT timerCheckAndDelete();
        ClRcT timerCreate(ClTimerTimeOutT timeOut,
                            ClTimerTypeT timerType,
                            ClTimerContextT timerContext,
                            ClTimerCallBackT timerCallback,
                            void *timerData);
        ClRcT timerCreateAndStart(ClTimerTimeOutT timeOut,
                                    ClTimerTypeT timerType,
                                    ClTimerContextT timerContext,
                                    ClTimerCallBackT timerCallback,
                                    void *timerData);
        ClRcT timerDelete();
        ClRcT timerDeleteAsync();
        Timer()
        {

        }
        Timer(ClTimerTimeOutT timeOut,
                        ClTimerTypeT timerType,
                        ClTimerContextT timerContext,
                        ClTimerCallBackT timerCallback,
                        void *timerData)
        {
            timerCreate(timeOut,timerType,timerContext,timerCallback,timerData);
        }
        ~Timer();



    };

    class TimerBase
    {
      public:
        ClBoolT initialized;
        ClBoolT timerRunning;
        ClOsalMutexT timerListLock;
        ClTimeT now;
        ClRbTreeRootT timerTree;
        ClOsalTaskIdT timerId;
        ClUint32T runningTimers;
        ClTimeT frequency;
        ThreadPool pool;
        /*
         * Cluster timer replicate method registered
         */
        TimerBase();
        ClRcT TimerBaseInitialize();
        ClRcT timerRun(void);
        void timerSpawn(Timer *pTimer);
        void timeUpdate(void);
        ~TimerBase()
        {

        }
    };
    static ClInt32T timerCompare(ClRbTreeT *refTimer, ClRbTreeT *timer);
}

#endif
