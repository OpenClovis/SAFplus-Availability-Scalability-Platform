/* 
 * File Node.hxx
 * This file has been auto-generated by Y2CPP, the
 * plug-in of pyang.
 */ 

#pragma once
#ifndef NODE_HXX_
#define NODE_HXX_

#include "EntityId.hxx"
#include "PresenceState.hxx"
#include "MgtFactory.hxx"
#include "clTransaction.hxx"
#include "clMgtIdentifierList.hxx"
#include <string>
#include "clMgtProv.hxx"
#include "clMgtList.hxx"
#include "ServiceUnit.hxx"
#include "Stats.hxx"
#include "SAFplusAmfCommon.hxx"
#include <vector>
#include "AdministrativeState.hxx"
#include "ServiceUnitFailureEscalationPolicy.hxx"

namespace SAFplusAmf
  {

    class Node : public EntityId {

        /* Apply MGT object factory */
        MGT_REGISTER(Node);

    public:
        SAFplus::MgtProv<::SAFplusAmf::PresenceState> presenceState;

        /*
         * Does the operator want this entity to be off, idle, or in service?
         */
        SAFplus::MgtProv<::SAFplusAmf::AdministrativeState> adminState;

        /*
         * True is enabled, False is disabled.  To move from False to True a 'repair' action must occur.
         */
        SAFplus::MgtProv<bool> operState;

        /*
         * Automatically attempt to bring this entity back into a healthy state if its operational state becomes disabled.
         */
        SAFplus::MgtProv<bool> autoRepair;

        /*
         * If a component fails to instantiate on this node after potentially multiple attempts (as configured in the component) the AMF will reboot this node if this field is true
         */
        SAFplus::MgtProv<bool> failFastOnInstantiationFailure;

        /*
         * If a component's cleanup script fails on this node after potentially multiple attempts (as configured in the component) the AMF will reboot this node if this field is true
         */
        SAFplus::MgtProv<bool> failFastOnCleanupFailure;

        /*
         * A list of service group name separated by space to indicate that the cell in the node by this SG array is disabled, no assignment is performed
         */
        SAFplus::MgtProv<std::string> disableAssignmentOn;

        /*
         * Service Units configured to be instantiated on this node.
         */
        SAFplus::MgtIdentifierList<::SAFplusAmf::ServiceUnit*> serviceUnits;
        SAFplusAmf::Stats stats;
        SAFplusAmf::ServiceUnitFailureEscalationPolicy serviceUnitFailureEscalationPolicy;

        /*
         * An abstract definition of the amount of work this node can handle.  Nodes can be assigned capacities for arbitrarily chosen strings (MEM or CPU, for example).  Service Instances can be assigned 'weights' and the sum of the weights of service instances assigned active or standby on this node cannot exceed these values.
         */
        SAFplus::MgtList<std::string> capacityList;

    public:
        Node();
        Node(const std::string& nameValue);
        std::vector<std::string> getKeys();
        std::vector<std::string>* getChildNames();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/presenceState
         */
        ::SAFplusAmf::PresenceState getPresenceState();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/presenceState
         */
        void setPresenceState(::SAFplusAmf::PresenceState &presenceStateValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/adminState
         */
        ::SAFplusAmf::AdministrativeState getAdminState();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/adminState
         */
        void setAdminState(::SAFplusAmf::AdministrativeState &adminStateValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/operState
         */
        bool getOperState();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/operState
         */
        void setOperState(bool operStateValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/autoRepair
         */
        bool getAutoRepair();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/autoRepair
         */
        void setAutoRepair(bool autoRepairValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/failFastOnInstantiationFailure
         */
        bool getFailFastOnInstantiationFailure();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/failFastOnInstantiationFailure
         */
        void setFailFastOnInstantiationFailure(bool failFastOnInstantiationFailureValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/failFastOnCleanupFailure
         */
        bool getFailFastOnCleanupFailure();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/failFastOnCleanupFailure
         */
        void setFailFastOnCleanupFailure(bool failFastOnCleanupFailureValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/disableAssignmentOn
         */
        std::string getDisableAssignmentOn();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/disableAssignmentOn
         */
        void setDisableAssignmentOn(std::string disableAssignmentOnValue, SAFplus::Transaction &t=SAFplus::NO_TXN);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/serviceUnits
         */
        std::vector<::SAFplusAmf::ServiceUnit*> getServiceUnits();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/serviceUnits
         */
        void setServiceUnits(::SAFplusAmf::ServiceUnit* serviceUnitsValue);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/stats
         */
        SAFplusAmf::Stats* getStats();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/stats
         */
        void addStats(SAFplusAmf::Stats *statsValue);

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/serviceUnitFailureEscalationPolicy
         */
        SAFplusAmf::ServiceUnitFailureEscalationPolicy* getServiceUnitFailureEscalationPolicy();

        /*
         * XPATH: /SAFplusAmf/safplusAmf/Node/serviceUnitFailureEscalationPolicy
         */
        void addServiceUnitFailureEscalationPolicy(SAFplusAmf::ServiceUnitFailureEscalationPolicy *serviceUnitFailureEscalationPolicyValue);
        ~Node();

    };
}
/* namespace ::SAFplusAmf */
#endif /* NODE_HXX_ */
