
#include <string.h>
#include <clLogApi.h>
#include <clSnmpLog.h>
#include <clDebugApi.h>
#include <clSnmpOp.h>
#include <clSnmpocTrainScalars.h>
#include <clSnmpocTrainTables.h>
#include <clSnmpocTrainNotifications.h>
#include <clSnmpocTrainUtil.h>
#include <clSnmpocTrainInstXlation.h>
#include <clSnmpSubAgentocTrainConfig.h>

/*
 * This function needs to be written for every application MIB sub-agent. From
 * this function call the app MIB specific init functions. The app MIB
 * specific init functions are generated by mib2c
 */
 
void init_ocTrainMIB(void)
{
    /*Application needs to replace the below function with  mib2c generated init function.*/
    clSnmpocTrainScalarsInit();
    clSnmpocTrainTablesInit();
}

ClInt32T  clSnmpocTrainDefaultInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpclockTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%d], Index value2: [%d].", 
        (ClInt32T) pTabIdx1->index.clockTableInfo.clockRow, (ClInt32T) pTabIdx2->index.clockTableInfo.clockRow);

	if ( (retVal = ((ClInt32T) pTabIdx1->index.clockTableInfo.clockRow - (ClInt32T) pTabIdx2->index.clockTableInfo.clockRow)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmptimeSetTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%d], Index value2: [%d].", 
        (ClInt32T) pTabIdx1->index.timeSetTableInfo.timeSetRow, (ClInt32T) pTabIdx2->index.timeSetTableInfo.timeSetRow);

	if ( (retVal = ((ClInt32T) pTabIdx1->index.timeSetTableInfo.timeSetRow - (ClInt32T) pTabIdx2->index.timeSetTableInfo.timeSetRow)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpnameTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.nameTableInfo.nodeAdd, (ClUint32T) pTabIdx2->index.nameTableInfo.nodeAdd);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.nameTableInfo.nodeAdd - (ClUint32T) pTabIdx2->index.nameTableInfo.nodeAdd)) != 0)
	    return retVal;

    return 0;
}
