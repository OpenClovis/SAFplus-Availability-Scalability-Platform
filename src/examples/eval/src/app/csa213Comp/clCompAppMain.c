/******************************************************************************
 *
 * clCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2008 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component.
 *
 * Template Version: 1.0
 *
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
#include <assert.h>
#include <errno.h>

/*
 * Basic ASP Includes.
 */
#include <clCommon.h>

/*
 * ASP Client Includes.
 */
#include <clLogApi.h>
#include <clDebugApi.h>
#include <clCpmApi.h>
#include <saAmf.h>
#include <saAis.h>
#include <saEvt.h>
#include <clEventApi.h>
#include <clEventExtApi.h>

#include "clCompAppMain.h"
#include "../ev/ev.h"
#include "../common/common.h"

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This template has a few default clprintfs. These can be disabled by
 * changing clprintf to a null function
 */

#define clprintf(severity, ...)   clAppLog(gTestInfo.evalLogStream, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

pid_t mypid;
SaAmfHandleT amfHandle;

ClBoolT unblockNow = CL_FALSE;

/*
 * Declare other global variables here.
 */
static char             appname[80];

/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/

//
// Poor man's namespace.  Gather together some globals that don't
// really need to be global.
typedef struct
{
    ClEoExecutionObjT             *tstRegEoObj;
    ClCpmHandleT                  cpmHandle;
    SaEvtHandleT		  evtInitHandle;
    SaEvtEventHandleT		  eventHandle;
    ClVersionT                    version;
    SaVersionT                    evtVersion;
    SaNameT                       evtChannelName;
    SaNameT                       publisherName;
    int                           running;
    int                           exiting;
    SaAmfHAStateT                 haState;
    ClLogStreamHandleT            evalLogStream;
} gTestInfoT;
static gTestInfoT gTestInfo =
{
    .tstRegEoObj      = 0,
    .cpmHandle        = 0,                 // CPM service instance handle
    .evtInitHandle    = 0,
    .eventHandle      = 0,
    .version          =                 // Expected/Required for CPM service API
    {
        .releaseCode                    = 'B',
        .majorVersion                   = 01,
        .minorVersion                   = 01
    },
    .evtVersion                         = CL_EVENT_VERSION,
    .evtChannelName  =
    {
        .length                         = sizeof(EVENT_CHANNEL_NAME) - 1,
        .value                          = EVENT_CHANNEL_NAME
    },
    .publisherName   =
    {
        .length                         = sizeof (PUBLISHER_NAME) - 1,
        .value                          = PUBLISHER_NAME
    },
    .running          = 1,              // 0 => suspended; 1 => resumed
    .exiting          = 0,              // flag that tells main loop to exit
    .haState          = SA_AMF_HA_STANDBY,
    .evalLogStream    = CL_HANDLE_INVALID_VALUE
};

static inline void
logrc(ClLogSeverityT severity, char *buffer, char *appname, ClRcT rc)
{
    clLogWrite(gTestInfo.evalLogStream, severity, NULL, buffer, appname, rc);
}

static inline void
logmsg(ClLogSeverityT severity, char *buffer, char *appname)
{
    clLogWrite(gTestInfo.evalLogStream, severity, NULL, buffer, appname);
}

static ClRcT csa113Comp_PublishEvent();

static void *saAmfDispatchThread(void *arg)
{
    /*
     * Block on AMF dispatch file descriptor for callbacks
     */
    saAmfDispatch (amfHandle, SA_DISPATCH_BLOCKING);

    return NULL;
}


/*
 * main
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

int main(int argc, char *argv[])
{
    SaNameT             appName = {0};
    SaAmfCallbacksT     callbacks;
    SaVersionT          version;
    ClIocPortT          iocPort;
    SaAisErrorT         rc = SA_AIS_OK;
    SaEvtChannelHandleT evtChannelHandle      = 0;
    SaEvtCallbacksT     evtCallbacks          = {NULL, NULL};

    SaSelectionObjectT dispatch_fd;
    fd_set read_fds;
    
    /*
     * Declare other local variables here.
     */

    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the
     * version of AMF with which this application would like to
     * interface. 'callbacks' is used to register the callbacks this
     * component expects to receive.
     */

    version.releaseCode  = 'B';
    version.majorVersion = 01;
    version.minorVersion = 01;
    
    callbacks.saAmfHealthcheckCallback          = NULL;
    callbacks.saAmfComponentTerminateCallback   = clCompAppTerminate;
    callbacks.saAmfCSISetCallback               = clCompAppAMFCSISet;
    callbacks.saAmfCSIRemoveCallback            = clCompAppAMFCSIRemove;
    callbacks.saAmfProtectionGroupTrackCallback = NULL;
        
    /*
     * Initialize AMF client library.
     */

    if ( (rc = saAmfInitialize(&amfHandle, &callbacks, &version)) != SA_AIS_OK) 
        goto errorexit;

    FD_ZERO(&read_fds);

    /*
     * Get the AMF dispatch FD for the callbacks
     */
    if ( (rc = saAmfSelectionObjectGet(amfHandle, &dispatch_fd)) != SA_AIS_OK)
        goto errorexit;
    
    FD_SET(dispatch_fd, &read_fds);


    /*
     * Do the application specific initialization here.
     */


    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = saAmfComponentNameGet(amfHandle, &appName)) != SA_AIS_OK) 
        goto errorexit;
    if ( (rc = saAmfComponentRegister(amfHandle, &appName, NULL)) != SA_AIS_OK) 
        goto errorexit;

    rc = clOsalTaskCreateDetached("DISPATCH-THREAD", CL_OSAL_SCHED_OTHER, 0, 0,
                                  saAmfDispatchThread, NULL);

    if(rc != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR, "Dispatch task create failed with rc 0x%x",rc);
        return rc;
    }

    clEvalAppLogStreamOpen((ClCharT *)appName.value, &gTestInfo.evalLogStream);
    /*
     * Print out standard information for this component.
     */

    clEoMyEoIocPortGet(&iocPort);
    
    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Initializing\n", appName.length, appName.value, mypid);
    clprintf (CL_LOG_SEV_INFO, "   IOC Address             : 0x%x\n", clIocLocalAddressGet());
    clprintf (CL_LOG_SEV_INFO, "   IOC Port                : 0x%x\n", iocPort);

    // ...
    #define min(x,y) ((x < y)? x: y)

    strncpy(appname, (ClCharT *)appName.value, min(sizeof appname, appName.length));
    appname[min(sizeof appname - 1, appName.length)] = 0;

    
    // Initialize the the event code
    rc = saEvtInitialize(&gTestInfo.evtInitHandle,
                           &evtCallbacks,
                           &gTestInfo.evtVersion);
    if (rc != SA_AIS_OK)
    {
        logrc(CL_LOG_SEV_ERROR, "%s\t:Failed to init event system[0x%x]\n",
                    appname, rc);
        return rc;
    }
    
    // Open an event channel so we can publish our events.
    rc = saEvtChannelOpen (gTestInfo.evtInitHandle,
                             &gTestInfo.evtChannelName,
                            (SA_EVT_CHANNEL_PUBLISHER |
                             SA_EVT_CHANNEL_CREATE),
                             (ClTimeT)SA_TIME_END,
                             &evtChannelHandle);
    if (rc != SA_AIS_OK)
    {
        logrc(CL_LOG_SEV_ERROR, "%s\t:Failed to open event channel [0x%x]\n",
                appname, rc);
        return rc;
    }

    rc = saEvtEventAllocate(evtChannelHandle, &gTestInfo.eventHandle);
    if (rc != SA_AIS_OK)
    {
        logrc(CL_LOG_SEV_ERROR, "%s\t:Failed to cllocate event [0x%x]\n",
                appname, rc);
        return rc;
    }

    rc = saEvtEventAttributesSet(gTestInfo.eventHandle,
            NULL,
            1,
            0,
            &gTestInfo.publisherName);
    if (rc != SA_AIS_OK)
    {
        logrc(CL_LOG_SEV_ERROR, "%s\t:Failed to set event attributes [0x%x]\n",
                appname, rc);
        return rc;
    }


    clprintf(CL_LOG_SEV_INFO,"%s: Waiting for CSI assignment...\n", appname);

    /* Letting the world know that we entered the mainloop */
    logmsg(CL_LOG_SEV_DEBUG, "%s entered main loop", appname);
    /* Main loop: Keep printing and publishing unless we are suspended */
    /*
     * Block on AMF dispatch file descriptor for callbacks
     */
    do
    {
        if (gTestInfo.running && (ClAmsHAStateT)gTestInfo.haState == CL_AMS_HA_STATE_ACTIVE)
        {
            csa113Comp_PublishEvent();
        }
        if( select(dispatch_fd + 1, &read_fds, NULL, NULL, NULL) < 0)
        {
            if (EINTR == errno)
            {
                continue;
            }
		    clprintf (CL_LOG_SEV_ERROR, "Error in select()");
			perror("");
            break;
        }
        saAmfDispatch(amfHandle, SA_DISPATCH_ALL);
    }while(!unblockNow);

    /*
     * Do the application specific finalization here.
     */


    if((rc = saAmfFinalize(amfHandle)) != SA_AIS_OK)
	{
        clprintf (CL_LOG_SEV_ERROR, "AMF finalization error[0x%X]", rc);
	}

    clprintf (CL_LOG_SEV_INFO, "AMF Finalized");
    
    return 0;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%.*s] : PID [%d]. Initialization error [0x%x]\n",
              appName.length, appName.value, mypid, rc);

    return -1;
}


/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

void clCompAppTerminate(SaInvocationT invocation, const SaNameT *compName)
{
    SaAisErrorT rc = SA_AIS_OK;

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Terminating\n",
              compName->length, compName->value, mypid);

    
    /*
     * Unregister with AMF and respond to AMF saying whether the
     * termination was successful or not.
     */

    if ( (rc = saAmfComponentUnregister(amfHandle, compName, NULL)) != SA_AIS_OK)
        goto errorexit;

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. Terminated\n",
              compName->length, compName->value, mypid);

    unblockNow = CL_TRUE;
    
    return;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%.*s] : PID [%d]. Termination error [0x%x]\n",
              compName->length, compName->value, mypid, rc);

    return;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 *
 * WARNING: This function is deprecated, and may not be supported in the future.
 * Usage of this feature is discouraged.
 */

ClRcT clCompAppStateChange(ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            gTestInfo.running = 0;
            logmsg(CL_LOG_SEV_DEBUG, "%s entered suspended state", appname);

            break;
        }

        case CL_EO_STATE_RESUME:
        {
            gTestInfo.running = 1;
            logmsg(CL_LOG_SEV_DEBUG, "%s resumed running state", appname);

            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT clCompAppHealthCheck(ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The
     * defaults indicate EO is healthy and polling interval is
     * unaltered.
     */

    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;


    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

void clCompAppAMFCSISet(SaInvocationT       invocation,
                        const SaNameT       *compName,
                        SaAmfHAStateT       haState,
                        SaAmfCSIDescriptorT csiDescriptor)
{
    /*
     * Print information about the CSI Set
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. CSI Set Received\n", 
              compName->length, compName->value, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case SA_AMF_HA_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */
            clprintf(CL_LOG_SEV_INFO,"csa213: ACTIVE state request: activating service");
            gTestInfo.running = 1;
    	    gTestInfo.haState = haState;
            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */
            clprintf(CL_LOG_SEV_INFO,"csa213: New state is not ACTIVE: deactivating service");
            gTestInfo.running = 0;
    	    gTestInfo.haState = haState;
            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */
            clprintf(CL_LOG_SEV_INFO,"csa213: Acknowledging new state");
            gTestInfo.running = 0;
            gTestInfo.haState = haState;
            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */
            clprintf(CL_LOG_SEV_INFO,"csa213: Signaling completion of QUIESCING");
            gTestInfo.running = 0;
            gTestInfo.haState = haState;
            saAmfCSIQuiescingComplete(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        default:
        {
            assert(0);
            break;
        }
    }

    return;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

void clCompAppAMFCSIRemove(SaInvocationT  invocation,
                           const SaNameT  *compName,
                           const SaNameT  *csiName,
                           SaAmfCSIFlagsT csiFlags)
{
    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%d]. CSI Remove Received\n", 
              compName->length, compName->value, mypid);

    clprintf (CL_LOG_SEV_INFO, "   CSI                     : %.*s\n", csiName->length, csiName->value);
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : 0x%d\n", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;
}

/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

void clCompAppAMFPrintCSI(SaAmfCSIDescriptorT csiDescriptor,
                          SaAmfHAStateT haState)
{
    clprintf (CL_LOG_SEV_INFO,
              "CSI Flags : [%s]",
              STRING_CSI_FLAGS(csiDescriptor.csiFlags));

    if (SA_AMF_CSI_TARGET_ALL != csiDescriptor.csiFlags)
    {
        clprintf (CL_LOG_SEV_INFO, "CSI Name : [%s]", 
                  csiDescriptor.csiName.value);
    }

    if (SA_AMF_CSI_ADD_ONE == csiDescriptor.csiFlags)
    {
        ClUint32T i = 0;
        
        clprintf (CL_LOG_SEV_INFO, "Name value pairs :");
        for (i = 0; i < csiDescriptor.csiAttr.number; i++)
        {
            clprintf (CL_LOG_SEV_INFO, "Name : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrName);
            clprintf (CL_LOG_SEV_INFO, "Value : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrValue);
        }
    }
    
    clprintf (CL_LOG_SEV_INFO, "HA state : [%s]",
              STRING_HA_STATE(haState));

    if (SA_AMF_HA_ACTIVE == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Active Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Transition Descriptor : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.transitionDescriptor);
        clprintf (CL_LOG_SEV_INFO,
                  "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.activeCompName.value);
    }
    else if (SA_AMF_HA_STANDBY == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Standby Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Standby Rank : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.standbyRank);
        clprintf (CL_LOG_SEV_INFO, "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.activeCompName.value);
    }
}

/*
 * Insert any other utility functions here.
 */
static void
generate_time_of_day(char **data, ClSizeT *data_len)
{
    time_t t;

    // minimal error checking
    if (data == 0 || data_len == 0)
    {
        logmsg(CL_LOG_SEV_ERROR,
                "%s\t: generate_time_of_day passed null pointer\n", appname);
        return;
    }

    // magic number, but well, that's what ctime_r needs
    *data_len = 26;
    *data = clHeapAllocate(*data_len);
    if (*data == 0)
    {
        *data_len = 0;
        return;
    }
    time(&t);
    ctime_r(&t, *data);
    *(*data + 24) = 0;
    (*data_len) -= 1;
    return;
}

static void
generate_load_average(char **data, ClSizeT *data_len)
{
    int fd;
    char *tmp_ptr;
    char buf[500];                  //insane over doing it
    ssize_t num_read;

    // minimal error checking
    if (data == 0 || data_len == 0)
    {
        logmsg(CL_LOG_SEV_ERROR,
                "%s\t: generate_load_average passed null pointer\n ", appname);
        return;
    }
    
    // Now open the load average file in /proc, read the file into a local
    // buffer, allocate memory to hold the file contents, copy the contents
    // of the file into the newly allocated buffer.
    if ((fd = open("/proc/loadavg", O_RDONLY, 0)) == -1)
    {
        logmsg(CL_LOG_SEV_ERROR, "%s\t: failed to open /proc/loadavg\n", appname);
        return;
    }
    num_read = read(fd, buf, sizeof buf);
    if (num_read == 0 || num_read == -1)
    {
        logmsg(CL_LOG_SEV_ERROR, "%s\t: bogus result from read of loadavg\n",
                appname);
        return;
    }
    close(fd);
    *data_len = num_read + 1;
    *data = clHeapAllocate(*data_len);
    if (data == 0)
    {
        logmsg(CL_LOG_SEV_ERROR,
                "%s: failed to allocate memory for loadavg contents\n",
                appname);
        *data_len = 0;
        close(fd);
        return;
    }
    *(*data + (*data_len) - 1) = 0;     // preemptively null-terminate the line
    strncpy(*data, buf, *data_len);

    //
    // Do MINIMAL parsing in that we look for the third space in the buffer
    // (which comes after the load average information proper) and we replace
    // the space with a nul character to terminate the string.
    // If there is no third space character, just return the buffer unchanged.
    tmp_ptr = strchr(*data, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    tmp_ptr = strchr(tmp_ptr + 1, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    tmp_ptr = strchr(tmp_ptr + 1, ' ');
    if (tmp_ptr == 0)
    {
        return;
    }
    *tmp_ptr = 0;
    return;
}

static ClRcT
csa113Comp_PublishEvent()
{
    ClEventIdT      eventId         = 0;
    static int      index           = 0;
    SaSizeT         data_len        = 0;
    char            *data           = 0;
    typedef void (*Generator)(char **, ClSizeT*);

    //
    // Note: to add a new generator, just define it above and then include
    // the new functions name in the generators list.
    // Next, maybe something that gets disk free info by way of getfsent
    // and statfs?
    static Generator generators[]   =
    {
        generate_time_of_day,
        generate_load_average
    };

    //
    // every time through increment index and then set index to
    // it's value modulo the number of entries in the generators
    // array.  This will cause us to cycle through the list of
    // generators as we're called to publish events.
    (*generators[index++])(&data, &data_len);
    index %= (int)(sizeof generators / sizeof generators[0]);
    if (data == 0 || data_len == 0)
    {
        logmsg(CL_LOG_SEV_ERROR, "%s: no event data generated\n", appname);
        return CL_ERR_NO_MEMORY;
    }
    clprintf(CL_LOG_SEV_INFO,"%s: Publishing Event: %.*s\n", appname, (int)data_len, data);
    saEvtEventPublish(gTestInfo.eventHandle, (void *)data, data_len, &eventId);
    clHeapFree(data);

    return CL_OK;
}

/*
 * ---END_APPLICATION_CODE---
 */

