##################################################
### mib2c/clSnmpSubAgent${name}Config.h
##################################################
@open mib2c/clSnmpSubAgent${name}Config.h@
#ifndef _CL_SNMP_SUBAGENT_$name.uc_CONFIG_H_
#define _CL_SNMP_SUBAGENT_$name.uc_CONFIG_H_

#ifdef __cplusplus
extern "C" {
#endif

/***************************
* General ASP header files
****************************/
#include <clCorMetaData.h>
#include <clMedApi.h>
#include <clSnmpDefs.h>
#include <clSnmpDataDefinition.h>

/***************************
* Constant definition 
****************************/

/*
 * Index information for all tables.
 */

@foreach $t table@
@perleval $vars{'t'}=~ s/[^a-zA-Z0-9]*//g; 0@
typedef struct clSnmp${t}IndexInfo
{
### TO DO: Handling string/OID indexes when the table has multiple indexes while satisfying the condition of max. OID length 128.
    @foreach $idx index@
        ### FUTURE USE: ClUint32T ${idx}Length;
        @if $idx.type eq "ASN_OCTET_STR"@
### CL_SNMP_MAX_STR_LEN should have a value such that the max. OID length (which has OID prefix 
### plus the index component), should not exceed 128.
### Also need to handle the condition when CL_SNMP_MAX_STR_LEN != max. string length mentioned in MIB. 
            @eval $str_var = $idx@
            @calldefine STR_UPPER_LIMIT@
    ClCharT $idx[$final_max];

        @elsif $idx.type eq "ASN_IPADDRESS"@
    ClUint8T $idx[4]; /* IPv4 address length */

        @elsif $idx.type eq "ASN_OBJECT_ID"@
    ClUint32T $idx[CL_SNMP_MAX_OID_LEN];

        @elsif $idx.type eq "ASN_INTEGER"@
    ClInt32T $idx;
        @elsif $idx.type eq "ASN_UNSIGNED" || $idx.type eq "ASN_GAUGE" || $idx.type eq "ASN_COUNTER" || $idx.type eq "ASN_TIMETICKS"@
    ClUint32T $idx;
        @else@
            @eval $decl = '$idx.decl'@
            @calldefine GET_CLOVIS_CODING_CONV@
    $c_type $idx;
        @end@
    @end@
} ClSnmp${t}IndexInfoT;

@end@

/* function prototypes.*/
@if $scalars_exist == 1@
ClInt32T  clSnmp${name}DefaultInstCompare (ClCntKeyHandleT key1,
                            ClCntKeyHandleT key2);
@end@
@foreach $t table@
@perleval $vars{'t'}=~ s/[^a-zA-Z0-9]*//g; 0@
ClInt32T  clSnmp${t}InstCompare (ClCntKeyHandleT key1,
                            ClCntKeyHandleT key2);
@end@

extern void init_${name}MIB(void);
/* Global structures.*/
extern ClSnmpOidInfoT appOidInfo[];
extern ClSnmpNtfyCallbackTableT clSnmpAppCallback[];

#ifdef __cplusplus
}
#endif

#endif /* _CL_SNMP_SUBAGENT_$name.uc_CONFIG_H_ */
@close mib2c/clSnmpSubAgent${name}Config.h@

##################################################
### mib2c/clSnmpSubAgent${name}Config.c
##################################################
@open mib2c/clSnmpSubAgent${name}Config.c@

#include <string.h>
#include <clLogApi.h>
#include <clSnmpLog.h>
#include <clDebugApi.h>
#include <clSnmpOp.h>
@if $scalars_exist == 1@
#include <clSnmp${name}Scalars.h>
@end@
@if $tables_exist == 1@
#include <clSnmp${name}Tables.h>
@end@
@if $notifications_exist == 1@
#include <clSnmp${name}Notifications.h>
@end@
#include <clSnmp${name}Util.h>
#include <clSnmp${name}InstXlation.h>
#include <clSnmpSubAgent${name}Config.h>

/*
 * This function needs to be written for every application MIB sub-agent. From
 * this function call the app MIB specific init functions. The app MIB
 * specific init functions are generated by mib2c
 */
 
void init_${name}MIB(void)
{
    /*Application needs to replace the below function with  mib2c generated init function.*/
@if $scalars_exist == 1@
    clSnmp${name}ScalarsInit();
@end@
@if $tables_exist == 1@
    clSnmp${name}TablesInit();
@end@
}

ClInt32T  clSnmp${name}DefaultInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    return 0;
}
@foreach $t table@
@perleval $vars{'t'}=~ s/[^a-zA-Z0-9]*//g; 0@
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmp${t}InstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    @foreach $idx index@
        @if $idx.type eq "ASN_OCTET_STR"@
    {
    ClInt32T len1 = strlen(pTabIdx1->index.${t}Info.$idx);
    ClInt32T len2 = strlen(pTabIdx2->index.${t}Info.$idx);

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "String Lenght1 : [%d] Lenght2 : [%d] Str1 : [%s] Str2 : [%s] ",
        len1, len2, pTabIdx1->index.${t}Info.$idx, pTabIdx2->index.${t}Info.$idx); 

    if(len1 != len2)
        return (len1 - len2);
    }

    if((retVal = strncmp(pTabIdx1->index.${t}Info.$idx,
                    pTabIdx2->index.${t}Info.$idx,
                    sizeof(pTabIdx1->index.${t}Info.$idx))) != 0)
        return retVal;

        @elsif $idx.type eq "ASN_OBJECT_ID" || $idx.type eq "ASN_IPADDRESS"@
    ### TO DO: For OID indexes, need to check length of OIDs with different lengths.
    ### compare the C arrays with memcmp
    if((retVal = memcmp(pTabIdx1->index.${t}Info.$idx,
                    pTabIdx2->index.${t}Info.$idx,
                    sizeof(pTabIdx1->index.${t}Info.$idx))) != 0)
        return retVal;

        @elsif $idx.type eq "ASN_INTEGER"@
    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%d], Index value2: [%d].", 
        (ClInt32T) pTabIdx1->index.${t}Info.$idx, (ClInt32T) pTabIdx2->index.${t}Info.$idx);

	if ( (retVal = ((ClInt32T) pTabIdx1->index.${t}Info.$idx - (ClInt32T) pTabIdx2->index.${t}Info.$idx)) != 0)
	    return retVal;

        @elsif $idx.type eq "ASN_UNSIGNED" || $idx.type eq "ASN_GAUGE" || $idx.type eq "ASN_COUNTER" || $idx.type eq "ASN_TIMETICKS"@
    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.${t}Info.$idx, (ClUint32T) pTabIdx2->index.${t}Info.$idx);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.${t}Info.$idx - (ClUint32T) pTabIdx2->index.${t}Info.$idx)) != 0)
	    return retVal;

        @else@
            @eval $decl = '$idx.decl'@
            @calldefine GET_CLOVIS_CODING_CONV@
	if ( (retVal = (($c_type) pTabIdx1->index.${t}Info.$idx - ($c_type) pTabIdx2->index.${t}Info.$idx)) != 0)
	    return retVal;
        @end@
    @end@
    return 0;
}
@end@
@close mib2c/clSnmpSubAgent${name}Config.c@
