#!/usr/bin/env python3
import sys, os, os.path, time, types, ast
import traceback,pdb
import argparse
import configparser
import re
from tabulate import tabulate
import random, errno
import amfctrl


#command completion
import readline

basedir = os.path.split(os.path.realpath(__file__))[0]
sys.path.append(os.path.abspath(os.path.join(basedir, '..', 'lib')))
sys.path.append(os.path.abspath(os.path.join(basedir, '..', 'lib', '3rdparty')))

DropToDebugger = True
access = None
CliName = ''
amfMgmtHandle = None

# We have to parse the args before main, because the args will determine what modules are imported
#parser = argparse.ArgumentParser()
#parser.add_argument("-l", "--local", action="store_true", help=('Force local access mode'))
#parser.add_argument("-nw", "--nw", action="store_true", help=('No window -- do not start a separate window'))
#args = parser.parse_args()

access = None
if False:#args.local == False:
  try:
    import netconfaccess
    access = netconfaccess
    CliName = "SAFplus CLI"
  except ImportError as e:
    print (e)
    pass

if access is None:
  try:
    import localaccess
    access = localaccess
    CliName = "SAFplus Local CLI"
  except ImportError as e:
    print (e)
    pass

print ("CliName: %s" % CliName)

# assert (AVAILABLE_SERVICES['localaccess'] == 1 or AVAILABLE_SERVICES['netconfaccess'] == 1)

SuNameColor = (50,160,80)
SuNameSize = 32

SuListColor = (20,100,60)
SuListSize = 40

NodeColor = (30,30,0xc0)
LeafColor = (0x30,0,0x30)

FullPathColor = (0xa0,0x70,0)

SAFplusNamespace = "http://www.openclovis.org/ns/amf"

import pdb
import xml.etree.ElementTree as ET
from xml.dom import minidom


#try:
#  if args.nw == True: raise Exception("Text mode selected on command line")
#  import xmlterm
#  windowed=True
#except Exception as e:
#print ("Cannot initialize windowing [%s], using no-window mode" % str(e))
import textxmlterm as xmlterm
windowed=False

def formatTag(tag):
  """Take a tag and format it for display"""
  if tag[0] == "{":  # Get rid of the namespace indicator b/c that's ugly
    tag = tag.split("}")[1]
  return tag
  

def commonSuffix(stringList):
  """Given a list of strings, return the string that is the common ending of all strings in the list"""
  revList = [ s[::-1] for s in stringList]
  revPfx = os.path.commonprefix(revList)
  return revPfx[::-1]

# Handlers take XML ElementTree objects and turn them into displayable objects


def epochTimeHandler(elem, resolver,context):
  """Convert an xml leaf containing seconds since the epoch into a user readable date panel"""
  seconds = int(elem.text)
  s = time.strftime('%Y-%b-%d %H:%M:%S', time.localtime(seconds))
  w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + formatTag(elem.tag) + ": " +  s)
  resolver.add(w)  

def dumpNoTagHandler(elem, resolver,context):
  """"""
  resolver.add(xmlterm.FancyText(resolver.parentWin, elem.text))

def epochMsTimeHandler(elem, resolver,context):
  """Convert an xml leaf containing milli-seconds since the epoch into a user readable date panel"""
  try:
    mseconds = int(elem.text)
    s = time.strftime('%Y-%b-%d %H:%M:%S', time.localtime(mseconds/1000))
  except TypeError:
    if elem.text is None: s = 'unspecified'
    else:  # garbage in the field
      assert(0)  
      s = "!error bad numeric field: ", str(elem.text)

  w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + formatTag(elem.tag) + ": " +  s)
  resolver.add(w)  
  
def elapsedSecondsHandler(elem, resolver,context):
  """Convert an xml leaf containing seconds to a user readable version of elapsed time"""
  if elem.text is None:
    s = ": unspecified"
  else:
    seconds = int(elem.text)
    days, rest = divmod(seconds,60*60*24)
    hours, rest = divmod(rest,60*60)
    minutes, seconds = divmod(rest,60)
    s = ": %d days %d hours %d minutes and %d seconds" % (days,hours,minutes,seconds)
  w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + formatTag(elem.tag) + s)
  resolver.add(w)  
  

def childReorg(elem,path):
  """Reorganize children of this element into the manner preferred by display.  This includes:
     1. Grouping all elements of a list into a common child node
  """
  lists = {}
  if elem.attrib.get("type",None) != "list":  # If I'm already a list, no list item isolation needed
   for child in elem:  # go thru all the children
    lstName = access.isListElem(child,path)  # Ask the access layer if this is a list element
    if lstName:  # if so, add this element to our temporary dictionary and remove it from elem
      if not lstName in lists:
        lists[lstName] = []
      lists[lstName].append(child)

   for (lstName,children) in lists.items():  # go through the temp dict creating list elements and adding items
    e = ET.SubElement(elem,lstName)
    e.attrib["type"] = "list"  # Mark this new element as a list so no infinite recursion
    for c in children:
      elem.remove(c)
      e.append(c)

def defaultHandler(elem,resolver,context):
  """Handle normal text and any XML that does not have a specific handler"""
  # Name preference order is: "key" attribute of tag (for lists) > "name" attribute of tag > "name" child of tag > tag 
  childReorg(elem,context.path)
  nameChild = elem.find("name")
  if nameChild is not None: name=nameChild.text
  else: name=elem.tag
  name = elem.attrib.get("name",elem.tag) 
  name = elem.attrib.get("listkey", name)
  name = formatTag(name) # Get rid of the namespace indicator b/c that's ugly
  # ns = 

  fore = None
  #more = elem.find("more")
  #if more is None:
  #  more = elem.find("{%s}more" % SAFplusNamespace)
  #if more is not None:

  if hasattr(elem, '_children'):  # it will either have child nodes or a "more" child node if it has children
    fore = NodeColor
  else:
    fore = LeafColor

  if elem.text:
    top = name + ":" + elem.text
  else:
    top = name

  w = xmlterm.FancyTextChunked(resolver.parentWin, ("  "*resolver.depth) + top,chunkSize=2048,fore=fore)
  resolver.add(w)  

  resolver.depth += 1
  context.path.append(elem.tag)
  for child in elem:
    resolver.resolve(child,context)
    if child.tail and child.tail.strip():
      w = xmlterm.FancyTextChunked(resolver.parentWin,("  "*resolver.depth) + child.tail,chunkSize=2048)
      resolver.add(w)
  del context.path[-1]   
  resolver.depth -= 1

def nowinhelpCmdHandler(elem,resolver,context):
  """handle help output in text mode"""
  if not elem.find("helpCmdName") is None:
    cmd = elem.find("helpCmdName").text
  else:
    cmd = ""

  if not elem.find("helpBrief") is None:
    brief = elem.find("helpBrief").text
  else:
    brief = ""

  if not elem.find("helpDetails") is None:
    details = elem.find("helpDetails").text
    if details == brief: details = ""
  else: 
    details = ""
  w = ("  "*resolver.depth) + cmd + ": " + brief
  resolver.add(w)  
  w = ("  "*(resolver.depth+1)) + details
  resolver.add(w)  


def defaultTextHandler(elem,resolver,context):
  """Handle normal text and any XML that does not have a specific handler"""
  # Name preference order is: "key" attribute of tag (for lists) > "name" attribute of tag > "name" child of tag > tag 
  childReorg(elem,context.path)
  nameChild = elem.find("name")
  if nameChild is not None: name=nameChild.text
  else: name=elem.tag
  name = elem.attrib.get("name",elem.tag) 
  name = elem.attrib.get("listkey", name)
  name = formatTag(name) # Get rid of the namespace indicator b/c that's ugly
  fore = None

  if hasattr(elem, '_children'):  # it will either have child nodes or a "more" child node if it has children
    fore = NodeColor
  else:
    fore = LeafColor

  if elem.text:
    top = name + ":" + elem.text
  else:
    top = name

  w = ("  "*resolver.depth) + top
  resolver.add(w)  

  resolver.depth += 1
  context.path.append(elem.tag)
  for child in elem:
    resolver.resolve(child,context)
    if child.tail and child.tail.strip():
      w = ("  "*resolver.depth) + child.tail
      resolver.add(w)
  del context.path[-1]   
  resolver.depth -= 1


def topHandler(elem,resolver,context):
  """Make this XML node invisible -- skip down to the children"""
  childReorg(elem,context.path)
  for child in elem:
    fullpath = child.attrib.get("path",None)
    if fullpath: # print out the full path with a : if it is placed into the child's attribute list.  This only happens for top level nodes so the user can see where they were found
      resolver.add(xmlterm.FancyText(resolver.parentWin,fullpath + ":",fore=FullPathColor))      
      resolver.depth+=1
    resolver.resolve(child,context)
    if fullpath:
      resolver.depth-=1

    if child.tail and child.tail.strip():
      w = xmlterm.FancyTextChunked(resolver.parentWin,("  "*resolver.depth) + child.tail,chunkSize=2048)
      resolver.add(w)
    

def childrenOnlyHandler(elem,resolver,context):
  """Make this XML node invisible -- skip down to the children"""
  childReorg(elem,context.path)
  for child in elem:
    resolver.resolve(child,context)
    if child.tail and child.tail.strip():
      w = xmlterm.FancyTextChunked(resolver.parentWin,("  "*resolver.depth) + child.tail,chunkSize=2048)
      resolver.add(w)

def historyHandler(elem,resolver,context):
  """Create a plot for the historical statistics XML nodes"""
  if elem.text:
    data = [float(x) for x in elem.text.split(",")]
    title = elem.attrib.get("title", formatTag(elem.tag))
    xlabel = elem.attrib.get("xlabel", "time")
    ylabel = elem.attrib.get("ylabel", "")  # TODO: grab the parent's tag as the ylabel?
    
    plotAttrib = { "title":title, "xlabel":xlabel, "ylabel":ylabel}
    if len(resolver.windows)>1:  # If there is lots of other data in this command, show a small graph
      plotAttrib["size"]="(200,100)"
    plot = ET.Element("plot",plotAttrib)
    series = ET.Element("series", {"label":""},text=elem.text)
    series.text = elem.text
    plot.append(series)
    resolver.add(xmlterm.FancyText(resolver.parentWin,formatTag(elem.tag)))
    w = xmlterm.PlotPanel(resolver.parentWin,plot)
    resolver.add(w)
  else:
    resolver.defaultHandler(elem,resolver,context)


def serviceUnitHandler(elem,resolver,context):
  """Custom representation of a service unit"""
  name = elem.attrib.get("listkey",formatTag(elem.tag))
  w = xmlterm.FancyText(resolver.parentWin,("  "*resolver.depth) + name,fore=SuNameColor,size=SuNameSize)
  resolver.add(w)
  try:
    w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + "  Admin: %s Operational: %s %s " % (elem.find("adminState").text,"OK" if elem.find("operState").text == "1" else "FAULTED", elem.find("haState").text))
    resolver.add(w)
    w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + "  Active Work: %s Standby Work: %s" % (elem.find("numActiveServiceInstances").find("current").text,elem.find("numStandbyServiceInstances").find("current").text))
    resolver.add(w)
    w = xmlterm.FancyText(resolver.parentWin, ("  "*resolver.depth) + "  On Node: %s  In Service Group: %s" % (elem.find("node").text.split("/")[-1],elem.find("serviceGroup").text.split("/")[-1]))
    resolver.add(w)
  except AttributeError as e: # object could have no children because recursion depth exceeded
    pass 

def serviceUnitListHandler(elem,resolver,context):
  """Create a graphical representation of the XML 'text' tag"""
  if 'listkey' in elem.attrib: # Its an instance of the list
    serviceUnitHandler(elem,resolver,context)
    return
  path = elem.attrib.get("path",None)
  if path == "/SAFplusAmf/ServiceUnit" or len(elem)>0:  # serviceunit tag can be a list, a list entry, or a su ref.  SU ref has no children
    resolver.add(xmlterm.FancyText(resolver.parentWin,("  "*resolver.depth) + "ServiceUnit",fore=SuListColor,size=SuListSize))
    resolver.depth += 1
    for su in elem:
      serviceUnitHandler(su,resolver,context)
    resolver.depth -= 1
  else:  # Could be ServiceUnit has no children because recursion depth exceeded
    w = xmlterm.FancyText(resolver.parentWin,("  "*resolver.depth) + formatTag(elem.tag))  # so normal display
    resolver.add(w)
    
  
  if elem.text:  # There should not be any text in the service unit list but display it if there is
    size = elem.attrib.get("size",None)
    if size: size = int(size)
    fore = elem.attrib.get("fore",None)
    if fore: fore = color.rgb(fore) # [ int(x) for x in fore.split(",")]
    back = elem.attrib.get("back",None)
    if back: back = color.rgb(back) # [ int(x) for x in back.split(",")]
    w = xmlterm.FancyText(resolver.parentWin,elem.text,fore=fore, back=back,size=size)
    resolver.add(w)

seriesTags = ["history10sec","history1min","history10min","history1hour","history1day","history1week","history4weeks"]

def findSeries(et,prefix=None):
  """Pull all plottable elements out of the element tree and return them with a series label.  A series is a list of numbers"""
  if prefix is None: 
    prefix = ""
  if 'path' in et.attrib:  # override the prefix with a supplied path if it exists, since that is guaranteed to be complete
    prefix = et.attrib["path"]
  else:
    prefix = prefix + "/" + et.tag  # Build the prefix from the et structure
  if et.tag in seriesTags:
      return [(prefix, et.text)]
  ret = []
  for e in et:
    t = findSeries(e,prefix)
    if t: ret += t
  return ret

def findMetrics(et,prefix=None):
  """Pull all plottable elements out of the element tree and return them with a metric label.  A metric is just a single number, while a series is a list of numbers"""
  if prefix is None: 
    prefix = ""
  if 'path' in et.attrib:  # override the prefix with a supplied path if it exists, since that is guaranteed to be complete
    prefix = et.attrib["path"]
  else:
    prefix = prefix + "/" + et.tag  # Build the prefix from the et structure
  ret = []
  try:  # If we can convert into a number, report it as a metric
    test = float(et.text)
    ret.append((prefix, et.text))
  except Exception as e:
    pass
  for e in et:
    t = findMetrics(e,prefix)
    if t: ret += t
  return ret

def uniquePortion(seriesNames):
    """Determine the common prefix and suffix of a list of names, and return (x,y) such that name[x:y] removes the common parts"""
    commonPfx = os.path.commonprefix(seriesNames)
    t = commonPfx.rfind("/")  # we want to split across / boundaries, not within tags. that is: commonprefix([a/bc, a/bd] -> a/b  so convert that to "a/"
    if t>=0: commonPfx = commonPfx[0:t+1]
    pfxLen=len(commonPfx)
 
    commonSfx = commonSuffix(seriesNames)
    t = commonSfx.find("/")
    if t>=0: commonSfx = commonSfx[t:]
    sfxLen=-1 * len(commonSfx)
    if sfxLen==0: sfxLen = None
    return (pfxLen,sfxLen)

def getDictCommandHelp(d, prefix="",single=None):
  ret = []
  for (name,val) in d.items():
    if name is None: name = "" # convert to something printable
    hlp = []
    if type(val) is dict:
      tmp = prefix + name + " "
      hlp = getDictCommandHelp(val, tmp,single=single)
    else:
      if val[0] and (type(val[0]) == types.FunctionType or type(val[0]) == types.MethodType or type(val[0]) == types.LambdaType ):
        if not single or single == prefix + name:
          hlp = ["<helpCmd><helpCmdName>" + prefix + name + "</helpCmdName>"] + getFunctionHelp(val[0]) + ["</helpCmd>"]
    ret += hlp
  print (ret)
  return ret  

def getFunctionHelp(fn):
  # TODO gather info from the arguments
  #argspec = inspect.getargspec(fn)

  if fn.__doc__:
    brief = ""
    doc = ""
    tmp = fn.__doc__
    if tmp[0] == "?":  # YaDoG style documentation
      tmp=tmp[1:]
    if 1:
      bpos = tmp.find("\n")  # Finds the first of \n or .
      bpos = tmp.find(".",0,bpos) 
      doc = "<helpDetails>" + tmp + "</helpDetails>"
      if bpos != -1:
        brief = "<helpBrief>" + tmp[0:bpos] + "</helpBrief>"
      elif len(tmp)<120: 
        brief = "<helpBrief>" + tmp + "</helpBrief>"
      else:
        pass
 
    return [brief,doc]  # TODO interprete and xmlize the docstring
  else:
    return ["<helpBrief>No help available</helpBrief>"]

class Dot:
    """
    The dot class lets you access fields either through field notation (.)
    or dictionary notation ([]).
    """

    def __init__(self, dict):
        for (key, val) in dict.items():
            if type(val) == type({}): val = Dot(val)
            self.__dict__[key] = val

    def __str__(self):
        s=[]
        for (key, val) in self.__dict__.items():
            s.append("'%s':%s" % (str(key), str(val)))
        return "{ " + ", ".join(s) + " }"

    def __repr__(self): return 'Dot(%s)' % self.__str__()

    #def has_key(self, key): return self.__dict__.has_key(key)

    def keys(self): return self.__dict__.keys()

    def values(self): return self.__dict__.values()

    def items(self): return self.__dict__.items()

    def clear(self): self.__dict__.clear()

    def get(self, key, default = None): return self.__dict__.get(key, default)

    def setdefault(self, key, default = None): return self.__dict__.setdefault(key, default)

    def pop(self, key, default = None): return self.__dict__.pop(key, default)

    def popitem(self): return self.__dict__.popitem()

    def iteritems(self): return self.__dict__.iteritems()

    def iterkeys(self): return self.__dict__.iterkeys()

    def itervalues(self): return self.__dict__.itervalues()

    def __getitem__(self, key): return self.__dict__[key]

    def __setitem__(self, key, val): self.__dict__[key] = val

    def __delitem__(self, key): del self.__dict__[key]

    def __len__(self): return self.__dict__.__len__()

    def __contains__(self, item): return item in self.__dict__

    def dot_print(self, prefix=None):
        s = []
        for (key, val) in self.__dict__.items():
            p = (prefix and prefix+'.' or '')+str(key)
            try:
                s.append(val.dot_print(p))
            except AttributeError:
                s.append(p + '=' + str(val))
        return '\n'.join(s)

class TermController(xmlterm.XmlResolver):
  """This class customizes the XML terminal"""
  def __init__(self):
    xmlterm.XmlResolver.__init__(self)
    self.tags.update(xmlterm.GetDefaultResolverMapping())
    self.curdir = "/"
    self.cmds.append(self)  # I provide some default commands
    self.xmlterm = None
    self.helpdoc = None
    self.handle = None
    self.didConnect = 0

  def newContext(self):
    path = self.curdir.split("/")
    return xmlterm.ParsingContext(path)

  def start(self,xt):
    """Called when the XML terminal is just getting started"""
    self.xmlterm = xt
    xt.frame.SetTitle(CliName)
    
  def prompt(self):
    """Returns the terminal prompt"""
    return self.curdir + "> "

  def new(self):
    """Clone this controller for sub-documents"""
    return TermController()

  def completion(self,text, state):
    """Return the best command line completion candidate, given that the user already typed the string s""" 
    return clicompletion.process_completion(text, state, readline.get_line_buffer(), self.curdir)

  def getHelp(self,command=None):
    ret = []
    if command:  # Filter specific commands
      for c in command:
        for cmdContext in self.cmds:
          if hasattr(cmdContext,"commands"):  # If the object has a command lookup table, then print help on it
            ret += getDictCommandHelp(cmdContext.commands,single=c)
          fnname = "do_" + c
          if hasattr(cmdContext,fnname):
            ret += [ "<helpCmd><helpCmdName>" + fnname[3:] + "</helpCmdName>"] + getFunctionHelp(getattr(cmdContext,fnname)) + ["</helpCmd>"]        
    else: # Get all commands
      if self.helpdoc:
        ret.append(self.helpdoc)

      for cmdContext in self.cmds:
        if hasattr(cmdContext,"helpdoc") and cmdContext.helpdoc:   # Put the command category's help doc up
          ret.append(cmdContext.helpdoc)
        if hasattr(cmdContext,"commands"):  # If the object has a command lookup table, then print help on it
          ret += getDictCommandHelp(cmdContext.commands)
        for fnname in dir(cmdContext):    # IF the object has do_ functions print help on them.
          if fnname.startswith("do_"):
            ret += [ "<helpCmd><helpCmdName>" + fnname[3:] + "</helpCmdName>"] + getFunctionHelp(getattr(cmdContext,fnname)) + ["</helpCmd>"]
    return "\n".join(ret)

  def bar(self,xml,xt):
    """Implement the bar graph command, which draws a bar graph"""
    et = ET.fromstring("<top>" + "".join(xml) + "</top>")
    metrics = findMetrics(et)
    if not metrics: return
    metricNames = [x[0] for x in metrics]
    (pfxLen,sfxLen) = uniquePortion(metricNames)
    st = ['<barGraph>']
    for s in metrics:
      if s[1]:  # If the series has some data then add it to the plot
        lbl = s[0][pfxLen:sfxLen]
        st.append('<metric label="%s">' % lbl)
        st.append(s[1])
        st.append('</metric>')
    st.append("</barGraph>")
    xt.doc.append("".join(st))  # I have to wrap in an xml tag in case I get 2 top levels from mgtGet
  

  def plot(self,xml,xt):
    """Implement the plot command -- draws a plot (line graph)"""
    et = ET.fromstring("<top>" + "".join(xml) + "</top>")
    series = findSeries(et)
    seriesNames = [x[0] for x in series]

    sz = xt.GetSize()
    sizeString = "(%s,%s)" % (sz[0]-30,sz[1]/2)
    (pfxLen,sfxLen) = uniquePortion(seriesNames)

    st = ['<plot size="%s">' % sizeString]
    for s in series:
      if s[1]:  # If the series has some data then add it to the plot
        lbl = s[0][pfxLen:sfxLen]
        st.append('<series label="%s">' % lbl)
        st.append(s[1])
        st.append('</series>')
    st.append("</plot>")
    # print "".join(st)
    xt.doc.append("".join(st))  # I have to wrap in an xml tag in case I get 2 top levels from mgtGet
 
  def do_help(self,*command):
    """? display this help, or detailed help about a particular command"""
    if command:
      command = [" ".join(command)]
    else:
      command = None
    return "<top>" + self.getHelp(command) + "</top>"

  def do_ls(self,*sp):
    """Displays the object tree at the current or specified location.
Arguments: [-N] location
By default the specified location and children are shown.  Use -N to specify how many children to show.  For example -2 will show this location, children and grandchildren.
    """
    depth=1
    rest = ""
    if len(sp):  
      if sp[0][0] == "-":  # Its a flag
        depth = int(sp[0][1:])  # depth modifier flag
        if len(sp)>2:
          rest = sp[1]
      else:             
        rest = sp[0]
    t = os.path.normpath(os.path.join(self.curdir,rest))
    gs = "{d=%s}%s" % (depth,str(t))
    #print "getting ", gs
    try:
      xml = access.mgtGet(self.handle, gs)
    except RuntimeError as e:
      if str(e) == "Route has no implementer":
        return "<error>Invalid path [%s]</error>" % str(t)
      return "<error>" + str(e) + "</error>"
    except Exception as e:
      return "<error>" + str(e) + "</error>"
    #print xml
    return "<top>" + xml + "</top>"  # I have to wrap in an xml tag in case I get 2 top levels from mgtGet

  def do_cd(self,location):
    """Change the current directory (object tree context)"""
    tmp = os.path.normpath(os.path.join(self.curdir,location))
    if access.isValidDirectory(tmp):
      self.curdir = tmp
      self.xmlterm.cmdLine.setPrompt()
    else:
      return "<error>Invalid path [%s]</error>" % tmp
    return ""

  def do_pwd(self,*sp):
    """Print working directory - shows the current directory"""
    print (self.curdir)
    return ""

  def do_raw(self,*sp):
    """Equivalent to 'ls' but displays raw XML"""
    depth=1
    prefix = "{d=%s}"
    rest = ""
    flags = sp
    for flag in flags:  
      if flag[0] == "-":  # Its a flag
        if flag[1] == 'b':
          prefix = "{b,d=%s}"
        elif flag[1] == 'p':
          prefix = "{p,d=%s}"
        else:
          try:  
            depth = int(flag[1:])  # depth modifier flag
          except ValueError as e:
            xt.doc.append("bad flag: " + flag)
            pass
      else:             
        rest = flag
    t = os.path.normpath(os.path.join(self.curdir,rest))
    # print (prefix % depth) + str(t)
    xml = access.mgtGet((prefix % depth) + str(t))
    txt = "<text>" + xmlterm.escape(xmlterm.indent("<top>" + xml + "</top>")) + "</text>"
    return txt # I have to wrap in an xml tag in case I get 2 top levels from mgtGet

  def do_time(self,*sp):
    """Show the time"""
    import datetime
    now = datetime.datetime.now()
    print ("Current date and time : ")
    print (now.strftime("%Y-%m-%d %H:%M:%S"))
    #return "<time/>"
    return ""

  def do_echo(self,*sp):
    """Print the args back at the user"""
    return " ".join(sp[1:])

  def do_title(self,title):
    """Change this window's title"""
    self.xmlterm.frame.SetTitle(title)
    return ""

  def do_alias(self,alias,*val):
    """Make one command be replaced by another string"""
    self.xmlterm.aliases[alias] = " ".join(val)
    return ""

  def do_exit(self):
    """Exit this program"""
    self.xmlterm.frame.Close()    

  def do_plot(self,*sp):
          """? Draw a line graph
    Arguments: locations that contain plottable data (comma separated list of numbers)
    Example:  Plot memory utilization on all components in 10 second and 1 minute time frames. 
       cd /*/safplusAmf/Component/*/procStats/memUtilization
       plot history10sec history1min         
"""
          depth=1
          rest = ""
          if len(sp):  
            if sp[0][0] == "-":  # Its a flag
              depth = int(sp[0][1:])  # depth modifier flag
              if len(sp)>1:
                rest = sp[1:]
            else:             
              rest = sp
          xml = []
          for arg in rest:
            t = os.path.normpath(os.path.join(self.curdir,arg))
            xml.append(access.mgtGet("{d=%s}%s" % (depth,str(t))))
          self.plot(xml,self.xmlterm)
          return ""

  def do_bar(self,*sp):
          """? Draw a bar graph.  A bar graph compares single values of multiple entities.  If locations do not resolve to single-number entities, the bar graph will not be shown.
    Arguments: locations (must contain a number)
    Example:  Compare number of threads in all components on all network elements
       cd /*/safplusAmf/Component/*/procStats
       bar numThreads/current
          """
          depth=1
          rest = ""
          if len(sp):  
            if sp[0][0] == "-":  # Its a flag
              depth = int(sp[0][1:])  # depth modifier flag
              if len(sp)>1:
                rest = sp[1:]
            else:             
              rest = sp
          xml = []
          for arg in rest:
            t = os.path.normpath(os.path.join(self.curdir,arg))
            xml.append(access.mgtGet("{d=%s}%s" % (depth,str(t))))
          self.bar(xml,self.xmlterm)
          return ""

  def xxexecute(self,textLine,xt):
    """Execute the passed string"""
    cmdList = textLine.split(";")
    depth = 1
    while cmdList:
      text = cmdList.pop(0) 
      sp = text.split()
      if sp:
        alias = xt.aliases.get(sp[0],None)
        if alias: # Rewrite text with the alias and resplit
          sp[0] = alias
          text = " ".join(sp)
          sp = text.split()
        # Now process the command
        if sp[0]=="ls" or sp[0] == "dir":
          rest = ""
          if len(sp)>1:  
            if sp[1][0] == "-":  # Its a flag
              depth = int(sp[1][1:])  # depth modifier flag
              if len(sp)>2:
                rest = sp[2]
            else:             
              rest = sp[1]
          t = os.path.normpath(os.path.join(self.curdir,rest))
          gs = "{d=%s}%s" % (depth,str(t))
          #print "getting ", gs
          xml = access.mgtGet(gs)
          #print xml
          xt.doc.append("<top>" + xml + "</top>")  # I have to wrap in an xml tag in case I get 2 top levels from mgtGet
        elif sp[0]=="plot":
          rest = ""
          if len(sp)>1:  
            if sp[1][0] == "-":  # Its a flag
              depth = int(sp[1][1:])  # depth modifier flag
              if len(sp)>2:
                rest = sp[2:]
            else:             
              rest = sp[1:]
          xml = []
          for arg in rest:
            t = os.path.normpath(os.path.join(self.curdir,arg))
            xml.append(access.mgtGet("{d=%s}%s" % (depth,str(t))))
          self.plot(xml,xt)
        elif sp[0]=="bar":
          rest = ""
          if len(sp)>1:  
            if sp[1][0] == "-":  # Its a flag
              depth = int(sp[1][1:])  # depth modifier flag
              if len(sp)>2:
                rest = sp[2:]
            else:             
              rest = sp[1:]
          xml = []
          for arg in rest:
            t = os.path.normpath(os.path.join(self.curdir,arg))
            xml.append(access.mgtGet("{d=%s}%s" % (depth,str(t))))
          self.bar(xml,xt)
        
        elif sp[0]=="cd":
          self.curdir = os.path.normpath(os.path.join(self.curdir,sp[1]))
          xt.cmdLine.setPrompt()
        elif sp[0]=='pwd':
          xt.doc.append(self.curdir)
        elif sp[0]=='raw':
          prefix = "{d=%s}"
          rest = ""
          flags = sp[1:]
          for flag in flags:  
            if flag[0] == "-":  # Its a flag
              if flag[1] == 'b':
                prefix = "{b,d=%s}"
              elif flag[1] == 'p':
                prefix = "{p,d=%s}"
              else:
                try:  
                  depth = int(flag[1:])  # depth modifier flag
                except ValueError as e:
                  xt.doc.append("bad flag: " + flag)
                  pass
            else:             
              rest = flag
          t = os.path.normpath(os.path.join(self.curdir,rest))
          # print (prefix % depth) + str(t)
          xml = access.mgtGet((prefix % depth) + str(t))
          txt = "<text>" + xmlterm.escape(xmlterm.indent("<top>" + xml + "</top>")) + "</text>"
          xt.doc.append(txt)  # I have to wrap in an xml tag in case I get 2 top levels from mgtGet

        elif sp[0]=="!time": # Show the time (for fun)
          xt.doc.append("<time/>")
        elif sp[0] == '!echo':  # Display something on the terminal
          xt.doc.append(" ".join(sp[1:]))
          if 0:
           try:  # If its good XML append it, otherwise excape it and dump as text
            rest = " ".join(sp[1:])
            testtree = ET.fromstring(rest)
            xt.doc.append(rest)
           except ET.ParseError:
            xt.doc.append(xmlterm.escape(rest))
        elif sp[0] == '!name':  # Change the terminal's title
          xt.frame.SetTitle(sp[1])
        elif sp[0] == 'alias' or sp[0] == '!alias':  # Make one command become another
          xt.aliases[sp[1]] = " ".join(sp[2:])
        elif sp[0] == '!exit' or sp[0] == 'exit':  # goodbye
          self.parentWin.GetParent().frame.Close()
        else:
          pdb.set_trace()
          # TODO look for registered RPC call
          t = xmlterm.escape(" ".join(sp))
          xt.doc.append('<process>%s</process>' % t)  

  def do_connect(self,ipAddress):
    """syntax: connect ipAddress
    Connect to an active node
    """
    self.didConnect = 1
    pattern = r"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    try:
      ip = [match[3] for match in re.findall(pattern, ipAddress)]
      print ("nodeName: %s" %ip[0])
      self.handle = access.getProcessHandle(1, int(ip[0]))
    except IndexError as e:
      print ("<error>ipAddress [%s] error [%s]</error>" % (ipAddress, str(e)))
      self.didConnect = 0
      return ""
    return ""

  def do_entityPrint(self, *entityTypeAndEntityNamePairs):
    """syntax: entityPrint entityType entityName
    Display attributes in an entity
    """
    if len(entityTypeAndEntityNamePairs) % 2 != 0:
      print ("don't have entityName with the corresponding entityType")
      return ""

    i = 0
    while i < len(entityTypeAndEntityNamePairs):
      entityType = entityTypeAndEntityNamePairs[i]
      entityName = entityTypeAndEntityNamePairs[i+1]
      t = os.path.normpath(os.path.join(self.curdir,"/safplusAmf",entityType,entityName))
      depth=1
      gs = "{d=%s}%s" % (depth,str(t))
      try:
        xml = access.mgtGet(self.handle, gs)
      except RuntimeError as e:
        if str(e) == "Route has no implementer":
          return "<error>Invalid path [%s]</error>" % str(t)
        return "<error>" + str(e) + "</error>"
      except Exception as e:
        return "<error>" + str(e) + "</error>"

      configureItems = "adminState",  "autoRepair",  "canBeInherited",  "currentRecovery",\
        "disableAssignmentOn",  "failFastOnCleanupFailure",  "failFastOnInstantiationFailure",\
          "id",  "lastSUFailure",  "name",  "restartable",  "serviceUnitFailureEscalationPolicy",\
            "userDefinedType",  "autoAdjust",  "autoAdjustInterval",  "componentRestart",\
              "maxActiveWorkAssignments",  "maxStandbyWorkAssignments",  "preferredNumActiveServiceUnits",\
                "preferredNumIdleServiceUnits",  "preferredNumStandbyServiceUnits",  "serviceInstances",\
                  "serviceUnitRestart",  "serviceUnits",  "assignedServiceInstances",  "compRestartCount",\
                    "components",  "failover",  "lastCompRestart",  "lastRestart",  "node",  "rank",\
                      "saAmfSUHostNodeOrNodeGroup",  "serviceGroup",  "capabilityModel",  "cleanup",\
                        "csiType",  "delayBetweenInstantiation",  "instantiate",  "instantiateLevel",\
                          "maxInstantInstantiations",  "maxStandbyAssignments",  "proxied",  "proxyCSI",  "recovery",\
                            "serviceUnit",  "terminate",  "timeouts",  "isFullStandbyAssignment",  "isFullActiveAssignment",\
                              "preferredActiveAssignments",  "preferredStandbyAssignments",  "dependencies",  "type",\
                                "instantiationSuccessDuration",  "maxActiveAssignments",  "maxDelayedInstantiations",\
                                  "componentServiceInstances",  "serviceInstance", "data"
      configureList = [["Configuration -------------------------------", "---------------------------"], ["", ""]]
      statusItems = "operState", "presenceState", "stats", "numAssignedServiceUnits", "numIdleServiceUnits",\
        "numSpareServiceUnits", "haReadinessState", "haState", "numActiveServiceInstances", "numStandbyServiceInstances",\
          "preinstantiable", "probationTime", "readinessState", "restartCount", "activeAssignments", "compCategory",\
            "compProperty", "lastError", "lastInstantiation", "numInstantiationAttempts", "pendingOperation",\
              "pendingOperationExpiration", "procStats", "processId", "safVersion", "swBundle", "numActiveAssignments",\
                "numStandbyAssignments", "standbyAssignments", "activeComponents", "isProxyCSI", "standbyComponents",\
                  "assignmentState"
      statusList = [["Status --------------------------------------", "---------------------------"], ["", ""]]

      try:
        root = ET.fromstring(xml)
      except IndexError as e:
        print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
        return ""
      except ET.ParseError as e:
        print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
        return ""
      exist = False
      for child in root:
        d = [child.tag, child.text]
        if child.text == None:
          t1 = os.path.normpath(os.path.join(self.curdir,"/safplusAmf",entityType,entityName,child.tag))
          depth1=1
          gs1 = "{d=%s}%s" % (depth1,str(t1))
          xml1 = access.mgtGet(self.handle, gs1)
          if "<val>"in xml1 and "<name>" in xml1:
            if exist == True:
                continue
            exist = True
            newXML = "<root>" + xml1 + "</root>"
            root = ET.fromstring(newXML)
            count = 0
            content = ""
            for data in root.findall("data"):
              name = data.find("name").text
              val = data.find("val").text
              count += 1
              content +=  "\n    Name: " + name + "\n    Val : " + val + "\n"
            formatData = "data[%s]%s" % (count,content)
            d = [child.tag, formatData]
            configureList.append(d)
            continue
          elif "data listkey" in xml1:
            continue
          else:
            root1 = ET.fromstring(xml1)
            for child1 in root1.iter('current'):
              d = [child.tag, child1.text]
        if child.tag in configureItems:
          configureList.append(d)
        elif child.tag in statusItems:
          statusList.append(d)
        else:
          print ("not in configure and status: %s %s" %(child.tag, child.text))
      headers = ["Name", entityName]
      print (tabulate(configureList, headers, tablefmt="psql"))
      print (tabulate(statusList, headers, tablefmt="psql"))
      i += 2
    return ""

  def do_entityLockAssignment(self, entityType, entityName):
    """syntax: entityLockAssignment entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeLockAssignment(handleTest, entityName)
      elif entityType == "ServiceGroup":
        ret = access.amfMgmtSGLockAssignment(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSULockAssignment(handleTest, entityName)
      elif entityType == "ServiceInstance":
        ret = access.amfMgmtSILockAssignment(handleTest, entityName)

      if ret == 0x0:
        print("entityLockAssignment completed successfully")
      elif ret != "invalidType":
        print('entityLockAssignment failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit and ServiceInstance")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_entityLockInstantiation(self, entityType, entityName):
    """syntax: entityLockInstantiation entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeLockInstantiation(handleTest, entityName)
      elif entityType == "ServiceGroup":
        ret = access.amfMgmtSGLockInstantiation(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSULockInstantiation(handleTest, entityName)

      if ret == 0x0:
        print("entityLockInstantiation completed successfully")
      elif ret != "invalidType":
        print('entityLockInstantiation failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceGroup and ServiceUnit")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print("error: ", e)

    return ret

  def do_entityUnlock(self, entityType, entityName):
    """syntax: entityUnlock entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeUnlock(handleTest, entityName)
      elif entityType == "ServiceGroup":
        ret = access.amfMgmtSGUnlock(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSUUnlock(handleTest, entityName)
      elif entityType == "ServiceInstance":
        ret = access.amfMgmtSIUnlock(handleTest, entityName)

      if ret == 0x0:
        print("entityUnlock completed successfully")
      elif ret != "invalidType":
        print('entityUnlock failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit and ServiceInstance")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_entityRepaired(self, entityType, entityName):
    """syntax: entityRepaired entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeRepair(handleTest, entityName)
      elif entityType == "Component":
        ret = access.amfMgmtCompRepair(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSURepair(handleTest, entityName)

      if ret == 0x0:
        print("entityRepaired completed successfully")
      elif ret != "invalidType":
        print('entityRepaired failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, Component and ServiceUnit")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_start(self, entityName):
    """syntax: start entityName
    """

    entityTypes = "Node", "ServiceGroup", "ServiceUnit", "Component", "ServiceInstance"
    for entityType in entityTypes:
      try:
        print("for entityType is ", entityType, " : ", self.do_entityUnlock(entityType, entityName))
      except RuntimeError as e:
        print ("error: ", e)
    return ""

  def do_stop(self, entityName):
    """syntax: stop entityName
    """

    entityTypes = "Node", "ServiceGroup", "ServiceUnit", "Component", "ServiceInstance"
    for entityType in entityTypes:
      try:
        print("for entityType is ", entityType, " : ", self.do_entityLockInstantiation(entityType, entityName))
      except RuntimeError as e:
        print ("error: ", e)
    return ""

  def do_idle(self, entityName):
    """syntax: idle entityName
    """

    entityTypes = "Node", "ServiceGroup", "ServiceUnit", "Component", "ServiceInstance"
    for entityType in entityTypes:
      try:
        print("for entityType is ", entityType, " : ", self.do_entityLockAssignment(entityType, entityName))
      except RuntimeError as e:
        print ("error: ", e)
    return ""

  def do_repair(self, entityName):
    """syntax: repair entityName
    """

    entityTypes = "Node", "ServiceGroup", "ServiceUnit", "Component", "ServiceInstance"
    for entityType in entityTypes:
      try:
        print("for entityType is ", entityType, " : ", self.do_entityRepaired(entityType, entityName))
      except RuntimeError as e:
        print ("error: ", e)
    return ""

  def do_repairAll(self):
    """syntax: repairAll
    """
    entityTypes = "Node", "ServiceUnit", "Component"
    for entityType in entityTypes:
      listEntityName = self.parseXML(entityType)
      if len(listEntityName) != 0:
        for entityName in listEntityName:
          try:
            self.do_entityRepaired(entityType, entityName)
          except RuntimeError as e:
            print ("error: ", e)

    return ""

  def parseXML(self, entityType):
    t = os.path.normpath(os.path.join(self.curdir,"/safplusAmf/", entityType))
    depth=1
    gs = "{d=%s}%s" % (depth,str(t))
    try:
      xml = access.mgtGet(self.handle, gs)
      xml = "<top>" + xml + "</top>"
    except RuntimeError as e:
      if str(e) == "Route has no implementer":
        return "<error>Invalid path [%s]</error>" % str(t)
      return "<error>" + str(e) + "</error>"
    except Exception as e:
      return "<error>" + str(e) + "</error>"
    try:
      # print xml
      root = ET.fromstring(xml)
    except IndexError as e:
      print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
      return ""
    except ET.ParseError as e:
      print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
      return ""
    listEntityName = []
    for child in root:
      dictAtrr = child.attrib
      listEntityName.append(dictAtrr["listkey"])
    return listEntityName

  def do_dbPrint(self):
    """syntax: dbPrint
    """
    entityTypes = "Node", "ServiceUnit", "Component", "ServiceGroup", "ServiceInstance", "ComponentServiceInstance"
    for entityType in entityTypes:
      listEntityName = self.parseXML(entityType)
      if len(listEntityName) != 0:
        for entityName in listEntityName:
          try:
            self.do_entityPrint(entityType, entityName)
          except RuntimeError as e:
            print ("error: ", e)

    return ""

  def prettify(self, elem):
    rough_string = ET.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")

  def recursiveParseXML(self, dom, top):
    if len(dom.childNodes) > 0:
      for n in dom.childNodes:
        if n.nodeType == n.TEXT_NODE:
          child = ET.SubElement(top, dom.tagName)
          child.text = n.data
        else:
          if len(n.childNodes) > 0:
            self.recursiveParseXML(n, top)
          else:
            if n.getAttribute("listkey") != "":
              if n.tagName == "Node":
                element = top.find("Nodes")
                if element == None:
                  element = ET.SubElement(top, "Nodes")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
              elif n.tagName == "ServiceGroup":
                element = top.find("ServiceGroups")
                if element == None:
                  element = ET.SubElement(top, "ServiceGroups")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
              elif n.tagName == "ServiceUnit":
                element = top.find("ServiceUnits")
                if element == None:
                  element = ET.SubElement(top, "ServiceUnits")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
              elif n.tagName == "Component":
                element = top.find("Components")
                if element == None:
                  element = ET.SubElement(top, "Components")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
              elif n.tagName == "ServiceInstance":
                element = top.find("ServiceInstances")
                if element == None:
                  element = ET.SubElement(top, "ServiceInstances")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
              elif n.tagName == "ComponentServiceInstance":
                element = top.find("ComponentServiceInstances")
                if element == None:
                  element = ET.SubElement(top, "ComponentServiceInstances")
                child2 = ET.SubElement(element, n.tagName, {'listkey':n.getAttribute("listkey")})
                self.parseXMLParent2Child(n.tagName, child2)
            else:
              child = ET.SubElement(top, n.tagName)
              t1 = os.path.normpath(os.path.join(self.curdir,"/safplusAmf",dom.tagName, dom.getAttribute("listkey"), n.tagName))
              depth1=1
              gs1 = "{d=%s}%s" % (depth1,str(t1))
              xml1 = access.mgtGet(self.handle, gs1)
              xml1 = "<top>" + xml1 + "</top>"
              print (t1)
              print (xml1)
              root1 = ET.fromstring(xml1)
              for child1 in root1.iter('current'):
                child.text = child1.text
    return ""

  def parseXMLParent2Child(self, entityType, top):
    t = os.path.normpath(os.path.join(self.curdir,"/safplusAmf/", entityType))
    depth=1
    gs = "{d=%s}%s" % (depth,str(t))
    try:
      xml = access.mgtGet(self.handle, gs)
      xml = "<top>" + xml + "</top>"
    except RuntimeError as e:
      if str(e) == "Route has no implementer":
        return "<error>Invalid path [%s]</error>" % str(t)
      return "<error>" + str(e) + "</error>"
    except Exception as e:
      return "<error>" + str(e) + "</error>"
    dom = minidom.parseString(xml)
    if entityType == "":
      top = ET.Element(dom.childNodes[0].childNodes[0].tagName)
    self.recursiveParseXML(dom, top)
    return top

  def do_dbXMLPrint(self):
    """syntax: dbXMLPrint
    """
    top = ET.Element("")
    top = self.parseXMLParent2Child("", top)
    print (self.prettify(top))

    f = open("../var/log/safplusAmf_db_print.xml", "w")
    f.write(self.prettify(top))
    f.close()

    path = os.path.abspath(os.getcwd())
    parent = os.path.join(path, os.pardir)
    print ("Success - Output written to [%s/var/log/safplusAmf_db_print.xml]" %os.path.abspath(parent))

    return ""

  def do_entitySet(self, entityType, entityName, *attributesAndValuesPairs):
    """syntax: entitySet entityType entityName attribute value
    Set the specified values to the attributes
    """
    if len(attributesAndValuesPairs) % 2 != 0 or len(attributesAndValuesPairs) == 0:
      ret = 0x02
      print('entitySet failed with error code [%s]'% hex(ret))
      return ret
    listAttributesAndValuesPairs = list(attributesAndValuesPairs)
    listAttributesAndValuesPairs.append("name")
    listAttributesAndValuesPairs.append(entityName)
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        if entityType == "Component":
          ret = access.updateComponent(amfMgmtHandle, entityName, listAttributesAndValuesPairs)
        elif entityType == "ServiceGroup":
          ret = access.updateServiceGroup(amfMgmtHandle, listAttributesAndValuesPairs)
        elif entityType == "Node":
          ret = access.updateNode(amfMgmtHandle, listAttributesAndValuesPairs)
        elif entityType == "ServiceUnit":
          ret = access.updateServiceUnit(amfMgmtHandle, listAttributesAndValuesPairs)
        elif entityType == "ServiceInstance":
          ret = access.updateServiceInstance(amfMgmtHandle, listAttributesAndValuesPairs)
        elif entityType == "ComponentServiceInstance":
          ret = access.updateComponentServiceInstance(amfMgmtHandle, entityName, listAttributesAndValuesPairs)
        else:
          print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit and ServiceInstance")
          ret = 1
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("entitySet completed successfully with code [%s]"% hex(ret))
        else:
          print('entitySet failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))

      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "entitySet failed"

  def do_entityCreate(self, entityType, entityName, *args):
    """syntax:
    - entityCreate Component entityName suName binary
    - entityCreate ServiceGroup entityName suName siName
    - entityCreate Node entityName suName
    - entityCreate ServiceUnit entityName compName sgName nodeName
    - entityCreate ServiceInstance entityName sgName csiName
    - entityCreate ComponentServiceInstance entityName siName key/value
    Creates a new entityName with the specified entityType
    """
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        if entityType == "Component":
          if len(args) == 2:
            ret = access.addNewComponent(amfMgmtHandle, entityName, args[0], args[1])
          else:
            ret = "CompErr"
        elif entityType == "ServiceGroup":
          if len(args) == 2:
            ret = access.addNewServiceGroup(amfMgmtHandle, entityName, args[0], args[1])
          else:
            ret = "SGErr"
        elif entityType == "Node":
          if len(args) == 1:
            ret = access.addNewNode(amfMgmtHandle, entityName, args[0])
          else:
            ret = "NodeErr"
        elif entityType == "ServiceUnit":
          if len(args) == 3:
            ret = access.addNewServiceUnit(amfMgmtHandle, entityName, args[0], args[1], args[2])
          else:
            ret = "SUErr"
        elif entityType == "ServiceInstance":
          if len(args) == 2:
            ret = access.addNewServiceInstance(amfMgmtHandle, entityName, args[0], args[1])
          else:
            ret = "SIErr"
        elif entityType == "ComponentServiceInstance":
          if len(args) >= 1:
            siName = args[0]
            listArg = list(args[1:])
            ret = access.addNewComponentServiceInstance(amfMgmtHandle, entityName, siName, listArg)
          else:
            ret = "CSIErr"
        else:
          print("Invalid entity type, valid entity types are Component, ServiceGroup, Node, ServiceUnit, ServiceInstance and ComponentServiceInstance")
          ret = "TypeErr"
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("entityCreate completed successfully with code [%s]"% hex(ret))
        elif ret == "CompErr" or ret == "SGErr" or ret == "NodeErr" or ret == "SUErr" or ret == "SIErr" or ret == "CSIErr" or ret == "TypeErr":
          print('Syntax error')
          ret = 1
        else:
          print('entityCreate failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))
      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "entityCreate failed"

  def do_entityDelete(self, entityType, entityName):
    """syntax: entityDelete entityType entityName
    Deletes the entityNames
    """
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        if entityType == "Component":
          ret = access.amfMgmtComponentDelete(amfMgmtHandle, entityName)
        elif entityType == "ServiceGroup":
          ret = access.amfMgmtServiceGroupDelete(amfMgmtHandle, entityName)
        elif entityType == "Node":
          ret = access.amfMgmtNodeDelete(amfMgmtHandle, entityName)
        elif entityType == "ServiceUnit":
          ret = access.amfMgmtServiceUnitDelete(amfMgmtHandle, entityName)
        elif entityType == "ServiceInstance":
          ret = access.amfMgmtServiceInstanceDelete(amfMgmtHandle, entityName)
        elif entityType == "ComponentServiceInstance":
          ret = access.amfMgmtComponentServiceInstanceDelete(amfMgmtHandle, entityName)
        elif entityType == "CSINVP":
          ret = access.amfMgmtCSINVPDelete(amfMgmtHandle, entityName)
        else:
          print("Invalid entity type, valid entity types are Component, ServiceGroup, Node, ServiceUnit, ServiceInstance and ComponentServiceInstance")
          ret = "TypeErr"
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("entityDelete completed successfully with code [%s]"% hex(ret))
        elif ret == "TypeErr":
          print('Syntax error')
          ret = 1
        else:
          print('entityDelete failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))
      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "entityDelete failed"

  def do_entityShutdown(self, entityType, entityName):
    """syntax: entityShutdown entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeLockAssignment(handleTest, entityName)
      elif entityType == "ServiceGroup":
        ret = access.amfMgmtSGLockAssignment(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSULockAssignment(handleTest, entityName)
      elif entityType == "ServiceInstance":
        ret = access.amfMgmtSILockAssignment(handleTest, entityName)

      if ret == 0x0:
        print("entityShutdown completed successfully")
      elif ret != "invalidType":
        print('entityShutdown failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit and ServiceInstance")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def getValueFromAttributeName(self, entityType, entityName, attributeName):
    t = os.path.normpath(os.path.join(self.curdir,"/safplusAmf/",entityType, entityName, attributeName))
    depth=1
    gs = "{d=%s}%s" % (depth,str(t))
    try:
      xml = access.mgtGet(self.handle, gs)
      xml = "<top>" + xml + "</top>"
    except RuntimeError as e:
      if str(e) == "Route has no implementer":
        return "<error>Invalid path [%s]</error>" % str(t)
      return "<error>" + str(e) + "</error>"
    except Exception as e:
      return "<error>" + str(e) + "</error>"
    try:
      root = ET.fromstring(xml)
      state = ""
      for child in root.findall(attributeName):
        state =  child.text
      return state
    except IndexError as e:
      print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
      return
    except ET.ParseError as e:
      print ("<error>xml [%s] error [%s]</error>" % (xml, str(e)))
      return
    return

  def do_compList(self):
    """syntax: compList
    """
    entityTypes = ["Component"]
    attributeList = "id", "processId", "presenceState", "restartCount"
    for entityType in entityTypes:
      listEntityName = self.parseXML(entityType)
      if len(listEntityName) != 0:
        valueList = [["", "", "", "", ""]]
        headers = ["CompName", "ID", "PID", "Presence state", "Restart count"]
        for entityName in listEntityName:
          d = [entityName]
          for attribute in attributeList:
            if attribute == "restartCount":
              d.append(self.getValueFromAttributeName(entityType,entityName + "/" + attribute, "current"))
            else:
              d.append(self.getValueFromAttributeName(entityType,entityName, attribute))
          valueList.append(d)
        print (tabulate(valueList, headers, tablefmt="psql"))
    return ""

  def do_clusterList(self):
    """syntax: clusterList
    """
    entityTypes = ["Node"]
    attributeList = ["presenceState"]
    for entityType in entityTypes:
      listEntityName = self.parseXML(entityType)
      if len(listEntityName) != 0:
        valueList = [["", ""]]
        headers = ["NodeName", "Presence state"]
        for entityName in listEntityName:
          d = [entityName]
          for attribute in attributeList:
            d.append(self.getValueFromAttributeName(entityType,entityName, attribute))
          valueList.append(d)
        print (tabulate(valueList, headers, tablefmt="psql"))
    return ""

  def do_compPIDGet(self, componentName):
    """syntax: compPIDGet
    """
    print ("compPId is %s" %self.getValueFromAttributeName("Component", componentName, "processId"))
    return ""

  def do_nodeName(self):
    """syntax: nodeName
    """
    nodeList = self.parseXML("Node")
    for node in nodeList:
      print("nodeName is %s" %node)
    return ""

  def do_entityRestart(self, entityType, entityName):
    """syntax: entityRestart entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Node":
        ret = access.amfMgmtNodeRestart(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSURestart(handleTest, entityName)
      elif entityType == "Component":
        ret = access.amfMgmtCompRestart(handleTest, entityName)

      if ret == 0x0:
        print("entityRestart completed successfully")
      elif ret != "invalidType":
        print('entityRestart failed with error code [%s]'% hex(ret))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceUnit and Component")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_sgAdjust(self, sgName, enabled):
    """syntax: sgAdjust sgName on/off

    """
    ret = 0
    if enabled != "on" and enabled != "off":
      print ('enabled argument must be "on" or "off"')
      return ""
    b = False
    if enabled == 'on': b = True
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtSGAdjust(handleTest, sgName, b)

      if ret == 0x0:
        print("sgAdjust completed successfully")
      else:
        print('sgAdjust failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_entitySISwap(self, siName):
    """syntax: entitySISwap siName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtSISwap(handleTest, siName)

      if ret == 0x0:
        print("entitySISwap completed successfully")
      else:
        print('entitySISwap failed with error code [%s]'% hex(ret))

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_compReport(self, compName, recommendedRecovery):
    """syntax: compReport compName recommendedRecovery
               recommendedRecovery is one of values no_recommendation, comp_restart, comp_failover, node_switchover, node_failover or node_failfast
    """
    ret = 0
    recRecovery = Recovery_NoRecommendation
    if recommendedRecovery == 'no_recommendation':
      recRecovery = Recovery_NoRecommendation
    elif recommendedRecovery == 'comp_restart':
      recRecovery = Recovery_Restart
    elif recommendedRecovery == 'comp_failover':
      recRecovery = Recovery_Failover
    elif recommendedRecovery == 'node_switchover':
      recRecovery = Recovery_NodeSwitchover
    elif recommendedRecovery == 'node_failover':
      recRecovery = Recovery_Failover
    elif recommendedRecovery == 'node_failfast':
      recRecovery = Recovery_NodeFailfast
    else:
      print('recommendedRecovery argument must be no_recommendation, comp_restart, comp_failover, node_switchover, node_failover or node_failfast')
      return ret
      
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtCompErrorReport(handleTest, compName, recRecovery)

      if ret == 0x0:
        print("compReport completed successfully")
      else:
        print('compReport failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_nodeErrorReport(self, nodeName):
    """syntax: nodeErrorReport nodeName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtNodeErrorReport(handleTest, nodeName)

      if ret == 0x0:
        print("nodeErrorReport completed successfully")
      else:
        print('nodeErrorReport failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_nodeErrorClear(self, nodeName):
    """syntax: nodeErrorClear nodeName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtNodeErrorClear(handleTest, nodeName)

      if ret == 0x0:
        print("nodeErrorClear completed successfully")
      else:
        print('nodeErrorClear failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_nodeJoin(self, nodeName):
    """syntax: nodeJoin nodeName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtNodeJoin(handleTest, nodeName)

      if ret == 0x0:
        print("nodeJoin completed successfully")
      else:
        print('nodeJoin failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_nodeShutdown(self, nodeName):
    """syntax: nodeShutdown nodeName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtNodeShutdown(handleTest, nodeName)

      if ret == 0x0:
        print("nodeShutdown completed successfully")
      else:
        print('nodeShutdown failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_nodeRestart(self, nodeName, graceful):
    """syntax: nodeRestart nodeName graceful
               graceful: 1: indicates the graceful restart
                         0: indicates the ungraceful restart
    """
    ret = 0
    if graceful != '0' and graceful != '1':
      print('graceful argument must be 0 or 1')
      return ret
    grf = True if graceful=='1' else False
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfNodeRestart(handleTest, nodeName, grf)

      if ret == 0x0:
        print("nodeRestart completed successfully")
      else:
        print('nodeRestart failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_middlewareRestart(self, nodeName, graceful, nodeReset):
    """syntax: nodeRestart nodeName graceful, nodeReset
               nodeName: name of node to take the action
               graceful: 1: indicates the graceful restart
                         0: indicates the ungraceful restart
               nodeReset: 1: indicates the node is reset
                          0: indicates the middleware is restarted only
    """
    ret = 0
    if graceful != '0' and graceful != '1':
      print('graceful argument must be 0 or 1')
      return ret
    if nodeReset != '0' and nodeReset != '1':
      print('nodeReset argument must be 0 or 1')
      return ret
    grf = True if graceful=='1' else False
    nrst = True if nodeReset=='1' else False
    try:     
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMiddlewareRestart(handleTest, nodeName, grf, nrst)
      #ret = access.amfMiddlewareRestart(handleTest, nodeName, graceful, nodeReset)

      if ret == 0x0:
        print("middlewareRestart completed successfully")
      else:
        print('middlewareRestart failed with error code [%s]'% hex(ret))
      
      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_assignSUtoSI(self, siName, activeSUName, standbySUName):
    """syntax: assignSUtoSI siName activeSUName standbySUName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if activeSUName == "NULL" or standbySUName == "NULL":
        appendString = "objectIsNULL_"
        listEntityName = self.parseXML("ServiceUnit")
        if len(listEntityName) != 0:
          for entityName in listEntityName:
            t = os.path.normpath(os.path.join(self.curdir,"/safplusAmf/ServiceUnit/", entityName, "haState"))
            depth=1
            gs = "{d=%s}%s" % (depth,str(t))
            try:
              xml = access.mgtGet(self.handle, gs)
              root = ET.fromstring(xml)
              # print root.tag, root.text
              if activeSUName == "NULL" and root.text == "standby":
                activeSUName = appendString + entityName
                if activeSUName != "NULL" and standbySUName != "NULL":
                  break

              if standbySUName == "NULL" and root.text == "active":
                standbySUName = appendString + entityName
                if standbySUName != "NULL" and activeSUName != "NULL":
                  break
            except RuntimeError as e:
              print("error: ", e)

      ret = access.amfMgmtAssignSUtoSI(handleTest, siName, activeSUName, standbySUName)

      if ret == 0x0:
        print("assignSUtoSI completed successfully")
      else:
        print('assignSUtoSI failed with error code [%s]'% hex(ret))

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_forceLockInstantiation(self, entityName):
    """syntax: forceLockInstantiation entitySUName
    """
    ret = 0
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      ret = access.amfMgmtForceLockInstantiation(handleTest, entityName)

      if ret == 0x0:
        print("forceLockInstantiation completed successfully")
      else:
        print('forceLockInstantiation failed with error code [%s]'% hex(ret))

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print ("error: ", e)

    return ret

  def do_compAddressGet(self, entityName):
    """syntax: compAddressGet entitySUName
    """
    try:
      handle = access.amfMgmtCompAddressGet(entityName)
      print ("node: ", handle.getNode())
      print ("port: ", handle.getPort())
      
      # print "amfMgmtFinalize: ", hex(ret)
    except RuntimeError as e:
      print ("Failed get component Address: ", e)

    return ""

  def get_amf_master_handle(self):
    info = access.grpCliClusterViewGet()
    rows = info.split('\n')
    for row in rows:
        if len(row) == 0:
            continue
        cells = row.split()
        if cells[1] == 'controller' and cells[2] == 'active':
            masterNodeId = int(cells[3])
            self.handle = access.getProcessHandle(1, masterNodeId)
            self.didConnect = 1
            return masterNodeId

  def do_entityGetConfig(self, entityType, entityName):
    """syntax: entityGetConfig entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "Component":
        ret = access.amfMgmtComponentGetConfig(handleTest, entityName)
      elif entityType == "Node":
        ret = access.amfMgmtNodeGetConfig(handleTest, entityName)
      elif entityType == "ServiceGroup":
        ret = access.amfMgmtSGGetConfig(handleTest, entityName)
      elif entityType == "ServiceUnit":
        ret = access.amfMgmtSUGetConfig(handleTest, entityName)
      elif entityType == "ServiceInstance":
        ret = access.amfMgmtSIGetConfig(handleTest, entityName)
      elif entityType == "ComponentServiceInstance":
        ret = access.amfMgmtCSIGetConfig(handleTest, entityName)

      if "error" not in ret and ret != "invalidType":
        print("entityGetConfig completed successfully")
        print("dictionary: ", ret)
      elif ret != "invalidType":
        print('entityGetConfig failed with error code [%s]'% hex(ret["error"]))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit, ServiceInstance, ComponentServiceInstance")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print("error: ", e)

    return ret

  def do_CSIGetStatus(self, entityType, entityName):
    """syntax: CSIGetStatus entityType entityName
    """
    ret = "invalidType"
    try:
      handleTest = access.getProcessHandle(0, 0)
      access.amfMgmtInitialize(handleTest)

      if entityType == "ComponentServiceInstance":
        ret = access.amfMgmtCSIGetStatus(handleTest, entityName)

      if "error" not in ret and ret != "invalidType":
        print("CSIGetStatus completed successfully")
        print("dictionary: ", ret)
      elif ret != "invalidType":
        print('CSIGetStatus failed with error code [%s]'% hex(ret["error"]))
      else:
        ret = 0
        print("Invalid entity type, valid entity types are ComponentServiceInstance")

      access.amfMgmtFinalize(handleTest)
    except RuntimeError as e:
      print("error: ", e)

    return ret

  def do_startApp(self, entityType, entityName):
    """syntax: startApp entityType entityName
    """
    if entityType not in ["Node", "ServiceGroup", "ServiceUnit", "ServiceInstance"]:
      print("Invalid entity type, valid entity types are Node, ServiceGroup, ServiceUnit and ServiceInstance")
      ret = 2 #CL_ERR_INVALID_PARAMETER = hex(0x02)
      print('startApp failed with error code [%s]'% hex(ret))
      return ret
    ret = self.do_entityUnlock(entityType, entityName)
    if ret == 0x00:
      print("startApp completed successfully")
      return ret
    elif ret == 0x12: #CL_ERR_INVALID_STATE = hex(0x12)
      ret = self.do_entityLockAssignment(entityType, entityName)
      if ret == 0x00:
          time.sleep(3)
          ret = self.do_entityUnlock(entityType, entityName)
          if ret == 0x00:
              print("startApp completed successfully")
              return ret
    print('startApp failed with error code [%s]'% hex(ret))

    return ret

  def do_stopApp(self, entityType, entityName):
    """syntax: stopApp entityType entityName
    """
    if entityType not in ["Node", "ServiceGroup", "ServiceUnit"]:
      print("Invalid entity type, valid entity types are Node, ServiceGroup and ServiceUnit")
      ret = 2 #CL_ERR_INVALID_PARAMETER = hex(0x02)
      print('stopApp failed with error code [%s]'% hex(ret))
      return ret
    ret = self.do_entityLockInstantiation(entityType, entityName)
    if ret == 0x00:
      print("stopApp completed successfully")
      return ret
    elif ret == 0x12: #CL_ERR_INVALID_STATE = hex(0x12)
      ret = self.do_entityLockAssignment(entityType, entityName)
      if ret == 0x00:
          time.sleep(3)
          ret = self.do_entityLockInstantiation(entityType, entityName)
          if ret == 0x00:
              print("stopApp completed successfully")
              return ret
    print('stopApp failed with error code [%s]'% hex(ret))

    return ret

  def do_addSUIntoNode(self, nodeName, suName):
    """syntax: addSUIntoNode nodeName suName
    """
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        ret = access.addSUIntoNode(amfMgmtHandle, nodeName, suName)
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("addSUIntoNode completed successfully code [%s]"% hex(ret))
        else:
          print('addSUIntoNode failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))

      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "addSUIntoNode failed"

  def do_addSUIntoSG(self, sgName, suName):
    """syntax: addSUIntoSG sgName suName
    """
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        ret = access.addSUIntoSG(amfMgmtHandle, sgName, suName)
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("addSUIntoSG completed successfully code [%s]"% hex(ret))
        else:
          print('addSUIntoSG failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))

      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "addSUIntoSG failed"

  def do_addCompIntoSU(self, suName, compName):
    """syntax: addCompIntoSU suName suName
    """
    global amfMgmtHandle
    try:
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
        ret = access.addCompIntoSU(amfMgmtHandle, suName, compName)
        if ret == 0x0:
          ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("addCompIntoSU completed successfully code [%s]"% hex(ret))
        else:
          print('addCompIntoSU failed with error code [%s]'% hex(ret))

        ret = access.amfMgmtFinalize(amfMgmtHandle)
        if ret !=0:
          print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtInitialize failed with error code [%s]'% hex(ret))

      return ret
    except RuntimeError as e:
      print ("error: ", e)
    return "addCompIntoSU failed"

class CaptureOutput:
  def __init__(self,resolver):
    try: 
      self.aliases = resolver.aliases
    except:
      self.aliases = {}
    self.resolver=resolver
    self.doc = []

  def run(self,s):
    self.resolver.execute(s,self)
    return "".join(self.doc)

class Dotter:
    pass

class CliError(Exception):
  pass

def csv2List(csvString):
  """Convert comma separated values to a Python list"""
  if not csvString.strip(): return []  # turn "" into [], otherwise it is ['']
  return [x.strip() for x in csvString.split(",")]

def Modifiers2Sg(params=Dot({}), entities={}):
  if params is not None:
    for attr in params.keys():
      if attr == "autoRepair":
        entities["autoRepair"] = params.get("autoRepair",None)
      elif attr == "autoAdjust":
        entities["autoAdjust"] = params.get("autoAdjust",None)
      elif attr == "autoAdjustInterval":
        entities["autoAdjustInterval"] = params.get("autoAdjustInterval",None)
      elif attr == "maxActiveWorkAssignments":
        entities["maxActiveWorkAssignments"] = params.get("maxActiveWorkAssignments",None)
      elif attr == "maxStandbyWorkAssignments":
        entities["maxStandbyWorkAssignments"] = params.get("maxStandbyWorkAssignments",None)
  return entities

def RedundancyModel2Si(params=None, entities={}):
  if params is not None:
    for attr in params.keys():
      if attr == "preferredActiveAssignments":
        entities["preferredActiveAssignments"] = params.get("preferredActiveAssignments",None)
      elif attr == "preferredStandbyAssignments":
        entities["preferredStandbyAssignments"] = params.get("preferredStandbyAssignments",None)
      elif attr == "rank":
        entities["rank"] = params.get("rank",None)
  return entities

def AmfCreateApp(suffix, compList, nodes, appDir=None, cfg=None, amfMasterHdl=None):
  sg = "ServiceGroup_%s" % suffix
  if appDir == None or appDir == "None":
    appDir = "./"
  else:
    appDir = appDir.replace("'", "")
  compList = compList.replace("'", "")
  compList = compList.split(" ")
  ret = 0
  paramsSG = Dot({})
  paramsSI = Dot({})
  entities = {}

  if cfg is not None:
    cfg= cfg.replace("'", "")
    # Convert cfg from str to a dict
    cfg = ast.literal_eval(cfg)
    if isinstance(cfg, dict):
      # Convert cfg to a Dot class to allow use of . to specify fields
      cfg = Dot(cfg)
      paramsSG = cfg.get("modifiers",None)
      paramsSI = cfg.get("redundancyModel",None)
    else:
      ret = 0x02
      print('cfg is invalid, AmfCreateApp failed with error code [%s]'% hex(ret))
      return ret

  entities["ServiceGroup/%s" % sg] = { "adminState":"off", "serviceInstances" :  "ServiceInstance_%s" % suffix}

  entities["ServiceInstance/ServiceInstance_%s" % suffix] = { "serviceGroup": sg, "componentServiceInstances" :"ComponentServiceInstance_%s" % suffix }

  entities["ComponentServiceInstance/ComponentServiceInstance_%s" % suffix] ={ "serviceInstance": "ServiceInstance_%s" % suffix, "name/testKey" : "testVal", "type" : "ComponentServiceInstance_%s" % suffix }

  entities["ServiceGroup/%s" % sg] = Modifiers2Sg(paramsSG, entities["ServiceGroup/%s" % sg])
  entities["ServiceInstance/ServiceInstance_%s" % suffix] = RedundancyModel2Si(paramsSI, entities["ServiceInstance/ServiceInstance_%s" % suffix])

  count = 0
  sus = []
  for n in nodes:
    suname = "ServiceUnit_%s_%d" % (suffix,count)
    comps = []
    for c in compList:
      name = os.path.basename(c.split(" ")[0])
      cname = "%s_in_%s" % (name,suname)
      idx=1
      while cname in comps:
        cname = "%s_in_%s_%d" % (name,suname,idx)
        idx+=1

      entities["Component/%s" % cname] = { "maxActiveAssignments":1, "maxStandbyAssignments":1, "serviceUnit": suname, "csiType": "ComponentServiceInstance_%s" % suffix, "instantiate": { "command" : appDir + c, "timeout":15*1000 }}
      comps.append(cname)

    entities["ServiceUnit/%s" % suname] = { "components":",".join(comps),"node":n, "serviceGroup": sg }
    sus.append(suname)
    count += 1

  entities["ServiceGroup/%s" % sg]["serviceUnits"] = ",".join(sus)
  amfctrl.commit(entities, amfMasterHdl=amfMasterHdl)

  # ADD serviceUnit into Node
  time.sleep(3)
  global amfMgmtHandle
  count = 0
  for n in nodes:
    suname = "ServiceUnit_%s_%d" % (suffix,count)
    listAttributesAndValuesPairs = []
    listAttributesAndValuesPairs.append("name")
    listAttributesAndValuesPairs.append(n)
    listAttributesAndValuesPairs.append("serviceUnits")
    listAttributesAndValuesPairs.append(suname)
    try:
      if len(listAttributesAndValuesPairs) % 2 != 0 or len(listAttributesAndValuesPairs) == 0:
        ret = 0x02
        print('entitySet failed with error code [%s]'% hex(ret))
        return ret
      ret = access.amfMgmtInitialize(amfMgmtHandle)
      if ret == 0x0:
          ret = access.updateNode(amfMgmtHandle, listAttributesAndValuesPairs)
          if ret == 0x0:
            ret = access.amfMgmtCommit(amfMgmtHandle)
            if ret == 0x0:
              print("entitySet completed successfully with code [%s]"% hex(ret))
            else:
              print('amfMgmtCommit failed with error code [%s]'% hex(ret))
          else:
            print('updateNode failed with error code [%s]'% hex(ret))

          ret = access.amfMgmtFinalize(amfMgmtHandle)
          if ret !=0:
            print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
      else:
          print('amfMgmtInitialize failed with error code [%s]'% hex(ret))
    except RuntimeError as e:
      print ("error: ", e)
      return "entitySet failed"
    count += 1
  return 0


def deleteSusInNode(nodeName, suName):
  global amfMgmtHandle
  print("nodeName: ", nodeName)
  print("suName: ", suName)
  try:
    listSus = []
    listSus.append(suName)
    if nodeName == None or suName == None:
      ret = 0x02
      print('deleteSusInNode failed with error code [%s]'% hex(ret))
      return ret
    ret = access.amfMgmtInitialize(amfMgmtHandle)
    if ret == 0x0:
      ret = access.amfMgmtNodeSUListDelete(amfMgmtHandle, nodeName, listSus)
      if ret == 0x0:
        ret = access.amfMgmtCommit(amfMgmtHandle)
        if ret == 0x0:
          print("deleteSusInNode completed successfully with code [%s]"% hex(ret))
        else:
          print('amfMgmtCommit failed with error code [%s]'% hex(ret))
      else:
        print('amfMgmtNodeSUListDelete failed with error code [%s]'% hex(ret))

      ret = access.amfMgmtFinalize(amfMgmtHandle)
      if ret !=0:
        print('amfMgmtFinalize failed with error code [%s]'% hex(ret))
    else:
      print('amfMgmtInitialize failed with error code [%s]'% hex(ret))

    return ret
  except RuntimeError as e:
    print ("error: ", e)
    return "deleteSusInNode failed"

class RunScript:
  def __init__(self,resolver):
    self.resolver = resolver
    self.context = None
    self.commands = {"show" : (self.show, None),
                    "createApp" : (self.createApp, None),
                    "deleteApp" : (self.deleteApp, None)
    }
    self.raiseException = Dotter()
    self.env = {}
    self.cli = Dotter()
    self.cli.run = lambda s,resolver=resolver: CaptureOutput(resolver).run(s)
    self.cli.get = lambda s,deflt = self.raiseException, me=self: me.cliGet(s,deflt)
    self.cli.getInt = lambda s,deflt = self.raiseException,me=self: int(me.cliGet(s,deflt))
    self.cli.getFloat = lambda s,deflt = self.raiseException,me=self: float(me.cliGet(s,deflt))
    self.cli.getList = lambda s,deflt = self.raiseException,me=self: csv2List(me.cliGet(s,deflt))
    self.cli.add = lambda cmd, me=self: self.context.addCmds(cmd)
    self.cli.set = lambda s, val, me=self: me.cliSet(s,val)
    self.cli.Error = CliError
    self.env["cli"] = self.cli
    #self.env["cli"] = lambda s,resolver=resolver: CaptureOutput(resolver).run(s)
    #self.env["cliGet"] = lambda s,me=self: me.cliGet(s)
    #self.env["addCliCommands"] = lambda cmd, me=self: self.context.addCmds(cmd)

  def cliSet(self,s, val):
    t = CaptureOutput(self.resolver).run("ls %s" % s)
    try:
      t1 = ET.fromstring(t)[0]
    except IndexError:
      pdb.set_trace()
    return True

  def cliGet(self,s, default):
    t = CaptureOutput(self.resolver).run("ls %s" % s)
    try:
      t1 = ET.fromstring(t)[0]
    except IndexError:
      if default is self.raiseException:
        raise CliError("Invalid element")
      else:
        return default
    return t1.text

  def setContext(self,context):
    """Sets the context (environment) object so commands can access it while they are executing"""
    self.context = context
    #self.env["display"] = lambda s,context=self.context: context.xmlterm.doc.append(s)
    self.cli.display = lambda s,context=self.context: context.xmlterm.doc.append(s)
  
  def do_run(self, filename, *args):
    """Run a script.  This can be either a python script (.py extension) or a shell script"""
    try:
      f = open(filename,"r")
    except IOError as e:
      self.context.xmlterm.doc.append("<error>" + str(e) + "</error>")
      return ""

    ext = os.path.splitext(filename)
    self.env["argv"] = args
    if ext[1] == ".py":
      try:
        exec (f in self.env)
      except Exception as e:
        if DropToDebugger:
          type, value, tb = sys.exc_info()
          traceback.print_exc()
          last_frame = lambda tb=tb: last_frame(tb.tb_next) if tb.tb_next else tb
          frame = last_frame().tb_frame
          pdb.post_mortem()
              # TODO: print the command's help and try to hint at the problem
        self.context.xmlterm.doc.append("<error>" + str(e) + "</error>")
        return ""
    return ""

  def deleteApp(self, appName):
    """syntax: deleteApp appName
    """
    sg = None
    sus = []
    comps = []
    sgName = None
    suNames = []
    compNames = []
    siNames = []
    csiNames = []
    try:
      sgName = "/safplusAmf/ServiceGroup/%s" % (appName)
      sg = ET.fromstring(self.cli.run("ls " + sgName))
      if len(sg) == 0:
        ret = 2 #CL_ERR_INVALID_PARAMETER = hex(0x02)
        print('deleteApp failed with error code [%s]'% hex(ret))
        return ret
      else: sg=sg[0]
    except self.cli.Error as e:
      pass
    if sg:
      if str(sg.find("adminState").text) != "off":
        ret = 18 #CL_ERR_INVALID_STATE = hex(0x12)
        print('deleteApp failed with error code [%s]'% hex(ret))
        return ret
      siNameText = sg.find("serviceInstances").text
      siNames = [ str(x) for x in siNameText.split(",")]
      suNameText = sg.find("serviceUnits").text
      suNames = [ str(x) for x in suNameText.split(",")]
      for suName in suNames:
        if suName[0] != "?":
          su = ET.fromstring(self.cli.run("ls %s" % suName))
          if len(su) != 0:
            su=su[0]
            sus.append(su)
            compN = su.find("components").text
            compN = compN.split(",")
            for compName in compN:
              if compName[0] != "?":
                comp = ET.fromstring(self.cli.run("ls %s" % compName))
                if len(comp) != 0:  # if it is valid then add it to the delete list
                  compNames.append(str(compName))
            node = su.find("node").text
            node = node.split("/")[-1]
            suName = suName.split("/")[-1]
            ret = deleteSusInNode(node, suName)
            if ret != 0:
              print('deleteApp failed')
              return ret
      if siNames:
       for siName in siNames:
        if siName[0] != "?":
          si = ET.fromstring(self.cli.run("ls %s" % siName))
          if len(si) != 0:
            si=si[0] # remove the "top"
            csiNameStr = si.find("componentServiceInstances").text
            tmp = [ str(x) for x in csiNameStr.split(",")]
            csiNames += tmp

    if sgName:
      self.cli.run("delete " + str(sgName))
      allNames = [sgName]
      if suNames:
        for su in suNames: self.cli.run("delete " + str(su))
        allNames += suNames
      if compNames:
        for compName in compNames: self.cli.run("delete " + str(compName))
        allNames += compNames
      if siNames:
        for si in siNames: self.cli.run("delete " + str(si))
        allNames += siNames
      if csiNames:
        for csi in csiNames: self.cli.run("delete " + str(csi))
        allNames += csiNames

      print(("Deleted %s" % ", ".join(allNames)))
      return ""
    print("No such application")
    return ""

  def createApp(self, appName=None, appCommandLine=None, nodes=None, appDir=None, cfg=None):
    """syntax: createApp appName 'appCommandLine' 'nodes' 'appDir' 'cfg'
    Create an application running on the specified nodes
    Argument 1: application name prefix -- an arbitrary name given to all management elements created for this application
    Argument 2: list of binary applications. If spaces are needed, must enclose in single quotation mark
    Argument 3: list of node names on which the application should be run. If spaces are needed, must enclose in single quotation mark
    Argument 4: path of Component must enclose in single quotation mark or None with default
    Argument 5: list of attributes on which the application should be set. Must enclose in single quotation mark
    """
    if appName == None or appCommandLine == None or nodes == None:
      ret = 0x02
      print('createApp failed with error code [%s]'% hex(ret))
      return ret

    # test if there is a amf failover in progress
    xml = access.mgtGet(self.resolver.handle, '/safplusAmf/Node')
    if len(xml) == 0:
        time.sleep(3.5)
        self.resolver.get_amf_master_handle()

    errors = []
    nodes = nodes.replace("'", "")
    nodes = nodes.split(" ")
    for n in nodes:
      nodeData = ET.fromstring(self.cli.run("ls /safplusAmf/Node/%s" % n))
      if len(nodeData) == 0:
        errors.append("Node %s does not exist." % n)
    if errors:
      print(("\n".join(errors)))
      return ""

    ret = AmfCreateApp(appName, appCommandLine, nodes, appDir, cfg, self.resolver.handle)
    if ret == 0:
      print("createApp completed successfully")
      return ret

    print('createApp failed with error code [%s]'% hex(ret))
    return ret

  # All commands are defined as do_<command>.  So this function defines the "basicStatus" command.
  def show(self,element):
    """Display the status of the Basic application
    """
    # This demonstrates an API called "get" to access a single element.  This API is a wrapper around
    # run("ls ...") which subsequently parses the XML and grabs the text of the first element in the response.
    # It will throw an exception of the element cannot be accessed
    sg = None
    sus = []
    comps = []
    try:
      sg = ET.fromstring(self.cli.run("ls /safplusAmf/ServiceGroup/ServiceGroup%s" % element))
      if len(sg) == 0:
        sg = ET.fromstring(self.cli.run("ls /safplusAmf/ServiceGroup/ServiceGroup_%s" % element))
      if len(sg) == 0:
        return None
      else: sg=sg[0]
    except self.cli.Error as e:
      pass

    if sg:
      suNames = sg.find("serviceUnits").text
      suNames = suNames.split(",")
      print(suNames)
      for suName in suNames:
        if suName[0] != "?":
          su = ET.fromstring(self.cli.run("ls %s" % suName))
          if len(su) != 0:
            su=su[0]
            sus.append(su)
            compNames = su.find("components").text
            compNames = compNames.split(",")
            for compName in compNames:
              if compName[0] != "?":
                comp = ET.fromstring(self.cli.run("ls %s" % compName))
                if len(comp) != 0:
                  comps.append(comp)
              else:
                comps.append("<error>Unresolved component: %s</error>" % compName[1:])
        else:
          sus.append("<error>Unresolved service unit: %s</error>" % suName[1:])
    else:
      self.cli.display("""<text size="24" fore="#108010">Invalid entity name "%s"</text>""" % element)
      return None

    self.cli.display(ET.tostring(sg))
    for su in sus:
      if type(su) in (str,):
        self.cli.display(su)
      else:
        self.cli.display(ET.tostring(su))
    for comp in comps:
      if type(comp) in (str,):
        self.cli.display(comp)
      else:
        self.cli.display(ET.tostring(comp))

    self.cli.display("""<text size="24" fore="#108010"></text>""")
    return "" # If you return None, the self.cli will look for another matching function
        
def amfMgmtHandleInitialize():
  global access
  global amfMgmtHandle

  currentPID = os.getpid()
  amfMgmtHandle = access.Handle.create(currentPID)

def main(argLst):
  global access, CliName
  global xmlterm, windowed
  global amfMgmtHandle

  cmds,handlers = access.Initialize()

  config = configparser.SafeConfigParser()
  config.read(".safplus_cli.cfg")  

  RED='\033[0;31m'
  NOCOLOR='\033[m'   # reset
  # print (RED + "Connect to active node before do anything please!" + NOCOLOR)
  windowed = False

  if windowed:
    os.environ["TERM"] = "XT1" # Set the term in the environment so child programs know xmlterm is running
    resolver = TermController()
    resolver.addCmds(cmds)
    resolver.addCmds(RunScript(resolver))
    resolver.tags["ServiceUnit"] = serviceUnitListHandler
    resolver.tags["top"] = topHandler
    resolver.tags["more"] = childrenOnlyHandler  # don't show this indicator that the node has children
    resolver.tags["bootTime"] = epochTimeHandler
    resolver.tags["lastInstantiation"] = epochMsTimeHandler
    resolver.tags["upTime"] = elapsedSecondsHandler
    resolver.tags["pendingOperationExpiration"] = epochMsTimeHandler

    resolver.tags["history10sec"] = historyHandler
    resolver.tags["history1min"] = historyHandler
    resolver.tags["history10min"] = historyHandler
    resolver.tags["history1hour"] = historyHandler
    resolver.tags["history1day"] = historyHandler
    resolver.tags["history1week"] = historyHandler
    resolver.tags["history4weeks"] = historyHandler

    resolver.tags.update(handlers)

    resolver.depth = 0
    resolver.defaultHandler = defaultHandler

    doc = []
    app = xmlterm.App(lambda parent,doc=doc,resolver=resolver: xmlterm.XmlTerm(parent,doc,resolver,config),redirect=False,size=(600,900))
    app.MainLoop()
  else:
    resolver = TermController()
    resolver.xmlterm = resolver # just dumping everything in one class
    resolver.defaultHandler = defaultTextHandler
    resolver.tags["bootTime"] = epochTimeHandler
    resolver.tags["lastInstantiation"] = epochMsTimeHandler
    resolver.tags["upTime"] = elapsedSecondsHandler
    resolver.tags["pendingOperationExpiration"] = epochMsTimeHandler
    resolver.tags["top"] = topHandler
    resolver.tags["more"] = childrenOnlyHandler  # don't show this indicator that the node has children
    resolver.tags["text"] = dumpNoTagHandler 
    resolver.tags["helpCmd"] = nowinhelpCmdHandler
    resolver.addCmds(cmds)
    resolver.addCmds(RunScript(resolver))

    # automatically connect
    masterNodeId = resolver.get_amf_master_handle()

    amfMgmtHandleInitialize()

    while 1:      
      cmd = resolver.cmdLine.input()

      if resolver.didConnect == 0:
        if cmd != "help" and cmd != "exit":
          if not "connect" in cmd:
            print (RED + "connect to active node before do anything please!" + NOCOLOR)
            continue

      output = resolver.execute(cmd,resolver)
  access.Finalize()


if __name__ == '__main__':
    main(sys.argv)


def Test():
  main([])

def TestNW():
  main(["--nw"])
