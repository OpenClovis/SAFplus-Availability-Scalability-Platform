#!/usr/bin/env python3
##############################################################################
#
# Copyright (C) 2020 by OpenClovis Inc. All  Rights Reserved.
# 
# The source code for  this program is not published  or otherwise 
# divested of  its trade secrets, irrespective  of  what  has been 
# deposited with the U.S. Copyright office.
# 
# This program is  free software; you can redistribute it and / or
# modify  it under  the  terms  of  the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the  hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
# 
# You  should  have  received  a  copy of  the  GNU General Public
# License along  with  this program. If  not,  write  to  the 
# Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################
"""
Provides various status information about SAFplus running on this node and on the
cluster

Use the --help option or the help command to obtain more information
on available asp-info commands.

The plan is to provide info on many different things, such as (not all
of these are implemented yet):

Info                                                              Needs running
about:                                                                 SAFplus
---------------------------------------------------------------   -------------
- check if SAFplus is properly installed (approximation)                    N
- check the version (build number) of this installation                 N
- check if SAFplus is running and if so, what PID number                    N/A
- list all SAFplus middleware processes running                             Y
- list all SAFplus-based applications started by SAFplus and their status       Y
- list the tipc/gms parameters of this instance of SAFplus                  N
- list all other hosts in the cluster having same tipc netid            N
- list all other SAFplus nodes that are candidates for this cluster         N
- list all SGs in the cluster and their state                           Y
- list all SU in the cluster and their state (and node to run on)       Y

"""
from functools import cmp_to_key
import sys
import os
import time
import signal
import cmd
import pdb
import re
#import commands
import subprocess
import socket
import fcntl
import struct
import safplus as s
import microdom
import amfctrl

#try:
from lxml import etree as et
#    hasLxml = True
#except ImportError:
#    import xml.dom.minidom as minidom
#    hasLxml = False


access = None
try:
    import localaccess
    access = localaccess    
except ImportError as e:
    print (e)
    pass


def on_platform(p):
  return p in sys.platform

try: # Readline is optional, just gives up command completion and so forth
  if on_platform('linux'): import readline
except:
  pass

##
## Customizable constants
##
xmlRoot = '/safplusAmf'
amfMasterHdl            = 0
GMSCONFIGFILE           = '/etc/clGmsConfig.xml'
HISTORY_FILE            = '.asp-info.hist'
AMF_DB_CACHE_TIMEOUT    = 7.0  # cache aging for amf database [sec]
WELCOME_MSG             = 'SAFplus info utility -- OpenClovis, Inc., 2020'
AMF_NAME                = "safplus_amf"
##
## Internal variables and constants
##
_dblevel = 0 # default debug level
_asp_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
_exit_code = 0
try:
  _app_name = os.path.basename(__file__)
except NameError:  # __file__ is not defined if I'm in the pdb debugger
  _app_name = "safplus_info"
_asp_conf = None                    # caching asp.conf content
_asp_run_env = None                 # caching asp_run.env content
_amf_config_xml = None              # caching clAmfConfig.xml content as dot tree
_do_colors = sys.stderr.isatty()    # output coloring on if not a redirect
_amf_db = None                      # caching amf database
_amf_db_timestamp = None            # time.time of last amf_db cache refresh
_su_names = None                    # cached SU names
_sg_names = None                    # cached SU names
_node_names = None                  # cached Node names
_interactive_shell = False
_yesno_map = {
    'True':     'Y',
    'False':    'N'
}
_member_map = {
    'True':     'Y',
    'False':    'N',
    'Leaving':  'L'
}
_state_map = {
    'idle':    'LA',
    'on':      'UL',
    'off':     'LI'
}
_classtype_map = {
    'Class A':          'A',
    'Class B':          'B',
    'Class C':          'C',
    'Class D':          'D'
}
_redundancy_map = {
    'No Redundancy':    'None',
    '2N (1+1)':         '1+1',
    'M + N':            'M+N',
    'N-Way-Active':     'N-Way-A'
}
_presence_map = {
    'uninstantiated':       'U',
    'instantiating':        'i',
    'instantiated':         'I',
    'terminating':          'T',
    'restarting':           'R',
    'instantiationFailed': 'iF',
    'terminationFailed':   'tF'    
}
_operstate_map = {
    '1':             'E',
    '0':             'D'    
}
_readiness_map = {
    'inService':           'IS',
    'stopping':            'S',
    'outOfService':        'OOS',
    'None':                '-'
}
_hastate_map = {
    'active':               'A',
    'standby':              'S',
    'quiesced':             'Q',
    'quiescing':            'q',
    'none':                 '-',
    'invalid':              '?'
}

NO_SUCH_FILE_OR_DIR     = 127
PROC_GOT_SIGKILL        = 137

USAGE_MSG = """
OpenClovis SAFplus run-time information utility

Usage:
    %(_app_name)s [options] [command(s)]

Options:
    -h, --help          This help page
    -v, --verbose       Be more verbose
    -c, --no-colors     Disables output coloring
""" % locals()


class AspError(Exception): pass
class UnknownError(AspError): pass
class CommandError(AspError): pass
class NotFoundError(AspError): pass
class DebugCliError(AspError): pass    


class Dot:
    """
    The dot class lets you access fields either through field notation (.)
    or dictionary notation ([]).
    """

    def __init__(self, dict):
        for (key, val) in dict.items():
            if type(val) == type({}): val = Dot(val)
            self.__dict__[key] = val

    def __str__(self):
        s=[]
        for (key, val) in self.__dict__.items():
            s.append("'%s':%s" % (str(key), str(val)))
        return "{ " + ", ".join(s) + " }"

    def __repr__(self): return 'Dot(%s)' % self.__str__()

    #def has_key(self, key): return self.__dict__.has_key(key)

    def keys(self): return self.__dict__.keys()

    def values(self): return self.__dict__.values()

    def items(self): return self.__dict__.items()

    def clear(self): self.__dict__.clear()

    def get(self, key, default = None): return self.__dict__.get(key, default)

    def setdefault(self, key, default = None): return self.__dict__.setdefault(key, default)

    def pop(self, key, default = None): return self.__dict__.pop(key, default)

    def popitem(self): return self.__dict__.popitem()

    def iteritems(self): return self.__dict__.iteritems()

    def iterkeys(self): return self.__dict__.iterkeys()

    def itervalues(self): return self.__dict__.itervalues()

    def __getitem__(self, key): return self.__dict__[key]

    def __setitem__(self, key, val): self.__dict__[key] = val

    def __delitem__(self, key): del self.__dict__[key]

    def __len__(self): return self.__dict__.__len__()

    def __contains__(self, item): return item in self.__dict__

    def dot_print(self, prefix=None):
        s = []
        for (key, val) in self.__dict__.items():
            p = (prefix and prefix+'.' or '')+str(key)
            try:
                s.append(val.dot_print(p))
            except AttributeError:
                s.append(p + '=' + str(val)) 
        return '\n'.join(s)

def get_ip_address(ifname):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(fcntl.ioctl(
        s.fileno(),
        0x8915,  # SIOCGIFADDR
        struct.pack('256s', bytes(ifname[:15],'utf-8'))
        )[20:24])

def color(code, string):
    """Return with the colorer string accroding to color code if coloring is
       enabled, or the original string otherwise. Color is one of the colors
       define in the following dictionary (using ANSI codes):
    """
    colors = {
        'normal':       '0',
        'bold':         '1',
        'cyan':         '0;36',
        'bold-cyan':    '1;36',
        'red':          '0;31',
        'bold-red':     '1;31',
        'green':        '0;32',
        'bold-green':   '1;32',
        'yellow':       '0;33',
        'bold-yellow':  '1;33',
        'blue':         '0;34',
        'bold-blue':    '1;34'
    }
    col = colors.get(code)
    if _do_colors and col:
        return '\033[%sm%s\033[0m' % (col, string)
    else:
        return string


def color_state(state):
    if state == 'active': return color('bold-red', state)
    elif state == 'standby': return color('bold-yellow', state)
    else: return state
    

def extend_path():
    """Inserts asp_dir/bin to the beginning of the PATH environment"""
    path = os.getenv('PATH')
    path = _asp_dir + '/bin:' + path
    os.putenv('PATH', path)
    

def dbmsg(level, *args):
    """ Level sensitive debug printing function """
    if _dblevel >= level:
        for s in args:
            print (s),
        print ('')


def error(msg):
    print ('***Error: ' + msg)
    global _exit_code
    _exit_code = 1


def system(cmd): return sys_asp['system'](cmd)

def assert_root():
    """Exits if the program is not run as root"""
    ec, res, s, c = system('whoami')
    if ec or len(res)==0:
        error('Could not run "whoami"')
        sys.exit(1)
    if not res[0].strip() == 'root':
        error('You need to be root to run %(_app_name)s' % globals())
        sys.exit(1)


def load_asp_run_env():
    """Returns the content of asp_run.env as a dictionary"""

    global _asp_run_env
    
    if _asp_run_env:
        return _asp_run_env
    
    f = open(_asp_dir + '/etc/asp_run.env', "r")
    lines = f.readlines()
    f.close()
    try:
        d = dict([l.split('=') for l in [l.strip() for l in lines]
                                     if not l.startswith('#')])
    except:
        raise CommandError('Could not parse asp_run.env. Values are missing?')
    
    _asp_run_env = d
    return _asp_run_env

def safe_remove(f):
    try:
        os.remove(f)
    except:
        os.system('rm -f %s' %f)
    
def get_amf_pid(watchdog_pid = False):
    while True:
        valid = subprocess.getstatusoutput("pidof %s" % AMF_NAME);
        if valid[0] == 0:
            if len(valid[1].split())==1:
                return int(valid[1])
        else:
            break
        log.warning('There is more than one AMF pid. Try again...')
        time.sleep(0.25)
    if watchdog_pid:
         valid = subprocess.getstatusoutput("pidof safplus_watchdog.py");
         if valid[0] == 0:
            return int(valid[1])
    return 0;

def is_asp_running(watchdog_pid = False):
    '''
    Return value meaning :
    0 -> running
    1 -> not running,
    2 -> booting/shutting down
    3 -> running without status file, this is a bug.
    '''

    amf_pid = get_amf_pid(watchdog_pid)

    if amf_pid == 0:
        return 1
    return 0
    #asp_status_file = asp_run_env['ASP_RUNDIR'] + '/aspstate-%s' % asp_run_env['ASP_NODEADDR']

    #if os.path.exists(asp_status_file):
    #    (ec, t, signal, core) = system('cat %s' % asp_status_file)
    #    asp_up = bool(int(t[0]))
    #    if asp_up:
    #        return 0
    #    else:
    #        return 2
    #else:
    #    return 3

def get_asp_status():
    v = is_asp_running(watchdog_pid = True)

    if v == 0:
        return ('SAFplus is running on node [%s], pid [%s]' % (asp_run_env['ASP_NODEADDR'], get_amf_pid(True)))
    elif v == 1:
        return ('SAFplus is not running on node [%s]' % asp_run_env['ASP_NODEADDR'])
    elif v == 2:
        return ('SAFplus is booting up/shutting down')
    elif v == 3:
        return ('SAFplus is running with pid [%s], but it was not started from this sandbox [%s].' % (get_amf_pid(True), asp_run_env['ASP_DIR']))
    return ""

def get_status_info():
    """Returns with SAFplus running status, as a dict with following entries:
       Key:         Value(s):
       status       'down', 'up', 'booting/shutting down'
       pid          <pid> or 'N/A'
       nodeaddr     <nodeaddr> or 'N/A'
       nodename     <nodename>
    """

    d = Dot({})
    # need to parse 3 forms:
    #   INFO ASP is not running on node [1]
    #   INFO ASP is booting up/shutting down
    #   INFO ASP is running on node [1], pid [21548]
    res = get_asp_status().strip()
    if res.find('not running') >= 0:
        d.status = 'down'
        d.pid    = d.nodeaddr = 'N/A'
        #conf = load_asp_conf()
        d.nodename = asp_run_env['ASP_NODENAME']
    elif res.find('booting up') >= 0:
        d.status = 'booting or shutting down'
    elif res.find('running on node') >= 0:
        d.status = 'up'
    else:
        raise CommandError('Unexpected output from asp status: [%s]' % res)
    
    if d.status in ['up', 'booting or shutting down']:        
        ip = get_ip_address(asp_run_env['SAFPLUS_BACKPLANE_INTERFACE'])
        myNodeID = ip.split('.')[3]
        d.nodeaddr = myNodeID
        d.nodename = asp_run_env['ASP_NODENAME']
        amf_cmd_line = '%s/bin/safplus_amf' % (_asp_dir)
        cmd = sys_asp['grep_amf_cmd'](amf_cmd_line)
        (ec, output, signal, core) = system(cmd)
        if ec:
            raise CommandError('SAFplus is reported running, but could not retrieve PID')
        d.pid = output[0].split()[0].strip().decode('utf-8')
        # Sanity check: if 'up', same pid should have been in res message
        if d.status == 'up' and res.find(d.pid) == -1:
            raise UnknownError('PID mismatch beetween asp status and pgrep')
    
    return d

def get_amf_master_handle():
    #print 'get_amf_master_handle'
    global amfMasterHdl
    info = s.grpCliClusterViewGet()
    rows = info.split('\n')
    for row in rows:
        if len(row) == 0:
            continue
        cells = row.split()
        #print cells[1]
        #cells[2]
        if cells[1] == 'controller' and cells[2] == 'active':
            masterNodeId = int(cells[3])
            #print 'master node id:%d'%masterNodeId
            amfMasterHdl = s.getProcessHandle(1,masterNodeId)
            return
        
def mgtGet(xpath):
    #print 'mgtGet:%s'%xpath
    if not xpath or len(xpath)==0 or xpath[0]!='/':
        return ""
    xml = s.mgtGet(amfMasterHdl,xpath)
    #print '====================='
    if len(xml) == 0:
        #print 'get the master handle'
        time.sleep(3)
        get_amf_master_handle()
        return s.mgtGet(amfMasterHdl,xpath)
    return xml
 
def get_cluster_info():
    """Obtain the cluster list from master CPM and return a list of dot objects
       with following keys:
            .nodename
            .nodeaddr
            .nodetype
            .hastate
    """
    info = s.grpCliClusterViewGet()
    rows = info.split('\n')
    nodes = []
    for row in rows:
        if len(row) == 0:
            continue
        n = Dot({})
        #print row
        #cells = row.split()
        #assert len(cells)>=7, 'Unexpected cluster view line from safplus_console: %s' % row
        cells = row.split()
        #print str(cells)        
        n.nodename = cells[0]
        n.nodetype = cells[1]
        n.hastate = cells[2]
        n.nodeaddr = cells[3]
        #n.nodeaddr, n.nodename, addr, port, leader, credential = cells[0:6]
        #if credential != '0':
        #    n.nodetype = 'controller'
        #    if leader == 'Yes':
        #        n.hastate = 'active'
        #    else:
        #      if leader == '(Pending)':
        #        n.hastate = 'unassigned'
        #      else:
        #        n.hastate = 'standby'
        #else:
        #     n.nodetype = 'worker'
        #     assert leader == 'No', 'a worker node shall never be the cluster leader'
        #     n.hastate = '-'

        nodes.append(n)
    
    return nodes
    
    #return info
def countAssignedSU(su):
    #print 'countAssignedSU: %s' % su
    xmlStr = '%s/ServiceUnit'%xmlRoot    
    xml = mgtGet(xmlStr)
    d = '<ServiceUnit listkey='
    sustrlist = [d+e for e in xml.split(d) if e]
    count = 0
    for e in sustrlist:        
        root = et.fromstring(e)
        newroot = et.Element('su')
        newroot.insert(0,root)
        #if su=='SU12':
        #    print et.tostring(newroot,pretty_print=True)
        for e in newroot.getchildren():
            if e.tag == 'ServiceUnit' and e.get('listkey') == su:
                for n in e.getchildren():               
                    if n.tag == 'assignedServiceInstances':
                    #print n.text
                        if n.text:
                            count += 1
    return count

def countInstantiatedSU(su):
    #print 'countInstantiatedSU: %s' % su
    xmlStr = '%s/ServiceUnit'%xmlRoot    
    xml = mgtGet(xmlStr)
    d = '<ServiceUnit listkey='
    sustrlist = [d+e for e in xml.split(d) if e]
    count = 0
    for e in sustrlist:
        root = et.fromstring(e)
        newroot = et.Element('su')
        newroot.insert(0,root)
        for e in newroot.getchildren():
            if e.tag == 'ServiceUnit' and e.get('listkey') == su:
                for n in e.getchildren():                
                    if n.tag == 'presenceState':
                        #print n.text
                        if n.text == 'instantiated':
                            count += 1
    return count

def countActiveStandbySU(sg):
    suNames = amfctrl.csv2List(sg.serviceUnits.data_)
    numActives=numStandbys=0
    for sun in suNames:
        #print 'sun:'+sun
        sux = mgtGet(sun)
        if sux: 
            su = microdom.LoadString(sux)
            #print 'haState:'+su.haState.data_
            if su.haState.data_ == 'active':
                numActives+=1
            elif su.haState.data_ == 'standby':
                numStandbys+=1
        else:
            print ('mgtget for su %s failed'% sun)
    return numActives,numStandbys

def countInstantiatedComp(su):
    compNames = amfctrl.csv2List(su.components.data_)
    count = 0
    for compName in compNames:        
        compx = mgtGet(compName)
        if compx: 
            comp = microdom.LoadString(compx)
            #print 'comp:%s, presenceState:%s'%(comp.name.data_,comp.presenceState.data_)
            if comp.presenceState.data_ == 'instantiated':
                count+=1                
        else:
            print ('mgtget for comp %s failed'% compName)
    #print 'count:%d\n\n\n'%count
    return count

def getNumActiveStandbySI(su):
    nActiveSI = su.numActiveServiceInstances.current.data_ if su.numActiveServiceInstances.current else 0
    nStandbySI = su.numStandbyServiceInstances.current.data_ if su.numStandbyServiceInstances.current else 0
    #print 'nASI:%d'%nActiveSI
    #print 'nSSI:%d'%nStandbySI
    return nActiveSI,nStandbySI

def get_nodes_info():
    """Obtain the su list as a list of Dot objects with following info:
    """    
    #xml = mgtGet( xmlRoot)
    #xml = mgtGet(xmlRoot)
    #if len(xml)==0:
    #    print 'cannot get nodes info'
    #    return None
    #print xml
    #root = et.fromstring(xml)
    xmlStr = '%s/Node'%xmlRoot
    #print xmlStr
    xml = mgtGet(xmlStr)
    #print xml
    #root = et.fromstring(xml)
    #print str(root)
    d = '<Node listkey='
    nodestrlist = [d+e for e in xml.split(d) if e]

    nodes = []
    isu = 0
    asu = 0
    for e in nodestrlist:
        root = et.fromstring(e)        
        newroot = et.Element('node')
        newroot.insert(0,root)
        #print et.tostring(newroot,pretty_print=True)
        for e2 in newroot.getchildren():
            if e2.tag == 'Node':
                node = Dot({})
                for n in e2.getchildren():
                    #node.classtype    = None#_classtype_map[n.config[0].class_type[0]]                    
                    if n.tag == 'name':
                        node.nodename     = n.text                    
                    elif n.tag == 'adminState':
                        node.astate       = _state_map[n.text]
                    elif n.tag == 'presenceState':
                        node.presence       = _presence_map[n.text]
                    elif n.tag == 'operState':
                        node.operstate       = _operstate_map[n.text]
                    elif n.tag == 'serviceUnits':
                        if not n.text:
                            continue
                        suList = amfctrl.csv2List(n.text)
                        for suName in suList:
                            su = suName[suName.rfind('/')+1:]
                            asu += countAssignedSU(su)
                            isu += countInstantiatedSU(su)
                            #print asu
                            #print isu

        
        #node.castate      = _state_map[n.config[0].computed_admin_state[0]]
        #node.presence     = _presence_map[n.presenceState[0]]
        #node.operstate    = _operstate_map[n.operState[0]]
        #node.instantiable = _yesno_map[n.status[0].is_instantiable[0]]
        #node.member       = _member_map[n.status[0].is_cluster_member[0]]
        #node.isu          = n.status[0].num_instantiated_sus[0]
        #node.asu          = n.status[0].num_assigned_sus[0]
                node.isu = isu
                node.asu = asu            
                nodes.append(node)
                isu = asu = 0

    return nodes

def get_sg_info(sgName):
    sg = None
    sgx = mgtGet(xmlRoot + "/ServiceGroup/" + sgName)
    if sgx: 
        sg = microdom.LoadString(sgx)
        sg.su = {}
        suNames = amfctrl.csv2List(sg.serviceUnits.data_)
        for sun in suNames:
            if not sun: continue
            sut = mgtGet(sun)
            if sut:
                #print 'geting su obj of [%s]'%sut
                sumd = microdom.LoadString(sut)
                sg.su[sumd.name.data_] = sumd # Add this su to the sg's dictionary
    else:
        raise
    return sg

def get_sgs_info():
    sgs = []
    for sgname in get_sg_names():
        sginfo = get_sg_info(sgname)
        sg = Dot({})
        sg.sgname     = sginfo.name.data_
        sg.astate     = _state_map[sginfo.adminState.data_]
        numA,numS     = countActiveStandbySU(sginfo)
        sg.activesus  = numA
        sg.stbysus    = numS
        sg.started    = 'True' if sginfo.adminState.data_=='on' or sginfo.adminState.data_=='idle' else 'False'
        sgs.append(sg)
    return sgs

def get_sg_names():
    xmlStr = '%s/ServiceGroup'%xmlRoot
    #print xmlStr
    xml = mgtGet(xmlStr)
    #print xml
    #root = et.fromstring(xml)
    #print str(root)
    d = '<ServiceGroup listkey='
    sgstrlist = [d+e for e in xml.split(d) if e]
    sgs = []
    for e in sgstrlist:
        root = et.fromstring(e)
        newroot = et.Element('sg')
        newroot.insert(0, root)
        for e2 in newroot.getchildren():
            if e2.tag == 'ServiceGroup':
                sgs.append(e2.get('listkey'))
    return sgs

def get_sus_info(nodename=None):
    """Obtain the su list as a list of Dot objects with following info:
    """
    xmlStr = '%s/ServiceUnit'%xmlRoot    
    xml = mgtGet(xmlStr)
    d = '<ServiceUnit listkey='
    sustrlist = [d+e for e in xml.split(d) if e]
    sus = []
    for e in sustrlist:
        root = et.fromstring(e)
        newroot = et.Element('su')
        newroot.insert(0,root)
        for e2 in newroot.getchildren():
            if e2.tag == 'ServiceUnit':    
                sux = mgtGet(xmlRoot + '/ServiceUnit/' + e2.get('listkey'))
                if sux: 
                    suxm = microdom.LoadString(sux)
                    thisNode = suxm.node.data_ if hasattr(suxm, 'node') else ''
                    this_nodename = thisNode[thisNode.rfind('/')+1:]
                    if nodename and not nodename == this_nodename:
                        continue
                    su = Dot({})
                    su.suname    = suxm.name.data_
                    #print 'suname:'+su.suname
                    su.sgname    = suxm.serviceGroup.data_[suxm.serviceGroup.data_.rfind('/')+1:]
                    su.nodename  = this_nodename
                    su.astate    = _state_map[suxm.adminState.data_]
                    su.presence  = _presence_map[suxm.presenceState.data_]
                    #print 'operState:%s'% str(suxm.operState.data_)
                    su.operstate = _operstate_map[str(suxm.operState.data_)]
                    su.readiness = _readiness_map[suxm.readinessState.data_]
                    su.comps     = countInstantiatedComp(suxm)
                    nA,nS = getNumActiveStandbySI(suxm)
                    if nA:
                        su.sis   = 'A'
                    elif nS:
                        su.sis   = 'S'
                    else:
                        su.sis   = '-'
            #else:
            #    su.sis   = ''.join([ _hastate_map[si.ha_state[0]]
            #                       for si in s.status[0].sis[0].si ])
                    sus.append(su)

    return sus

def get_comps_info():
    """Obtain the component list from CPM and return it as list of dot objects
       with following fields:
            .compname       <compname>
            .running        'Y' or '-'
            .pid            <pid> or '-'            
            .command        <command name> or '-'            
    """

    xmlStr = '%s/Component'%xmlRoot    
    xml = mgtGet(xmlStr)
    d = '<Component listkey='
    compstrlist = [d+e for e in xml.split(d) if e]
    comps = []
    for e in compstrlist:
        root = et.fromstring(e)
        newroot = et.Element('su')
        newroot.insert(0,root)
        for e2 in newroot.getchildren():
            if e2.tag == 'Component':    
                compx = mgtGet(xmlRoot + '/Component/' + e2.get('listkey'))
                if compx:
                    comp = microdom.LoadString(compx)
                    if comp:
                        c = Dot({})
                        c.compname = comp.name.data_
                        c.running = (comp.presenceState.data_ == 'instantiated' and 'Y' or '-')
                        if c.running == 'Y':
                            c.pid = str(comp.processId.data_)
                            pid = int(c.pid)
                            if not pid:
                                c.pid = '-'
                            if pid>0:
                                c.command = comp.instantiate.command.data_
                            else:
                                c.command = '-'
                        else:
                            c.pid = c.command = '-'
                        comps.append(c)
    
    return comps

def cmp(a,b):
    return (a>b)-(a<b)

class Cli(cmd.Cmd):
    """Command line handler class"""
    
    def __init__(self, histfile):
        self.doc_header = "Available commands (type help <topic> for more info):"
        cmd.Cmd.__init__(self)
        try:
            self.prompt = color('bold-blue', '[%s@' % _app_name) + \
                          color('bold-red', load_asp_conf(False).NODENAME) + \
                          color('bold-blue', ']==> ')
        except:
            self.prompt = color('bold-blue', '[%s]==> ' % _app_name)
            
        self.histfile = histfile

    def preloop(self):
        """ Load history file """
        cmd.Cmd.preloop(self) # call original preloop to activate completion
        
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

        print ()
        print (color('bold', WELCOME_MSG))
        print ('-'*len(WELCOME_MSG))

    def postloop(self):
        """ Save history file """
        cmd.Cmd.postloop(self) # call original postloop to deactivate completion
        if on_platform('linux'):
            try:
                readline.read_history_file(self.histfile)
            except: # Catch all readline exceptions since this an optional component
                pass

    def completenames(self, text, *ignored):
        """override cmd's builtin: sneak in a trailing space if cmd was fully
           resolved
        """
        dotext = 'do_'+text
        cmds = [a[3:] for a in self.get_names() if a.startswith(dotext)]
        if len(cmds) == 1:
            cmds[0] = cmds[0]+' '
        return cmds

    def do_exit(self, msg):
        """Exiting the asp-info utility"""
        if len(msg):
            print ('No arguments to exit command, please')
            return
        return(1) # will exit cmd loop (but call postloop() first)

    def do_bye(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)
      
    def do_quit(self, msg):
        """Exit the asp-info utility"""
        return self.do_exit(msg)    
    
    ##
    ## status command
    ##
    def do_status(self, msg):
        """Show SAFplus running status and some basic run-time information"""

        try:
            info = get_status_info()
        except AspError as e:
            error(str(e))
            return 0
        print ('SAFplus run status:          %s' % color('bold-red',
                                                    '%(status)s' % info))
        print ('pid of safplus_amf:          %(pid)s' % info)
        # print 'node instance name:      %(nodename)s' % info

        print ('actual node address:         %(nodeaddr)s' % info)
        
        # TODO: try connecting to local node and master node and fill the following info:
        # Hint: use mgtGet(dest, xpath) in which dest is masterHandle. If it returns an empty string, the master is not available, otherwise, it's available
        # use mgtGet(xpath). If it returns an empty string, the local is not available, otherwise, it's available
        d = {}
        #try:
        #    s, output = asp_console_execute(['setc %(nodeaddr)s' % info])
        #except AspError:
        #    d['console'] = 'not available'
        #else:
        #    if s:
        #        d['console'] = 'not available'
        #    else:
        #        d['console'] = 'available'
        #print 'SAFplus local console:       %(console)s' % d

        #if info.status == 'down':
        #    return
        #s, output = asp_console_execute(['setc master'])
        clusterView = s.grpCliClusterViewGet()
        if len(clusterView)==0:
            d['master'] = 'not available'
        else:
            d['master'] = 'available'
            
        print ('SAFplus master console:      %(master)s' % d)
        try:
            xml = mgtGet(xmlRoot+'/ServiceInstance')
            #if len(xml)>0:
            #    d['console'] = 'available'
            #else:
            #    d['console'] = 'not available'
            d['console'] = 'available'
        except:
            d['console'] = 'not available' #TODO: more specific error handling
        print ('SAFplus local console:       %(console)s' % d)
    
    ##
    ## cluster command
    ##
    def do_cluster(self, msg):
        """Show cluster nodes and their state """

        try:
            nodes = get_cluster_info()
        except AspError as e:
            error(str(e))
            return 0
        
        
        len_nodename = max([len(n.nodename) for n in nodes]+[9])
        fmt = '%%(nodename)%ds  %%(nodetype)10s  %%(hastate)-8s  %%(nodeaddr)9s' % \
            (len_nodename)

        h = Dot({}) # table header
        h.nodename, h.nodetype, h.hastate,  h.nodeaddr = \
        'NODE-NAME', 'NODE-TYPE', 'HA-STATE', 'NODE-ADDR'

        nodes.sort(key = cmp_to_key(lambda x,y: cmp(int(x.nodeaddr), int(y.nodeaddr))))

        print (color('bold', fmt % h))
        status_info = get_status_info()
        for n in nodes:
            line = n.hastate == 'active' and color('bold-red', fmt % n) or fmt % n
            if n.nodeaddr == status_info.nodeaddr:
                line += ' <-- this node'
            print (line)
        #print info
    
    ##
    ## nodes command
    ##
    def do_nodes(self, msg):
        "Show list of node entities and their state\n" \
        "\n" \
        "Usage: nodes\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    ISU:        # of instantiated SUs\n" \
        "    ASU:        # of assigned SUs\n"
        try:
            nodes = get_nodes_info()
        except Exception as e:
            error('Command is not available while SAFplus is down (run "status"),')
            error('or if another safplus_console is running')
            error(str(e))
            return 0

        if len(nodes)==0:
            error('No node defined in the model or database is empty')
            return 0
        
        len_name = max([len(n.nodename) for n in nodes])
       
        fmt = '%%(nodename)%ds  %%(astate)2s  %%(presence)2s  %%(operstate)2s  %%(isu)3s  %%(asu)3s' % \
                (len_name)

        h = Dot({}) # table header
        h.nodename, h.astate,  h.presence, h.operstate, h.isu, h.asu = \
        'NODE',     'AS',      'PS',       'OS',       'ISU',       'ASU'
        
        nodes.sort(key = cmp_to_key(lambda x,y: cmp(x.nodename, y.nodename)))
        print (color('bold', fmt % h))
        for n in nodes:
            if  n.astate == 'UL':
                print (color('bold-red', fmt % n))
            elif n.astate == 'LA':
                print (color('yellow', fmt % n))
            else:
                print (fmt % n)

    def do_forest(self, msg):
        """print the HA hierarchy for each SG in the cluster (call 'tree' for each SG)"""
        for sgname in get_sg_names():
            self.onecmd('tree %s' % sgname)

    def do_tree(self, msg):
        "Show a tree view of related HA entities containing the specified SG\n" \
        "\n" \
        "Usage: tree <sg-name>\n" \
        "\n" \
        "where\n" \
        "    <sg-name>       is one of the names listed by the 'sgs' command\n"

        args = msg.split()
        if len(args)!=1:
            self.onecmd('help tree')
            return 0
    
        sg_name = msg.strip()
        sg = None
        try:
            sg = get_sg_info(sg_name)        
        except:
            pass            
        if not sg:
            error('Could not find SG [%s] in AMF database' % sg_name)
            return 0       

        print ('SG %s (state:%s)' % \
            (color('bold', sg.name.data_),
             color('bold-red', _state_map[sg.adminState.data_])))

        
        def getNodeNameList(nodes):            
            nodeNameList = []
            for node in nodes:
                nodeNameList.append(node.name.data_)
            #print 'DBG1010: list:%s'%str(nodeNameList)
            return nodeNameList

        suList = sg.su.items()        
        nodes = []
        for sun,su in suList:
            nodeName = su.node.data_ if hasattr(su, 'node') else ''
            #print 'DBG1010:%s'%nodeName
            if nodeName and nodeName.split('/')[3] not in getNodeNameList(nodes):#list(filter(lambda n: n.name.data_, nodes))
                nodex = mgtGet(nodeName)
                #print 'get node obj of [%s]'%nodex
                if nodex:
                    node = microdom.LoadString(nodex)
                    nodes.append(node)
        
        #nodes.sort()
        for node in nodes:

            print ('   Node %s' % color('bold', node.name.data_))
            
            sus = [su for sun,su in suList
                   if hasattr(su,'node') and su.node.data_[su.node.data_.rfind('/')+1:] == node.name.data_]
            
            #sus.sort(lambda x,y: cmp(x.value, y.value))
            for su in sus:

                print ('        SU %s (state:%s)' % \
                    (color('bold', su.name.data_),
                     color('bold-red', _state_map[su.adminState.data_])))
                sis = []
                siNames = [x.strip() for x in su.assignedServiceInstances.data_.split(",")]
                for sin in siNames:
                    if not sin: continue
                    six = mgtGet(sin)
                    if six:
                        sim = microdom.LoadString(six)
                        sis.append(sim)                        
                
                for si in sis:
                    siState = '-'
                    #print 'DBG: su [%s], numActiveServiceInstances.current [%d]'%(su.name.data_,su.numActiveServiceInstances.current.data_)
                    if su.numActiveServiceInstances.current.data_ > 0:
                        siState = 'active'
                    elif su.numStandbyServiceInstances.current.data_ > 0:
                        siState = 'standby'
                    print ('           SI %s (state:%s)' % \
                        (si.name.data_, color_state(siState)))
        
                compNames = amfctrl.csv2List(su.components.data_)
                comps = []
                for cn in compNames:
                    if not cn: continue
                    #print ('mgtget comp name [%s]'%cn)                   
                    cux = mgtGet(cn)
                    if cux:
                        compMicrodom = microdom.LoadString(cux)
                        comps.append(compMicrodom)
                
                for comp in comps:                    
                    print ('           Comp %s (PS:%s OS:%s RS:%s PID:%s)' % \
                        (color('bold', comp.name.data_),
                         comp.presenceState.data_,
                         _operstate_map[str(comp.operState.data_)],
                         _readiness_map[comp.readinessState.data_],
                         color('bold-cyan', comp.processId.data_)))                    

                    csis = []
                    for si in sis:                        
                        csiNames = amfctrl.csv2List(si.componentServiceInstances.data_)
                        for csin in csiNames:
                            if not csin: continue
                            csix = mgtGet(csin)
                            #print 'getting csi obj from [%s]' % csix
                            csim = microdom.LoadString(csix)
                            #print 'DBG: adding csi [%s] to list csis'%csin
                            csis.append(csim)
                    activeComps = standbyComps = []                    
                    csiState = '-'
                    csin = ''
                    for csi in csis:                        
                        #print 'DBG:compname:%s/csiname:%s/active comps:%s'%(comp.name.data_,csi.name.data_,csi.activeComponents.data_)
                        #print 'DBG:compname:%s/csiname:%s/standby comps:%s'%(comp.name.data_,csi.name.data_,csi.standbyComponents.data_)
                        if len(csi.activeComponents.data_)>0:
                            #print 'DBG1:active comps:%s'%csi.activeComponents.data_                            
                            activeCompsX = amfctrl.csv2List(csi.activeComponents.data_)
                            for c in activeCompsX:
                                activeComps.append(c[c.rfind('/')+1:])
                            #print 'DBG1.1:active comps:%s'%str(activeComps)
                            if comp.name.data_ in activeComps:
                                csiState = 'active'
                                csin = csi.name.data_
                                break                            
                        if len(csi.standbyComponents.data_)>0:
                            #print 'DBG2:standby comps:%s'%csi.activeComponents.data_                           
                            standbyCompsX = amfctrl.csv2List(csi.standbyComponents.data_)
                            for c in standbyCompsX:
                                standbyComps.append(c[c.rfind('/')+1:])  
                            #print 'DBG2.2:standby comps:%s'%str(standbyComps)                          
                            if comp.name.data_ in standbyComps:
                                csiState = 'standby'
                                csin = csi.name.data_
                                break
                        #print 'active comps:%s'%str(activeComps)
                        #print 'standby comps:%s'%str(standbyComps)
                    
                    print ('                CSI %s (state:%s)' % \
                            (csin, color_state(csiState)))
                    #del csis

    def do_sgs(self, msg):
        "Show all defined service groups in cluster\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    A-SUS       # of active SUs\n" \
        "    S-SUS:      # of standby SUS\n" \
        "\n" \
        "Use the 'sg' command to get more information on a given SG\n"
        sgs = get_sgs_info()
        if len(sgs)==0:
            error('No ServiceGroup defined in the model or database is empty')
            return 0
        len_name = max([len(s.sgname) for s in sgs])
        fmt = '%%(sgname)-%ds  %%(astate)3s  %%(started)7s %%(activesus)5s  %%(stbysus)5s' % \
                (len_name)

        h = Dot({}) # table header
        h.sgname,  h.astate,  h.activesus, h.stbysus, h.started = \
        'SG-NAME',     'AS',     'A-SUS',     'S-SUS',   'STARTED'
        
        sgs.sort(key = cmp_to_key(lambda x,y: cmp(x.sgname, y.sgname)))

        print (color('bold', fmt % h))
        for sg in sgs:
            if  sg.astate == 'UL':
                print (color('bold-red', fmt % sg))
            elif sg.astate == 'LA':
                print (color('yellow', fmt % sg))
            else:
                print (fmt % sg)

    def do_sus(self, msg):
        "Show list of service units\n" \
        "\n" \
        "Usage: sus [ <nodename> | all ]\n" \
        "\n" \
        "Without argument, lists all SUS defined in the cluster. With the optional node\n" \
        "name, lists SUs dedicated to the given node.\n" \
        "\n" \
        "Abbreviations:\n" \
        "    AS:         Administrative state (LI: Locked-instantiation, LA: Locked-assignment,\n" \
        "                UL: Unlocked)\n" \
        "    PS:         Presence state:\n" \
        "                I: Instantiated, U: Uninstantiated\n" \
        "    OS:         Operational state:\n" \
        "                E: Enabled, D: Disabled\n" \
        "    RS:         Readiness state:\n" \
        "                FIXME add details here\n" \
        "    IC:         # of instantiated components\n" \
        "    SIS:        Assigned SIs ('A'=active, 'S'=standby, 'Q'=quiesced)\n"

        args = msg.split()
        nodename = None
        if len(args)>1:
            self.onecmd('help sus')
            return 0
        elif len(args)==1:
            if msg == 'all':
                pass
            else:
                nodename = msg
        #else:
        #    nodename = get_node_info_from_cpm().nodename
           
        sus = get_sus_info(nodename=nodename)
        if len(sus)==0:
            error('No ServiceUnit defined in the model or database is empty')
            return 0
        len_suname = max([len(s.suname) for s in sus]+[7])
        len_sgname = max([len(s.sgname) for s in sus]+[13])
        len_nodename = max([len(s.nodename) for s in sus]+[7])
        fmt = '%%(suname)%ds  %%(sgname)-%ds  %%(nodename)-%ds %%(astate)2s %%(presence)-2s %%(operstate)-2s %%(readiness)-3s %%(comps)2s %%(sis)s' % \
                (len_suname, len_sgname, len_nodename)

        h = Dot({}) # table header
        h.suname,  h.sgname,      h.nodename, h.astate,  h.presence, h.operstate, h.readiness, h.comps, h.sis = \
        'SU-NAME','MEMBER-OF-SG', 'ON-NODE',  'AS',     'PS',       'OS',        'RS',        'IC',    'SIS'
        
        sus.sort(key = cmp_to_key(lambda x,y: cmp(x.suname, y.suname)))
        
        print (color('bold', fmt % h))
        for su in sus:
            if  su.astate == 'UL':
                print (color('bold-red', fmt % su))
            elif su.astate == 'LA':
                print (color('yellow', fmt % su))
            else:
                print (fmt % su)

    def do_components(self, msg):
        "Show user components running on this node\n" \
        "\n" \
        "Abbreviations:\n" \
        "    R:     Running?\n" \
        
        comps = get_comps_info()
        if len(comps)==0: 
            error('No component defined in the model or database is empty')
            return 0

        len_compname = max([len(c.compname) for c in comps])
        len_pid = max([len(c.pid) for c in comps])
        len_command = max([len(c.command) for c in comps])
        fmt = '%%(compname)%ds  %%(running)s  %%(pid)-%ds  %%(command)-%ds' % \
                (len_compname, len_pid, len_command)

        h = Dot({}) # table header
        h.compname, h.running, h.pid, h.command = \
        'COMPNAME', 'R',       'PID',       'COMMAND'
        
        #comps.sort(lambda x,y: cmp(x.compname, y.compname))
        
        print (color('bold', fmt % h))
        for c in comps:
            print (c.running=='Y' and color('bold-red', fmt % c) or fmt % c)

    def do_lock_a(self, msg):
        "Lock-assigment on an SG,SU,NODE or SI\n" \
        "\n" \
        "Usage: lock_a sg <sg-name> or\n" \
        "       lock_a su <su-name>\n" \
        "       lock_a node <node-name>\n" \
        "       lock_a si <si-name>\n"
        
        args = msg.split()
        
        if len(args)!=2:
            self.onecmd('help lock_a')
            return 0
        
        if args[0] not in ['sg', 'su', 'node', 'si']:
            self.onecmd('help lock_a')
            return 0
        
        e_type, e_name = args
        dummyHdl = s.getProcessHandle(0,0)
        ret = s.amfMgmtInitialize(dummyHdl)
        if ret != 0x0:
            print ('Cannot initialize safplus amf managememt, error code [0x%x]'% ret)
            return 0
        if e_type == 'sg':
            ret = s.amfMgmtSGLockAssignment(dummyHdl, e_name)
        elif e_type == 'node':
            ret = s.amfMgmtNodeLockAssignment(dummyHdl, e_name)
        elif e_type == 'su':
            ret = s.amfMgmtSULockAssignment(dummyHdl, e_name)
        elif e_type == 'si':
            ret = s.amfMgmtSILockAssignment(dummyHdl, e_name)
        if ret == 0x11:
            print ("entity [%s] does not exist" % e_name)
        elif ret == 0x12:
            print ("entity [%s] has an invalid state for lockAssignment" % e_name)
        elif ret == 0x0:
            print (" entity [%s] lockAssignment OK" % e_name)
        else:
            print ("entity [%s] lockAssignment unknown error [0x%x]" % (e_name,ret))
        ret = s.amfMgmtFinalize(dummyHdl)
        
    def do_lock_i(self, msg):
        "Lock-instantiation on an SG, SU or NODE\n" \
        "\n" \
        "Usage: lock_i sg <sg-name> or\n" \
        "       lock_i su <su-name>\n" \
        "       lock_i node <node-name>\n"
                
        args = msg.split()
        
        if len(args)!=2:
            self.onecmd('help lock_i')
            return 0
        
        if args[0] not in ['sg', 'su', 'node']:
            self.onecmd('help lock_i')
            return 0
        
        e_type, e_name = args
        dummyHdl = s.getProcessHandle(0,0)
        ret = s.amfMgmtInitialize(dummyHdl)
        if ret != 0x0:
            print ('Cannot initialize safplus amf managememt, error code [0x%x]'% ret)
            return 0
        if e_type == 'sg':
            ret = s.amfMgmtSGLockInstantiation(dummyHdl, e_name)
        elif e_type == 'node':
            ret = s.amfMgmtNodeLockInstantiation(dummyHdl, e_name)
        elif e_type == 'su':
            ret = s.amfMgmtSULockInstantiation(dummyHdl, e_name)
        if ret == 0x11:
            print ("entity [%s] does not exist" % e_name)
        elif ret == 0x12:
            print ("entity [%s] has an invalid state for lockInsantiation" % e_name)
        elif ret == 0x0:
            print (" entity [%s] lockInsantiation OK" % e_name)
        else:
            print ("entity [%s] lockInstantiation unknown error [0x%x]" % (e_name,ret))
        ret = s.amfMgmtFinalize(dummyHdl)

    def do_unlock(self, msg):
        "Unlock an SG,SU,NODE or SI\n" \
        "\n" \
        "Usage: unlock sg <sg-name> or\n" \
        "       unlock su <su-name>\n" \
        "       unlock node <node-name>\n" \
        "       unlock si <si-name>\n" 
                
        args = msg.split()
        
        if len(args)!=2:
            self.onecmd('help unlock')
            return 0
        
        if args[0] not in ['sg', 'su', 'node', 'si']:
            self.onecmd('help unlock')
            return 0
        
        e_type, e_name = args
        dummyHdl = s.getProcessHandle(0,0)
        ret = s.amfMgmtInitialize(dummyHdl)
        if ret != 0x0:
            print ('Cannot initialize safplus amf managememt, error code [0x%x]'% ret)
            return 0
        if e_type == 'sg':
            ret = s.amfMgmtSGUnlock(dummyHdl, e_name)
        elif e_type == 'node':
            ret = s.amfMgmtNodeUnlock(dummyHdl, e_name)
        elif e_type == 'su':
            ret = s.amfMgmtSUUnlock(dummyHdl, e_name)
        elif e_type == 'si':
            ret = s.amfMgmtSIUnlock(dummyHdl, e_name)
        if ret == 0x11:
            print ("entity [%s] does not exist" % e_name)
        elif ret == 0x12:
            print ("entity [%s] has an invalid state for unlock" % e_name)
        elif ret == 0x0:
            print (" entity [%s] unlock OK" % e_name)
        else:
            print ("entity [%s] unlock unknown error [0x%x]" % (e_name,ret))
        ret = s.amfMgmtFinalize(dummyHdl)


    def do_EOF(self, msg):
        """Type 'exit' or press Ctrl-D to exit"""
        print # a new line before exiting
        return(self.do_exit(msg))    
    
    def help_help(self):
        """Print this help page"""
        pass

def init_sys_asp():
    linux_code = \
    '''\
import subprocess
import os
import time

def system(cmd):
    """Similar to the os.system call, except that both the output and
    return value is returned"""
    
    #print 'Executing command: %s' % cmd
    child = subprocess.Popen(cmd, shell=True,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
    output = []
    while True:
        pid, sts = os.waitpid(child.pid, os.WNOHANG)
        output += child.stdout.readlines() 
        if pid == child.pid:
            break
        else:
            time.sleep(0.00001)

    child.stdout.close()
    child.stderr.close()
    retval = sts
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    #print 'Command return value %s, Output: %s' % (str(retval),output)
    del child
    return (retval, output, signal, core)

def grep_amf_cmd(e):
    return 'ps -eo pid,cmd | grep %s | grep -v grep' % e

def proc_info_cmd(e):
    return 'ps h -p %s -ocomm,%%cpu,nlwp,rss,vsz' % e

echo_cmd = '/bin/echo -e'

'''

    qnx_code = \
    '''\
import popen2
import platform

def on_arch(arch_name):
    return arch_name in arch

def system(cmd):
    """Similar to the os.system call, except that both the output and return value is returned"""
    # WARNING: system will deadlock if command output exceeds ~64 KB!
    #print 'Executing command: [%s]' % cmd
    child = popen2.Popen4(cmd)
    retval = child.wait()
    signal = retval & 0x7f
    core   = ((retval & 0x80) !=0)
    retval = retval >> 8
    if on_arch("x86"):
        output = child.fromchild.readlines()
    else:
        output = child.fromchild.readlines()[3:]
        
    #print 'Command return value [%s], output:%s' % (str(retval), output)
    del child
    return (retval, output, signal, core)

def grep_amf_cmd(e):
    return 'pidin ar | grep %s' % e

def proc_info_cmd(e):
    return 'ps -p %s -ocomm,pcpu,threads,sz,vsz | grep -v COMMAND' % e

arch = platform.machine()
echo_cmd = '/bin/echo'

'''
    if on_platform("linux"):
      p = "linux"
      code = linux_code
    else:
      p = "qnx"
      code = qnx_code

    import imp
    s = imp.new_module("aspinfo_%s" % p)
    sys.modules['aspinfo_%s'%p] = s

    exec (code, s.__dict__)

    d = {}

    d['system'] = s.system
    d['echo_cmd'] = s.echo_cmd
    d['grep_amf_cmd'] = s.grep_amf_cmd
    d['proc_info_cmd'] = s.proc_info_cmd

    return d

##
## main function
##
def main(argv):
    global _interactive_shell
    global access, amfMasterHdl
    #print 'access init'
    cmds,handlers = access.Initialize()
    #print 'extend path'
    extend_path()
    
    cli = Cli(HISTORY_FILE)
    
    def usage(exit_code=0):
        print (USAGE_MSG)
        cli.onecmd('help')
        sys.exit(exit_code)

    import getopt
    try:
        opts, args = getopt.getopt(argv[1:],'hvc',['help', 'verbose', 'no-colors'])
    except getopt.GetoptError:
        usage(1)
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
        if o in ("-v", "--verbose"):
            global _dblevel
            _dblevel += 1
        if o in ("-c", "--no-colors"):
            global _do_colors
            _do_colors = False
            
    if len(args):
        t = ' '.join(args)
        cmds = t.split(",")
        for c in cmds:
          cli.onecmd(c)
        sys.exit(_exit_code)
    else:
        _interactive_shell = True
        #print 'get master node ID'
        #masterNodeId = 109 #s.amfMasterNodeIDGet()
        #print 'master node id:%d'%masterNodeId
        #if masterNodeId == 0:
        #    sys.exit('Cannot not get the master node ID. Exitting...')
        #print 'get master process handle'
        #amfMasterHdl = s.getProcessHandle(1,masterNodeId)
        get_amf_master_handle()
        try:
            cli.cmdloop("Starting interactive prompt (type 'help' for help)")
        except KeyboardInterrupt:
            print ('Exiting on Ctrl-C')
    sys.exit(0)

asp_run_env = load_asp_run_env()
sys_asp = init_sys_asp()
if __name__ == '__main__':
    main(sys.argv)
