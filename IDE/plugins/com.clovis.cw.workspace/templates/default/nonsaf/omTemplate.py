from string import Template

mopathTemplate = Template("""\
"$path"
""")


doEnumEntryTemplate = Template("""\
    CL_${doEnumName},   
""")

halConfHeaderFileTemplate = Template("""\
/******************************************************************************
 *
 * cl${compName}HalConf.h
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 ***************************** Description ************************************
 *
 * This is a header for hal library configuration. 
 *
 *****************************************************************************/

#ifndef _CL_${capCompName}_HAL_CONF_H_
#define _CL_${capCompName}_HAL_CONF_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <clCommon.h>
#include <clHalApi.h>


/**
 * The Device Id of the Ethernet Device Object , the name space of device Id is the
 * process.This implies that device Id needs to be unique in a process context but
 * same device ID could be used to address two different devices provided they are 
 * managed by different components/processes. 
 */

typedef enum ClDeviceId
{
    CL_DEVICE_ID_START = 0,
    ${deviceIDEnums}    
}ClDeviceIdT;    

#define CL_HAL_DEV_NUM_OPERATIONS  CL_HAL_DEV_NUM_STD_OPERATIONS
""")

halConfHeaderFileFooterTemplate = Template("""\
#ifdef __cplusplus
}
#endif

#endif /* _CL_${capCompName}_HAL_CONF_H_ */
""")


halConfSrcFileHeaderTemplate = Template("""\
/******************************************************************************
 *
 * cl${compName}HalConf.c
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 ***************************** Description ************************************
 *
 * This file contains the configuration part for the Clovis HAL layer
 * This is a sample C file for hal library configuration. In this file the
 * sample configuration is provided for a process which will manage a gigE port.
 *
 *****************************************************************************/
                                                                                                                                                                                    
#include <clHalApi.h>
#include <clHalObjectApi.h>
#include <clOmClassId.h>
#include <cl${compName}HalConf.h>
                                                                                                                                                                                    
/******************************************
 * Device Object Configuration
 ******************************************/

""")

deviceOperationTableTemplate = Template("""\

ClfpDevOperationT g${resName}${doName}DevOperations[] =
{
    ${init},            /* HAL_DEV_INIT             */
    ${open},            /* HAL_DEV_OPEN             */
    ${close},           /* HAL_DEV_CLOSE            */
    ${read},            /* HAL_DEV_READ             */
    ${write},           /* HAL_DEV_WRITE            */
    ${cold_boot},       /* HAL_DEV_COLD_BOOT        */
    ${warm_boot},       /* HAL_DEV_WARM_BOOT        */
    ${pwr_off},         /* HAL_DEV_PWR_OFF          */
    ${image_download},  /* HAL_DEV_IMAGE_DN_LOAD    */
    ${direct_access}    /* HAL_DEV_DIRECT_ACCESS    */
};
""")

deviceObjectTableTemplate = Template("""\
ClHalDevObjectT g${compName}DevObjectTable[]=
{
${deviceObjectTableEntries}
};
""")

deviceObjectTableEntryTemplate = Template("""\
    {
       CL_${deviceID},              /* deviceId          */
       ${deviceCapability},     /* pdevCapability    */
       ${deviceCapabilityLen},     /* devCapLen         */
       ${maxResponseTime},      /* Max Response Time */
       ${bootPriority},         /* Boot Up Priority  */
       ${doOperationTable}      /* DO Operations table referance */
    },
""")

halDevObjInfoTableTemplate = Template("""\
ClHalDevObjectInfoT g${resName}${svc}HalDevObjInfo[]=
{
${associatedDOTableEntries} 
};
""")

associatedDOTableEntryTemplate = Template("""\
    {
        CL_${deviceID},             /* deviceId */
        ${accessPriority}      /* Device Access Priority   */
    },
""")

halObjConfTableTemplate = Template("""\
ClHalObjectConfT g${compName}HalObjConf[]=
{
${halObjConfTableEntries}
};
""")

halObjConfTableEntryTemplate = Template("""\
    {
        ${omClassId}, /* OM ClassId */
        ${mopath},    /* Mo Path in string */
        g${resName}${svc}HalDevObjInfo, /* Information about the Devices */
        (sizeof(g${resName}${svc}HalDevObjInfo))/(sizeof(ClHalDevObjectInfoT))   /*Num of DevObjects */
    },
""")

halConfigTemplate = Template("""\
/* Please Do Not Modify the Init of this structure */
ClHalConfT halConfig=
{
    CL_HAL_DEV_NUM_OPERATIONS, /* From halConf.h */
     (sizeof(g${compName}DevObjectTable))/(sizeof(ClHalDevObjectT)), /* halNumDevObject */
     g${compName}DevObjectTable, /* DevObject Table */
     sizeof(g${compName}HalObjConf)/sizeof(ClHalObjectConfT),    /* halNumHalObject */
     g${compName}HalObjConf /* Hal Object Table */
 
};
""")


deviceOperationsHeadertemplate = Template("""\
/******************************************************************************
 *
 * cl${compName}DO.c
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 ***************************** Description ************************************
 *
 * This is a source file for DO configuration
 *
 *****************************************************************************/
 
#include <clHalApi.h>
#include <clHalObjectApi.h>
#include <cl${compName}HalConf.h>
                                                                                
/**
 * The declaration of functions below will come from Application Header File , for
 * the purpose of compilation they have been declared here.
 */
""")

deviceOperationMethodTemplate = Template("""\
ClRcT cl${resName}${deviceID}${methodName}(ClUint32T omId, ClCorMOIdPtrT moId, ClUint32T subOperation,
        void *pUserData, ClUint32T usrDataLen)
{
    ClRcT   rc = CL_OK;
                                                                                
    /* */
                                                                                
    return rc;
}

""")

deviceOperationMethodProtoTypeTemplate = Template("""\
ClRcT cl${resName}${deviceID}${methodName}(ClUint32T omId, ClCorMOIdPtrT   moId,
        ClUint32T subOperation,  void *pUserData, ClUint32T usrDataLen);
        
""")


oampConfigFooterTemplate = Template("""\
#ifdef __cplusplus
}
#endif                                                                                                                                                                           
                                                                                                                                                                                    
#endif /* _CL_${capCompName}_OAMP_CONFIG_H_ */
""")


#------------------------templates for cl<compName>OAMPConfig.h------------------
#------------------------------------------------------------------------------
oampConfigHeaderTemplate = Template("""\
/******************************************************************************
 *
 * cl${compName}OAMPConfig.h
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 ***************************** Description ************************************
 *
 * This is a header file for oamp configuration. 
 *
 *****************************************************************************/
 
#ifndef _CL_${capCompName}_OAMP_CONFIG_H_
#define _CL_${capCompName}_OAMP_CONFIG_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <clOmApi.h>
#include <clCorApi.h>
#include <clProvOmApi.h>
#include <clProvApi.h>
#include <clAlarmApi.h>
#include <clHalApi.h>
#include <clHalObjectApi.h>

typedef ClRcT (*fp) (CL_OM_PROV_CLASS*, ClHandleT,  ClProvTxnDataT*);

""") 

omClassTemplate = Template("""\

CL_OM_BEGIN_CLASS(CL_OM_${svcid}_CLASS,  CL_OM_${svcid}_${res}_CLASS)
${halObj}
CL_OM_END
""")

provConstDestPrototypeTemplate = Template("""\

/**
 ***********************************************************
 *  \\brief Assigns the callback functions to be called at runtime in the
 *         context of object implementer.
 *
 *  \param pThis        (in) : This is a pointer to the om client handle.
 *  \param pUsrData     (in) : Pointer to the MOID of the object being deleted. 
 *                             It is a void pointer pointing to the ClCorMOIdT 
 *                             structure. So user need to typecast it to
 *                             ClCorMOIdPtrT pointer before accessing it.
 *                             
 *  \param usrDataLen   (in) : This is the length of the user data. It is 
 *                             size of ClCorMOIdT structure.
 *  \\retval CL_OK            : The API executed successfully.
 *
 *  \par Description:
 *  When the managed object is created, this function is called by the provisioning
 *  library to assign the callback functions. These callback functions are objcectstart, 
 *  validate, update, rollback, read and objectend. These callbacks present in the object
 *  implementer's context are called when an north bound operation (create, set,
 *  get or delete) occur on the managed resource. These can be called during the
 *  provisioning initialization phase of the component.
 *  The trio of the callback functions that is validate, update and rollback
 *  functions are called when any modification is done on the managed resource.
 *  The read callback function is called when a get operation is done on a runtime
 *  or transient attribute of the managed resource. 
 *
 *  The objectstart callback function is called before calling any of the other 
 *  callback functions. The objectend callback function is called after all the 
 *  transaction requests are completed on the object. Both of these callbacks are optional. 
 *  If the user doesn't want these two callbacks to be called, then he can pass NULL 
 *  as the value. 
 *  
 *  As this function is called on the creation of a managed object, a user can add 
 *  their logic inside this function which will be called on per object basis.
 *
 *  \sa
 *  cl${compName}${res}ProvDestructor (), cl${compName}${res}ProvValidate (),
 *  cl${compName}${res}ProvUpdate(), cl${compName}${res}ProvRollback()
 */
ClRcT cl${compName}${res}${svc}Constructor( void *pThis, void *pUsrData, ClUint32T usrDataLen );

/**
 ***********************************************************
 *  \\brief This is called before removing the callback function information.
 *
 *  \param pThis        (in) : This is a pointer to the om client handle.
 *  \param pUsrData     (in) : Pointer to the MOID of the object being deleted. 
 *                             It is a void pointer pointing to the ClCorMOIdT 
 *                             structure. So user need to typecast it to
 *                             ClCorMOIdPtrT pointer before accessing it.
 *  \param usrDataLen   (in) : This is the length of the user data. It is 
 *                             size of ClCorMOIdT structure.
 *
 *  \\retval CL_OK   : The API executed successfully.
 *
 *  \par Description:
 *  This function is executed when the resource is deleted by the north bound.
 *  The information about the callback functions (objectstart, validate, update, rollback,
 *  read and the objectend function) is removed after this function is called. A user 
 *  can call its own function to delete any resource which was created during the
 *  call of the cl${compName}${res}ProvConstructor function.
 *
 *  \sa
 *  cl${compName}${res}ProvConstructor()
 */
ClRcT cl${compName}${res}${svc}Destructor ( void *pThis , void  *pUsrData, ClUint32T usrDataLen );
""")

alarmConstDestPrototypeTemplate = Template("""\

/**
 ***********************************************************
 *  \\brief A function called when the resource is created by the alarm library.
 *
 *  \param pThis        (in) : This is a pointer to the om client handle.
 *  \param pUsrData     (in) : Pointer to the MOID of the object being deleted. 
 *                             It is a void pointer pointing to the ClCorMOIdT 
 *                             structure. So user need to typecast it to
 *                             ClCorMOIdPtrT pointer before accessing it.
 *                             
 *  \param usrDataLen   (in) : This is the length of the user data. It is 
 *                             size of ClCorMOIdT structure.
 *  \\retval CL_OK            : The API executed successfully.
 *
 *  \par Description:
 *  When the managed object is created, this function is called by the alarm 
 *  library. An alarm resource specific allocation can be done in this function.
 *  The counter deallocation for this can be done in the alarm destructor function.
 *
 *  \sa
 *  cl${compName}${res}AlarmDestructor () 
 */
ClRcT cl${compName}${res}${svc}Constructor( void *pThis, void *pUsrData, ClUint32T usrDataLen );

/**
 ***********************************************************
 *  \\brief The function to deallocate the resources allocated in the alarm contructor.
 *
 *  \param pThis        (in) : This is a pointer to the om client handle.
 *  \param pUsrData     (in) : Pointer to the MOID of the object being deleted. 
 *                             It is a void pointer pointing to the ClCorMOIdT 
 *                             structure. So user need to typecast it to
 *                             ClCorMOIdPtrT pointer before accessing it.
 *  \param usrDataLen   (in) : This is the length of the user data. It is 
 *                             size of ClCorMOIdT structure.
 *
 *  \\retval CL_OK   : The API executed successfully.
 *
 *  \par Description:
 *  This function is executed when the resource is deleted by the north bound.
 *  A user can call its own function to delete any resource which was created 
 *  during the call of the clAlarmOwnerCompWORKERAlarmConstructor function.
 *
 *  \sa
 *  cl${compName}${res}AlarmConstructor()
 */
ClRcT cl${compName}${res}${svc}Destructor ( void *pThis , void  *pUsrData, ClUint32T usrDataLen );
""")

provFunctionPrototypesTemplate = Template("""\

/**
 ***********************************************************
 *  \\brief Validate the job sent from north bound
 *
 *  \param pThis        (in) : This is a pointer to the Prov class.
 *  \param txnHandle    (in) : Unique handle for one request. For a request
 *                             contain multiple jobs, this is unique and can be used
 *                             to identify the jobs which are part of same request.
 *  \param pProvTxnData (in) : This is pointer to the structure containing the
 *                             information about the set/create/delete job.
 *                             The different fields of the structure are explained
 *                             as part of the definition of ClProvTxnDataT structure
 *                             in the API reference guide.
 *  \\retval CL_OK           : The user validation is successful for this request. Any return
 *                             value other than this will make the transaction to rollback.
 *
 *  \par Description:
 *  This function is used to validate single job at a time, which is sent
 *  by the north bound station. This job can be CREATE, DELETE or SET operation.
 *  The application having this callback is the object implementer of the managed
 *  resource. A job is MOID of the object for which create or delete is done, or
 *  a MOID plus attribute Id for which set is done.
 *  The north bound request lands in COR, from where it is routed to the object
 *  implementer(s). This callback is executed in the context of OI to validate
 *  the request sent by the north bound management station, before it is updated
 *  in the OI.
 *
 *  This is one of the callback function along with update and rollback which are
 *  used to implement the transaction's ACID semantics in object implementer. These
 *  callbacks are called by the provisioning library.
 *  The object modification request is sent from the north bound. This request can
 *  be a create or delete operation or it can be a set operation on an attribute
 *  on the managed resource, containing single job or multiple jobs. Using transaciton
 *  semantics the jobs are applied to all the OIs in an all or nothing semantics.
 *
 *  For a request containing single job, this callback is called only once. If
 *  it returns success then the cl${compName}${res}ProvUpdate() will be
 *  called otherwise cl${compName}${res}ProvRollback() is called for
 *  rolling back the job.
 *  In the case of request containing multiple jobs, validate callback is called
 *  multiple times that is once for each job. If this function returns success for
 *  all the jobs, then cl${compName}${res}ProvUpdate() is called for each
 *  one of them. If validation function fails at 'r'th job for a multi request 
 *  job rollback will be called for all the first 'r' jobs.
 *
 *  \sa
 *  cl${compName}${res}ProvUpdate, cl${compName}${res}ProvRollback
 */
ClRcT cl${compName}${res}ProvValidate(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData);

/**
 ***********************************************************
 *  \\brief Update the value sent from the north bound station.
 *
 *  \param pThis        (in) : This is a pointer to the Prov class.
 *  \param txnHandle    (in) : Unique handle for one request. For a request
 *                             contain multiple jobs, this is unique and can be used
 *                             to identify the jobs which are part of same request.
 *  \param pProvTxnData (in) : This is pointer to the structure containing the
 *                             information of the set/create/delete job.
 *                             The different fields of the structure are explained
 *                             as part of the definition of ClProvTxnDataT structure
 *                             in the API reference guide.
 *  \\retval CL_OK            : Updation is successful in the application.
 *
 *  \par Description:
 *  This callback function is called for the job (that is create, delete or a set job)
 *  only if the validate callback has returned success. For a request containing multiple
 *  jobs, this callback is called only after the validation has returned success
 *  for all the jobs. For a job containing multiple sub-jobs, this callback is called for
 *  all the jobs one after the other.
 *
 *  Any error happening in the update phase is not reported to the north bound. It will
 *  be taken as success. It is assumed that the update phase never fails as the validate
 *  callback would have already done the sanity check on the job.
 *
 *  \sa
 *  cl${compName}${res}ProvValidate
 */
ClRcT cl${compName}${res}ProvUpdate(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData);

/**
 ***********************************************************
 *  \\brief Rollback the jobs for which validate is done.
 *
 *  \param pThis        (in) : This is a pointer to the Prov class.
 *  \param txnHandle    (in) : Unique handle for one request. For a request
 *                             contain multiple jobs, this is unique and can be used
 *                             to identify the jobs which are part of same request.
 *  \param pProvTxnData (in) : This is pointer to the structure containing the
 *                             information of the set/create/delete job.
 *                             The different fields of the structure are explained
 *                             as part of the definition of ClProvTxnDataT structure
 *                             in the API reference guide.
 *  \\retval CL_OK             : Rollback is done successfully in the application.
 *
 *  \par Description:
 *  This callback function is called for the job that is create, delete or set
 *  job when the validate callback returns failure.
 *
 *  For a request containing only one job, this is called once the validate callback
 *  returns failure. But for a request containing multiple jobs, this callback is
 *  called for all (including) till the job for which validate had returned failure.
 *  Like the update phase, any error happening in the rollback phase is not reported
 *  to the north bound.
 *
 *  \sa
 *  cl${compName}${res}ProvValidate
 */
ClRcT cl${compName}${res}ProvRollback(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData);

/**
 ***********************************************************
 *  \\brief  Read the value of transient attribute for a given attribute.
 *
 *  \param pThis        (in) : This is a pointer to the Prov class.
 *  \param txnHandle    (in) : Unique handle for one request. For a request
 *                             contain multiple jobs, this is unique and can be
 *                             used to identify the jobs which are part of same
 *                             request.
 *  \param pProvTxnData (in) : This is pointer to the structure containing the
 *                             information of the set/create/delete job.
 *                             The different fields of the structure are explained
 *                             as part of the definition of ClProvTxnDataT structure
 *                             in the API reference guide.
 *  \\retval CL_OK            : The API executed successfully.
 *
 *  \par Description:
 *  This callback function is called to get the value of a transient attribute.
 *  As the transient attributes of a managed resource are not stored at the COR, so
 *  for a get operation on any of these attributes, it routes the request to the
 *  the primary object implementer of the resource where this read callback is 
 *  executed to get the value for the attribute given by (pProvTxnData->attrId). 
 *  The value should be copied in the (*pProvTxnData->pProvData). This memory is
 *  allocated by the provisioning library which is of size (pProvTxnData->size) 
 *  and given to the user in the callback.
 *
 *  The user should be careful while copying value to this pointer. Only the
 *  required size given by (pProvTxnData->size) should be copied. For an array
 *  attribute, the value in the (pProvTxnData->index) contains the index from 
 *  which the value should be copied.
 *  The return value of this function is given to the user who has done the get
 *  operation on the transient otherwise runtime attribute.
 *
 */
ClRcT cl${compName}${res}ProvRead(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData);

/**
 ***********************************************************
 *  \\brief Object start callback function which will be called before
 *  starting any of the transaction requests on the object.
 *
 *  \param pMoId        (in) : Pointer to the MOID of the object on which the
 *  transaction requests are being started. 
 *  \param txnHandle    (in) : Unique handle for the transaction.
 *
 *  \\retval 
 *  None.
 *
 *  \par Description:
 *  This callback function is used to let the user know that the transactional 
 *  operations are being started on the object. This will be called before starting
 *  any of the transaction requests on the object. The 'txnHandle' is used to
 *  identify the transaction uniquely.
 *  
 *  \\note
 *  None
 *
 *  \sa
 *  cl${compName}${res}ProvObjectEnd
 *
 */
void cl${compName}${res}ProvObjectStart(ClCorMOIdPtrT pMoId, ClHandleT txnHandle);

/**
 ***********************************************************
 *  \\brief Object end callback function which will be called after
 *  completing all the transaction requests on the object.
 *
 *  \param pMoId        (in) : Pointer to the MOID of the object on which the
 *  transaction requests completed. 
 *  \param txnHandle    (in) : Unique handle for the transaction.
 *
 *  \\retval 
 *  None.
 *
 *  \par Description:
 *  This callback function is used to let the user know that the transactional 
 *  operations are being ended on the object. This will be called after completing
 *  all the transaction requests on the object. The 'txnHandle' is used to
 *  identify the transaction uniquely.
 *  
 *  \\note
 *  None
 *
 *  \sa
 *  cl${compName}${res}ProvObjectStart
 *
 */
void cl${compName}${res}ProvObjectEnd(ClCorMOIdPtrT pMoId, ClHandleT txnHandle);

""")

alarmFunctionPrototypesTemplate = Template("""\


""")


#------------------------templates for cl<compName>OAMPConfig.c------------------
#------------------------------------------------------------------------------
oampConfigSourceHeaderTemplate = Template("""\

/******************************************************************************
 *
 * cl${compName}OAMPConfig.c
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 ***************************** Description ************************************
 *
 * This is a source file for oamp configuration. 
 *
 *****************************************************************************/
 
#include <clOmClassId.h>
#include <cl${compName}OAMPConfig.h>
#define CL_MAX_OBJ 256
""")

oampConfigSourceHashDefineTemplate = Template("""\

#define ${capCompName}_${res}_${svcid}_CLASS_NAME    "CL_OM_${svcid}_${res}_CLASS_TYPE"
#define ${capCompName}_${res}_${svcid}_CLASS_VERSION    0x1
#define ${capCompName}_${res}_${svcid}_MAX_SLOTS    1   
""")

omClassTableTemplate = Template("""\

ClOmClassControlBlockT pAppOmClassTbl[] =
{
    ${omClassTableEntries}
};

ClUint32T appOmClassCnt = sizeof(pAppOmClassTbl)/sizeof(ClOmClassControlBlockT);
""")

omClassTableEntryTemplate = Template("""\
{  
    ${capCompName}_${res}_${svcid}_CLASS_NAME,
    sizeof(CL_OM_${svcid}_${res}_CLASS),
    CL_OM_${svcid}_CLASS_TYPE,
    cl${compName}${res}${svc}Constructor, 
    cl${compName}${res}${svc}Destructor,
    NULL,
    ${capCompName}_${res}_${svcid}_CLASS_VERSION,
    0,
    CL_MAX_OBJ,
    0,
    ${capCompName}_${res}_${svcid}_MAX_SLOTS,
    CL_OM_${svcid}_${res}_CLASS_TYPE
},

""")


#------------------------templates for <compName>_<Res>_.c------------------
#------------------------------------------------------------------------------
provConstructorHalBlobTemplate = Template("""\

    rc = clOmOmHandleByObjectReferenceGet(pThis, &omHandle);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while getting the OM handle from referance : [%x]\\r\\n",rc));
        return rc;
    }                                                                              
    rc = clHalObjectCreate((ClUint32T)omHandle, (ClCorMOIdPtrT)pUsrData, &((CL_OM_PROV_${res}_CLASS*)pThis)->halObj);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while creating HAL object : [%x]\\r\\n",rc));
        return rc;
    }
""")        

alarmConstructorHalBlobTemplate = Template("""\

    rc = clOmOmHandleByObjectReferenceGet(pThis, &omHandle);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while getting the OM handle from referance : [%x]\\r\\n",rc));
        return rc;
    }                                                                              
    rc = clHalObjectCreate((ClUint32T)omHandle, (ClCorMOIdPtrT)pUsrData, &((CL_OM_ALARM_${res}_CLASS*)pThis)->halObj);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while creating HAL object : [%x]\\r\\n",rc));
        return rc;
    }
""")        

alarmDestructorHalBlobTemplate = Template("""\
    rc = clHalObjectDelete(((CL_OM_ALARM_${res}_CLASS*)pThis)->halObj);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while deleting HAL object : [%x]\\r\\n",rc));
        return rc;
    }
""")        


provDestructorHalBlobTemplate = Template("""\
rc = clHalObjectDelete(((CL_OM_PROV_${res}_CLASS*)pThis)->halObj);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error while deleting HAL object : [%x]\\r\\n",rc));
        return rc;
    }
""")        

provUpdateHalBlobTemplate = Template("""\
rc = clHalObjectOperate(((CL_OM_PROV_${res}_CLASS*)pThis)->halObj, CL_HAL_DEV_WRITE, 0, CL_HAL_ACCESS_ORDER_INCR, pProvTxnData->pProvData, pProvTxnData->size, 0, 0);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Error writing into DO : [%x]\\r\\n",rc));
        return rc;
    }
""")

provFnDefsHeaderTemplate = Template("""\
/******************************************************************************
 *
 * cl${compName}${resName}.c
 *
 ******************************************************************************
 * This code is auto-generated by OpenClovis IDE Version 3.1
 *
 *****************************************************************************/

#include <cl${compName}OAMPConfig.h>
#include <clDebugApi.h>

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Additional #includes and globals go here.
 */

/*
 * ---END_APPLICATION_CODE---
 */

""")

provFnDefsTemplate = Template("""\

#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Additional user defined functions go here.
 */

/*
 * ---END_APPLICATION_CODE---
 */

/**** Prov functions */


/**
 * The Contructor function is called by the provisioning library when an object 
 * of the managed resource is created. Inside this function the callback functions
 * for validate, update, rollback and read functions are assigned. 
 * Inside this function, a user can add his or her own logic which need to be 
 * done on a per object basis. If this logic involves allocation of some resource, 
 * it can be freed in the destructor function, which is called when the managed 
 * resource is deleted.
 */ 
ClRcT cl${compName}${res}ProvConstructor( void *pThis, void *pUsrData, ClUint32T usrDataLen )
{
    ClRcT rc = CL_OK;

    /* Override "semantic check" virtual method in provClass*/
    ((CL_OM_PROV_CLASS*)pThis)->clProvObjectStart = cl${compName}${res}ProvObjectStart;      
    ((CL_OM_PROV_CLASS*)pThis)->clProvValidate = (fp)cl${compName}${res}ProvValidate;    
    ((CL_OM_PROV_CLASS*)pThis)->clProvUpdate = (fp)cl${compName}${res}ProvUpdate;    
    ((CL_OM_PROV_CLASS*)pThis)->clProvRollback = (fp)cl${compName}${res}ProvRollback;
    ((CL_OM_PROV_CLASS*)pThis)->clProvRead = (fp)cl${compName}${res}ProvRead;
    ((CL_OM_PROV_CLASS*)pThis)->clProvObjectEnd = cl${compName}${res}ProvObjectEnd;      
    
    /*
     * ---BEGIN_APPLICATION_CODE---
    */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */
     
    return rc;
}

/**
 * This function is called by the provisioning library when the managed resource 
 * is deleted. This can have logic of deleting the resources which might have 
 * been allocated in the constructor function.
 */ 
ClRcT cl${compName}${res}ProvDestructor ( void *pThis , void  *pUsrData, ClUint32T usrDataLen )
{
    ClRcT rc = CL_OK;
    
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;  
}

/**
 * This function is called by the provisioning library before forwarding any of the
 * transaction requests to this application on this managed resource. Please refer the file
 * cl${compName}${res}OAMPConfig.h for detailed documentation for this function.
 */
void cl${compName}${res}ProvObjectStart(ClCorMOIdPtrT pMoId, ClHandleT txnHandle)
{
    /*
     * ---BEGIN_APPLICATION_CODE---
    */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
    */
}

/**
 * This function is called by the provisioning library whenever the object modification 
 * operation is done on the resource being managed. This callback is called to validate
 * the job. For a single job request, this is called once before calling update or 
 * rollback based on the success or failure of this function. For a request containing
 * multiple jobs, this function is called for all the jobs for validating them.
 * Only when validation for all the jobs are success, the update callback is called for
 * all the jobs. In case of failure, the rollback it called for all the jobs till which
 * the failure was detected.
 *
 * The pThis is a pointer to the provisioning class. 
 * The txnHandle is the unique handle for all the jobs which are part of same session. So for
 * a session containing multiple jobs, then it is unique of all the jobs and it can be used
 * to identify them.
 *
 * The pProvTxnData is a pointer to the ClProvTxnDataT structure which contains 
 * the information about the job being performed on the managed resource. 
 * The pProvTxnData->provCmd stores the operation type which can be 
 * CL_COR_OP_CREATE_AND_SET, CL_COR_OP_CREATE, CL_COR_OP_SET or CL_COR_OP_DELETE
 * based on what is the operation happening on the resource.
 * In the case of set operation, the various fields of pProvTxnData provide the
 * the details about the operation which is happening on the resource. It contain 
 * MOID of the managed resource and information about the attribute on which set
 * operation is done. For a create, create-set and delete operation, the pProvTxnData 
 * contains the MOID of the resource on which the given operation is done.
 */ 
ClRcT cl${compName}${res}ProvValidate(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData)
{
    ClRcT rc = CL_OK;
    
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */
        
    return rc;
}

/**
 * This function is called by the provisioning library whenever the object modification 
 * operation is done on the resource being managed. This is called to update the jobs
 * after being validated in validate phase.
 *
 * The pThis is a pointer to the provisioning class. 
 * The txnHandle is the unique handle for all the jobs which are part of same session. So for
 * a session containing multiple jobs, then it is unique of all the jobs and it can be used
 * to identify them.
 *
 * The pProvTxnData is a pointer to the ClProvTxnDataT structure which contains 
 * the information about the job being performed on the managed resource. 
 * The pProvTxnData->provCmd stores the operation type which can be 
 * CL_COR_OP_CREATE_AND_SET, CL_COR_OP_CREATE, CL_COR_OP_SET or CL_COR_OP_DELETE
 * based on what is the operation happening on the resource.
 * In the case of set operation, the various fields of pProvTxnData provide the
 * the details about the operation which is happening on the resource. It contain 
 * MOID of the managed resource and information about the attribute on which set
 * operation is done. For a create, create-set and delete operation, the pProvTxnData 
 * contains the MOID of the resource on which the given operation is done.
 */ 
ClRcT cl${compName}${res}ProvUpdate(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData)
{
    ClRcT rc = CL_OK;

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */
     
    switch (pProvTxnData->provCmd)
    {
        case CL_COR_OP_CREATE :
        case CL_COR_OP_CREATE_AND_SET:
            
        /*
         * ---BEGIN_APPLICATION_CODE---
         */

        /*
         * ---END_APPLICATION_CODE---
         */

        break;
        case CL_COR_OP_SET:
        
        /*
         * ---BEGIN_APPLICATION_CODE---
         */
    
        /*
         * ---END_APPLICATION_CODE---
         */

        break;

        case  CL_COR_OP_DELETE:

        /*
         * ---BEGIN_APPLICATION_CODE---
         */

        /*
         * ---END_APPLICATION_CODE---
         */

        break;
        default:
            clprintf (CL_LOG_SEV_ERROR, "Prov command is not proper");

    }

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;   
}


/**
 * This function is called by the provisioning library whenever the object 
 * modification operation is done on the resource being managed. For a single job 
 * request, this function is called if the validate function is failed. For a 
 * multiple job request, on encountering a validate failure, this function is 
 * called to rollback all the jobs before the one (including) on which the 
 * validation failure is reported.
 *
 * The pThis is a pointer to the provisioning class. 
 * The txnHandle is the unique handle for all the jobs which are part of same session. So for
 * a session containing multiple jobs, then it is unique of all the jobs and it can be used
 * to identify them.
 * 
 * The pProvTxnData is a pointer to the ClProvTxnDataT structure which contains 
 * the information about the job being performed on the managed resource. 
 * The pProvTxnData->provCmd stores the operation type which can be 
 * CL_COR_OP_CREATE_AND_SET, CL_COR_OP_CREATE, CL_COR_OP_SET or CL_COR_OP_DELETE
 * based on what is the operation happening on the resource.
 * In the case of set operation, the various fields of pProvTxnData provide the
 * the details about the operation which is happening on the resource. It contain 
 * MOID of the managed resource and information about the attribute on which set
 * operation is done. For a create, create-set and delete operation, the pProvTxnData 
 * contains the MOID of the resource on which the given operation is done.
 */
ClRcT cl${compName}${res}ProvRollback(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData)
{
    ClRcT rc = CL_OK;

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;
}

/**
 * This function is called to perform a get operation on the transient attribute
 * which is owned by the primary object implementer (OI). As the COR doesn't have
 * the latest value of the transient attribute, it is obtained from the OI. This
 * function is called in the OI's context which it can use to fill the latest
 * value of the runtime or transient attribute.
 *
 * The pThis is pointer to the provisioning class.
 * The txnHandle is used to identify the jobs which are part of same bundle request.
 * For single request this field is of not much significance, but for a multiple job
 * request, this feild is used to identify all the jobs which are part of same
 * bundle request sent by COR.
 *
 * The pProvTxnData contains the information about the attribute jobs. It contains 
 * the MOId of the managed resource, the attribute identifier, its type (array or 
 * simple), its basic type (data type), index (in case it is array attriubte), 
 * size and the pointer (allocated by the library) to the memory on which the 
 * data can be copied.
 *
 * For a request containing only single job, this function is called only once. But
 * for a multiple job request, this is called for all the attributes one at a time.
 */ 
ClRcT cl${compName}${res}ProvRead(CL_OM_PROV_CLASS* pThis, ClHandleT txnHandle, ClProvTxnDataT* pProvTxnData)
{
    ClRcT rc = CL_OK;

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;
}

/**
 * This function is called by the provisioning library after all the transaction requests
 * for this managed resource are forwarded to this application. Please refer the file
 * cl${compName}${res}OAMPConfig.h for detailed documentation for this function.
 */
void cl${compName}${res}ProvObjectEnd(ClCorMOIdPtrT pMoId, ClHandleT txnHandle)
{
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "Inside the function %s", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */
}
""")

alarmFnDefsTemplate = Template("""\

/************** Alarm functions ************/

/**
 * The constructor function will be called when a resource
 * being managed by the alarm library is create by it.
 * This function is called on per resource basis, so a user
 * can do some operation ( like allocation of some resource)
 * that is necessary for each resource being managed.
 */
ClRcT cl${compName}${res}AlarmConstructor( void *pThis, void *pUsrData, ClUint32T usrDataLen )
{
    ClRcT rc = CL_OK;

    return rc;
}

/**
 * The destructor function is called by the alarm client library
 * either when the object is deleted from the north bound or the
 * when the alarm library is finalized. So this function allows to
 * do the counter operation (like deallocation for the resources)
 * to what was done in alarm constructor.
 */
ClRcT cl${compName}${res}AlarmDestructor ( void *pThis , void  *pUsrData, ClUint32T usrDataLen )
{
    ClRcT rc = CL_OK;

    return rc;
}
""")
