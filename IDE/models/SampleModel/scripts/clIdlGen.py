################################################################################
# ModuleName  : SampleModel
# $File$
# $Author$
# $Date$
################################################################################
# Description :
################################################################################
#! /usr/local/bin/python
import sys
import os
import string
import pdb
import xml.dom.minidom
from string import Template
from string import upper, lower

#The working of the script:
#It uses a xml.dom.minidom to parse the xml file & create a
#tree out of it. This tree has multiple levels at which relevant
#information is stored. It then descends the various levels & at
#every level, it consumes information & generates code for it.
#At every higher level, the code generated by the lower level is
#substituted in templates to generate bigger constructs. At the
#highest level, the code files are generated. This script uses
#"templates" and "dictionaries"(hereafter referred as map)
#construct in python extensively for the above.

#template for xdr header
clientIDHeader = Template('''
#ifndef _CLIENTID_H_
#define _CLIENTID_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <clEoApi.h>

${clientIDs}

#ifdef __cplusplus
}
#endif

#endif /*_CLIENTID_H_*/

''')

clientIDHeaderT = Template('''
#define ${clientId} (CL_EO_USER_CLIENT_ID_START + ${number})
''')

#template for xdr header
xdrHeaderT = Template('''
#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

struct _${type};
#include "clXdrApi.h"

${includeList}
${udtDefinition}

ClRcT  clXdrMarshall${type}(void *,ClBufferMessageHandleT , ClUint32T);

ClRcT  clXdrUnmarshall${type}(ClBufferMessageHandleT, void *);

#define clXdrMarshallArray${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallArray((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallArray${type}(msg,pointer, multiplicity) \\
clXdrUnmarshallArray((msg),(pointer), sizeof(${type}), (multiplicity), clXdrUnmarshall${type})

#define clXdrMarshallPointer${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallPointer((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallPointer${type}(msg,pointer) \\
clXdrUnmarshallPointer((msg),(pointer), sizeof(${type}), clXdrUnmarshall${type})

#ifdef __cplusplus
}
#endif

#endif /*_XDR_${TYPE}_H_*/

''')

#template for UDT member definition code
memberT = Template('''\
    ${hdrType}    ${name};
''')


def getCFileName(strName):
	return 'xdr' + upper(strName[0]) + strName[1:] + '.c'


def getHFileName(strName):
	return 'xdr' + upper(strName[0]) + strName[1:] + '.h'


def parseDataMember(userDT,prepend, member, structUnions):
	#this function parses a datamember 'member'. It creates a map
	#'memAttrMap' of all attributes of the member and gives out code
	#snippets relevant to this member in the map
	memAttrMap = dict()
	memAttrMap['name'] = member.attributes['name'].value
	memAttrMap['includeList'] = ''
	temp = clTypes.get(member.attributes.get('type').value)
	if temp != None:
		memAttrMap['type'] = temp
	else:
		memAttrMap['type'] = member.attributes['type'].value
		memAttrMap['includeList'] = '#include "' + getHFileName(member.attributes['type'].value) + '''"
'''
	memAttrMap['memberDT'] = memAttrMap['type']
	memAttrMap['marshallEntry'] = 'pVar' + '->' + prepend + memAttrMap['name']
	memAttrMap['unmarshallEntry'] = 'pVar' + '->' + prepend + memAttrMap['name']
	if member.attributes.has_key('pointer'):
		if member.attributes['pointer'].value == 'true':
			#member is a pointer
			memAttrMap['type'] += '*'
			memAttrMap['memberDT'] = 'Pointer' + memAttrMap['memberDT']
			if member.attributes.has_key('lengthVar'):
				#member is a pointer with length variable
				memAttrMap['marshallEntry'] += ', ' + 'pVar' + '->' + prepend + member.attributes['lengthVar'].value
			else:
				#member is a pointer without length variable
				memAttrMap['marshallEntry'] += ', 1'
			memAttrMap['unmarshallEntry'] = '(void**)&(' + memAttrMap['unmarshallEntry'] + ')'
	if member.attributes.has_key('multiplicity'):
		#member is an array
		memAttrMap['memberDT'] = 'Array' + memAttrMap['memberDT']
		memAttrMap['marshallEntry'] += ', ' + member.attributes['multiplicity'].value
		memAttrMap['unmarshallEntry'] += ', ' + member.attributes['multiplicity'].value
		memAttrMap['name'] += '[' + member.attributes['multiplicity'].value + ']'
	if not member.attributes.has_key('multiplicity'):
		if not member.attributes.has_key('pointer'):
			#member is none of the above, i.e. an ordinary variable
			memAttrMap['marshallEntry'] = '&(' + memAttrMap['marshallEntry'] + ')'
			memAttrMap['unmarshallEntry'] = '&(' + memAttrMap['unmarshallEntry'] + ')'
	temp = len([udt for udt in structUnions if member.attributes.get('type').value == udt])
#	if temp != 0:
#            if userDT.attributes.has_key("defNeed"):
#                memAttrMap['hdrType'] = memAttrMap['type']
#            else:            
#    		memAttrMap['hdrType'] = 'struct _' + memAttrMap['type']
#	else:
        if (userDT.attributes['name'].value == member.attributes['type'].value):
    		memAttrMap['hdrType'] = 'struct _' + memAttrMap['type']
        else:
		memAttrMap['hdrType'] = memAttrMap['type']
	return memAttrMap


#structure definition template
structMemberDefnT = Template('''
typedef struct _${type} {
${memberList}
}${type};
''')

#snippet for member marshalling
marshallStructMemberT = Template('''
    rc = clXdrMarshall${memberDT}(${marshallEntry},msg,isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#snippet for member unmarshalling
unmarshallStructMemberT = Template('''
    rc = clXdrUnmarshall${memberDT}(msg,${unmarshallEntry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#C file code generation template for xdr marshalling of struct
xdrMarshallStructCodeT = Template('''

#include "xdr${type1}.h"


ClRcT clXdrMarshall${type}(void* pGenVar, ClBufferMessageHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

${marshalledMemberList}

    return rc;
}
''')
xdrUnMarshallStructCodeT = Template('''
#include "xdr${type1}.h"

        
ClRcT clXdrUnmarshall${type}(ClBufferMessageHandleT msg , void* pGenVar)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

${unmarshalledMemberList}

    return rc;
}

''')


def parseStruct(genFilesDir, struct, structUnions,files):
	#this function parses a structure 'struct' and generates
	#the xdr marshalling/unmarshalling .c & .h files for that struct
	xdrAttrMap = dict()
	xdrAttrMap['includeList'] = ''
        for file in files:
            xdrAttrMap['includeList'] +='#include "' + file +'"'+'\n'
	xdrAttrMap['memberList'] = ''
	xdrAttrMap['marshalledMemberList'] = ''
	xdrAttrMap['unmarshalledMemberList'] = ''
	prepend = ''
	for member in struct.getElementsByTagName('DataMember'):
		memAttrMap = dict()
		memAttrMap = parseDataMember(struct,prepend, member, structUnions)
		xdrAttrMap['includeList'] += memAttrMap['includeList']
		xdrAttrMap['memberList'] += memberT.safe_substitute(memAttrMap)
		xdrAttrMap['marshalledMemberList'] += marshallStructMemberT.safe_substitute(memAttrMap)
		xdrAttrMap['unmarshalledMemberList'] += unmarshallStructMemberT.safe_substitute(memAttrMap)
	xdrAttrMap['type'] = struct.attributes['name'].value#changes here Ramesh to resolve first character
        xdrAttrMap['type1'] = upper(xdrAttrMap['type'][0])+xdrAttrMap['type'][1:]
	xdrAttrMap['TYPE'] = upper(xdrAttrMap['type'])
#        if struct.attributes.has_key("defNeed"): # fix for 4052 - always define the user defined struct/enum
    	xdrAttrMap['udtDefinition'] = structMemberDefnT.safe_substitute(xdrAttrMap)
#        else:    
#            xdrAttrMap['udtDefinition'] =''
        fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(struct.attributes['name'].value), 'w')
        fXdrH.write(xdrHeaderT.safe_substitute(xdrAttrMap))
        fXdrH.close()
        fXdrMarshalC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(struct.attributes['name'].value +"Marshall"), 'w')
        fXdrMarshalC.write(xdrMarshallStructCodeT.safe_substitute(xdrAttrMap))
        fXdrMarshalC.close()
        fXdrUnMarshalC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(struct.attributes['name'].value + "UnMarshall"),'w')
        fXdrUnMarshalC.write(xdrUnMarshallStructCodeT.safe_substitute(xdrAttrMap))
        fXdrUnMarshalC.close()


#template for defining the union
unionMemberDefnT = Template('''
typedef enum _${type}EnumT
{
${enumMemberList}
} ${type}EnumT;

typedef struct _${type}
{
    ${type}EnumT discriminant;
    union
    {
${memberList}
    }${unionName};
}${type};
''')

#union member marshalling code snippet
marshallUnionMemberT = Template('''
        case (ClInt32T)${discVal}:
            rc = clXdrMarshall${memberDT}(${marshallEntry}, msg, isDelete);
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

#union member unmarshalling code snippet
unmarshallUnionMemberT = Template('''
        case (ClInt32T)${discVal}:
            rc = clXdrUnmarshall${memberDT}(msg,${unmarshallEntry});
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

#C file code generation template for xdr marshalling of union
xdrMarshallUnionCodeT = Template('''
#include <netinet/in.h>
#include "xdr${type1}.h"


ClRcT clXdrMarshall${type}(void *pGenVar,ClBufferMessageHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    rc = clXdrMarshallClInt32T(&(pVar->discriminant),msg, isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
${marshalledMemberList}
        default:
            return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }

    return rc;
}
''')
xdrUnMarshallUnionCodeT = Template('''
#include <netinet/in.h>        
#include "xdr${type1}.h"
        
ClRcT clXdrUnmarshall${type}(ClBufferMessageHandleT msg , void *pGenVar)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    if (0 == msg)
    {
        return CL_XDR_RC(CL_ERR_INVALID_BUFFER);
    }

    rc = clXdrUnmarshallClInt32T(msg,&(pVar->discriminant));
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
${unmarshalledMemberList}
        default:
            return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }

    return rc;
}

''')

def parseUnion(genFilesDir, union, structUnions):
	#this function parses a structure 'union' and generates
	#the xdr marshalling/unmarshalling .c & .h files for that union
	xdrAttrMap = dict()
	xdrAttrMap['includeList'] = ''
	xdrAttrMap['memberList'] = ''
	xdrAttrMap['enumMemberList'] = ''
	xdrAttrMap['marshalledMemberList'] = ''
	xdrAttrMap['unmarshalledMemberList'] = ''
	xdrAttrMap['type'] = union.attributes['name'].value
        xdrAttrMap['type1'] = upper(xdrAttrMap['type'][0]) + xdrAttrMap['type'][1:];#added code here Ramesh
	xdrAttrMap['discVal'] = ''
	firstEnumValue = ' = 1'
	xdrAttrMap['unionName'] = lower(xdrAttrMap['type'][0]) + xdrAttrMap['type'][1:]
	for member in union.getElementsByTagName('DataMember'):
		memAttrMap = dict()
		memAttrMap = parseDataMember(union,xdrAttrMap['unionName'] + '.', member, structUnions)
		memAttrMap['discVal'] = upper(xdrAttrMap['type'] + member.attributes['name'].value)
		xdrAttrMap['includeList'] += memAttrMap['includeList']
		xdrAttrMap['memberList'] += '    ' + memberT.safe_substitute(memAttrMap)
		xdrAttrMap['enumMemberList'] += '    ' + memAttrMap['discVal'] + firstEnumValue + ''',
'''
		firstEnumValue = ''
		xdrAttrMap['marshalledMemberList'] += marshallUnionMemberT.safe_substitute(memAttrMap)
		xdrAttrMap['unmarshalledMemberList'] += unmarshallUnionMemberT.safe_substitute(memAttrMap)
	xdrAttrMap['TYPE'] = upper(xdrAttrMap['type'])
	xdrAttrMap['udtDefinition'] = unionMemberDefnT.safe_substitute(xdrAttrMap)
	xdrAttrMap['enumMemberList'] += xdrAttrMap['enumMemberList'][:-2]
	fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(xdrAttrMap['type']), 'w')
	fXdrH.write(xdrHeaderT.safe_substitute(xdrAttrMap))
        fXdrH.close()
	fXdrMarshallC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(union.attributes['name'].value + "Marshall"), 'w')
	fXdrMarshallC.write(xdrMarshallUnionCodeT.safe_substitute(xdrAttrMap))
        fXdrMarshallC.close()
	fXdrUnMarshallC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(union.attributes['name'].value + "UnMarshall"), 'w')
	fXdrUnMarshallC.write(xdrUnMarshallUnionCodeT.safe_substitute(xdrAttrMap))
        fXdrUnMarshallC.close()

#template for xdr header for enum
xdrEnumHeaderT = Template('''
#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "clXdrApi.h"
${includeList}
${udtDefinition}

#define      clXdrMarshall${type}               clXdrMarshallClInt32T

#define      clXdrUnmarshall${type}             clXdrUnmarshallClInt32T

#define      clXdrMarshallArray${type}          clXdrMarshallArrayClInt32T

#define      clXdrUnmarshallArray${type}        clXdrUnmarshallArrayClInt32T

#define      clXdrMarshallPointer${type}        clXdrMarshallPointerClInt32T

#define      clXdrUnmarshallPointer${type}      clXdrUnmarshallPointerClInt32T

#ifdef __cplusplus
}
#endif

#endif /*_XDR_${TYPE}_H_*/

''')

#enum definition template
enumDefnT = Template('''
typedef enum _${type}
{
${memberList}
} ${type};
''')

def parseEnum(genFilesDir, enum, structUnionsi,files):
	#this function parses a structure 'enum' and generates
	#the xdr marshalling/unmarshalling .h file for that enum
	xdrAttrMap = dict()
	xdrAttrMap['memberList'] = ''
        xdrAttrMap['includeList'] = ''
        for file in files:
            xdrAttrMap['includeList']+='#include "' + file +'"'+"\n"    
	for member in enum.getElementsByTagName('EnumMember'):
		if member.attributes.has_key('value'):
			xdrAttrMap['memberList'] += '    ' + member.attributes['name'].value +\
                        ' = ' + member.attributes['value'].value + ''',
'''
		else:
			xdrAttrMap['memberList'] += '    ' + member.attributes['name'].value + ''',
'''
	xdrAttrMap['memberList'] = xdrAttrMap['memberList'][:-2]
	xdrAttrMap['type'] = enum.attributes['name'].value
	xdrAttrMap['TYPE'] = upper(xdrAttrMap['type'])
#        if enum.attributes.has_key("defNeed"):
	xdrAttrMap['udtDefinition'] = enumDefnT.safe_substitute(xdrAttrMap)
#        else:
#            xdrAttrMap['udtDefinition'] = ''
	fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(enum.attributes['name'].value), 'w')
	fXdrH.write(xdrEnumHeaderT.safe_substitute(xdrAttrMap))
        fXdrH.close()

def createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo):
	#this is a generic stub creation routine. It parses a parameter
	#and invokes functions & templates passed to it through a map 'genTemplateT'
	#to create different kinds of stubs
#argMap = dict()
#	argMap['in'] = [arg for arg in service.getElementsByTagName('Argument')\
#                        if arg.attributes['ParameterType'].value == 'IN']
#	argMap['inout'] = [arg for arg in service.getElementsByTagName('Argument')\
#                          if arg.attributes['ParameterType'].value == 'INOUT']
#	argMap['out'] = [arg for arg in service.getElementsByTagName('Argument')\
#                         if arg.attributes['ParameterType'].value == 'OUT']

	inPtr = 0
	inoutPtr = 0
	outPtr = 0
	ptrNum = dict([('in', inPtr), ('inout', inoutPtr), ('out', outPtr)]);

	replyNeeded = 0
	inMsgNeeded = 0
	unused = 0
	reply = dict([('in', unused), ('inout', replyNeeded), ('out', replyNeeded)])
	inMsg = dict([('in', inMsgNeeded), ('inout', inMsgNeeded), ('out', unused)])
        argTypeNum = dict([('in',0),('inout',0),('out',0)]);
        convert = dict()
        convert['CL_IN']  = "in"
        convert['CL_OUT'] = "out"
	argNum = 0

	funcAttrMap = dict()
	genTemplateT['init'](funcAttrMap)
        for arg in service.getElementsByTagName('Argument'):
            argType = arg.attributes['ParameterType'].value
            if argType == "CL_INOUT":
                print "CL_INOUT option is not allowed"
                sys.exit();
            argType = convert[arg.attributes['ParameterType'].value]   
            argAttrMap = dict()
            #get the name
            argAttrMap['name'] = arg.attributes['name'].value
            #get the type
            temp = clTypes.get(arg.attributes.get('type').value)
            if temp != None:
                argAttrMap['type'] = temp
            else:
                argAttrMap['type'] = arg.attributes['type'].value
                typeNeeded[argAttrMap['type']] = 1
            argAttrMap['argNum'] = argNum
            argAttrMap['argTypeNum'] = argTypeNum[argType]
            if arg.attributes.has_key('pointer'):
                if arg.attributes['pointer'].value == 'true':
                    if arg.attributes.has_key('lengthVar'):
                        #element passed is array
                        ptrNum[argType] += 1
                        argAttrMap['lengthVar'] = arg.attributes['lengthVar'].value
                        genTemplateT['append'](funcAttrMap, genTemplateT['asPtrWithLength'][argType](argAttrMap))
                    else:
                        #element is passed by reference
                        genTemplateT['append'](funcAttrMap, genTemplateT['byReference'][argType](argAttrMap))
            else:
            #element is passed by value
                genTemplateT['append'](funcAttrMap, genTemplateT['byValue'][argType](argAttrMap))
            argNum += 1
            argTypeNum[argType]+=1;
            inMsg[argType] += 1
            reply[argType] += 1
	funcAttrMap['funcNo'] = 'CL_EO_GET_FULL_FN_NUM(' + clientId + ', ' + str(serviceNo) + ')'
	funcAttrMap['name'] = service.attributes['name'].value
	funcAttrMap['inPtr'] = ptrNum['in']
	funcAttrMap['inoutPtr'] = ptrNum['inout']
	funcAttrMap['outPtr'] = ptrNum['out']
	funcAttrMap['replyNeeded'] = reply['out'] + reply['inout']
	funcAttrMap['inMsgNeeded'] = inMsg['in'] + reply['inout']
	funcAttrMap['argNum'] = argNum
	funcAttrMap['eoName'] = eo
	funcOutput = dict()
	funcOutput['code'] = genTemplateT['function'](funcAttrMap)
	funcOutput['header'] = genTemplateT['header'].safe_substitute(funcAttrMap)
	return funcOutput



def doNothing(argAttrMap):
	return None

#template as indicated by name
pointerLengthWriteT = Template('''
    temp1 = htonl(${lengthVar});
    rc = clBufferMessageNBytesWrite(${inMsg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        return rc;
    }
''')

#template as indicated by name
pointerLengthReadT = Template('''
    temp2 = sizeof(ClUint32T);
    rc = clBufferMessageNBytesRead(${outMsg}, (ClUint8T*)&temp1, &temp2);
    if (rc != CL_OK)
    {
        return rc;
    }
''')

#template to marshall IN parameters
inSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${inMsg}, 0);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

#template to marshall INOUT parameters
inoutSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${inMsg}, 1);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

#template to unmarshall OUT parameters
outSyncClientUnmarshallT = Template('''
    rc = clXdrUnmarshall${memberFuncType}( ${outMsg}, ${unmarshallEntry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#we have 7 types of parameters. They are described as follows:
# IN by value
# IN by reference
# IN as pointer with length variable
# INOUT by reference
# INOUT as pointer with length variable
# OUT by reference
# OUT as pointer with length variable
#There are subtle differences as to the code snippet generated
#for each of these parameter types. Therfore we have different
#functions for each of these types.

def inSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
	marshallMap['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	marshallMap['unmarshallEntry'] = ''
	marshallMap['lengthVar'] = argAttrMap['lengthVar']
	funcAttrMap['marshallList'] = pointerLengthWriteT.safe_substitute(marshallMap)
	funcAttrMap['marshallList'] += inSyncClientMarshallT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


def inoutSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_INOUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
	marshallMap['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	marshallMap['unmarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	marshallMap['lengthVar'] = argAttrMap['lengthVar']
	funcAttrMap['marshallList'] = pointerLengthWriteT.safe_substitute(marshallMap)
	funcAttrMap['marshallList'] += inoutSyncClientMarshallT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] = pointerLengthReadT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] += outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap


def outSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_OUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
	marshallMap['marshallEntry'] = ''
	marshallMap['unmarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	funcAttrMap['marshallList'] = ''
	funcAttrMap['unmarshallList'] = pointerLengthReadT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] += outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap

def inSyncByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = argAttrMap['type']
	marshallMap['marshallEntry'] = argAttrMap['name']
	funcAttrMap['marshallList'] = inSyncClientMarshallT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


def inoutSyncByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_INOUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = argAttrMap['type']
	marshallMap['marshallEntry'] = argAttrMap['name']
	marshallMap['unmarshallEntry'] = argAttrMap['name']
	funcAttrMap['marshallList'] = inoutSyncClientMarshallT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap


def outSyncByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_OUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = argAttrMap['type']
	marshallMap['unmarshallEntry'] = argAttrMap['name']
	funcAttrMap['marshallList'] = ''
	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap


def inSyncByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for sync client stub
	funcAttrMap = dict()
	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + ' ' + argAttrMap['name']
	marshallMap = dict()
	marshallMap['memberFuncType'] = argAttrMap['type']
	marshallMap['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
	funcAttrMap['marshallList'] = inSyncClientMarshallT.safe_substitute(marshallMap)
	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


createOutMsgT = Template('''
    ${rc} = clBufferMessageCreate(&${outMsg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')


createInMsgT = Template('''

    ${rc} = clBufferMessageCreate(&${inMsg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')


deleteOutMsgT = Template('''\
clBufferMessageDelete(&${outMsg});
    ''')

#template for generating sync client stub
syncClientT = Template('''
ClRcT ${name}ClientSync(CL_IN ClIdlHandleT handle${decl})
{
    ClRcT rc = CL_OK;
    ClUint32T funcNo = ${funcNo};
    ClBufferMessageHandleT ${inMsg} = 0;
    ClBufferMessageHandleT ${outMsg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClUint32T tempFlags = 0;${temp1}${temp2}

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if( rc != CL_OK )
    {
        return rc ;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            return rc;
        }
    }
    else
    {
        return CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
    }${createInMsg}
${marshallList}
${createOutMsg}
    tempFlags |= pHandleObj->flags |
                 (CL_RMD_CALL_NON_PERSISTENT${flagNeedReply});
    tempFlags &= ~CL_RMD_CALL_ASYNC;

    rc = clRmdWithMsg(address, funcNo, ${inMsg}, ${outMsg}, tempFlags, &(pHandleObj->options), NULL);
    if(CL_OK != rc)
    {
        ${deleteOutMsg}return rc;
    }

${unmarshallList}
    ${deleteOutMsg}
    rc = clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;
}
''')

#template for #defining the function call <func> as <func>ClientSync
syncHeaderT = Template('''
#define ${name} ${name}ClientSync
ClRcT ${name}ClientSync(CL_IN ClIdlHandleT handle${decl});
''')


def syncInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['decl'] = ''
	funcAttrMap['funcNo'] = ''
	funcAttrMap['marshallList'] = ''
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['temp1'] = ''
	funcAttrMap['temp2'] = ''
	funcAttrMap['ptrChecks'] = ''
	funcAttrMap['outMsgCreate'] = ''
	funcAttrMap['outMsgDelete'] = ''
	funcAttrMap['inMsgCreate'] = ''
	funcAttrMap['flagNeedReply'] = ''


def syncAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['marshallList'] += argEntryToAdd['marshallList']
	funcAttrMap['unmarshallList'] += argEntryToAdd['unmarshallList']
	funcAttrMap['decl'] += ', ' + argEntryToAdd['decl']


def createSyncFunc(funcAttrMap):
	inPtr = funcAttrMap['inPtr'] + funcAttrMap['inoutPtr']
	outPtr = funcAttrMap['outPtr'] + funcAttrMap['inoutPtr']
	if outPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
		funcAttrMap['temp2'] = '''
    ClUint32T temp2 = 0;'''
	elif inPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
		funcAttrMap['temp2'] = ''
	else:
		funcAttrMap['temp1'] = ''
		funcAttrMap['temp2'] = ''
	if funcAttrMap['replyNeeded'] > 0:
		funcAttrMap['createOutMsg'] = createOutMsgT.safe_substitute()
		funcAttrMap['deleteOutMsg'] = deleteOutMsgT.safe_substitute()
		funcAttrMap['flagNeedReply'] = ' | CL_RMD_CALL_NEED_REPLY'
	else:
		funcAttrMap['createOutMsg'] = ''
		funcAttrMap['deleteOutMsg'] = ''
		funcAttrMap['deleteOutMsg'] = ''
	if funcAttrMap['inMsgNeeded'] > 0:
		funcAttrMap['createInMsg'] = createInMsgT.safe_substitute()
	else:
		funcAttrMap['createInMsg'] = ''
	return syncClientT.safe_substitute(funcAttrMap)
		

def createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate sync stub
	genTemplateT = dict()
	genTemplateT['init'] = syncInit
	genTemplateT['append'] = syncAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inSyncAsPtrWithLength),\
						('inout', inoutSyncAsPtrWithLength),\
						('out', outSyncAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inSyncByReference),\
						('inout', inoutSyncByReference),\
						('out', outSyncByReference)])
	genTemplateT['byValue'] = dict([('in', inSyncByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['function'] = createSyncFunc
	genTemplateT['header'] = syncHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo)




asyncCreateOutMsgT = Template('''
        ${rc} = clBufferMessageCreate(&${outMsg});
        if (CL_OK != ${rc})
        {
            goto L2;
        }
''')

asyncCreateInMsgT = Template('''

    ${rc} = clBufferMessageCreate(&${inMsg});
    if (CL_OK != ${rc})
    {
        goto L;
    }''')

inAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${callMemberFuncType}(${callMarshallEntry}, ${inMsg}, 0);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inoutAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${callMemberFuncType}(${callMarshallEntry}, ${inMsg}, 1);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inAsyncUnmarshallT = Template('''
    retVal = clXdrUnmarshall${cbMemberFuncType}(${inMsg}, ${cbUnmarshallEntry});
    if (CL_OK != retVal)
    {
        goto L${argNum};
    }
''')

outAsyncUnmarshallT = Template('''
    if (CL_OK == rc)
    {
        retVal = clXdrUnmarshall${cbMemberFuncType}(${outMsg}, ${cbUnmarshallEntry});
        if (CL_OK != retVal)
        {
            goto L${argNum};
        }
    }
''')

asyncUnmarshallErrorEntryT = Template('''\
L${argNumPlusOne}:  clXdrMarshall${cbMemberFuncType}(${cbErrorMarshallEntry},0, 1);
''')

asyncPointerLengthWriteT = Template('''
    temp1 = htonl(${lengthVar});
    rc = clBufferMessageNBytesWrite(${inMsg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        goto L;
    }
''')

def asyncAsPtrWithLength(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outAsyncAsPointerwithLength is
	#made into a function and called in the respective functions
	map['callMemberFuncType'] = 'Array' + argAttrMap['type']
	map['callMarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	map['cbMemberFuncType'] = 'Pointer' + argAttrMap['type']
	map['cbUnmarshallEntry'] = '(void**)&(' + argAttrMap['name'] + ')'
	map['cbErrorMarshallEntry'] = map['callMarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	map['lengthVar'] = argAttrMap['lengthVar']
	funcAttrMap['callDecl'] += argAttrMap['type'] + '* ' + argAttrMap['name']
	funcAttrMap['cbDecl'] = argAttrMap['type'] + '* ' + argAttrMap['name']
	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '*))'
	funcAttrMap['callMarshallList'] = asyncPointerLengthWriteT.safe_substitute(map)
	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['argList'] = argAttrMap['name']


def inAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_IN '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] += inAsyncClientMarshallT.safe_substitute(map)
	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inoutAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_INOUT '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] += inoutAsyncClientMarshallT.safe_substitute(map)
	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def outAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_OUT '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] = ''
	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def asyncByReference(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outAsyncByReference is
	#made into a function and called in the respective functions
	map['callMemberFuncType'] = argAttrMap['type']
	map['callMarshallEntry'] = argAttrMap['name']
	map['cbMemberFuncType'] = argAttrMap['type']
	map['cbUnmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['cbErrorMarshallEntry'] = map['cbUnmarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	funcAttrMap['callDecl'] += argAttrMap['type'] + '* ' + argAttrMap['name']
	funcAttrMap['cbDecl'] = argAttrMap['type'] + '  ' + argAttrMap['name']
	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '))'
	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['argList'] = '&(' + argAttrMap['name'] + ')'


def inAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_IN '
	asyncByReference(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] = inAsyncClientMarshallT.safe_substitute(map)
	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inoutAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_INOUT '
	asyncByReference(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] = inoutAsyncClientMarshallT.safe_substitute(map)
	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def outAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_OUT '
	asyncByReference(funcAttrMap, argAttrMap, map)
	funcAttrMap['callMarshallList'] = ''
	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inAsyncByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for async client stub
	funcAttrMap = dict()
	map = dict()
	map['callMemberFuncType'] = argAttrMap['type']
	map['callMarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['cbMemberFuncType'] = argAttrMap['type']
	map['cbUnmarshallEntry'] = map['callMarshallEntry']
	map['cbErrorMarshallEntry'] = map['cbUnmarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	funcAttrMap['callDecl'] = 'CL_IN ' + argAttrMap['type'] + '  ' + argAttrMap['name']
	funcAttrMap['cbDecl'] = argAttrMap['type'] + '  ' + argAttrMap['name']
	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '))'
	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['callMarshallList'] = inAsyncClientMarshallT.safe_substitute(map)
	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	funcAttrMap['argList'] = argAttrMap['name']
	return funcAttrMap


def asyncInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['callDecl'] = ', '
	funcAttrMap['cbDecl'] = ''
	funcAttrMap['funcNo'] = ''
	funcAttrMap['callMarshallList'] = ''
	funcAttrMap['cbErrorMarshallList'] = ''
	funcAttrMap['cbUnmarshallList'] = ''
	funcAttrMap['cbMemset'] = ''
	funcAttrMap['argList'] = ''
	funcAttrMap['temp1'] = ''
	funcAttrMap['temp2'] = ''
	funcAttrMap['ptrChecks'] = ''
	funcAttrMap['outMsgCreate'] = ''
	funcAttrMap['outMsgDelete'] = ''
	funcAttrMap['inMsgCreate'] = ''
	funcAttrMap['flagNeedReply'] = ''


def asyncAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['callDecl'] += argEntryToAdd['callDecl'] + ', '
	funcAttrMap['cbDecl'] += '    ' + argEntryToAdd['cbDecl'] + ''';
'''
	funcAttrMap['cbMemset'] += '    ' + argEntryToAdd['cbMemset'] + ''';
'''
	funcAttrMap['callMarshallList'] += argEntryToAdd['callMarshallList']
	funcAttrMap['cbUnmarshallList'] += argEntryToAdd['cbUnmarshallList']
	funcAttrMap['cbErrorMarshallList'] = argEntryToAdd['cbErrorMarshallList'] + funcAttrMap['cbErrorMarshallList']
	funcAttrMap['argList'] += argEntryToAdd['argList'] + ', '


#template for generating async client stub
asyncClientT = Template('''
${asyncCallback}

ClRcT ${name}ClientAsync(CL_IN ClIdlHandleT handle${callDecl}${cookieCallback})
{
    ClRcT rc = CL_OK;
    ClUint32T funcNo = ${funcNo};
    ClBufferMessageHandleT ${inMsg} = 0;
    ClBufferMessageHandleT ${outMsg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClRmdAsyncOptionsT asyncOptions;
    ClUint32T tempFlags = 0;
    ClIdlCookieT* pCookie = NULL;${temp1}

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if(rc != CL_OK)
    {
        goto L;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            goto L;
        }
    }
    else
    {
        rc = CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
        goto L;
    }${createInMsg}
${callMarshallList}
    if(fpAsyncCallback != NULL)
    {
        ${rmdCookie}
        
        asyncOptions.pCookie = NULL;
        asyncOptions.fpCallback = NULL;
        ${createOutMsg}
        tempFlags |= pHandleObj->flags |
                     (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT${flagNeedReply});
        ${asyncOptionsFill}
        rc = clRmdWithMsg(address, funcNo, ${inMsg}, ${outMsg}, tempFlags, &(pHandleObj->options), &asyncOptions);
        if (CL_OK != rc)
        {
            goto ${errorLabel};
         }
    }
    else
    {
        tempFlags |= pHandleObj->flags |
                         (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT);
        rc = clRmdWithMsg(address, funcNo, ${inMsg}, 0, tempFlags, &(pHandleObj->options),NULL);
        if(CL_OK != rc)
        {
               goto L;
        }
    }
    
${return}
}

''')


#template for generating async callback
asyncCallbackT = Template('''
static void ${name}AsyncCallback(ClRcT rc, void *pIdlCookie, ClBufferMessageHandleT ${inMsg}, ClBufferMessageHandleT ${outMsg})
{
    ClIdlCookieT* pCookie = (ClIdlCookieT*)pIdlCookie;
    ClRcT retVal = CL_OK;
${cbDecl}
${cbMemset}
${cbUnmarshallList}
    if (rc != CL_OK)
    {
        retVal = rc;
    }

    ((${EoName}${Name}AsyncCallbackT)(pCookie->actualCallback))(pCookie->handle, ${argList}retVal, pCookie->pCookie);
    goto L${argNum};

${cbErrorMarshallList}
L0:  clOsalFree(pCookie);
     clBufferMessageDelete(&${outMsg});
     return;
}
''')

#this template is for the snippet that creates the rmd
#cookie from IDL user's cookie & callback
asyncOptionsFillT = Template('''
        pCookie->pCookie = cookie;
        pCookie->actualCallback = (void(*)())fpAsyncCallback;
        pCookie->handle = handle;
        asyncOptions.pCookie = pCookie;
        asyncOptions.fpCallback = ${name}AsyncCallback;
''')


asyncHeaderT = Template('''
${asyncCallbackDef}ClRcT ${name}ClientAsync(CL_IN ClIdlHandleT handle${callDecl}${cookieCallback});
''')


def createAsyncFuncs(funcAttrMap):
	funcAttrMap['callDecl'] = funcAttrMap['callDecl'][:-2]
	funcAttrMap['EoName'] = upper(funcAttrMap['eoName'][0]) + funcAttrMap['eoName'][1:]
	funcAttrMap['Name'] = upper(funcAttrMap['name'][0]) + funcAttrMap['name'][1:]
	inPtr = funcAttrMap['inPtr'] + funcAttrMap['inoutPtr']
	if inPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
	else:
		funcAttrMap['temp1'] = ''
	funcAttrMap['rmdCookie'] = '''

        pCookie = clOsalMalloc(sizeof(ClIdlCookieT));
        if (NULL == pCookie)
        {
            return CL_IDL_RC(CL_ERR_NO_MEMORY);
        }'''
	funcAttrMap['createOutMsg'] = asyncCreateOutMsgT.safe_substitute()
	funcAttrMap['deleteOutMsg'] = deleteOutMsgT.safe_substitute()
	funcAttrMap['flagNeedReply'] = ' | CL_RMD_CALL_NEED_REPLY'
	funcAttrMap['cookieCallback'] = ',CL_IN ' + funcAttrMap['EoName'] + funcAttrMap['Name'] + 'AsyncCallbackT fpAsyncCallback, CL_IN void *cookie'
	funcAttrMap['asyncCallbackDef'] = 'typedef void (*' + funcAttrMap['EoName'] + funcAttrMap['Name'] + 'AsyncCallbackT) (CL_IN ClIdlHandleT handle' + funcAttrMap['callDecl'] + ''', CL_IN ClRcT rc, CL_IN void* pCookie);

'''
	funcAttrMap['asyncCallback'] = asyncCallbackT.safe_substitute(funcAttrMap)
	funcAttrMap['asyncOptionsFill'] = asyncOptionsFillT.safe_substitute(funcAttrMap)
	funcAttrMap['return'] = '''    return rc;

LL: clBufferMessageDelete(&${outMsg});
L2:  clOsalFree(pCookie);
     clHandleCheckin(gIdlClnt.idlDbHdl,handle);
L:
    return rc;'''
	funcAttrMap['errorLabel'] = 'LL'
	if funcAttrMap['inMsgNeeded'] > 0:
		funcAttrMap['createInMsg'] = asyncCreateInMsgT.safe_substitute()
	else:
		funcAttrMap['createInMsg'] = ''
	return asyncClientT.safe_substitute(funcAttrMap)


def createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate async client stub
	genTemplateT = dict()
	genTemplateT['init'] = asyncInit
	genTemplateT['append'] = asyncAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inAsyncAsPtrWithLength),\
						('inout', inoutAsyncAsPtrWithLength),\
						('out', outAsyncAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inAsyncByReference),\
						('inout', inoutAsyncByReference),\
						('out', outAsyncByReference)])
	genTemplateT['byValue'] = dict([('in', inAsyncByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['function'] = createAsyncFuncs
	genTemplateT['header'] = asyncHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo)






#server unmarshalling snippet
inServerUnmarshallT = Template('''
    ${rc} = clXdrUnmarshall${memberFuncType}( ${inMsg},${unmarshallEntry});
    if (CL_OK != ${rc})
    {
        goto LL${argNum};
    }
''')


#server marshalling snippet
inServerMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${outMsg}, ${isDelete});
    if (CL_OK != ${rc})
    {
        goto L${argNumPlusOne};
    }
''')

#error code snippet if error encountered during marshall
marshallErrorEntryT = Template('''\
L${argNum}:  clXdrMarshall${memberFuncType}(${marshallEntry}, 0, 1);
''')

#error code snippet if error encountered during unmarshall
unmarshallErrorEntryT = Template('''\
LL${argNum}:  clXdrMarshall${memberFuncType}(${marshallEntry}, 0, 1);
''')

def serverAsPtrWithLength(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outServerAsPointerwithLength is
	#made into a function and called in the respective functions
	type =  argAttrMap['type'] + '*'
	funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
	funcAttrMap['argList'] = argAttrMap['name']
	funcAttrMap['funcDecl'] = map['argType'] + funcAttrMap['decl']
	map['memberFuncType'] = 'Pointer' + argAttrMap['type']
	map['unmarshallEntry'] = '(void**)&(' + argAttrMap['name'] + ')'
	map['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	map['isDelete'] = '1'
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['marshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)
	funcAttrMap['marshallList'] = inServerMarshallT.safe_substitute(map)


def inServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_IN '
	map['outMsg'] = '0'
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def inoutServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_INOUT '
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	return funcAttrMap


ptrAllocateT = Template('''
    ${name} = (${type}*)clOsalMalloc(sizeof(${type}) * ${lengthVar});
    if (NULL == ${name})
    {
        goto LL${argNum};
    }
''')

def outServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_OUT '
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	funcAttrMap['unmarshallList'] = ptrAllocateT.safe_substitute(argAttrMap)
	return funcAttrMap


def serverByReference(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outServerByReference is
	#made into a function and called in the respective functions
	type =  argAttrMap['type']
	map['isDelete'] = '1'
	funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
	funcAttrMap['argList'] = '&(' + argAttrMap['name'] + ')'
	funcAttrMap['funcDecl'] = map['argType'] + argAttrMap['type'] + '*  ' + argAttrMap['name']
	map['memberFuncType'] = argAttrMap['type']
	map['unmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['marshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)
	funcAttrMap['marshallList'] = inServerMarshallT.safe_substitute(map)
	return funcAttrMap


def inServerByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_IN '
	map['outMsg'] = '0'
	serverByReference(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def inoutServerByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_INOUT '
	serverByReference(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def outServerByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_OUT '
	serverByReference(funcAttrMap, argAttrMap, map)
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['unmarshallErrorList'] = ''
	return funcAttrMap


def inServerByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for server stub
	funcAttrMap = dict()
	type =  argAttrMap['type']
	funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
	funcAttrMap['argList'] = argAttrMap['name']
	funcAttrMap['funcDecl'] = 'CL_IN ' + funcAttrMap['decl']
	map = dict()
	map['memberFuncType'] = argAttrMap['type']
	map['unmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['outMsg'] = '0'
	map['isDelete'] = '1'
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
	funcAttrMap['marshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)
	funcAttrMap['marshallList'] = inServerMarshallT.safe_substitute(map)
	return funcAttrMap


def serverInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['decl'] = ''
	funcAttrMap['memset'] = ''
	funcAttrMap['funcDecl'] = ''
	funcAttrMap['argList'] = ''
	funcAttrMap['marshallList'] = ''
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['marshallErrorList'] = ''
	funcAttrMap['unmarshallErrorList'] = ''


def serverAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['marshallList'] += argEntryToAdd['marshallList']
	funcAttrMap['unmarshallList'] += argEntryToAdd['unmarshallList']
	funcAttrMap['marshallErrorList'] += argEntryToAdd['marshallErrorList']
	funcAttrMap['unmarshallErrorList'] = argEntryToAdd['unmarshallErrorList'] + funcAttrMap['unmarshallErrorList']
	funcAttrMap['decl'] += '    ' + argEntryToAdd['decl'] + ''';
'''
	funcAttrMap['memset'] += '    ' + argEntryToAdd['memset'] + ''';
'''
	funcAttrMap['funcDecl'] += ', ' + argEntryToAdd['funcDecl']
	funcAttrMap['argList'] += ', ' + argEntryToAdd['argList']


#template for generating server stub
serverT = Template('''
static ClRcT ${name}Server(ClUint32T eoData, ClBufferMessageHandleT ${inMsg}, ClBufferMessageHandleT ${outMsg})
{
    ClIdlHandleT handle = 0;
    ClRcT ${rc} = CL_OK;
${decl}
${memset}
${unmarshallList}

    /* Uncomment following code (change to #if 1) after ${name} is defined */
#if 0
    ${rc} = ${name}(handle${argList});
#else
   clOsalPrintf("In Remote Method Server %s (%d)\\n", __FUNCTION__, handle);
   clOsalPrintf("**** Please define method ${name} ****\\n");
   rc = !CL_OK;
#endif

    if (CL_OK != ${rc})
    {
       goto L0;
    }
${marshallList}
L${argNum}:    return ${rc};

${unmarshallErrorList}
    return ${rc};

${marshallErrorList}
    return ${rc};
}
''')


serverHeaderT = Template('''
ClRcT ${name}(CL_IN ClIdlHandleT handle${funcDecl});
''')


def createServerFunc(funcAttrMap):
	return serverT.safe_substitute(funcAttrMap)


def createServerStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate server stub
	genTemplateT = dict()
	genTemplateT['init'] = serverInit
	genTemplateT['append'] = serverAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inServerAsPtrWithLength),\
						('inout', inoutServerAsPtrWithLength),\
						('out', outServerAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inServerByReference),\
						('inout', inoutServerByReference),\
						('out', outServerByReference)])
	genTemplateT['byValue'] = dict([('in', inServerByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['function'] = createServerFunc
	genTemplateT['header'] = serverHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo)


#template to create server header
serverHFileT = Template('''
#ifndef _${EO}_SERVER_H_
#define _${EO}_SERVER_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include "../clientIDDefinitions.h"
${xdrIncList}

ClRcT idlClientInstall(void);

ClRcT idlClientUninstall(void);

${serverDeclarations}

#ifdef __cplusplus
}
#endif
#endif /*_${EO}_SERVER_H_*/
''')


#template to create server C file
serverCFileT = Template('''\
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <string.h>
#include "${eo}Server.h"
${serviceDeclList}

${clientList}

${serverFuncList}

ClRcT idlClientInstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }

${clientInstallList}

    return ${rc};
}

ClRcT idlClientUninstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }

${clientUninstallList}

    return ${rc};
}
''')

#template to create function that installs server stubs in EO
clientInstallT = Template('''
    ${rc} = clEoClientInstall(${pEoObj}, ${clientId}, ${client}, 0, (sizeof(${client})/sizeof(${client}[0])));
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')

#template to create function that uninstalls server stubs from EO
clientUninstallT = Template('''
    clEoClientUninstall(${pEoObj}, ${clientId});''');

#template for the data structure that is passed to the functions above
clientDefinitionT = Template('''
static ClEoPayloadWithReplyCallbackT ${eo}Client${Num}[] = {
${serviceInstallList}
};
''')

#template to create client C file
clientCFileT = Template('''
#include <netinet/in.h>
#include <string.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clIdlApi.h>
#include <clEoApi.h>
#include <clXdrApi.h>
#include <clHandleApi.h>
#include "${eo}Client.h"
extern ClIdlClntT gIdlClnt;
        

${syncClientList}

''')

#template to create client header
clientHFileT = Template('''
#ifndef _${EO}_CLIENT_H_
#define _${EO}_CLIENT_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include "../clientIDDefinitions.h"
${xdrIncList}

${syncClientDecl}

#ifdef __cplusplus
}
#endif
#endif /*_${EO}_CLIENT_H_*/
''')


def parseEo(genFilesDir, eoObj):
	#this function parses the EO definition and creates
	#the server & client files
	number = 0
	stubGen = dict()
	eo = eoObj.attributes["name"].value
	typeNeeded = dict()

	syncClientList = ''
	syncClientDecl = ''

	serviceDeclList = ''
	clientList = ''
	serverFuncList = ''
	clientInstallList = ''
	clientUninstallList = ''
	serverDeclarations = ''

	clientNum = 0
	clientIDs = ""	
	#parse the client definitions
	for client in eoObj.getElementsByTagName('Client'):
		clientId = client.attributes["ID"].value
		if clientId != 'CL_EO_NATIVE_COMPONENT_TABLE_ID':
			clientIDDef = clientIDHeaderT.safe_substitute(clientId = clientId, number = number)
			number = number + 1
			clientIDs += clientIDDef
		clMap = dict()
		clMap['clientId'] = clientId
		clMap['client'] = eo + 'Client' + str(clientNum)
		clientInstallList += clientInstallT.safe_substitute(clMap)
		clientUninstallList += clientUninstallT.safe_substitute(clMap)
		serviceInstallList = ''
    		serviceNo = 0
		#parse the service definitions
                for service in client.getElementsByTagName('Service'):
                #create the server stub
                    stubGen = createServerStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                    serverFuncList += stubGen['code']
                    serverDeclarations += stubGen['header']
                    serviceInstallList += service.attributes['name'].value + '''Server,
'''
                    serviceDeclList += 'static ClRcT ' + service.attributes['name'].value + '''Server(ClUint32T eoData, ClBufferMessageHandleT ${inMsg}, ClBufferMessageHandleT ${outMsg});
'''
                   #create the sync client stub
                    if service.attributes.has_key("type"):
                        if(service.attributes['type'].value == "sync"):
                            stubGen = createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                            syncClientList += stubGen['code']
                            syncClientDecl += stubGen['header']
                        elif(service.attributes['type'].value == "async"):
                        #create the async client stub
                            stubGen = createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                            syncClientList += stubGen['code']
                            syncClientDecl += stubGen['header']
                    else:
                        stubGen = createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                        syncClientList += stubGen['code']
                        syncClientDecl += stubGen['header']
                        
                        stubGen = createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                        syncClientList += stubGen['code']
                        syncClientDecl += stubGen['header']
                    serviceNo+=1    
                          
		srvInstMap = dict()
		srvInstMap['serviceInstallList'] = serviceInstallList[:-2]
		srvInstMap['eo'] = eo
		srvInstMap['Num'] = str(clientNum)
		clientList += clientDefinitionT.safe_substitute(srvInstMap)

		clientNum += 1

	commonHeaderFile = open(genFilesDir + filePathSeparator + 'clientIDDefinitions.h', 'w');
	commonHeaderFile.write(clientIDHeader.safe_substitute(clientIDs = clientIDs))
	commonHeaderFile.close();

	incList = ''
	for udt in typeNeeded.keys():
		incList += '#include "' + getHFileName(udt) + '''"
'''
	symbolMap = dict([('rc', 'rc'), ('inMsg', 'inMsgHdl'), ('outMsg', 'outMsgHdl'), ('pEoObj', 'pEoObj')])

	#write the generated code into the files
	#write to file: server
	serverMap = dict()
	serverMap['serverFuncList'] = serverFuncList
	serverMap['serviceDeclList'] = serviceDeclList
	serverMap['clientList'] = clientList
	serverMap['clientInstallList'] = clientInstallList
	serverMap['clientUninstallList'] = clientUninstallList
	serverMap['serverDeclarations'] = serverDeclarations
	serverMap['eo'] = eo
	serverMap['EO'] = upper(eo)
	serverMap['xdrIncList'] = incList
	serverCodeT = Template(serverCFileT.safe_substitute(serverMap))
	serverFile = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +\
				eo + 'Server.c', 'w')
	serverFile.write(serverCodeT.safe_substitute(symbolMap))
	serverFile.close()
	serverHeader = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +\
				eo + 'Server.h', 'w')
	serverHeader.write(serverHFileT.safe_substitute(serverMap))
	serverHeader.close()

	#write to file: client
	clientMap = dict()
	clientMap['syncClientList'] = syncClientList
	clientMap['syncClientDecl'] = syncClientDecl
	clientMap['eo'] = eo
	clientMap['EO'] = upper(eo)
	clientMap['xdrIncList'] = incList
	clientCodeT = Template(clientCFileT.safe_substitute(clientMap))
	clientFile = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator +\
				eo + 'Client.c', 'w')
	clientFile.write(clientCodeT.safe_substitute(symbolMap))
	clientFile.close()
	clientHeader = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator +\
				eo + 'Client.h', 'w')
	clientHeader.write(clientHFileT.safe_substitute(clientMap))
	clientHeader.close()

#Makefile for all idl
idlMakeT = Template("""
                                                                                                                             
################################################################################
#
#
# This Makefile is auto-generated by OpenClovis IDE
# Makefile for components
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
# Date: ${DateTime}
# User: ${User}
#
################################################################################
                                                                                                                                                                                                                                                           
# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server
                                                                                                                                                                                                                                                           
SUBDIRS          = ${eoList}
                                                                                                                                                                                                                                                           
#
# If you have any ordering dependence among subdirectories, list them as
# target-prerequisite pairs.
#
                                                                                                                                                                                                                                                           
include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
                                                                                                                             
""")

#top level makefile template
topLevelMakeT = Template('''\
################################################################################
#
# Makefile for idl library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = client server

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')
topXdrMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = xdr

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')

#library (client/server) makefile template
clientMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${eoname}

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c) $(wildcard ../xdr/*.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${Eoname}${libType}
CPPFLAGS	= -I ../xdr

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

#library (xdr) makefile template
xdrMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${comp1}xdr 

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${comp1}Xdr

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

def generateCode(topgenFilesDir, idlSpecFile):
	eoNameList = ""
	makeMap = dict()
	#parse the xml file!!!
	idlSpec = xml.dom.minidom.parse(idlSpecFile)
	#create the directory structure
	eoList = idlSpec.getElementsByTagName("EO")
	for eo in eoList:
		genFilesDir = topgenFilesDir + filePathSeparator + eo.attributes["name"].value 
		eoNameList += eo.attributes["name"].value + " "
		if 0 == os.path.exists(genFilesDir + filePathSeparator + 'xdr'):
			os.makedirs(genFilesDir + filePathSeparator + 'xdr')
		structUnions = [struct.attributes['name'].value for struct in eo.getElementsByTagName('Struct')]
		structUnions += [struct.attributes['name'].value for struct in eo.getElementsByTagName('Union')]
        	files = []
        	for file in idlSpec.getElementsByTagName('Include'):
            		files.append(file.attributes['name'].value)
        
		#generate the XDR code
		for struct in eo.getElementsByTagName('Struct'):
			parseStruct(genFilesDir, struct, structUnions,files)
		for union in eo.getElementsByTagName('Union'):
			parseUnion(genFilesDir, union, structUnions)
		for enum in eo.getElementsByTagName('Enum'):
			parseEnum(genFilesDir, enum, structUnions,files)
		#generate the server & client stubs
		if 0 == os.path.exists(genFilesDir + filePathSeparator + 'client'):
			os.makedirs(genFilesDir + filePathSeparator + 'client')
		if 0 == os.path.exists(genFilesDir + filePathSeparator + 'server'):
			os.makedirs(genFilesDir + filePathSeparator + 'server')
                makeMap['eoname'] = eo.attributes['name'].value
                makeMap['Eoname'] = upper(makeMap['eoname'][0]) + makeMap['eoname'][1:]
                parseEo(genFilesDir, eo)
            	#generate the makefiles
            	makeMap['svrName'] = makeMap['eoname']
            	topMkFile = open(genFilesDir + filePathSeparator + 'Makefile', 'w')
            	topMkFile.write(topLevelMakeT.safe_substitute(makeMap))
            	topMkFile.close()
            	makeMap['comp']=''
            	for comp in idlSpec.getElementsByTagName("Comp"):
			makeMap['comp']+= " "+comp.attributes['name'].value
            	makeMap['libType'] = 'Client'
            	clientMkFile = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator + 'Makefile', 'w')
            	clientMkFile.write(clientMakeT.safe_substitute(makeMap))
            	clientMkFile.close()
            	makeMap['libType'] = 'Server'
            	serverMkFile = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator + 'Makefile', 'w')
            	serverMkFile.write(clientMakeT.safe_substitute(makeMap))
            	serverMkFile.close()
	topIdlMakefile = open(topgenFilesDir + filePathSeparator + 'Makefile', 'w')
	topIdlMakefile.write(idlMakeT.safe_substitute(eoList = eoNameList))
	topIdlMakefile.close()
#	topMkFile = open(genFilesDir + filePathSeparator + 'Makefile', 'w')
#	topMkFile.write(topXdrMakeT.safe_substitute(makeMap))
#	topMkFile.close()
#	for comp in idlSpec.getElementsByTagName("Comp"):
#		makeMap['comp'] = comp.attributes['name'].value 
#		makeMap['comp1'] = upper(makeMap['comp'][0])+ makeMap['comp'][1:]
#	xdrMkFile = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + 'Makefile', 'w')
#	xdrMkFile.write(xdrMakeT.safe_substitute(makeMap))
#	xdrMkFile.close()
		       
        


#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#Script Execution Starts Here.
idlSpecXml = sys.argv[1]

genFilesDir = sys.argv[2]

filePathSeparator = '/'

#clTypes is a map that is used to convert from xml basic type to
#the corresponding actual clovis basic type
clTypes = dict()
clTypes['ClInt8T'] = 'ClInt8T';
clTypes['ClInt16T'] = 'ClInt16T';
clTypes['ClInt32T'] = 'ClInt32T';
clTypes['ClInt64T'] = 'ClInt64T';
clTypes['ClUint8T'] = 'ClUint8T';
clTypes['ClUint16T'] = 'ClUint16T';
clTypes['ClUint32T'] = 'ClUint32T';
clTypes['ClUint64T'] = 'ClUint64T';
clTypes['ClCharT']  = 'ClCharT';
clTypes['ClNameT']  = 'ClNameT';
clTypes['ClVersionT']  = 'ClVersionT';
try:                    
	file = open (idlSpecXml)
	generateCode(genFilesDir, idlSpecXml)
except IOError:
	print idlSpecXml + " does not exist"




