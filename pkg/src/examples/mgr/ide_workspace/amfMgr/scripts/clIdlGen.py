#!/usr/local/bin/python
################################################################################
# ModuleName  : plugins
# File        : clIdlGen.py
################################################################################
# Description :
################################################################################

import sys
import os
import string
import pdb
import re
import xml.dom.minidom
from string import Template
from string import upper, lower
from string import find

#The working of the script:
#It uses a xml.dom.minidom to parse the xml file & create a
#tree out of it. This tree has multiple levels at which relevant
#information is stored. It then descends the various levels & at
#every level, it consumes information & generates code for it.
#At every higher level, the code generated by the lower level is
#substituted in templates to generate bigger constructs. At the
#highest level, the code files are generated. This script uses
#"templates" and "dictionaries"(hereafter referred as map)
#construct in python extensively for the above.

#template for xdr header
clientIDHeader = Template('''
#ifndef _CLIENTID_H_
#define _CLIENTID_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <clEoApi.h>

${clientIDs}

#ifdef __cplusplus
}
#endif

#endif /*_CLIENTID_H_*/

''')

clientIDHeaderT = Template('''
#define ${clientId} (CL_EO_USER_CLIENT_ID_START + ${number})
''')

#template for xdr header
xdrHeaderT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the declarations for marshall 
*               and unmarshall funtions of ${type} 
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

struct _${type};
#include "clXdrApi.h"

${includeList}
${udtDefinition}

ClRcT  clXdrMarshall${type}(void *,ClBufferHandleT , ClUint32T);

ClRcT  clXdrUnmarshall${type}(ClBufferHandleT, void *);

#define clXdrMarshallArray${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallArray((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallArray${type}(msg,pointer, multiplicity) \\
clXdrUnmarshallArray((msg),(pointer), sizeof(${type}), (multiplicity), clXdrUnmarshall${type})

#define clXdrMarshallPointer${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallPointer((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallPointer${type}(msg,pointer) \\
clXdrUnmarshallPointer((msg),(pointer), sizeof(${type}), clXdrUnmarshall${type})

#define clXdrMarshallPtr${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallPtr((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallPtr${type}(msg,pointer,multiplicity) \\
clXdrUnmarshallPtr((msg),(pointer), sizeof(${type}),multiplicity, clXdrUnmarshall${type})
#ifdef __cplusplus
}
#endif

#endif /*_XDR_${TYPE}_H_*/

''')

#template for UDT member definition code
memberT = Template('''\
    ${hdrType}    ${name};
''')


def getCFileName(strName):
	return 'xdr' + upper(strName[0]) + strName[1:] + '.c'


def getHFileName(strName):
	return 'xdr' + upper(strName[0]) + strName[1:] + '.h'


def parseDataMember(userDT,prepend, member, structUnions):
	#this function parses a datamember 'member'. It creates a map
	#'memAttrMap' of all attributes of the member and gives out code
	#snippets relevant to this member in the map
	memAttrMap = dict()
	memAttrMap['name'] = member.attributes['name'].value
	memAttrMap['includeList'] = ''
	temp = clTypes.get(member.attributes.get('type').value)
	if temp != None:
		memAttrMap['type'] = temp
	else:
		memAttrMap['type'] = member.attributes['type'].value
		memAttrMap['includeList'] = '#include "' + getHFileName(member.attributes['type'].value) + '''"
'''
	memAttrMap['memberDT'] = memAttrMap['type']
	memAttrMap['marshallEntry'] = 'pVar' + '->' + prepend + memAttrMap['name']
	memAttrMap['unmarshallEntry'] = 'pVar' + '->' + prepend + memAttrMap['name']
	if member.attributes.has_key('pointer'):
		if member.attributes['pointer'].value == "Single":
			#member is a pointer
			memAttrMap['type'] += '*'
			memAttrMap['memberDT'] = 'Ptr' + memAttrMap['memberDT']
			if member.attributes.has_key('lengthVar'):
				#member is a pointer with length variable
				memAttrMap['marshallEntry'] += ', ' + 'pVar' + '->' + prepend + member.attributes['lengthVar'].value
        			memAttrMap['unmarshallEntry'] = '(void**)&(' + memAttrMap['unmarshallEntry'] + ')' +','+ 'pVar' + '->' + member.attributes['lengthVar'].value
			else:
				#member is a pointer without length variable
				memAttrMap['marshallEntry'] += ', 1'
        			memAttrMap['unmarshallEntry'] = '(void**)&(' + memAttrMap['unmarshallEntry'] + ')'+','+ '1'
	if member.attributes.has_key('multiplicity'):
		#member is an array
		memAttrMap['memberDT'] = 'Array' + memAttrMap['memberDT']
		memAttrMap['marshallEntry'] += ', ' + member.attributes['multiplicity'].value
		memAttrMap['unmarshallEntry'] += ', ' + member.attributes['multiplicity'].value
		memAttrMap['name'] += '[' + member.attributes['multiplicity'].value + ']'
	if not member.attributes.has_key('multiplicity'):
		if not member.attributes.has_key('pointer'):
			#member is none of the above, i.e. an ordinary variable
			memAttrMap['marshallEntry'] = '&(' + memAttrMap['marshallEntry'] + ')'
			memAttrMap['unmarshallEntry'] = '&(' + memAttrMap['unmarshallEntry'] + ')'
	temp = len([udt for udt in structUnions if member.attributes.get('type').value == udt])
        if (userDT.attributes['name'].value == member.attributes['type'].value): ## Checking if there is a self referential member.
    		memAttrMap['hdrType'] = 'struct _' + memAttrMap['type']
        else:
		memAttrMap['hdrType'] = memAttrMap['type']
	return memAttrMap


#structure definition template
structMemberDefnT = Template('''
typedef struct _${type} {
${memberList}
}${type};
''')

#snippet for member marshalling
marshallStructMemberT = Template('''
    rc = clXdrMarshall${memberDT}(${marshallEntry},msg,isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#snippet for member unmarshalling
unmarshallStructMemberT = Template('''
    rc = clXdrUnmarshall${memberDT}(msg,${unmarshallEntry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#C file code generation template for xdr marshalling of struct
xdrMarshallStructCodeT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Marshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#include "xdr${type1}.h"


ClRcT clXdrMarshall${type}(void* pGenVar, ClBufferHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar    = (${type}*)pGenVar;
    ClRcT rc         = CL_OK;
    ClUint32T length = 0;    

    if ((void*)0 == pVar)
    {
        clXdrMarshallClUint32T(&length, msg, 0);
    }
    else
    {
        length = 1;
        clXdrMarshallClUint32T(&length, msg, 0);
    ${marshalledMemberList}
    }
        
    return rc;
}
''')
xdrUnMarshallStructCodeT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Unmarshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include "xdr${type1}.h"

ClRcT clXdrUnmarshall${type}(ClBufferHandleT msg , void* pGenVar)
{
    ${type}*  pVar   = (${type}*)pGenVar;
    ClRcT     rc     = CL_OK;
    ClUint32T length = 0;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    clXdrUnmarshallClUint32T(msg, &length);
    if( 0 == length)
    {
        pGenVar = NULL;
    }
    else
    {
    ${unmarshalledMemberList}
    }

    return rc;
}

''')


def parseStruct(genFilesDir, struct, structUnions,files):
	#this function parses a structure 'struct' and generates
	#the xdr marshalling/unmarshalling .c & .h files for that struct
	xdrAttrMap = dict()
	xdrAttrMap['includeList'] = ''
        for file in files:
            xdrAttrMap['includeList'] +='#include "' + file +'"'+'\n'
	xdrAttrMap['memberList'] = ''
	xdrAttrMap['marshalledMemberList'] = ''
	xdrAttrMap['unmarshalledMemberList'] = ''
	prepend = ''

        orderedMembers = []
        varLengthMembers = []
        for member in struct.getElementsByTagName('DataMember'):
                if member.attributes.has_key("lengthVar"):
                        # variable length varaibles
                        varLengthMembers.append(member)
                else:
                        orderedMembers.append(member)

        for member in varLengthMembers:
                orderedMembers.append(member)
                
        
	for member in orderedMembers:
		memAttrMap = dict()
		memAttrMap = parseDataMember(struct,prepend, member, structUnions)
		xdrAttrMap['includeList'] += memAttrMap['includeList']
## If a member is of user defined type. Then it can't be used directly as self referential structures' name is prepended with an '_'
		xdrAttrMap['memberList'] += memberT.safe_substitute(memAttrMap)
		xdrAttrMap['marshalledMemberList'] += marshallStructMemberT.safe_substitute(memAttrMap)
		xdrAttrMap['unmarshalledMemberList'] += unmarshallStructMemberT.safe_substitute(memAttrMap)
	xdrAttrMap['type'] = struct.attributes['name'].value  #changes here to resolve first character :Ramesh
	xdrAttrMap['type1'] = upper(xdrAttrMap['type'][0])+xdrAttrMap['type'][1:]
        l = xdrAttrMap['type']
        l = re.sub('(?<=[a-z0-9])([A-Z])', r'_\1', l)
        l = re.sub('(?<=[A-Z])([A-Z])([a-z0-9])', r'_\1\2', l)
        l = l.upper()

	xdrAttrMap['TYPE'] = l 
        if struct.attributes.has_key("defNeed"):# fix for 4052 - always define the user defined struct/enum
                if struct.attributes["defNeed"].value.lower() == "true" :
                        xdrAttrMap['udtDefinition'] = structMemberDefnT.safe_substitute(xdrAttrMap)
                else:                        
                        xdrAttrMap['udtDefinition'] =''
			includeFile = struct.attributes["include"].value
			if (0 == os.path.exists(includeFile)):
				print "ERROR: The given include file does not exist."
				sys.exit(0);
			else:
				xdrAttrMap['includeList'] += '#include "' + includeFile + '"' + '\n'
						    
        else:    
        	xdrAttrMap['udtDefinition'] = ''
                if struct.attributes.has_key("include"):
                        includeFile = struct.attributes["include"].value
                        if (0 == os.path.exists(includeFile)):
                                print "ERROR: The given include file does not exist."
                                sys.exit(0);
                        else:
                                xdrAttrMap['includeList'] += '#include "' + includeFile + '"' + '\n'

	fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(struct.attributes['name'].value), 'w')
	fXdrH.write(xdrHeaderT.safe_substitute(xdrAttrMap))
	fXdrH.close()
	fXdrMarshalC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(struct.attributes['name'].value +"Marshall"), 'w')
	fXdrMarshalC.write(xdrMarshallStructCodeT.safe_substitute(xdrAttrMap))
	fXdrMarshalC.close()
	fXdrUnMarshalC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(struct.attributes['name'].value + "UnMarshall"),'w')
	fXdrUnMarshalC.write(xdrUnMarshallStructCodeT.safe_substitute(xdrAttrMap))
	fXdrUnMarshalC.close()


#template for defining the union
unionMemberDefnT = Template('''
typedef enum _${type}EnumT
{
${enumMemberList}
} ${type}EnumT;

typedef struct _${type}
{
    ${type}EnumT discriminant;
    union
    {
${memberList}
    }${unionName};
}${type};
''')

#union member marshalling code snippet
marshallUnionMemberT = Template('''
        case (ClInt32T)${discVal}:
            rc = clXdrMarshall${memberDT}(${marshallEntry}, msg, isDelete);
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

#union member unmarshalling code snippet
unmarshallUnionMemberT = Template('''
        case (ClInt32T)${discVal}:
            rc = clXdrUnmarshall${memberDT}(msg,${unmarshallEntry});
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

#C file code generation template for xdr marshalling of union
xdrMarshallUnionCodeT = Template('''
#include <netinet/in.h>
#include "xdr${type1}.h"


ClRcT clXdrMarshall${type}(void *pGenVar,ClBufferHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;
    ClUint32T length = 0;

    if ((void*)0 == pVar)
    {
        clXdrMarshallClUint32T(&length, msg, 0);
    }
    else
    {
        length = 1;
        clXdrMarshallClUint32T(&length, msg, 0);
    rc = clXdrMarshallClInt32T(&(pVar->discriminant),msg, isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
        ${marshalledMemberList}
    default:
        return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }
    }

    return rc;
}
''')
xdrUnMarshallUnionCodeT = Template('''
#include <netinet/in.h>        
#include "xdr${type1}.h"
        
ClRcT clXdrUnmarshall${type}(ClBufferHandleT msg , void *pGenVar)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;
    ClUint32T  length = 0;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    if (0 == msg)
    {
        return CL_XDR_RC(CL_ERR_INVALID_BUFFER);
    }

    clXdrUnmarshallClUint32T(msg, &length);
    if( 0 == length)
    {
        pGenVar = NULL;
    }
    else
    {
    rc = clXdrUnmarshallClInt32T(msg,&(pVar->discriminant));
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
        ${unmarshalledMemberList}
    default:
        return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }
    }

    return rc;
}

''')

def parseUnion(genFilesDir, union, structUnions):
	#this function parses a structure 'union' and generates
	#the xdr marshalling/unmarshalling .c & .h files for that union
	xdrAttrMap = dict()
	xdrAttrMap['includeList'] = ''
	xdrAttrMap['memberList'] = ''
	xdrAttrMap['enumMemberList'] = ''
	xdrAttrMap['marshalledMemberList'] = ''
	xdrAttrMap['unmarshalledMemberList'] = ''
	xdrAttrMap['type'] = union.attributes['name'].value
        xdrAttrMap['type1'] = upper(xdrAttrMap['type'][0]) + xdrAttrMap['type'][1:];#added code here Ramesh
	xdrAttrMap['discVal'] = ''
	firstEnumValue = ' = 1'
	xdrAttrMap['unionName'] = lower(xdrAttrMap['type'][0]) + xdrAttrMap['type'][1:]
	for member in union.getElementsByTagName('DataMember'):
		memAttrMap = dict()
		memAttrMap = parseDataMember(union,xdrAttrMap['unionName'] + '.', member, structUnions)
		memAttrMap['discVal'] = upper(xdrAttrMap['type'] + member.attributes['name'].value)
		xdrAttrMap['includeList'] += memAttrMap['includeList']
		xdrAttrMap['memberList'] += '    ' + memberT.safe_substitute(memAttrMap)
		xdrAttrMap['enumMemberList'] += '    ' + memAttrMap['discVal'] + firstEnumValue + ''',
'''
		firstEnumValue = ''
		xdrAttrMap['marshalledMemberList'] += marshallUnionMemberT.safe_substitute(memAttrMap)
		xdrAttrMap['unmarshalledMemberList'] += unmarshallUnionMemberT.safe_substitute(memAttrMap)
        l = xdrAttrMap['type']
        l = re.sub('(?<=[a-z0-9])([A-Z])', r'_\1', l)
        l = re.sub('(?<=[A-Z])([A-Z])([a-z0-9])', r'_\1\2', l)
        l = l.upper()

	xdrAttrMap['TYPE'] = l 
                                                                                                  
	xdrAttrMap['udtDefinition'] = unionMemberDefnT.safe_substitute(xdrAttrMap)
	xdrAttrMap['enumMemberList'] += xdrAttrMap['enumMemberList'][:-2]
	fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(xdrAttrMap['type']), 'w')
	fXdrH.write(xdrHeaderT.safe_substitute(xdrAttrMap))
        fXdrH.close()
	fXdrMarshallC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(union.attributes['name'].value + "Marshall"), 'w')
	fXdrMarshallC.write(xdrMarshallUnionCodeT.safe_substitute(xdrAttrMap))
        fXdrMarshallC.close()
	fXdrUnMarshallC = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getCFileName(union.attributes['name'].value + "UnMarshall"), 'w')
	fXdrUnMarshallC.write(xdrUnMarshallUnionCodeT.safe_substitute(xdrAttrMap))
        fXdrUnMarshallC.close()

#template for xdr header for enum
xdrEnumHeaderT = Template('''
#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "clXdrApi.h"
${includeList}
${udtDefinition}

#define      clXdrMarshall${type}               clXdrMarshallClInt32T

#define      clXdrUnmarshall${type}             clXdrUnmarshallClInt32T

#define      clXdrMarshallArray${type}          clXdrMarshallArrayClInt32T

#define      clXdrUnmarshallArray${type}        clXdrUnmarshallArrayClInt32T

#define      clXdrMarshallPointer${type}        clXdrMarshallPointerClInt32T

#define      clXdrUnmarshallPointer${type}      clXdrUnmarshallPointerClInt32T

#define      clXdrMarshallPtr${type}            clXdrMarshallPtrClInt32T

#define      clXdrUnmarshallPtr${type}          clXdrUnmarshallPtrClInt32T

#ifdef __cplusplus
}
#endif

#endif /*_XDR_${TYPE}_H_*/

''')

#enum definition template
enumDefnT = Template('''
typedef enum _${type}
{
${memberList}
} ${type};
''')

def parseEnum(genFilesDir, enum, structUnionsi,files):
	#this function parses a structure 'enum' and generates
	#the xdr marshalling/unmarshalling .h file for that enum
	xdrAttrMap = dict()
	xdrAttrMap['memberList'] = ''
        xdrAttrMap['includeList'] = ''
        for file in files:
            xdrAttrMap['includeList']+='#include "' + file +'"'+"\n"    
	for member in enum.getElementsByTagName('EnumMember'):
		if member.attributes.has_key('value'):
			xdrAttrMap['memberList'] += '    ' + member.attributes['name'].value +\
                        ' = ' + member.attributes['value'].value + ''',
'''
		else:
			xdrAttrMap['memberList'] += '    ' + member.attributes['name'].value + ''',
'''
	xdrAttrMap['memberList'] = xdrAttrMap['memberList'][:-2]
	xdrAttrMap['type'] = enum.attributes['name'].value
        l = xdrAttrMap['type']
        l = re.sub('(?<=[a-z0-9])([A-Z])', r'_\1', l)
        l = re.sub('(?<=[A-Z])([A-Z])([a-z0-9])', r'_\1\2', l)
        l = l.upper()

	xdrAttrMap['TYPE'] = l 
                                                      
        if enum.attributes.has_key("defNeed"):
                if enum.attributes["defNeed"].value.lower() == "true":
                        xdrAttrMap['udtDefinition'] = enumDefnT.safe_substitute(xdrAttrMap)
                else:
                        xdrAttrMap['udtDefinition'] = ''
                        includeFile = enum.attributes["include"].value
                        if (0 == os.path.exists(includeFile)):
                                print "ERROR: The given include file does not exist."
                                sys.exit(0);
                        else:
                                xdrAttrMap['includeList'] += '#include "' + includeFile + '"' + '\n'

        else:
                xdrAttrMap['udtDefinition'] = ''
                if enum.attributes.has_key("include"):
                        includeFile = enum.attributes["include"].value
                        if (0 == os.path.exists(includeFile)):
                                print "ERROR: The given include file does not exist."
                                sys.exit(0);
                        else:
                                xdrAttrMap['includeList'] += '#include "' + includeFile + '"' + '\n'
 
	fXdrH = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + getHFileName(enum.attributes['name'].value), 'w')
	fXdrH.write(xdrEnumHeaderT.safe_substitute(xdrAttrMap))
        fXdrH.close()


def createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo,flag):
	argMap = dict()
	argMap['in'] = [arg for arg in service.getElementsByTagName('Argument')\
                        if arg.attributes['ParameterType'].value == 'CL_IN']
	argMap['inout'] = [arg for arg in service.getElementsByTagName('Argument')\
                           if arg.attributes['ParameterType'].value == 'CL_INOUT']
	argMap['out'] = [arg for arg in service.getElementsByTagName('Argument')\
                         if arg.attributes['ParameterType'].value == 'CL_OUT']
	inPtr = 0
	inoutPtr = 0
	outPtr = 0
	ptrNum = dict([('in', inPtr), ('inout', inoutPtr), ('out', outPtr)]);

	replyNeeded = 0
	inMsgNeeded = 0
	unused = 0
	reply = dict([('in', unused), ('inout', replyNeeded), ('out', replyNeeded)])
	inMsg = dict([('in', inMsgNeeded), ('inout', inMsgNeeded), ('out', unused)])
	argNum = 0
        convert = dict()
        paramTypeNum = dict([('in',0),('inout',0),('out',0)]);
        convert['CL_IN']  = "in"
        convert['CL_OUT'] = "out"
        convert['CL_INOUT'] = "inout"

	funcAttrMap = dict()
	genTemplateT['init'](funcAttrMap)
        for arg in service.getElementsByTagName('Argument'):
                argType = arg.attributes['ParameterType'].value
                argType = convert[arg.attributes['ParameterType'].value]   
                argAttrMap = dict()
                #get the name
                argAttrMap['isDecl'] = '1'
                argAttrMap['name'] = arg.attributes['name'].value
                #get the type
                temp = clTypes.get(arg.attributes.get('type').value)
                if temp != None:
                        argAttrMap['type'] = temp
                else:
                        argAttrMap['type'] = arg.attributes['type'].value
                argAttrMap['argNum'] = argNum
                argAttrMap['argTypeNum'] = paramTypeNum[argType]
                if arg.attributes.has_key('pointer'):
                        if arg.attributes['pointer'].value == "Single":
                                if arg.attributes.has_key('lengthVar'):
                                        if argType == 'inout':
                                                print "Error:CL_INOUT is not allowed for bufferVariable which has lengthVaribale\n"+arg.attributes['name'].value + " is having lengthVar,so CL_INOUT is not allowed"
                                                sys.exit(0);
                                #element passed is array
                                        checkList = [list for list in service.getElementsByTagName('Argument')\
                                        if list.attributes['name'].value ==  arg.attributes['lengthVar'].value and list.attributes['ParameterType'].value == 'CL_IN']
                                        if len(checkList) == 0:
                                                print "Error:Invalid Argument"+ arg.attributes['name'].value+" is a single pointer.so the lengthVar should not be CL_INOUT or CL_OUT or"+ arg.attributes['name'].value+" should be a double pointer" 
                                                print service.attributes['name'].value, arg.attributes['pointer'].value
                                                sys.exit(0);
                                        argAttrMap['lengthVar'] = arg.attributes['lengthVar'].value
                                        for var in checkList:
                                                argAttrMap['lengthVarType'] = var.attributes['ParameterType'].value+' '+var.attributes['type'].value+' '+var.attributes['name'].value
                                        genTemplateT['declAppend'](funcAttrMap, genTemplateT['asPtrWithLength'][argType](argAttrMap))
                                else:
                                        #element is passed by reference
                                        genTemplateT['declAppend'](funcAttrMap, genTemplateT['byReference'][argType](argAttrMap))
                        elif arg.attributes['pointer'].value == "Double":                                        
                                if arg.attributes.has_key('lengthVar'):                        
                                        if argType == 'inout':
                                                print "Error:CL_INOUT is not allowed for bufferVariable which has lengthVaribale\n"+arg.attributes['name'].value + " is having lengthVar,so CL_INOUT is not allowed"
                                                sys.exit(0);
                                        argAttrMap['lengthVar'] = arg.attributes['lengthVar'].value
                                        checkList = [list for list in service.getElementsByTagName('Argument')\
                                        if list.attributes['name'].value ==  arg.attributes['lengthVar'].value]
                                        genTemplateT['declAppend'](funcAttrMap, genTemplateT['asDoublePointer'][argType](argAttrMap))
                else:
                #element is passed by value
                        genTemplateT['declAppend'](funcAttrMap, genTemplateT['byValue'][argType](argAttrMap))

        paramMap = dict()
	for argType in ['in', 'inout','out']:
		if len(argMap[argType]) == 0:
			continue                        
                paramMap['fixed'] = []
                paramMap['variable'] = []
                for param in argMap[argType]:
                        if param.attributes.has_key('lengthVar'):
                                paramMap['variable'].append(param)
                        else:
                                paramMap['fixed'].append(param)                     
                argTypeNum = 0
                for paramType in ['fixed','variable']:
                        if len(paramMap[paramType]) == 0:
                                continue
        		for arg in paramMap[paramType]:
        			argAttrMap = dict()
                                argAttrMap['isDecl'] = '0'
                                argAttrMap['eo'] = eo
        			#get the name
        			argAttrMap['name'] = arg.attributes['name'].value
        			#get the type
        			temp = clTypes.get(arg.attributes.get('type').value)
        			if temp != None:
        				argAttrMap['type'] = temp
        			else:
        				argAttrMap['type'] = arg.attributes['type'].value
        				typeNeeded[argAttrMap['type']] = 1
        			argAttrMap['argNum'] = argNum
        			argAttrMap['argTypeNum'] = argTypeNum
        			if arg.attributes.has_key('pointer'):
        				if arg.attributes['pointer'].value == "Single":
        					if arg.attributes.has_key('lengthVar'):
        						#element passed is array
        						ptrNum[argType] += 1
        						argAttrMap['lengthVar'] = arg.attributes['lengthVar'].value
        						genTemplateT['append'](funcAttrMap, genTemplateT['asPtrWithLength'][argType](argAttrMap))
        					else:
        						#element is passed by reference
        						genTemplateT['append'](funcAttrMap, genTemplateT['byReference'][argType](argAttrMap))
        				elif arg.attributes['pointer'].value == "Double":
                                                if arg.attributes.has_key('lengthVar'):
        			                        ptrNum[argType] += 1
        						argAttrMap['lengthVar'] = arg.attributes['lengthVar'].value
        						genTemplateT['append'](funcAttrMap, genTemplateT['asDoublePointer'][argType](argAttrMap))
        			else:
        				#element is passed by value
        				genTemplateT['append'](funcAttrMap, genTemplateT['byValue'][argType](argAttrMap))
        			argNum += 1
        			argTypeNum += 1
        			inMsg[argType] += 1
        			reply[argType] += 1
        	#create the func decl here!!!            
        funcAttrMap['funcNo'] = 'CL_EO_GET_FULL_FN_NUM(' + clientId + ', ' + str(serviceNo) + ')'
	funcAttrMap['name'] = service.attributes['name'].value
	funcAttrMap['inPtr'] = ptrNum['in']
	funcAttrMap['inoutPtr'] = ptrNum['inout']
	funcAttrMap['outPtr'] = ptrNum['out']
	funcAttrMap['replyNeeded'] = reply['out'] + reply['inout']
	funcAttrMap['inMsgNeeded'] = inMsg['in'] + reply['inout']
	funcAttrMap['argNum'] = argNum
	funcAttrMap['eoName'] = eo
	if flag == 2:
        	lastArgIndex = funcAttrMap['funcDecl'][:-2]
        	funcAttrMap['funcDecl'] ='' 
	        funcAttrMap['funcDecl'] += lastArgIndex 
        	lastArgIndex = funcAttrMap['argList'][:-2]
        	funcAttrMap['argList'] ='' 
	        funcAttrMap['argList'] += lastArgIndex 
	funcOutput = dict()
	funcOutput['code'] = genTemplateT['function'](funcAttrMap)
	funcOutput['header'] = genTemplateT['header'].safe_substitute(funcAttrMap)
	return funcOutput

def doNothing(argAttrMap):
	return None

#template as indicated by name
pointerLengthWriteT = Template('''
    temp1 = htonl(${lengthVar});
    rc = clBufferNBytesWrite(${inMsg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        return rc;
    }
''')

#template as indicated by name
pointerLengthReadT = Template('''
    temp2 = sizeof(ClUint32T);
    rc = clBufferNBytesRead(${outMsg}, (ClUint8T*)&temp1, &temp2);
    if (rc != CL_OK)
    {
        return rc;
    }
''')

#template to marshall IN parameters
inSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${inMsg}, 0);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

#template to marshall INOUT parameters
inoutSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${inMsg}, 1);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')
#template to unmarshall OUT parameters
outSyncClientUnmarshallT = Template('''
    rc = clXdrUnmarshall${memberFuncType}( ${outMsg}, ${unmarshallEntry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

#we have 7 types of parameters. They are described as follows:
# IN by value
# IN by reference
# IN as pointer with length variable
# INOUT by reference
# INOUT as pointer with length variable
# OUT by reference
# OUT as pointer with length variable
#There are subtle differences as to the code snippet generated
#for each of these parameter types. Therfore we have different
#functions for each of these types.

def inSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['marshallList'] = '' 
        	funcAttrMap['unmarshallList'] = ''
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
        	marshallMap['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	marshallMap['unmarshallEntry'] = ''
        	marshallMap['lengthVar'] = argAttrMap['lengthVar']
        	funcAttrMap['marshallList'] = inSyncClientMarshallT.safe_substitute(marshallMap)
        	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


def inoutSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_INOUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['marshallList'] ='' 
        	funcAttrMap['unmarshallList'] ='' 
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
        	marshallMap['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	marshallMap['unmarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	marshallMap['lengthVar'] = argAttrMap['lengthVar']
        	funcAttrMap['marshallList'] = inoutSyncClientMarshallT.safe_substitute(marshallMap)
        	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap

def outSyncAsdoublePointer(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_OUT ' + argAttrMap['type'] + '** ' + argAttrMap['name']
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['unmarshallList'] ='' 
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = 'Ptr' + argAttrMap['type']
        	marshallMap['marshallEntry'] = ''
        	marshallMap['unmarshallEntry'] = "(void **)"+argAttrMap['name'] + ', ' + '*'+ argAttrMap['lengthVar']
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap

def outSyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_OUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['unmarshallList'] ='' 
        	funcAttrMap['marshallList'] = ''
        else:
        	funcAttrMap['decl'] = ''
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = 'Array' + argAttrMap['type']
        	marshallMap['marshallEntry'] = ''
        	marshallMap['unmarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap

def inSyncByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for sync client stub
	funcAttrMap = dict()
	marshallMap = dict()
	marshallMap['memberFuncType'] = argAttrMap['type']
	marshallMap['marshallEntry'] = argAttrMap['name']
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['marshallList'] =''
        	funcAttrMap['unmarshallList'] = ''
        else:        
        	funcAttrMap['decl'] ='' 
        	funcAttrMap['marshallList'] = inSyncClientMarshallT.safe_substitute(marshallMap)
        	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


def inoutSyncByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_INOUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['marshallList'] ='' 
        	funcAttrMap['unmarshallList'] =''
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = argAttrMap['type']
        	marshallMap['marshallEntry'] = argAttrMap['name']
        	marshallMap['unmarshallEntry'] = argAttrMap['name']
        	funcAttrMap['marshallList'] = inoutSyncClientMarshallT.safe_substitute(marshallMap)
        	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap


def outSyncByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_OUT ' + argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['unmarshallList'] ='' 
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = argAttrMap['type']
        	marshallMap['unmarshallEntry'] = argAttrMap['name']
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['unmarshallList'] = outSyncClientUnmarshallT.safe_substitute(marshallMap)
	return funcAttrMap


def inSyncByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for sync client stub
	funcAttrMap = dict()
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] = 'CL_IN ' + argAttrMap['type'] + ' ' + argAttrMap['name']
        	funcAttrMap['marshallList'] ='' 
        	funcAttrMap['unmarshallList'] = ''
        else:
        	funcAttrMap['decl'] ='' 
        	marshallMap = dict()
        	marshallMap['memberFuncType'] = argAttrMap['type']
        	marshallMap['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
        	funcAttrMap['marshallList'] = inSyncClientMarshallT.safe_substitute(marshallMap)
        	funcAttrMap['unmarshallList'] = ''
	return funcAttrMap


createOutMsgT = Template('''
    ${rc} = clBufferCreate(&${outMsg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')


createInMsgT = Template('''

    ${rc} = clBufferCreate(&${inMsg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')


deleteOutMsgT = Template('''\
clBufferDelete(&${outMsg});
    ''')

#template for generating sync client stub
syncClientT = Template('''
ClRcT ${name}ClientSync(CL_IN ClIdlHandleT handle${decl})
{
    ClRcT rc = CL_OK;
    ClUint32T funcNo = ${funcNo};
    ClBufferHandleT ${inMsg} = 0;
    ClBufferHandleT ${outMsg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClUint32T tempFlags = 0;

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if( rc != CL_OK )
    {
        return rc ;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            return rc;
        }
    }
    else
    {
        return CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
    }${createInMsg}
${marshallList}
${createOutMsg}
    tempFlags |= pHandleObj->flags |
                 (CL_RMD_CALL_NON_PERSISTENT${flagNeedReply});
    tempFlags &= ~CL_RMD_CALL_ASYNC;

    rc = clRmdWithMsg(address, funcNo, ${inMsg}, ${outMsg}, tempFlags, &(pHandleObj->options), NULL);
    if(CL_OK != rc)
    {
        ${deleteOutMsg}return rc;
    }

${unmarshallList}
    ${deleteOutMsg}
    rc = clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;
}
''')

#template for #defining the function call <func> as <func>ClientSync
syncHeaderT = Template('''
#define ${name} ${name}ClientSync
ClRcT ${name}ClientSync(CL_IN ClIdlHandleT handle${decl});
''')


def syncInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['decl'] = ''
	funcAttrMap['funcNo'] = ''
	funcAttrMap['marshallList'] = ''
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['temp1'] = ''
	funcAttrMap['temp2'] = ''
	funcAttrMap['ptrChecks'] = ''
	funcAttrMap['outMsgCreate'] = ''
	funcAttrMap['outMsgDelete'] = ''
	funcAttrMap['inMsgCreate'] = ''
	funcAttrMap['flagNeedReply'] = ''

def syncDeclAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['decl'] += ', ' + argEntryToAdd['decl']

def syncAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['marshallList'] += argEntryToAdd['marshallList']
	funcAttrMap['unmarshallList'] += argEntryToAdd['unmarshallList']


def createSyncFunc(funcAttrMap):
	inPtr = funcAttrMap['inPtr'] + funcAttrMap['inoutPtr']
	outPtr = funcAttrMap['outPtr'] + funcAttrMap['inoutPtr']
	if outPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
		funcAttrMap['temp2'] = '''
    ClUint32T temp2 = 0;'''
	elif inPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
		funcAttrMap['temp2'] = ''
	else:
		funcAttrMap['temp1'] = ''
		funcAttrMap['temp2'] = ''
	if funcAttrMap['replyNeeded'] > 0:
		funcAttrMap['createOutMsg'] = createOutMsgT.safe_substitute()
		funcAttrMap['deleteOutMsg'] = deleteOutMsgT.safe_substitute()
		funcAttrMap['flagNeedReply'] = ' | CL_RMD_CALL_NEED_REPLY'
	else:
		funcAttrMap['createOutMsg'] = ''
		funcAttrMap['deleteOutMsg'] = ''
		funcAttrMap['deleteOutMsg'] = ''
	if funcAttrMap['inMsgNeeded'] > 0:
		funcAttrMap['createInMsg'] = createInMsgT.safe_substitute()
	else:
		funcAttrMap['createInMsg'] = ''
	return syncClientT.safe_substitute(funcAttrMap)
		

def createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate sync stub
	genTemplateT = dict()
	genTemplateT['init'] = syncInit
	genTemplateT['declAppend'] = syncDeclAppend
	genTemplateT['append'] = syncAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inSyncAsPtrWithLength),\
						('inout', inoutSyncAsPtrWithLength),\
						('out', outSyncAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inSyncByReference),\
						('inout', inoutSyncByReference),\
						('out', outSyncByReference)])
	genTemplateT['byValue'] = dict([('in', inSyncByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['asDoublePointer'] = dict([('in', doNothing),\
					('inout', doNothing),\
					('out', outSyncAsdoublePointer)])
	genTemplateT['function'] = createSyncFunc
	genTemplateT['header'] = syncHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo,0)




asyncCreateOutMsgT = Template('''
        ${rc} = clBufferCreate(&${outMsg});
        if (CL_OK != ${rc})
        {
            goto L2;
        }
''')

asyncCreateInMsgT = Template('''

    ${rc} = clBufferCreate(&${inMsg});
    if (CL_OK != ${rc})
    {
        goto L;
    }''')

inAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${callMemberFuncType}(${callMarshallEntry}, ${inMsg}, 0);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inoutAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${callMemberFuncType}(${callMarshallEntry}, ${inMsg}, 1);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inAsyncUnmarshallT = Template('''
    retVal = clXdrUnmarshall${cbMemberFuncType}(${inMsg}, ${cbUnmarshallEntry});
    if (CL_OK != retVal)
    {
        goto L${argNum};
    }
''')

outAsyncUnmarshallT = Template('''
    if (CL_OK == rc)
    {
        retVal = clXdrUnmarshall${cbMemberFuncType}(${outMsg}, ${cbUnmarshallEntry});
        if (CL_OK != retVal)
        {
            goto L${argNum};
        }
    }
''')

asyncUnmarshallErrorEntryT = Template('''\
L${argNumPlusOne}: 
''')

asyncPointerLengthWriteT = Template('''
    temp1 = htonl(${lengthVar});
    rc = clBufferNBytesWrite(${inMsg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        goto L;
    }
''')

def asyncAsDoublePtr(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outAsyncAsPointerwithLength is
	#made into a function and called in the respective functions
	map['callMemberFuncType'] = 'Array' + argAttrMap['type']
	map['callMarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	map['cbMemberFuncType'] = 'Ptr' + argAttrMap['type']
	map['cbUnmarshallEntry'] = '(void**)&(' + argAttrMap['name'] + '), '+ argAttrMap['lengthVar']
	map['cbErrorMarshallEntry'] = map['callMarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	map['lengthVar'] = argAttrMap['lengthVar']
        if argAttrMap['isDecl'] == '1':
	        funcAttrMap['callDecl'] += argAttrMap['type'] + '** ' + argAttrMap['name']
        	funcAttrMap['cbDecl'] = argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '*))'
	        funcAttrMap['argList'] = '&'+argAttrMap['name']                
        else:
        	funcAttrMap['callMarshallList'] ='' 
        	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)
               	funcAttrMap['callMarshallList'] = ''
        	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)

def asyncAsPtrWithLength(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outAsyncAsPointerwithLength is
	#made into a function and called in the respective functions
	map['callMemberFuncType'] = 'Array' + argAttrMap['type']
	map['callMarshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
	map['cbMemberFuncType'] = 'Ptr' + argAttrMap['type']
	map['cbUnmarshallEntry'] = '(void**)&(' + argAttrMap['name'] + '), '+argAttrMap['lengthVar'] 
	map['cbErrorMarshallEntry'] = map['callMarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
	map['lengthVar'] = argAttrMap['lengthVar']
        if argAttrMap['isDecl'] == '1':
	        funcAttrMap['callDecl'] += argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['cbDecl'] = argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '*))'
	        funcAttrMap['argList'] = argAttrMap['name']
        else:                
        	funcAttrMap['callMarshallList'] ='' 
        	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)


def inAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_IN '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
        	funcAttrMap['callMarshallList'] += inAsyncClientMarshallT.safe_substitute(map)
        	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inoutAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_INOUT '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
	        funcAttrMap['callMarshallList'] += inoutAsyncClientMarshallT.safe_substitute(map)
        	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def outAsyncAsDoublePointer(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_OUT '
	asyncAsDoublePtr(funcAttrMap, argAttrMap, map)
	return funcAttrMap

def outAsyncAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_OUT '
	asyncAsPtrWithLength(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
        	funcAttrMap['callMarshallList'] = ''
                funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def asyncByReference(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outAsyncByReference is
	#made into a function and called in the respective functions
	map['callMemberFuncType'] = argAttrMap['type']
	map['callMarshallEntry'] = argAttrMap['name']
	map['cbMemberFuncType'] = argAttrMap['type']
	map['cbUnmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['cbErrorMarshallEntry'] = map['cbUnmarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['callDecl'] += argAttrMap['type'] + '* ' + argAttrMap['name']
        	funcAttrMap['cbDecl'] = argAttrMap['type'] + '  ' + argAttrMap['name']
	        funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '))'
	        funcAttrMap['argList'] = '&(' + argAttrMap['name'] + ')'
        else:                
        	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)


def inAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_IN '
	asyncByReference(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
	        funcAttrMap['callMarshallList'] = inAsyncClientMarshallT.safe_substitute(map)
        	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inoutAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_INOUT '
	asyncByReference(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
	        funcAttrMap['callMarshallList'] = inoutAsyncClientMarshallT.safe_substitute(map)
        	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def outAsyncByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for async client stub
	funcAttrMap = dict()
	map = dict()
	funcAttrMap['callDecl'] = 'CL_OUT '
	asyncByReference(funcAttrMap, argAttrMap, map)
        if argAttrMap['isDecl'] != '1':
	        funcAttrMap['callMarshallList'] = ''
        	funcAttrMap['cbUnmarshallList'] = outAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def inAsyncByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for async client stub
	funcAttrMap = dict()
	map = dict()
	map['callMemberFuncType'] = argAttrMap['type']
	map['callMarshallEntry'] = '&(' + argAttrMap['name'] + ')'
	map['cbMemberFuncType'] = argAttrMap['type']
	map['cbUnmarshallEntry'] = map['callMarshallEntry']
	map['cbErrorMarshallEntry'] = map['cbUnmarshallEntry']
	map['argNum'] = argAttrMap['argNum']
	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['callDecl'] = 'CL_IN ' + argAttrMap['type'] + '  ' + argAttrMap['name']
        	funcAttrMap['cbDecl'] = argAttrMap['type'] + '  ' + argAttrMap['name']
        	funcAttrMap['cbMemset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + argAttrMap['type'] + '))'
	        funcAttrMap['argList'] = argAttrMap['name']
        else:                
        	funcAttrMap['cbErrorMarshallList'] = asyncUnmarshallErrorEntryT.safe_substitute(map)
        	funcAttrMap['callMarshallList'] = inAsyncClientMarshallT.safe_substitute(map)
        	funcAttrMap['cbUnmarshallList'] = inAsyncUnmarshallT.safe_substitute(map)
	return funcAttrMap


def asyncInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['callDecl'] = ', '
	funcAttrMap['cbDecl'] = ''
	funcAttrMap['funcNo'] = ''
	funcAttrMap['callMarshallList'] = ''
	funcAttrMap['cbErrorMarshallList'] = ''
	funcAttrMap['cbUnmarshallList'] = ''
	funcAttrMap['cbMemset'] = ''
	funcAttrMap['argList'] = ''
	funcAttrMap['temp1'] = ''
	funcAttrMap['temp2'] = ''
	funcAttrMap['ptrChecks'] = ''
	funcAttrMap['outMsgCreate'] = ''
	funcAttrMap['outMsgDelete'] = ''
	funcAttrMap['inMsgCreate'] = ''
	funcAttrMap['flagNeedReply'] = ''

def asyncDeclAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['callDecl'] += argEntryToAdd['callDecl'] + ', '
	funcAttrMap['cbDecl'] += '    ' + argEntryToAdd['cbDecl'] + ''';
'''
	funcAttrMap['cbMemset'] += '    ' + argEntryToAdd['cbMemset'] + ''';
'''
	funcAttrMap['argList'] += argEntryToAdd['argList'] + ', '

def asyncAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['callMarshallList'] += argEntryToAdd['callMarshallList']
	funcAttrMap['cbUnmarshallList'] += argEntryToAdd['cbUnmarshallList']
	funcAttrMap['cbErrorMarshallList'] = argEntryToAdd['cbErrorMarshallList'] + funcAttrMap['cbErrorMarshallList']


#template for generating async client stub
asyncClientT = Template('''
${asyncCallback}

ClRcT ${name}ClientAsync(CL_IN ClIdlHandleT handle${callDecl}${cookieCallback})
{
    ClRcT rc = CL_OK;
    ClUint32T funcNo = ${funcNo};
    ClBufferHandleT ${inMsg} = 0;
    ClBufferHandleT ${outMsg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClRmdAsyncOptionsT asyncOptions;
    ClUint32T tempFlags = 0;
    ClIdlCookieT* pCookie = NULL;

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if(rc != CL_OK)
    {
        return rc;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            goto L;
        }
    }
    else
    {
        rc = CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
        goto L;
    }${createInMsg}
${callMarshallList}
    if(fpAsyncCallback != NULL)
    {
        ${rmdCookie}
        
        asyncOptions.pCookie = NULL;
        asyncOptions.fpCallback = NULL;
        ${createOutMsg}
        tempFlags |= pHandleObj->flags |
                     (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT${flagNeedReply});
        ${asyncOptionsFill}
        rc = clRmdWithMsg(address, funcNo, ${inMsg}, ${outMsg}, tempFlags, &(pHandleObj->options), &asyncOptions);
        if (CL_OK != rc)
        {
            goto ${errorLabel};
         }
    }
    else
    {
        tempFlags |= pHandleObj->flags |
                         (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT);
        rc = clRmdWithMsg(address, funcNo, ${inMsg}, 0, tempFlags, &(pHandleObj->options),NULL);
        if(CL_OK != rc)
        {
               goto L;
        }
    }
    
${return}
}

''')


#template for generating async callback
asyncCallbackT = Template('''
static void ${name}AsyncCallback(ClRcT rc, void *pIdlCookie, ClBufferHandleT ${inMsg}, ClBufferHandleT ${outMsg})
{
    ClIdlCookieT* pCookie = (ClIdlCookieT*)pIdlCookie;
    ClRcT retVal = CL_OK;
${cbDecl}
${cbMemset}
${cbUnmarshallList}
    if (rc != CL_OK)
    {
        retVal = rc;
    }

    ((${EoName}${Name}AsyncCallbackT)(pCookie->actualCallback))(pCookie->handle, ${argList}retVal, pCookie->pCookie);
    goto L${argNum};

${cbErrorMarshallList}
L0:  clHeapFree(pCookie);
     clBufferDelete(&${outMsg});
     return;
}
''')

#this template is for the snippet that creates the rmd
#cookie from IDL user's cookie & callback
asyncOptionsFillT = Template('''
        pCookie->pCookie = cookie;
        pCookie->actualCallback = (void(*)())fpAsyncCallback;
        pCookie->handle = handle;
        asyncOptions.pCookie = pCookie;
        asyncOptions.fpCallback = ${name}AsyncCallback;
''')


asyncHeaderT = Template('''
${asyncCallbackDef}ClRcT ${name}ClientAsync(CL_IN ClIdlHandleT handle${callDecl}${cookieCallback});
''')


def createAsyncFuncs(funcAttrMap):
	funcAttrMap['callDecl'] = funcAttrMap['callDecl'][:-2]
	funcAttrMap['EoName'] = upper(funcAttrMap['eoName'][0]) + funcAttrMap['eoName'][1:]
	funcAttrMap['Name'] = upper(funcAttrMap['name'][0]) + funcAttrMap['name'][1:]
	inPtr = funcAttrMap['inPtr'] + funcAttrMap['inoutPtr']
	if inPtr > 0:
		funcAttrMap['temp1'] = '''
    ClUint32T temp1 = 0;'''
	else:
		funcAttrMap['temp1'] = ''
	funcAttrMap['rmdCookie'] = '''

        pCookie = clHeapAllocate(sizeof(ClIdlCookieT));
        if (NULL == pCookie)
        {
            return CL_IDL_RC(CL_ERR_NO_MEMORY);
        }'''
	funcAttrMap['createOutMsg'] = asyncCreateOutMsgT.safe_substitute()
	funcAttrMap['deleteOutMsg'] = deleteOutMsgT.safe_substitute()
	funcAttrMap['flagNeedReply'] = ' | CL_RMD_CALL_NEED_REPLY'
	funcAttrMap['cookieCallback'] = ',CL_IN ' + funcAttrMap['EoName'] + funcAttrMap['Name'] + 'AsyncCallbackT fpAsyncCallback, CL_IN void *cookie'
	funcAttrMap['asyncCallbackDef'] = 'typedef void (*' + funcAttrMap['EoName'] + funcAttrMap['Name'] + 'AsyncCallbackT) (CL_IN ClIdlHandleT handle' + funcAttrMap['callDecl'] + ''', CL_IN ClRcT rc, CL_IN void* pCookie);

'''
	funcAttrMap['asyncCallback'] = asyncCallbackT.safe_substitute(funcAttrMap)
	funcAttrMap['asyncOptionsFill'] = asyncOptionsFillT.safe_substitute(funcAttrMap)
	funcAttrMap['return'] = '''    
    clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;

LL: clBufferDelete(&${outMsg});
L2:  clHeapFree(pCookie);
L:
    clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;'''
	funcAttrMap['errorLabel'] = 'LL'
	if funcAttrMap['inMsgNeeded'] > 0:
		funcAttrMap['createInMsg'] = asyncCreateInMsgT.safe_substitute()
	else:
		funcAttrMap['createInMsg'] = ''
	return asyncClientT.safe_substitute(funcAttrMap)


def createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate async client stub
	genTemplateT = dict()
	genTemplateT['init'] = asyncInit
	genTemplateT['declAppend'] = asyncDeclAppend
	genTemplateT['append'] = asyncAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inAsyncAsPtrWithLength),\
						('inout', inoutAsyncAsPtrWithLength),\
						('out', outAsyncAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inAsyncByReference),\
						('inout', inoutAsyncByReference),\
						('out', outAsyncByReference)])
	genTemplateT['byValue'] = dict([('in', inAsyncByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['asDoublePointer'] = dict([('in', doNothing),\
					('inout', doNothing),\
					('out', outAsyncAsDoublePointer)])
	genTemplateT['function'] = createAsyncFuncs
	genTemplateT['header'] = asyncHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo,1)


#dummy template for double pointer 
inServerDblPtrUnmarshallT = Template('''
''')

#server unmarshalling snippet
inServerUnmarshallT = Template('''
    ${rc} = clXdrUnmarshall${memberFuncType}( ${inMsg},${unmarshallEntry});
    if (CL_OK != ${rc})
    {
        goto LL${argNum};
    }
''')


#server marshalling snippet
inServerMarshallT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${outMsg}, ${isDelete});
    if (CL_OK != ${rc})
    {
        goto L${argNumPlusOne};
    }
''')

inArgServerMarshalT = Template('''
    ${rc} = clXdrMarshall${memberFuncType}(${marshallEntry}, ${outMsg}, ${isDelete});
    if (CL_OK != ${rc})
    {
        goto L${argErrNum};
    }
''')

#error code snippet if error encountered during marshall
marshallErrorEntryT = Template('''\
L${argNum}:  clXdrMarshall${memberFuncType}(${marshallEntry}, 0, 1);
''')

marshallErrorNumEntryT = Template('''\
L${argErrNum}:  clXdrMarshall${memberFuncType}(${marshallEntry}, 0, 1);
''')

unmarshallDblPtrErrorEntryT = Template('''\
''')
#error code snippet if error encountered during unmarshall
unmarshallErrorEntryT = Template('''\
LL${argNum}:  clXdrMarshall${memberFuncType}(${marshallEntry}, 0, 1);
''')

def serverAsPtrWithLength(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outServerAsPointerwithLength is
	#made into a function and called in the respective functions
	type =  argAttrMap['type'] + '*'
        if argAttrMap['isDecl'] == '1':
                funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
        	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
        	funcAttrMap['argList'] = argAttrMap['name']
        	funcAttrMap['funcDecl'] = map['argType'] + funcAttrMap['decl']
        	funcAttrMap['unmarshallErrorList'] = ''
        	funcAttrMap['marshallErrorList'] =''
        	funcAttrMap['unmarshallList'] =''
        	funcAttrMap['marshallList'] = ''
        	funcAttrMap['outFuncDecl'] = ''

                if(map['argType'] != 'CL_IN '):
        	        funcAttrMap['outFuncDecl'] += ','+argAttrMap['lengthVarType'] + ','+funcAttrMap['funcDecl']
        else:
                funcAttrMap['decl'] = '' 
        	funcAttrMap['memset'] = ''
        	funcAttrMap['argList'] = ''
        	funcAttrMap['funcDecl'] = ''
        	map['memberFuncType'] = 'Ptr' + argAttrMap['type']
        	map['unmarshallEntry'] = '(void**)&(' + argAttrMap['name'] + ')' + ', ' + argAttrMap['lengthVar']
        	map['marshallEntry'] = argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	map['isDelete'] = '1'
        	map['argNum'] = argAttrMap['argNum']
        	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
                funcAttrMap['outArgMarshallErrorList'] =''
                funcAttrMap['outArgMarshallList'] =''
                if(map['argType'] == 'CL_IN '):
                        funcAttrMap['inMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['outMarshallList'] = ''
                        funcAttrMap['inMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        funcAttrMap['outMarshallErrorList'] ='' 
                else:
                        funcAttrMap['outMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['inMarshallList'] = ''
                        funcAttrMap['inMarshallErrorList'] =''
                        funcAttrMap['outMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallErrorList'] += marshallErrorNumEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallList'] += inArgServerMarshalT.safe_substitute(map)
 
        	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)


def inServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type IN,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_IN '
	map['outMsg'] = '0'
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def inoutServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_INOUT '
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	return funcAttrMap

dblPtrAsyncAllocateT = Template('''
    ${name} = (${type}*)clHeapAllocate(sizeof(${type}) * (${lengthVar}));
    if (NULL == ${name})
    {
        return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
''')
dblPtrAllocateT = Template('''
    *${name} = (${type}*)clHeapAllocate(sizeof(${type}) * (*${lengthVar}));
    if (NULL == *${name})
    {
        return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
''')

ptrAllocateT = Template('''
    ${name} = (${type}*)clHeapAllocate(sizeof(${type}) * ${lengthVar});
    if (NULL == ${name})
    {
        goto LL${argNum};
    }
''')

def serverAsDoublePointer(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outServerAsPointerwithLength is
	#made into a function and called in the respective functions
	type =  argAttrMap['type'] + '*'
        if argAttrMap['isDecl'] == '1':
	        funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
        	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
        	funcAttrMap['argList'] = '&'+argAttrMap['name']
        	funcAttrMap['funcDecl'] = map['argType'] + type+'*'+ ' ' + argAttrMap['name']
        	funcAttrMap['unmarshallErrorList'] ='' 
        	funcAttrMap['marshallErrorList'] ='' 
        	funcAttrMap['unmarshallList'] ='' 
        	funcAttrMap['marshallList'] ='' 
        	funcAttrMap['outFuncDecl'] = ''
                if(map['argType'] != 'CL_IN '):
        	        funcAttrMap['outFuncDecl'] += ','+funcAttrMap['decl']
        else:
	        funcAttrMap['decl'] = '' 
        	funcAttrMap['memset'] =''
        	funcAttrMap['argList'] ='' 
        	funcAttrMap['funcDecl'] ='' 
        	map['memberFuncType'] = 'Ptr' + argAttrMap['type']
        	map['marshallEntry'] =  argAttrMap['name'] + ', ' + argAttrMap['lengthVar']
        	map['isDelete'] = '1'
        	map['argNum'] = argAttrMap['argNum']
	        map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        	funcAttrMap['unmarshallErrorList'] = unmarshallDblPtrErrorEntryT.safe_substitute(map)
        	funcAttrMap['unmarshallList'] = inServerDblPtrUnmarshallT.safe_substitute(map)
                funcAttrMap['outArgMarshallErrorList'] =''
                funcAttrMap['outArgMarshallList'] =''
                if(map['argType'] =='CL_IN '):
                        funcAttrMap['inMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['outMarshallList'] = ''
                        funcAttrMap['inMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        funcAttrMap['outMarshallErrorList'] =''
                else:
                        funcAttrMap['outMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['inMarshallList'] = '' 
                        funcAttrMap['inMarshallErrorList'] =''
                        funcAttrMap['outMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallErrorList'] += marshallErrorNumEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallList'] +=inArgServerMarshalT.safe_substitute(map)
        
def outServerByDoublePointer(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_OUT '
	serverAsDoublePointer(funcAttrMap, argAttrMap, map)
	return funcAttrMap

def outServerAsPtrWithLength(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#pointer with length variable for server stub
	map = dict()
	funcAttrMap = dict()
	map['argType'] = 'CL_OUT '
	serverAsPtrWithLength(funcAttrMap, argAttrMap, map)
	funcAttrMap['unmarshallList'] = ptrAllocateT.safe_substitute(argAttrMap)
	return funcAttrMap


def serverByReference(funcAttrMap, argAttrMap, map):
	#the common part of in/inout/outServerByReference is
	#made into a function and called in the respective functions
	type =  argAttrMap['type']
        if argAttrMap['isDecl'] == '1':
        	funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
        	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
        	funcAttrMap['argList'] = '&(' + argAttrMap['name'] + ')'
        	funcAttrMap['funcDecl'] = map['argType'] + argAttrMap['type'] + '*  ' + argAttrMap['name']
        	funcAttrMap['unmarshallErrorList'] ='' 
        	funcAttrMap['marshallErrorList'] = ''
        	funcAttrMap['unmarshallList'] = '' 
        	funcAttrMap['marshallList'] =''
        	funcAttrMap['outFuncDecl'] = ''
                if(map['argType'] != 'CL_IN '):
        	        funcAttrMap['outFuncDecl'] += ','+ map['argType']+' '+funcAttrMap['decl']
        else:
	        map['isDelete'] = '1'
        	funcAttrMap['decl'] =  ''
        	funcAttrMap['memset'] = ''
        	funcAttrMap['argList'] ='' 
        	funcAttrMap['funcDecl'] ='' 
        	map['memberFuncType'] = argAttrMap['type']
        	map['unmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
        	map['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
        	map['argNum'] = argAttrMap['argNum']
        	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
        	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)
                funcAttrMap['outArgMarshallErrorList'] =''
                funcAttrMap['outArgMarshallList'] =''
                if(map['argType'] =='CL_IN '):
                        funcAttrMap['inMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['outMarshallList'] = ''
                        funcAttrMap['inMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        funcAttrMap['outMarshallErrorList'] =''
                else:
                        funcAttrMap['outMarshallList'] = inServerMarshallT.safe_substitute(map)
                        funcAttrMap['inMarshallList'] = '' 
                        funcAttrMap['inMarshallErrorList'] =''
                        funcAttrMap['outMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallErrorList'] += marshallErrorNumEntryT.safe_substitute(map)
                        map['argErrNum'] = map['argNum']+1
                        funcAttrMap['outArgMarshallList'] += inArgServerMarshalT.safe_substitute(map)
	return funcAttrMap


def inServerByReference(argAttrMap):
	#collating code snippets for parameter of type IN,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_IN '
	map['outMsg'] = '0'
	serverByReference(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def inoutServerByReference(argAttrMap):
	#collating code snippets for parameter of type INOUT,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_INOUT '
	serverByReference(funcAttrMap, argAttrMap, map)
	return funcAttrMap


def outServerByReference(argAttrMap):
	#collating code snippets for parameter of type OUT,
	#reference for server stub
	funcAttrMap = dict()
	map = dict()
	map['argType'] = 'CL_OUT '
	serverByReference(funcAttrMap, argAttrMap, map)
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['unmarshallErrorList'] = ''
	return funcAttrMap


def inServerByValue(argAttrMap):
	#collating code snippets for parameter of type IN,
	#value for server stub
	funcAttrMap = dict()
	type =  argAttrMap['type']
        if argAttrMap['isDecl'] == '1':        
        	funcAttrMap['decl'] =  type + '  ' + argAttrMap['name']
        	funcAttrMap['memset'] = 'memset(&(' + argAttrMap['name'] + '), 0, sizeof(' + type + '))'
        	funcAttrMap['argList'] = argAttrMap['name']
        	funcAttrMap['funcDecl'] = 'CL_IN ' + funcAttrMap['decl']
        	funcAttrMap['unmarshallErrorList'] ='' 
        	funcAttrMap['marshallErrorList'] ='' 
        	funcAttrMap['unmarshallList'] ='' 
        	funcAttrMap['inMarshallList'] ='' 
        	funcAttrMap['outMarshallList'] ='' 
        	funcAttrMap['outFuncDecl'] = ''
        else:
        	funcAttrMap['decl'] = '' 
        	funcAttrMap['memset'] = ''
        	funcAttrMap['argList'] = ''
        	funcAttrMap['funcDecl'] = ''
        	map = dict()
        	map['memberFuncType'] = argAttrMap['type']
        	map['unmarshallEntry'] = '&(' + argAttrMap['name'] + ')'
        	map['marshallEntry'] = '&(' + argAttrMap['name'] + ')'
        	map['outMsg'] = '0'
        	map['isDelete'] = '1'
        	map['argNum'] = argAttrMap['argNum']
        	map['argNumPlusOne'] = argAttrMap['argNum'] + 1
        	funcAttrMap['unmarshallErrorList'] = unmarshallErrorEntryT.safe_substitute(map)
        	funcAttrMap['inMarshallErrorList'] = marshallErrorEntryT.safe_substitute(map)
        	funcAttrMap['outMarshallErrorList'] ='' 
        	funcAttrMap['outArgMarshallErrorList'] ='' 
        	funcAttrMap['outArgMarshallList'] ='' 
        	funcAttrMap['unmarshallList'] = inServerUnmarshallT.safe_substitute(map)
        	funcAttrMap['inMarshallList'] = inServerMarshallT.safe_substitute(map)
        	funcAttrMap['outMarshallList'] ='' 
	return funcAttrMap


def serverInit(funcAttrMap):
	funcAttrMap['name'] = ''
	funcAttrMap['decl'] = ''
	funcAttrMap['memset'] = ''
	funcAttrMap['funcDecl'] = ''
	funcAttrMap['outFuncDecl'] = ''
	funcAttrMap['argList'] = ''
	funcAttrMap['marshallList'] = ''
	funcAttrMap['inMarshallList'] = ''
	funcAttrMap['outMarshallList'] = ''
	funcAttrMap['outArgMarshallList'] = ''
	funcAttrMap['unmarshallList'] = ''
	funcAttrMap['inMarshallErrorList'] = ''
	funcAttrMap['outMarshallErrorList'] = ''
	funcAttrMap['outArgMarshallErrorList'] = ''
	funcAttrMap['unmarshallErrorList'] = ''


def serverDeclAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['decl'] += '    ' + argEntryToAdd['decl'] + ''';
'''
	funcAttrMap['memset'] += '    ' + argEntryToAdd['memset'] + ''';
'''
	funcAttrMap['funcDecl'] += argEntryToAdd['funcDecl'] +', '
        
        s = find(argEntryToAdd['outFuncDecl'][1:], ",") 
        if (find(funcAttrMap['outFuncDecl'], argEntryToAdd['outFuncDecl'][:s]) == -1):
                funcAttrMap['outFuncDecl'] += argEntryToAdd['outFuncDecl']
        else:
                funcAttrMap['outFuncDecl'] += argEntryToAdd['outFuncDecl'][s+1:]
	funcAttrMap['argList'] +=  argEntryToAdd['argList']+', '

def serverAppend(funcAttrMap, argEntryToAdd):
	funcAttrMap['inMarshallList'] += argEntryToAdd['inMarshallList']
	funcAttrMap['outMarshallList'] += argEntryToAdd['outMarshallList']
	funcAttrMap['outArgMarshallList'] += argEntryToAdd['outArgMarshallList']
	funcAttrMap['unmarshallList'] += argEntryToAdd['unmarshallList']
	funcAttrMap['inMarshallErrorList'] += argEntryToAdd['inMarshallErrorList']
	funcAttrMap['outMarshallErrorList'] += argEntryToAdd['outMarshallErrorList']
	funcAttrMap['outArgMarshallErrorList'] += argEntryToAdd['outArgMarshallErrorList']
	funcAttrMap['unmarshallErrorList'] = argEntryToAdd['unmarshallErrorList'] + funcAttrMap['unmarshallErrorList']


#template for generating server stub
serverT = Template('''
ClRcT ${name}Server(ClEoDataT eoData, ClBufferHandleT ${inMsg}, ClBufferHandleT ${outMsg})
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT ${rc} = CL_OK;
${decl}
${memset}
${unmarshallList}
    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, '0' ,sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(${eoName}idlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    /*
     * The macro APP_SERVICE_DEFINED needs to be set to 1, after
     * applicaiton defines its services. This definition exists in
     * the header file
     */
   #if APP_SERVICE_DEFINED 
    ${rc} = ${name}(${argList});
   #endif 
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != ${rc})
    {
       goto L0;
    }
    ${inMarshallList}
    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    ${outMarshallList}
L${argNum}:    return ${rc};

${unmarshallErrorList}
    return ${rc};

${inMarshallErrorList}
${outMarshallErrorList}
    return ${rc};
}

ClRcT ${name}ResponseSend(ClIdlHandleT idlHdl,ClRcT retCode${outFuncDecl})
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(${eoName}idlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Lable0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    ${outArgMarshallList}
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Lable1; 
${outArgMarshallErrorList}
    clHandleCheckin(${eoName}idlDatabaseHdl, idlHdl);
    clHandleDestroy(${eoName}idlDatabaseHdl, idlHdl);
    return rc;
Lable1:
    clHandleCheckin(${eoName}idlDatabaseHdl, idlHdl);
    clHandleDestroy(${eoName}idlDatabaseHdl, idlHdl);
Lable0:
    return rc;
}
''')


serverHeaderT = Template('''
ClRcT ${name}(${funcDecl});

ClRcT ${name}ResponseSend(CL_IN ClIdlHandleT idlHdl,CL_IN ClRcT retCode${outFuncDecl});

''')


def createServerFunc(funcAttrMap):
	return serverT.safe_substitute(funcAttrMap)


def createServerStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo):
	#this function creates the map 'genTemplateT' with
	#appropriate templates/functions and calls the createStub
	#to generate server stub
	genTemplateT = dict()
	genTemplateT['init'] = serverInit
	genTemplateT['declAppend'] = serverDeclAppend
	genTemplateT['append'] = serverAppend
	genTemplateT['asPtrWithLength'] = dict([('in', inServerAsPtrWithLength),\
						('inout', inoutServerAsPtrWithLength),\
						('out', outServerAsPtrWithLength)])
	genTemplateT['byReference'] = dict([('in', inServerByReference),\
						('inout', inoutServerByReference),\
						('out', outServerByReference)])
	genTemplateT['byValue'] = dict([('in', inServerByValue),\
					('inout', doNothing),\
					('out', doNothing)])
	genTemplateT['asDoublePointer'] = dict([('in', doNothing),\
					('inout', doNothing),\
					('out', outServerByDoublePointer)])
	genTemplateT['function'] = createServerFunc
	genTemplateT['header'] = serverHeaderT
	return createStub(genFilesDir, service, serviceNo, clientId, genTemplateT, typeNeeded, eo,2)


#template to create server header
serverHFileT = Template('''
/*********************************************************************
* File: 
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for server stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _${Service1}${CLIENT}${GROUP}_SERVER_H_
#define _${Service1}${CLIENT}${GROUP}_SERVER_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include <ipi/clRmdIpi.h>
#include "../clientIDDefinitions.h"

/* 
 * Set APP_SERVICE_DEFINED to 0, if application doesn't defines 
 * its services. Default value 1 will give compilation error if there
 * is no serivice defined by user.  
 */
#define APP_SERVICE_DEFINED 1
${xdrIncList}

${serverDeclarations}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}${CLIENT}${GROUP}_SERVER_H_*/
''')


#template to create server C file
serverCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "${eo}${client}${group}Server.h"
#include "${eo}Server.h"

extern ClUint32T  ${eo}idlSyncKey;
extern ClHandleDatabaseHandleT  ${eo}idlDatabaseHdl;


${serverFuncList}
''')

commServerHFileT = Template('''\
/*********************************************************************
* File: 
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for server stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _${Service1}_SERVER_H_
#define _${Service1}_SERVER_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include <ipi/clRmdIpi.h>
#include "../clientIDDefinitions.h"
${xdrIncList}


ClRcT cl${eo}IdlSyncDefer(ClIdlHandleT *pIdlHdl);
        
ClRcT cl${eo}ClientInstall(void);

ClRcT cl${eo}ClientUninstall(void);

${serviceDeclList}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}_SERVER_H_*/
''')
commServerCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "${eo}${client}${group}Server.h"
#include "${eo}Server.h"

ClHandleDatabaseHandleT  ${eo}idlDatabaseHdl = 0;
ClUint32T                ${eo}idlSyncKey     = 0;

${clientList}


ClRcT cl${eo}IdlSyncDefer(ClIdlHandleT *pIdlHdl)
{
    return clIdlSyncDefer(${eo}idlDatabaseHdl, ${eo}idlSyncKey, pIdlHdl);
}    
    
ClRcT cl${eo}ClientInstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }

${clientInstallList}
    rc = clOsalTaskKeyCreate(&${eo}idlSyncKey,NULL);
    if (CL_OK != rc)
    {
        return rc;
    }
    rc = clHandleDatabaseCreate(NULL,&${eo}idlDatabaseHdl);


    return ${rc};
}

ClRcT cl${eo}ClientUninstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
    rc = clOsalTaskKeyDelete(${eo}idlSyncKey);
    if (CL_OK != rc)
    {
        return rc;
    }
    rc = clHandleDatabaseDestroy(${eo}idlDatabaseHdl);
    if (CL_OK != rc)
    {
        return rc;
    }

${clientUninstallList}

    return ${rc};
}

    
''')

#template to create function that installs server stubs in EO
clientInstallT = Template('''
    ${rc} = clEoClientInstall(${pEoObj}, ${clientId}, ${client}, 0, (sizeof(${client})/sizeof(${client}[0])));
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')

#template to create function that uninstalls server stubs from EO
clientUninstallT = Template('''
    clEoClientUninstall(${pEoObj}, ${clientId});''');

#template for the data structure that is passed to the functions above
clientDefinitionT = Template('''
static ClEoPayloadWithReplyCallbackT ${eo}Client${Num}[] = {
${serviceInstallList}
};
''')

#template to create client C file
clientCFileT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :ClientSide Stub routines
*
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*
*********************************************************************/

#include <netinet/in.h>
#include <string.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clIdlApi.h>
#include <clEoApi.h>
#include <clXdrApi.h>
#include <clHandleApi.h>
#include "${eo}${client}${group}Client.h"
extern ClIdlClntT gIdlClnt;
        

${syncClientList}

''')

#template to create client header
clientHFileT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for client stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#ifndef _${Service1}${CLIENT}${GROUP}_CLIENT_H_
#define _${Service1}${CLIENT}${GROUP}_CLIENT_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include "../clientIDDefinitions.h"
${xdrIncList}

${syncClientDecl}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}${CLIENT}${GROUP}_CLIENT_H_*/
''')


userImplFileT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the server stub routines which user
* 				implements
*
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. 
*********************************************************************/

#include<clIdlApi.h>

''')

userImplFuncT = Template('''

ClRcT ${serviceName}(ClIdlHandleT handle, ClInt8T ARGUMENT0, ClInt16T* ARGUMENT1)
{
	ClRcT rc = CL_OK;
	
	
	return rc;
}

''')



def parseEo(genFilesDir, eoObj):
	#this function parses the EO definition and creates
	#the server & client files
	number = 0
	stubGen = dict()
	eo = eoObj.attributes["name"].value
	typeNeeded = dict()

	syncClientList = ''
	syncClientDecl = ''

	serviceDeclList = ''
	clientList = ''
	serverFuncList = ''
	clientInstallList = ''
	clientUninstallList = ''
	serverDeclarations = ''
	serviceInstallList = ''

	clientNum = 0
	clientIDs = ""
        serverMap = dict()
	#parse the client definitions
	for client in eoObj.getElementsByTagName('Port'):
		useNativeTable = "true"
		try:
			useNativeTable = client.attributes["useNativeTable"].value
		except:
			pass

		if useNativeTable == "true":
			clientId = 'CL_EO_NATIVE_COMPONENT_TABLE_ID'
		else:
			clientId = client.attributes["name"].value

		if clientId != 'CL_EO_NATIVE_COMPONENT_TABLE_ID':
			clientIDDef = clientIDHeaderT.safe_substitute(clientId = clientId, number = number)
			number = number + 1
			clientIDs += clientIDDef
		clMap = dict()
		clMap['clientId'] = clientId
		clMap['client'] = eo + 'Client' + str(clientNum)
		clientInstallList += clientInstallT.safe_substitute(clMap)
		clientUninstallList += clientUninstallT.safe_substitute(clMap)
                if client.attributes.has_key('startFuncId'):                
            		serviceNo = int(client.attributes['startFuncId'].value,10) 
                else:
                        serviceNo = 0
                tempCount = 0
                for tempCount in range(serviceNo):
                        serviceInstallList += "(ClEoPayloadWithReplyCallbackT) NULL,\n"
		#parse the service definitions
#               	srvInstMap['serviceInstallList'] = serviceInstallList[:2]

                for group in client.getElementsByTagName('Group'):
                        serverFuncList ='' 
                        serverDeclarations ='' 
                        syncClientList ='' 
                        syncClientDecl ='' 
                        userImplFunc =''
                        for service in group.getElementsByTagName('Operation'):
                #create the server stub
                            stubGen = createServerStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                            serverFuncList += stubGen['code']
                            serverDeclarations += stubGen['header']
                            serviceInstallList += service.attributes['name'].value + '''Server,
'''
                            serviceDeclList += 'extern ClRcT ' + service.attributes['name'].value + '''Server(ClEoDataT eoData, ClBufferHandleT inmSgHdl , ClBufferHandleT outMsgHdl);
'''
                            serviceName = service.attributes['name'].value
                            userImplFunc += userImplFuncT.safe_substitute(serviceName=serviceName)
                           #create the sync client stub
                            if service.attributes.has_key("type"):
                                if(service.attributes['type'].value == "sync"):
                                    stubGen = createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                                    syncClientList += stubGen['code']
                                    syncClientDecl += stubGen['header']
                                elif(service.attributes['type'].value == "async"):
                                #create the async client stub
                                    stubGen = createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                                    syncClientList += stubGen['code']
                                    syncClientDecl += stubGen['header']
                            else:
                                stubGen = createSyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                                syncClientList += stubGen['code']
                                syncClientDecl += stubGen['header']
                                
                                stubGen = createAsyncStub(genFilesDir, service, serviceNo, clientId, typeNeeded, eo)
                                syncClientList += stubGen['code']
                                syncClientDecl += stubGen['header']
                            serviceNo+=1    

        	        commonHeaderFile = open(genFilesDir + filePathSeparator + 'clientIDDefinitions.h', 'w');
        	        commonHeaderFile.write(clientIDHeader.safe_substitute(clientIDs = clientIDs))
        	        commonHeaderFile.close();

        	        incList = ''
        	        for udt in typeNeeded.keys():
        		        incList += '#include "../xdr/' + getHFileName(udt) + '''"
'''
                	symbolMap = dict([('rc', 'rc'), ('inMsg', 'inMsgHdl'), ('outMsg', 'outMsgHdl'), ('pEoObj', 'pEoObj')])
        
                  	#write the generated code into the files
        	        #write to file: server
                	
                	serverMap['serverFuncList'] = serverFuncList
                	serverMap['serviceDeclList'] = serviceDeclList
                	serverMap['clientInstallList'] = clientInstallList
                	serverMap['clientUninstallList'] = clientUninstallList
                	serverMap['serverDeclarations'] = serverDeclarations
                	serverMap['eo'] = eo
                	serverMap['client'] = client.attributes['name'].value
                        serverMap['group'] = group.attributes['name'].value
                	serverMap['Service1'] = upper(eo)
                	serverMap['CLIENT'] = upper(client.attributes['name'].value)
                	serverMap['GROUP'] =upper(group.attributes['name'].value); 
                	serverMap['xdrIncList'] = incList
                	serverCodeT = Template(serverCFileT.safe_substitute(serverMap))
                	serverFile = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +\
                				eo +client.attributes['name'].value+group.attributes['name'].value+'Server.c', 'w')
                	serverFile.write(serverCodeT.safe_substitute(symbolMap))
                	serverFile.close()
                	
                	#------------Generating user impl stub file---------#
                	userImplFileName = genFilesDir + filePathSeparator + 'server' + filePathSeparator + eo
                	userImplFileName += client.attributes['name'].value+group.attributes['name'].value + 'ServerImpl.c'
                	userImplFile = open(userImplFileName, "w")
                	userImplFileContents = userImplFileT.safe_substitute()
                	userImplFileContents += userImplFunc
                	userImplFile.write(userImplFileContents)
                	userImplFile.close()
                	#---------------------------------------------------#
                	userImplNewFileName = "app" + filePathSeparator + "idl" + filePathSeparator + eo + filePathSeparator
                	userImplNewFileName += "server" + filePathSeparator + eo + client.attributes['name'].value
                	userImplNewFileName += group.attributes['name'].value + 'ServerImpl.c'
                	
                	userImplOldFileName = "app" + filePathSeparator + "idl" + filePathSeparator + newOldNameMap[eo] + filePathSeparator
                	userImplOldFileName += "server" + filePathSeparator + newOldNameMap[eo] 
                	try:
                		userImplOldFileName += rdnToOldNameMap[client.attributes['rdn'].value]
                	except:
                		userImplOldFileName += client.attributes['name'].value
                	try:
                		userImplOldFileName += rdnToOldNameMap[group.attributes['rdn'].value]
                	except:
                		userImplOldFileName += group.attributes['name'].value
                		
                	userImplOldFileName += 'ServerImpl.c'
                	
                	writeToMapFile(userImplOldFileName, userImplNewFileName)
                	#---------------------------------------------------#
                	serverHeader = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +eo +client.attributes['name'].value+group.attributes['name'].value+'Server.h', 'w')
                	serverHeader.write(serverHFileT.safe_substitute(serverMap))
                	serverHeader.close()
                	#write to file: client
                	clientMap = dict()
                	clientMap['syncClientList'] = syncClientList
                	clientMap['syncClientDecl'] = syncClientDecl
                	clientMap['eo'] = eo
                	clientMap['client'] = client.attributes['name'].value
                	clientMap['group'] = group.attributes['name'].value
                	clientMap['CLIENT'] = upper(client.attributes['name'].value)
                	clientMap['GROUP'] = upper(group.attributes['name'].value)
                	clientMap['Service1'] = upper(eo)
                	clientMap['xdrIncList'] = incList
                	clientCodeT = Template(clientCFileT.safe_substitute(clientMap))
                	clientFile = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator +eo +client.attributes['name'].value+group.attributes['name'].value+'Client.c', 'w')
                	clientFile.write(clientCodeT.safe_substitute(symbolMap))
                	clientFile.close()
                	clientHeader = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator+eo +client.attributes['name'].value+group.attributes['name'].value+'Client.h', 'w')
                	clientHeader.write(clientHFileT.safe_substitute(clientMap))
                	clientHeader.close()
       		srvInstMap = dict()
       		srvInstMap['eo'] = eo
       		srvInstMap['Num'] = str(clientNum)
              	srvInstMap['serviceInstallList'] = serviceInstallList[:-2]
                clientList += clientDefinitionT.safe_substitute(srvInstMap)
                serverMap['clientList'] = clientList
                commServerCodeT = Template(commServerCFileT.safe_substitute(serverMap))
                commServerFile = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +eo+'Server.c', 'w')
               	commServerFile.write(commServerCodeT.safe_substitute(symbolMap))
               	commServerFile.close()
               	commServerHeader = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator +eo+'Server.h', 'w')
               	commServerHeader.write(commServerHFileT.safe_substitute(serverMap))
               	commServerHeader.close()
       		clientNum += 1
                                        
#Makefile for all idl
idlMakeT = Template("""
                                                                                                                             
##############################################################################
#
#
# This Makefile is auto-generated by OpenClovis IDE
# Makefile for components
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
# Date: ${DateTime}
# User: ${User}
#
################################################################################
# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server
SUBDIRS          = ${eoList}
#
# If you have any ordering dependence among subdirectories, list them as
# target-prerequisite pairs.
#

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
                                                                                                                             
""")


#top level makefile template
topLevelMakeT = Template('''\
################################################################################
#
# Makefile for idl client library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = xdr client server

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')
topXdrMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = xdr

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')

#library (client/server) makefile template
clientMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${eoname}

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c) 

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${Eoname}${libType}
CPPFLAGS    = -I ../xdr/

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

#library (xdr) makefile template
xdrMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${comp1}xdr 

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${comp1}Xdr

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

xdrOpenMakeT = Template('''\
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${eoname} 

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp} 

# Library name:

LIB_NAMES	= libCl${Eoname}${libType}

# ---BEGIN_APPLICATION_CODE---


# ---END_APPLICATION_CODE---

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

freeFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
* File        : clIdlGen.py
*********************************************************************/
/*********************************************************************
* Description : This file contains IDL related open functions.
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE.
*     
*********************************************************************/
#include <clCommonErrors.h>
#include <clOsalApi.h>
#include <clDebugApi.h>
#include <clXdrApi.h>
/*********************************************************************
 * Description: This function is used for freeing the server side
 *              memory allocated by server when called from IDL. The
 *              memory free mechanism used should be the same as used
 *              while allocating the memory. By default, clHeapFree is
 *              used, which should be replaced by user specific "free"
 *              function.
*********************************************************************/

ClRcT clIdlFree(void *pData)
{
    CL_DEBUG_PRINT(CL_DEBUG_WARN,("Warning! clIdlFree in file %s "
        "uses clHeapFree for freeing memory allocated by server "
        "function.\\n", __FILE__));
    clHeapFree(pData);
    return CL_OK;    
}
''')

def generateCode(topgenFilesDir, idlSpecFile):
	eoNameList = ""
	makeMap = dict()
	#parse the xml file!!!
	idlSpec = xml.dom.minidom.parse(idlSpecFile)
	#create the directory structure
	eoList = idlSpec.getElementsByTagName("Service")
        if(eoList != []):
	        for eo in eoList:
			## For each service specified in the xml file, we create a directory with 3 sub dirs, xdr, client and server
			
        		genFilesDir = topgenFilesDir + filePathSeparator + eo.attributes["name"].value 
        		eoNameList += eo.attributes["name"].value + " "
        		if 0 == os.path.exists(genFilesDir + filePathSeparator + 'xdr'):
        			os.makedirs(genFilesDir + filePathSeparator + 'xdr')
        		structUnions = [struct.attributes['name'].value for struct in eo.getElementsByTagName('Struct')]
        		structUnions += [struct.attributes['name'].value for struct in eo.getElementsByTagName('Union')]
			files = []  ## List of files to be included. Given in the xml.
                	for file in idlSpec.getElementsByTagName('Include'):
                    		files.append(file.attributes['name'].value)
        
        		#generate the XDR code
        		for struct in eo.getElementsByTagName('Struct'):
        			parseStruct(genFilesDir, struct, structUnions,files)
        		for union in eo.getElementsByTagName('Union'):
        			parseUnion(genFilesDir, union, structUnions)
        		for enum in eo.getElementsByTagName('Enum'):
        			parseEnum(genFilesDir, enum, structUnions,files)
        			
        		oldFreeFileName ="app" + filePathSeparator +"idl" + filePathSeparator + newOldNameMap[eo.attributes["name"].value] + '/xdr/clIdlOpen.c'
        		newFreeFileName ="app" + filePathSeparator +"idl" + filePathSeparator + eo.attributes["name"].value + '/xdr/clIdlOpen.c'
        		
        		writeToMapFile(oldFreeFileName, newFreeFileName)
        		
        		freeFile = open(genFilesDir + filePathSeparator + 'xdr/clIdlOpen.c','w')
        		freeFile.write(freeFileT.safe_substitute())
        		freeFile.close()
        		#generate the server & client stubs
	        	if 0 == os.path.exists(genFilesDir + filePathSeparator + 'client'):
        			os.makedirs(genFilesDir + filePathSeparator + 'client')
        		if 0 == os.path.exists(genFilesDir + filePathSeparator + 'server'):
        			os.makedirs(genFilesDir + filePathSeparator + 'server')
                        makeMap['eoname'] = eo.attributes['name'].value
                        makeMap['Eoname'] = upper(makeMap['eoname'][0]) + makeMap['eoname'][1:]
                        parseEo(genFilesDir, eo)
                    	#generate the makefiles
                    	makeMap['svrName'] = makeMap['eoname']
                    	topMkFile = open(genFilesDir + filePathSeparator + 'Makefile', 'w')
                    	topMkFile.write(topLevelMakeT.safe_substitute(makeMap))
                    	topMkFile.close()
                    	makeMap['comp']=''
                    	for comp in idlSpec.getElementsByTagName("Comp"):
        			makeMap['comp']+= " "+comp.attributes['name'].value
                       	makeMap['libType'] = 'IdlOpen'
                       	xdrMkFile = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + 'Makefile', 'w')
                       	xdrMkFile.write(xdrOpenMakeT.safe_substitute(makeMap))
                       	xdrMkFile.close()
                    	makeMap['libType'] = 'Client'
                    	clientMkFile = open(genFilesDir + filePathSeparator + 'client' + filePathSeparator + 'Makefile', 'w')
                    	clientMkFile.write(clientMakeT.safe_substitute(makeMap))
                    	clientMkFile.close()
                    	makeMap['libType'] = 'Server'
                    	serverMkFile = open(genFilesDir + filePathSeparator + 'server' + filePathSeparator + 'Makefile', 'w')
                    	serverMkFile.write(clientMakeT.safe_substitute(makeMap))
                    	serverMkFile.close()
        	topIdlMakefile = open(topgenFilesDir + filePathSeparator + 'Makefile', 'w')
        	topIdlMakefile.write(idlMakeT.safe_substitute(eoList = eoNameList))
        	topIdlMakefile.close()
        
        else:                
                genFilesDir = topgenFilesDir        
	        if 0 == os.path.exists(genFilesDir + filePathSeparator + 'xdr'):
        		os.makedirs(genFilesDir + filePathSeparator + 'xdr')
        	structUnions = [struct.attributes['name'].value for struct in idlSpec.getElementsByTagName('Struct')]
        	structUnions += [struct.attributes['name'].value for struct in idlSpec.getElementsByTagName('Union')]
                files = []
                for file in idlSpec.getElementsByTagName('Include'):
                    files.append(file.attributes['name'].value)
                
        	#generate the XDR code
        	for struct in idlSpec.getElementsByTagName('Struct'):
        		parseStruct(genFilesDir, struct, structUnions,files)
        	for union in idlSpec.getElementsByTagName('Union'):
        		parseUnion(genFilesDir, union, structUnions)
        	for enum in idlSpec.getElementsByTagName('Enum'):
        		parseEnum(genFilesDir, enum, structUnions,files)
                freeFile = open(genFilesDir + filePathSeparator + 'xdr/clIdlOpen.c','w')
                freeFile.write(freeFileT.safe_substitute())
                freeFile.close()
                topMkFile = open(genFilesDir + filePathSeparator + 'Makefile', 'w')
                topMkFile.write(topXdrMakeT.safe_substitute(makeMap))
                topMkFile.close()
        	for comp in idlSpec.getElementsByTagName("Comp"):
        		makeMap['comp'] = comp.attributes['name'].value 
        		makeMap['comp1'] = upper(makeMap['comp'][0])+ makeMap['comp'][1:]
        	xdrMkFile = open(genFilesDir + filePathSeparator + 'xdr' + filePathSeparator + 'Makefile', 'w')
        	xdrMkFile.write(xdrMakeT.safe_substitute(makeMap))
        	xdrMkFile.close()
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

def writeToMapFile(oldFilePath, newFilePath):
	nameMapFile.write(oldFilePath);
	nameMapFile.write(",");
	nameMapFile.write(newFilePath);
	nameMapFile.write("\n");
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------


#Script Execution Starts Here.
idlSpecXml = sys.argv[1]

genFilesDir = sys.argv[2]

#-----------------------------------------------------------------------------------------------#
#$projName/.nameMapFile contains entry for old to new file mapping
# used by code merge utility.

modelchangesXmi = sys.argv[3]

componentdataXml = sys.argv[4]

if os.path.exists(modelchangesXmi):
	modelchangesDoc = xml.dom.minidom.parse(modelchangesXmi)
else :
	modelchangesDoc = None
	
if os.path.exists(componentdataXml):
	componentdataDoc = xml.dom.minidom.parse(componentdataXml)
else:
	print "Cannot find file "+componentdataXml 

#new to old EO name map	
global newOldNameMap
newOldNameMap = dict()

#rdn to name map for PORT and GROUP of idl only when change type is modify
global rdnToOldNameMap
rdnToOldNameMap = dict()


import oldNewNameMapping
if modelchangesDoc != None:
	newOldNameMap = oldNewNameMapping.getNewOldEONameMap(modelchangesDoc, componentdataDoc)
	rdnToOldNameMap = oldNewNameMapping.getRdnToOldNameMap(modelchangesDoc)
else :
	newOldNameMap = oldNewNameMapping.getDefaultNewOldEONameMap(componentdataDoc)
	
global nameMapFile
nameMapFile = open("../.nameMapFile", "a")

#-----------------------------------------------------------------------------------------------#
filePathSeparator = '/'

#clTypes is a map that is used to convert from xml basic type to
#the corresponding actual clovis basic type
clTypes = dict()
clTypes['ClInt8T'] = 'ClInt8T';
clTypes['ClInt16T'] = 'ClInt16T';
clTypes['ClInt32T'] = 'ClInt32T';
clTypes['ClInt64T'] = 'ClInt64T';
clTypes['ClUint8T'] = 'ClUint8T';
clTypes['ClUint16T'] = 'ClUint16T';
clTypes['ClUint32T'] = 'ClUint32T';
clTypes['ClUint64T'] = 'ClUint64T';
clTypes['ClCharT']  = 'ClCharT';
clTypes['ClNameT']  = 'ClNameT';
clTypes['ClVersionT']  = 'ClVersionT';
clTypes['ClHandleT']  = 'ClHandleT';

if os.path.exists(idlSpecXml):
    generateCode(genFilesDir, idlSpecXml)

#close EO name map file
nameMapFile.close()



