
#include <string.h>
#include <clLogApi.h>
#include <clSnmpLog.h>
#include <clDebugApi.h>
#include <clSnmpOp.h>
#include <clSnmpsafAmfScalars.h>
#include <clSnmpsafAmfTables.h>
#include <clSnmpsafAmfNotifications.h>
#include <clSnmpsafAmfUtil.h>
#include <clSnmpsafAmfInstXlation.h>
#include <clSnmpSubAgentsafAmfConfig.h>

/*
 * This function needs to be written for every application MIB sub-agent. From
 * this function call the app MIB specific init functions. The app MIB
 * specific init functions are generated by mib2c
 */
 
void init_safAmfMIB(void)
{
    /*Application needs to replace the below function with  mib2c generated init function.*/
    clSnmpsafAmfScalarsInit();
    clSnmpsafAmfTablesInit();
}

ClInt32T  clSnmpsafAmfDefaultInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfApplicationTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfApplicationTableInfo.saAmfApplicationNameId, (ClUint32T) pTabIdx2->index.saAmfApplicationTableInfo.saAmfApplicationNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfApplicationTableInfo.saAmfApplicationNameId - (ClUint32T) pTabIdx2->index.saAmfApplicationTableInfo.saAmfApplicationNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfNodeTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfNodeTableInfo.saAmfNodeNameId, (ClUint32T) pTabIdx2->index.saAmfNodeTableInfo.saAmfNodeNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfNodeTableInfo.saAmfNodeNameId - (ClUint32T) pTabIdx2->index.saAmfNodeTableInfo.saAmfNodeNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSGTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSGTableInfo.saAmfSGNameId, (ClUint32T) pTabIdx2->index.saAmfSGTableInfo.saAmfSGNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSGTableInfo.saAmfSGNameId - (ClUint32T) pTabIdx2->index.saAmfSGTableInfo.saAmfSGNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSUTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSUTableInfo.saAmfSUNameId, (ClUint32T) pTabIdx2->index.saAmfSUTableInfo.saAmfSUNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSUTableInfo.saAmfSUNameId - (ClUint32T) pTabIdx2->index.saAmfSUTableInfo.saAmfSUNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSITableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSITableInfo.saAmfSINameId, (ClUint32T) pTabIdx2->index.saAmfSITableInfo.saAmfSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSITableInfo.saAmfSINameId - (ClUint32T) pTabIdx2->index.saAmfSITableInfo.saAmfSINameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSUsperSIRankTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSINameId, (ClUint32T) pTabIdx2->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSINameId - (ClUint32T) pTabIdx2->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSINameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSIRank, (ClUint32T) pTabIdx2->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSIRank);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSIRank - (ClUint32T) pTabIdx2->index.saAmfSUsperSIRankTableInfo.saAmfSUsperSIRank)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSGSIRankTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSGSIRankTableInfo.saAmfSGSIRankSGNameId, (ClUint32T) pTabIdx2->index.saAmfSGSIRankTableInfo.saAmfSGSIRankSGNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSGSIRankTableInfo.saAmfSGSIRankSGNameId - (ClUint32T) pTabIdx2->index.saAmfSGSIRankTableInfo.saAmfSGSIRankSGNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSGSIRankTableInfo.saAmfSGSIRank, (ClUint32T) pTabIdx2->index.saAmfSGSIRankTableInfo.saAmfSGSIRank);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSGSIRankTableInfo.saAmfSGSIRank - (ClUint32T) pTabIdx2->index.saAmfSGSIRankTableInfo.saAmfSGSIRank)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSGSURankTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSGSURankTableInfo.saAmfSGSURankSGNameId, (ClUint32T) pTabIdx2->index.saAmfSGSURankTableInfo.saAmfSGSURankSGNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSGSURankTableInfo.saAmfSGSURankSGNameId - (ClUint32T) pTabIdx2->index.saAmfSGSURankTableInfo.saAmfSGSURankSGNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSGSURankTableInfo.saAmfSGSURank, (ClUint32T) pTabIdx2->index.saAmfSGSURankTableInfo.saAmfSGSURank);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSGSURankTableInfo.saAmfSGSURank - (ClUint32T) pTabIdx2->index.saAmfSGSURankTableInfo.saAmfSGSURank)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSISIDepTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSISIDepTableInfo.saAmfSISIDepSINameId, (ClUint32T) pTabIdx2->index.saAmfSISIDepTableInfo.saAmfSISIDepSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSISIDepTableInfo.saAmfSISIDepSINameId - (ClUint32T) pTabIdx2->index.saAmfSISIDepTableInfo.saAmfSISIDepSINameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSISIDepTableInfo.saAmfSISIDepDepndSINameId, (ClUint32T) pTabIdx2->index.saAmfSISIDepTableInfo.saAmfSISIDepDepndSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSISIDepTableInfo.saAmfSISIDepDepndSINameId - (ClUint32T) pTabIdx2->index.saAmfSISIDepTableInfo.saAmfSISIDepDepndSINameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCompTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCompTableInfo.saAmfCompNameId, (ClUint32T) pTabIdx2->index.saAmfCompTableInfo.saAmfCompNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCompTableInfo.saAmfCompNameId - (ClUint32T) pTabIdx2->index.saAmfCompTableInfo.saAmfCompNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCompCSTypeSupportedTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCompNameId, (ClUint32T) pTabIdx2->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCompNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCompNameId - (ClUint32T) pTabIdx2->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCompNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCSTypeNameId, (ClUint32T) pTabIdx2->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCSTypeNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCSTypeNameId - (ClUint32T) pTabIdx2->index.saAmfCompCSTypeSupportedTableInfo.saAmfCompCSTypeSupportedCSTypeNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCSITableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSITableInfo.saAmfCSINameId, (ClUint32T) pTabIdx2->index.saAmfCSITableInfo.saAmfCSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSITableInfo.saAmfCSINameId - (ClUint32T) pTabIdx2->index.saAmfCSITableInfo.saAmfCSINameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCSICSIDepTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepCSINameId, (ClUint32T) pTabIdx2->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepCSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepCSINameId - (ClUint32T) pTabIdx2->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepCSINameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepDepndCSINameId, (ClUint32T) pTabIdx2->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepDepndCSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepDepndCSINameId - (ClUint32T) pTabIdx2->index.saAmfCSICSIDepTableInfo.saAmfCSICSIDepDepndCSINameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCSINameValueTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSINameValueTableInfo.saAmfCSINameValueCSINameId, (ClUint32T) pTabIdx2->index.saAmfCSINameValueTableInfo.saAmfCSINameValueCSINameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSINameValueTableInfo.saAmfCSINameValueCSINameId - (ClUint32T) pTabIdx2->index.saAmfCSINameValueTableInfo.saAmfCSINameValueCSINameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSINameValueTableInfo.saAmfCSINameValueAttrNameId, (ClUint32T) pTabIdx2->index.saAmfCSINameValueTableInfo.saAmfCSINameValueAttrNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSINameValueTableInfo.saAmfCSINameValueAttrNameId - (ClUint32T) pTabIdx2->index.saAmfCSINameValueTableInfo.saAmfCSINameValueAttrNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfCSTypeAttrNameTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeNameId, (ClUint32T) pTabIdx2->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeNameId - (ClUint32T) pTabIdx2->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeAttrNameId, (ClUint32T) pTabIdx2->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeAttrNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeAttrNameId - (ClUint32T) pTabIdx2->index.saAmfCSTypeAttrNameTableInfo.saAmfCSTypeAttrNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSUSITableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSUSITableInfo.saAmfSUSISuNameId, (ClUint32T) pTabIdx2->index.saAmfSUSITableInfo.saAmfSUSISuNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSUSITableInfo.saAmfSUSISuNameId - (ClUint32T) pTabIdx2->index.saAmfSUSITableInfo.saAmfSUSISuNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSUSITableInfo.saAmfSUSISiNameId, (ClUint32T) pTabIdx2->index.saAmfSUSITableInfo.saAmfSUSISiNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSUSITableInfo.saAmfSUSISiNameId - (ClUint32T) pTabIdx2->index.saAmfSUSITableInfo.saAmfSUSISiNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfHealthCheckTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCompNameId, (ClUint32T) pTabIdx2->index.saAmfHealthCheckTableInfo.saAmfHealthCompNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCompNameId - (ClUint32T) pTabIdx2->index.saAmfHealthCheckTableInfo.saAmfHealthCompNameId)) != 0)
	    return retVal;

    {
    ClInt32T len1 = strlen(pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey);
    ClInt32T len2 = strlen(pTabIdx2->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey);

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "String Lenght1 : [%d] Lenght2 : [%d] Str1 : [%s] Str2 : [%s] ",
        len1, len2, pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey, pTabIdx2->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey); 

    if(len1 != len2)
        return (len1 - len2);
    }

    if((retVal = strncmp(pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey,
                    pTabIdx2->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey,
                    sizeof(pTabIdx1->index.saAmfHealthCheckTableInfo.saAmfHealthCheckKey))) != 0)
        return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfSCompCsiTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCompNameId, (ClUint32T) pTabIdx2->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCompNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCompNameId - (ClUint32T) pTabIdx2->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCompNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCsiNameId, (ClUint32T) pTabIdx2->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCsiNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCsiNameId - (ClUint32T) pTabIdx2->index.saAmfSCompCsiTableInfo.saAmfSCompCsiCsiNameId)) != 0)
	    return retVal;

    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpsaAmfProxyProxiedTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxyNameId, (ClUint32T) pTabIdx2->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxyNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxyNameId - (ClUint32T) pTabIdx2->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxyNameId)) != 0)
	    return retVal;

    clLogDebug(CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Index value1 : [%u], Index value2: [%u].", 
        (ClUint32T) pTabIdx1->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxiedNameId, (ClUint32T) pTabIdx2->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxiedNameId);

	if ( (retVal = ((ClUint32T) pTabIdx1->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxiedNameId - (ClUint32T) pTabIdx2->index.saAmfProxyProxiedTableInfo.saAmfProxyProxiedProxiedNameId)) != 0)
	    return retVal;

    return 0;
}
