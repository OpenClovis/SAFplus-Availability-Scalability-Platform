/******************************************************************************
 *
 * clCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2009 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component. Application
 * specific code should be added between the ---BEGIN_APPLICATION_CODE--- and
 * ---END_APPLICATION_CODE--- separators.
 *
 * Template Version: 1.0
 *
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
#include <assert.h>

/*
 * Basic ASP Includes.
 */
#include <clCommon.h>

/*
 * ASP Client Includes.
 */
#include <clLogApi.h>

#include <clCpmApi.h>
#include <saAmf.h>

/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#include "clCompAppMain.h"
#include <clAmsMgmtClientApi.h>
#include <clHandleApi.h>
/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This is necessary if the component wishes to provide a service that
 * will be used by other components.
 */

#if HAS_EO_SERVICES

extern ClRcT dhaDemo_EOClientInstall(void);

#endif

/*
 * This template has a few default clprintfs. These can be disabled by
 * changing clprintf to a null function
 */

#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---BEGIN_APPLICATION_CODE---
 */


#define dhaInfoPrint(...)    clAppLog(CL_LOG_HANDLE_APP, CL_LOG_SEV_INFO, 11, \
                                      "DHA", "DMO", \
                                      __VA_ARGS__)

#define dhaErrorPrint(...)   clAppLog(CL_LOG_HANDLE_APP, CL_LOG_SEV_ERROR, 11, \
                                      "DHA", "DMO", \
                                      __VA_ARGS__)

#define clDhaExmpExec(execInfo, predicate, errorInfo, execOnFailure) \
do{                                                                  \
    dhaInfoPrint execInfo;                                           \
    int result = (predicate);                                        \
    if (!result)                                                     \
    {                                                                \
        dhaErrorPrint errorInfo;                                     \
        execOnFailure;                                               \
    }                                                                \
} while(0)


#define WORKER0 "WorkerI0"
#define WORKER1 "WorkerI1"
#define NEW_COMP_PREFIX "dynamicComp"
#define BASE_NAME "dynamicTwoN"

static ClRcT clDhaDemoStart(void);

static ClRcT clDhaDemoStop(void);

static void* clDhaDemoCreate(void*);

static void* clDhaDemoDelete(void*);

static ClRcT clAmsMgmtTestFillConfig(ClAmsMgmtHandleT mgmtHandle,
                                     ClAmsMgmtCCBHandleT ccbHandle,
                                     ClAmsEntityTypeT type,
                                     const ClCharT *pBaseName);

static ClRcT clAmsMgmtTestUnlock(ClAmsMgmtHandleT mgmtHandle,
                                 ClAmsMgmtCCBHandleT ccbHandle,
                                 const ClCharT *pBaseName);

static ClRcT clAmsMgmtTestLockI(ClAmsMgmtHandleT mgmtHandle,
                               ClAmsMgmtCCBHandleT ccbHandle,
                                const ClCharT *pBaseName);


/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

pid_t mypid;
SaAmfHandleT amfHandle;

ClBoolT unblockNow = CL_FALSE;

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Declare other global variables here.
 */

/*
 * ---END_APPLICATION_CODE---
 */

/*
 * Description of this EO
 */

ClEoConfigT clEoConfig =
{
    COMP_EO_NAME,               /* EO Name                                  */
    COMP_EO_THREAD_PRIORITY,    /* EO Thread Priority                       */
    COMP_EO_NUM_THREAD,         /* No of EO thread needed                   */
    COMP_IOC_PORT,              /* Required Ioc Port                        */
    COMP_EO_USER_CLIENT_ID, 
    COMP_EO_USE_THREAD_MODEL,   /* Thread Model                             */
    NULL,                       /* Application Initialize Callback          */
    NULL,                       /* Application Terminate Callback           */
    clCompAppStateChange,       /* Application State Change Callback        */
    clCompAppHealthCheck,       /* Application Health Check Callback        */
};

/*
 * Basic libraries used by this EO. The first 6 libraries are
 * mandatory, the others can be enabled or disabled by setting to
 * CL_TRUE or CL_FALSE.
 */

ClUint8T clEoBasicLibs[] =
{
    COMP_EO_BASICLIB_OSAL,      /* Lib: Operating System Adaptation Layer   */
    COMP_EO_BASICLIB_TIMER,     /* Lib: Timer                               */
    COMP_EO_BASICLIB_BUFFER,    /* Lib: Buffer Management                   */
    COMP_EO_BASICLIB_IOC,       /* Lib: Intelligent Object Communication    */
    COMP_EO_BASICLIB_RMD,       /* Lib: Remote Method Dispatch              */
    COMP_EO_BASICLIB_EO,        /* Lib: Execution Object                    */
    COMP_EO_BASICLIB_OM,        /* Lib: Object Management                   */
    COMP_EO_BASICLIB_HAL,       /* Lib: Hardware Adaptation Layer           */
    COMP_EO_BASICLIB_DBAL,      /* Lib: Database Adaptation Layer           */
};

/*
 * Client libraries used by this EO. All are optional and can be
 * enabled or disabled by setting to CL_TRUE or CL_FALSE.
 */

ClUint8T clEoClientLibs[] =
{
    COMP_EO_CLIENTLIB_COR,      /* Lib: Common Object Repository            */
    COMP_EO_CLIENTLIB_CM,       /* Lib: Chassis Management                  */
    COMP_EO_CLIENTLIB_NAME,     /* Lib: Name Service                        */
    COMP_EO_CLIENTLIB_LOG,      /* Lib: Log Service                         */
    COMP_EO_CLIENTLIB_TRACE,    /* Lib: Trace Service                       */
    COMP_EO_CLIENTLIB_DIAG,     /* Lib: Diagnostics                         */
    COMP_EO_CLIENTLIB_TXN,      /* Lib: Transaction Management              */
    CL_FALSE,                   /* NA */
    COMP_EO_CLIENTLIB_PROV,     /* Lib: Provisioning Management             */
    COMP_EO_CLIENTLIB_ALARM,    /* Lib: Alarm Management                    */
    COMP_EO_CLIENTLIB_DEBUG,    /* Lib: Debug Service                       */
    COMP_EO_CLIENTLIB_GMS,      /* Lib: Cluster/Group Membership Service    */
    COMP_EO_CLIENTLIB_PM        /* Lib: Performance Management              */
};

/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/

/*
 * main
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

int main(int argc, char *argv[])
{
    SaNameT             appName = {0};
    SaAmfCallbacksT     callbacks;
    SaVersionT          version;
    ClIocPortT          iocPort;
    ClRcT               rc = SA_AIS_OK;

    SaSelectionObjectT dispatch_fd;
    fd_set read_fds;
    
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * Declare other local variables here.
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the
     * version of AMF with which this application would like to
     * interface. 'callbacks' is used to register the callbacks this
     * component expects to receive.
     */

    version.releaseCode  = 'B';
    version.majorVersion = 01;
    version.minorVersion = 01;
    
    callbacks.saAmfHealthcheckCallback          = NULL;
    callbacks.saAmfComponentTerminateCallback   = clCompAppTerminate;
    callbacks.saAmfCSISetCallback               = clCompAppAMFCSISet;
    callbacks.saAmfCSIRemoveCallback            = clCompAppAMFCSIRemove;
    callbacks.saAmfProtectionGroupTrackCallback = NULL;
        
    /*
     * Initialize AMF client library.
     */

    if ( (rc = saAmfInitialize(&amfHandle, &callbacks, &version)) != SA_AIS_OK) 
        goto errorexit;

    FD_ZERO(&read_fds);

    /*
     * Get the AMF dispatch FD for the callbacks
     */
    if ( (rc = saAmfSelectionObjectGet(amfHandle, &dispatch_fd)) != SA_AIS_OK)
        goto errorexit;
    
    FD_SET(dispatch_fd, &read_fds);

    
#if HAS_EO_SERVICES


    rc = dhaDemo_EOClientInstall();

#endif

    /*
     * Do the application specific initialization here.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = saAmfComponentNameGet(amfHandle, &appName)) != SA_AIS_OK) 
        goto errorexit;
    if ( (rc = saAmfComponentRegister(amfHandle, &appName, NULL)) != SA_AIS_OK) 
        goto errorexit;

    /*
     * Print out standard information for this component.
     */

    clEoMyEoIocPortGet(&iocPort);
    
    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Initializing\n", appName.value, mypid);
    clprintf (CL_LOG_SEV_INFO, "   IOC Address             : 0x%x\n", clIocLocalAddressGet());
    clprintf (CL_LOG_SEV_INFO, "   IOC Port                : 0x%x\n", iocPort);

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Block on AMF dispatch file descriptor for callbacks
     */
    do
    {
        if( select(dispatch_fd + 1, &read_fds, NULL, NULL, NULL) < 0)
        {
		    clprintf (CL_LOG_SEV_ERROR, "Error in select()");
			perror("");
            break;
        }
        saAmfDispatch(amfHandle, SA_DISPATCH_ALL);
    }while(!unblockNow);      

    /*
     * Do the application specific finalization here.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    if((rc = saAmfFinalize(amfHandle)) != SA_AIS_OK)
	{
        clprintf (CL_LOG_SEV_ERROR, "AMF finalization error[0x%X]", rc);
	}

    clprintf (CL_LOG_SEV_INFO, "AMF Finalized");
    
    return 0;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%d]. Initialization error [0x%x]\n",
              appName.value, mypid, rc);

    return -1;
}


/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

void clCompAppTerminate(SaInvocationT invocation, const SaNameT *compName)
{
    SaAisErrorT rc = SA_AIS_OK;

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Terminating\n",
              compName->value, mypid);

    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */
    
    /*
     * Unregister with AMF and respond to AMF saying whether the
     * termination was successful or not.
     */

    if ( (rc = saAmfComponentUnregister(amfHandle, compName, NULL)) != SA_AIS_OK)
        goto errorexit;

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Terminated\n",
              compName->value, mypid);

    unblockNow = CL_TRUE;
    
    return;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%d]. Termination error [0x%x]\n",
              compName->value, mypid, rc);

    return;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 *
 * WARNING: This function is deprecated, and may not be supported in the future.
 * Usage of this feature is discouraged.
 */

ClRcT clCompAppStateChange(ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }

        case CL_EO_STATE_RESUME:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT clCompAppHealthCheck(ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The
     * defaults indicate EO is healthy and polling interval is
     * unaltered.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

void clCompAppAMFCSISet(SaInvocationT       invocation,
                        const SaNameT       *compName,
                        SaAmfHAStateT       haState,
                        SaAmfCSIDescriptorT csiDescriptor)
{
    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */
    ClRcT rc = CL_OK;
    
    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Print information about the CSI Set
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. CSI Set Received\n", 
              compName->value, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case SA_AMF_HA_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */
            clprintf(CL_LOG_SEV_NOTICE, "Starting dynamic HA demo.");
            clprintf(CL_LOG_SEV_NOTICE, "It will create 2N SG : %sSG", BASE_NAME);            
            rc = clDhaDemoStart();
            if(rc != CL_OK)
            {
                clprintf(CL_LOG_SEV_CRITICAL, "Failed to start dynamic HA demo.");
            }
            
            /*
             * ---End_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            rc = clDhaDemoStop();
            if(rc != CL_OK)
            {
                clprintf(CL_LOG_SEV_CRITICAL, "Failed to stop dynamic HA demo.");
            }
            
            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            rc = clDhaDemoStop();
            if(rc != CL_OK)
            {
                clprintf(CL_LOG_SEV_CRITICAL, "Failed to stop dynamic HA demo.");
            }
            

            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfCSIQuiescingComplete(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        default:
        {
            assert(0);
            break;
        }
    }

    return;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

void clCompAppAMFCSIRemove(SaInvocationT  invocation,
                           const SaNameT  *compName,
                           const SaNameT  *csiName,
                           SaAmfCSIFlagsT csiFlags)
{
    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. CSI Remove Received\n", 
              compName->value, mypid);

    clprintf (CL_LOG_SEV_INFO, "   CSI                     : %s\n", csiName->value);
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : 0x%d\n", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;
}

/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

void clCompAppAMFPrintCSI(SaAmfCSIDescriptorT csiDescriptor,
                          SaAmfHAStateT haState)
{
    clprintf (CL_LOG_SEV_INFO,
              "CSI Flags : [%s]",
              STRING_CSI_FLAGS(csiDescriptor.csiFlags));

    if (SA_AMF_CSI_TARGET_ALL != csiDescriptor.csiFlags)
    {
        clprintf (CL_LOG_SEV_INFO, "CSI Name : [%s]", 
                  csiDescriptor.csiName.value);
    }

    if (SA_AMF_CSI_ADD_ONE == csiDescriptor.csiFlags)
    {
        ClUint32T i = 0;
        
        clprintf (CL_LOG_SEV_INFO, "Name value pairs :");
        for (i = 0; i < csiDescriptor.csiAttr.number; i++)
        {
            clprintf (CL_LOG_SEV_INFO, "Name : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrName);
            clprintf (CL_LOG_SEV_INFO, "Value : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrValue);
        }
    }
    
    clprintf (CL_LOG_SEV_INFO, "HA state : [%s]",
              STRING_HA_STATE(haState));

    if (SA_AMF_HA_ACTIVE == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Active Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Transition Descriptor : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.transitionDescriptor);
        clprintf (CL_LOG_SEV_INFO,
                  "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.activeCompName.value);
    }
    else if (SA_AMF_HA_STANDBY == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Standby Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Standby Rank : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.standbyRank);
        clprintf (CL_LOG_SEV_INFO, "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.activeCompName.value);
    }
}

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Insert any other utility functions here.
 */

ClRcT
clDhaDemoStart(void)
{

    ClRcT  rc = CL_OK;


    rc = clOsalTaskCreateDetached("dhaDemoCreate", CL_OSAL_SCHED_OTHER,
                                  CL_OSAL_THREAD_PRI_NOT_APPLICABLE,
                                  CL_OSAL_MIN_STACK_SIZE,
                                  clDhaDemoCreate, NULL);
        
    return rc;

}


ClRcT
clDhaDemoStop(void)
{

    ClRcT  rc = CL_OK;


    rc = clOsalTaskCreateDetached("dhaDemoDelete", CL_OSAL_SCHED_OTHER,
                                  CL_OSAL_THREAD_PRI_NOT_APPLICABLE,
                                  CL_OSAL_MIN_STACK_SIZE,
                                  clDhaDemoDelete, NULL);
        
    return rc;

}


void* clDhaDemoCreate(void* arg)
{
    ClRcT rc = CL_OK;
    ClRcT retCode = CL_OK;    
    ClAmsMgmtHandleT mgmtHandle = 0;
    ClVersionT version = {'B', 0x1, 0x1 };
    ClAmsMgmtCCBHandleT ccbHandle = CL_HANDLE_INVALID_VALUE;
    const ClCharT *pBaseName = BASE_NAME;
    ClAmsEntityT entity = { 0 } ;
    ClAmsEntityConfigT *pEntityConfig = NULL;

    clprintf(CL_LOG_SEV_INFO, "Running MGMT initialize");
    
    rc = clAmsMgmtInitialize(&mgmtHandle, NULL, &version);
    if(rc != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR, "AmsMgmt initialize returned [%#x]", rc);
        return NULL;
    }

    clDhaExmpExec(("Running MGMT CCB initialize"),
                  (rc = clAmsMgmtCCBInitialize(mgmtHandle, &ccbHandle)) == CL_OK,
                  ("MGMT CCB initialize returned [%#x]", rc),
                  goto out1);


    /* 
     * Create the entities only if they are not created already
     */
    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value), "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                  &entity,
                                  &pEntityConfig);
    
    clHeapFree(pEntityConfig);

    if(rc == CL_OK)
    {
        clprintf(CL_LOG_SEV_INFO, "Not creating SG[%sSG], it already exist", pBaseName);
        goto out2;
    }

    /* SG doesn't exist, create SG and other entities dynamically*/
    
    /*First create the service hierarchies*/

    clprintf(CL_LOG_SEV_NOTICE,
             "Creating 2N SG [%sSG] and other entities(si, csi, su, comp, etc)",
             pBaseName);

    /* Create SG*/
    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("Creating SG [%s]", 
                   entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle,
                                                 &entity)) == CL_OK,
                  ("SG create returned [%#x]", rc),
                  goto out2);

    /* Create SI*/
    entity.type = CL_AMS_ENTITY_TYPE_SI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec( ("Create SI [%s]", entity.name.value),
                   (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                   ("SI create returned [%#x]", rc),
                   goto out2);

    /* Create CSI*/
    entity.type = CL_AMS_ENTITY_TYPE_CSI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sCSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("Create CSI [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                  ("CSI create returned [%#x]", rc),
                  goto out2);

    /*Create 2 SUs*/
    entity.type = CL_AMS_ENTITY_TYPE_SU;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU0", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec(("Create SU [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                  ("SU create returned [%#x]", rc),
                  goto out2);
    
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU1", pBaseName);
    
    clDhaExmpExec(("Create SU [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                  ("SU create returned [%#x]", rc),
                  goto out2);

    /*Create COMP*/
    entity.type = CL_AMS_ENTITY_TYPE_COMP;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%s0", NEW_COMP_PREFIX);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec(("Create COMP [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                  ("COMP create returned [%#x]", rc),
                  goto out2);

    snprintf(entity.name.value, sizeof(entity.name.value),
             "%s1", NEW_COMP_PREFIX);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("Create COMP [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityCreate(ccbHandle, &entity)) == CL_OK,
                  ("COMP create returned [%#x]", rc),
                  goto out2);


    /* CCB Commit*/
    clDhaExmpExec(("CCB Commit Create"),
                  (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                  ("CCB commit returned [%#x]", rc),
                  goto out2);

    
    clDhaExmpExec(("Fill SG config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_SG, pBaseName)) == CL_OK,
                  ("SG config fill returned [%#x]", rc),
                  goto out2);

    clDhaExmpExec(("Fill SI config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_SI, pBaseName)) == CL_OK,
                  ("SI config fill returned [%#x]", rc),
                  goto out2);

    clDhaExmpExec(("Fill CSI config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_CSI, pBaseName)) == CL_OK,
                  ("CSI config fill returned [%#x]", rc),
                  goto out2);

    clDhaExmpExec(("Fill SU config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_SU, pBaseName)) == CL_OK,
                  ("SU config fill returned [%#x]", rc),
                  goto out2);

    clDhaExmpExec(("Fill NODE config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_NODE, pBaseName)) == CL_OK,
                  ("NODE config fill returned [%#x]", rc),
                  goto out2);
    
    clDhaExmpExec(("Fill COMP config"),
                  (rc = clAmsMgmtTestFillConfig(mgmtHandle, ccbHandle, CL_AMS_ENTITY_TYPE_COMP, pBaseName)) == CL_OK,
                  ("COMP config fill returned [%#x]", rc),
                  goto out2);

    clDhaExmpExec(("Unlock AMS entities"),
                  (rc = clAmsMgmtTestUnlock(mgmtHandle, ccbHandle, pBaseName)) == CL_OK,
                  ("Unlock AMS entities returned [%#x]", rc),
                  goto out2);

out2:
    clDhaExmpExec(("Running CCB finalize"),
                  (retCode = clAmsMgmtCCBFinalize(ccbHandle) ) == CL_OK,
                  ("CCB finalize returned [%#x]", rc),
                  goto out1);

out1:
    clDhaExmpExec(("Running MGMT finalize"),
                  (retCode = clAmsMgmtFinalize(mgmtHandle)) == CL_OK,
                  ("MGMT finalize returned [%#x]", rc),
                  goto out);
    
out:
    if(rc == CL_OK)
    {
        clprintf(CL_LOG_SEV_NOTICE,
                 "Successfully created 2N SG [%sSG] and its entities(si, csi, su, comp, etc) dynamically",
                 pBaseName);
    }
    else
    {
        clprintf(CL_LOG_SEV_CRITICAL,
                 "Error while dynamically creating 2N SG [%sSG] and its entities(si, csi, su, comp, etc)",
                 pBaseName);
    }
    
    return NULL;
}

void* clDhaDemoDelete(void* arg)
{

    ClRcT rc = CL_OK;
    ClRcT retCode = CL_OK;
    ClAmsMgmtHandleT mgmtHandle = 0;
    ClVersionT version = {'B', 0x1, 0x1 };
    ClAmsMgmtCCBHandleT ccbHandle = CL_HANDLE_INVALID_VALUE;
    const ClCharT *pBaseName = "dynamicTwoN";
    ClAmsEntityT entity = { 0 } ;
    ClAmsEntityConfigT *pEntityConfig = NULL;

    clprintf(CL_LOG_SEV_INFO, "Running MGMT initialize");    

    rc = clAmsMgmtInitialize(&mgmtHandle, NULL, &version);
    if(rc != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR, "AmsMgmt initialize returned [%#x]", rc);
        return NULL;
    }

    clDhaExmpExec(("Running MGMT CCB initialize"),
                  (rc = clAmsMgmtCCBInitialize(mgmtHandle, &ccbHandle)) == CL_OK,
                  ("MGMT CCB initialize returned [%#x]", rc),
                  goto out1);


    /* 
     * Delete the entities only if they exist
     */
    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value), "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                  &entity,
                                  &pEntityConfig);
    clHeapFree(pEntityConfig);
    if(rc != CL_OK)
    {
        clprintf(CL_LOG_SEV_INFO, "Not deleting SG[%sSG],  SG config get returned [%#x]", pBaseName, rc);
        goto out2;

    }

    /* SG exist, Delete SG and other entities dynamically*/

    clprintf(CL_LOG_SEV_NOTICE,
             "Deleting SG [%sSG] and other entities(si, csi, su, comp, etc)",
             pBaseName);

    /*First move entities to lock instantiated mode*/    
    clDhaExmpExec(("LockI AMS entities"),
                  (rc = clAmsMgmtTestLockI(mgmtHandle, ccbHandle, pBaseName)) == CL_OK,
                  ("Unlock AMS entities returned [%#x]", rc),
                  goto out2);

    /*Delete 2 COMPs*/
    entity.type = CL_AMS_ENTITY_TYPE_COMP;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%s0", NEW_COMP_PREFIX);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec(("Delete COMP [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                  ("COMP delete returned [%#x]", rc),
                  goto out2);

    snprintf(entity.name.value, sizeof(entity.name.value),
             "%s1", NEW_COMP_PREFIX);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("Delete COMP [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                  ("COMP delete returned [%#x]", rc),
                  goto out2);

    /*Delete 2 SUs*/
    entity.type = CL_AMS_ENTITY_TYPE_SU;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU0", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec(("Delete SU [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                  ("SU delete returned [%#x]", rc),
                  goto out2);
    
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU1", pBaseName);
    
    clDhaExmpExec(("Delete SU [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                  ("SU delete returned [%#x]", rc),
                  goto out2);

    /* Delete CSI*/
    entity.type = CL_AMS_ENTITY_TYPE_CSI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sCSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("Delete CSI [%s]", entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                  ("CSI delete returned [%#x]", rc),
                  goto out2);

    /* Delete SI*/
    entity.type = CL_AMS_ENTITY_TYPE_SI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec( ("Delete SI [%s]", entity.name.value),
                   (rc = clAmsMgmtCCBEntityDelete(ccbHandle, &entity)) == CL_OK,
                   ("SI delete returned [%#x]", rc),
                   goto out2);

    /* Delete SG*/
    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    clDhaExmpExec(("Deleting SG [%s]", 
                   entity.name.value),
                  (rc = clAmsMgmtCCBEntityDelete(ccbHandle,
                                                 &entity)) == CL_OK,
                  ("SG delete returned [%#x]", rc),
                  goto out2);

    /* CCB Commit*/
    clDhaExmpExec(("CCB Commit Delete"),
                  (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                  ("CCB commit returned [%#x]", rc),
                  goto out2);

out2:
    clDhaExmpExec(("Running CCB finalize"),
                  (retCode = clAmsMgmtCCBFinalize(ccbHandle) ) == CL_OK,
                  ("CCB finalize returned [%#x]", rc),
                  goto out1);

out1:
    clDhaExmpExec(("Running MGMT finalize"),
                  (retCode = clAmsMgmtFinalize(mgmtHandle)) == CL_OK,
                  ("MGMT finalize returned [%#x]", rc),
                  goto out);
    
out:
    if(rc == CL_OK)
    {
        clprintf(CL_LOG_SEV_NOTICE,
                 "Successfully deleted dynamically created SG [%sSG] and other entities(si, csi, su, comp, etc)",
                 pBaseName);
    }
    else
    {
        clprintf(CL_LOG_SEV_CRITICAL,
                 "Error while deleting dynamically created SG [%sSG] and other entities(si, csi, su, comp, etc)",
                 pBaseName);
    }
        
    
    return NULL;

}



static ClRcT clAmsMgmtTestFillConfig(ClAmsMgmtHandleT mgmtHandle,
                                     ClAmsMgmtCCBHandleT ccbHandle,
                                     ClAmsEntityTypeT type,
                                     const ClCharT *pBaseName)
{
    ClRcT rc = CL_OK;
    ClAmsEntityT entity = {0};
    ClAmsEntityT targetEntity = {0};
    ClAmsEntityConfigT *pEntityConfig = NULL;

    entity.type = type;
    switch(type)
    {
        case CL_AMS_ENTITY_TYPE_SG:
        {
            /* 
             * By default AMS populates the SG config with 2N values
             */
            ClAmsSGConfigT sgConfig = { {0} };
            snprintf(entity.name.value, sizeof(entity.name.value), "%sSG", pBaseName);
            entity.name.length = strlen(entity.name.value)+1;
            clDhaExmpExec( ("SG config get [%s]", entity.name.value),
                           (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                          &entity,
                                                          &pEntityConfig)) == CL_OK,
                           ("SG config get returned [%#x]", rc),
                           goto out );
            memcpy(&sgConfig, pEntityConfig, sizeof(sgConfig));
            clHeapFree(pEntityConfig);
            
            /*
             * Fill SG SI list
             */
            targetEntity.type = CL_AMS_ENTITY_TYPE_SI;
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%sSI", pBaseName);
            targetEntity.name.length = strlen(targetEntity.name.value)+1;
            clDhaExmpExec(("SG set SI [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSGSIList(ccbHandle,
                                                        &entity,
                                                        &targetEntity)) == CL_OK,
                          ("SG set SI returned [%#x]", rc),
                          goto out);
            
            /*
             * Fill SU list
             */
            targetEntity.type = CL_AMS_ENTITY_TYPE_SU;
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%sSU0", pBaseName);
            targetEntity.name.length = strlen(targetEntity.name.value)+1;
            clDhaExmpExec(("SG set SU [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSGSUList(ccbHandle,
                                                        &entity,
                                                        &targetEntity)) == CL_OK,
                          ("SG set SU returned [%#x]", rc),
                          goto out);

            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value), 
                     "%sSU1", pBaseName);
            clDhaExmpExec(("SG set SU [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSGSUList(ccbHandle,
                                                        &entity,
                                                        &targetEntity) ) == CL_OK,
                          ("SG set SU returned [%#x]", rc),
                          goto out);
            
            /*
             * Commit SG settings.
             */
            clDhaExmpExec(("SG set commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle) ) == CL_OK,
                          ("SG commit returned [%#x]", rc),
                          goto out);
        }
        break;

        case CL_AMS_ENTITY_TYPE_SI:
        {
            ClAmsSIConfigT siConfig = {{0}};
            ClUint64T bitMask = 0;
            snprintf(entity.name.value, sizeof(entity.name.value), "%sSI", pBaseName);
            entity.name.length = strlen(entity.name.value)+1;
            clDhaExmpExec(("SI config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig)) == CL_OK,
                          ("SI config get returned [%#x]", rc),
                          goto out
                          );
            memcpy(&siConfig, pEntityConfig, sizeof(siConfig));
            clHeapFree(pEntityConfig);

            siConfig.numCSIs = 1;
            siConfig.numStandbyAssignments = 1;
            /*
             *We actually dont even have to fetch coz we can set
             *using the bitmask. But useful for code cov.
             */
            bitMask |= SI_CONFIG_NUM_CSIS | SI_CONFIG_NUM_STANDBY_ASSIGNMENTS;
            clDhaExmpExec(("SI config set [%s]", entity.name.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &siConfig.entity,
                                                            bitMask) ) == CL_OK,
                          ("SI config set returned [%#x]", rc),
                          goto out);
            
            /*
             * Fill SI CSI list
             */

            targetEntity.type = CL_AMS_ENTITY_TYPE_CSI;
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%sCSI", pBaseName);
            targetEntity.name.length = strlen(targetEntity.name.value)+1;
            clDhaExmpExec(("SI set CSI [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSICSIList(ccbHandle,
                                                         &entity,
                                                         &targetEntity)) == CL_OK,
                          ("SI set CSI returned [%#x]", rc),
                          goto out);

            /*
             * Commit to AMS db
             */
            clDhaExmpExec(("SI set commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                          ("SI commit returned [%#x]", rc),
                          goto out);
        }
        break;

        case CL_AMS_ENTITY_TYPE_CSI:
        {
            ClAmsCSIConfigT csiConfig = {{0}};
            ClUint64T bitMask = 0;
            snprintf(entity.name.value, sizeof(entity.name.value), "%sCSI", pBaseName);
            entity.name.length = strlen(entity.name.value)+1;
            clDhaExmpExec(("CSI config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig)) == CL_OK,
                          ("CSI config get returned [%#x]", rc),
                          goto out);
            memcpy(&csiConfig, pEntityConfig, sizeof(csiConfig));
            clHeapFree(pEntityConfig);

            /*
             * Set CSI type
             */
            bitMask |= CSI_CONFIG_TYPE;
            snprintf(csiConfig.type.value, sizeof(csiConfig.type.value),
                     "%sType", entity.name.value);
            csiConfig.type.length = strlen(csiConfig.type.value)+1;
            clDhaExmpExec(("CSI type set [%s]", csiConfig.type.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &csiConfig.entity,
                                                            bitMask)) == CL_OK,
                          ("CSI type set returned [%#x]", rc),
                          goto out);

            /*
             * Set CSI NVP list 
             */
            ClAmsCSINVPT nvp = { .paramName = { .value = "model", .length=sizeof("model") },
                                 .paramValue = {.value = "twoN",  .length = sizeof("twoN") },
            };
            clNameCopy(&nvp.csiName, &entity.name);
            clDhaExmpExec(("CSI set nvplist"),
                          (rc = clAmsMgmtCCBCSISetNVP(ccbHandle,
                                                      &entity,
                                                      &nvp)) == CL_OK,
                          ("CSI set nvplist returned [%#x]", rc),
                          goto out);

            /*
             * Commit CSI to AMS db
             */
            clDhaExmpExec(("CSI ccb commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                          ("CSI ccb commit returned [%#x]", rc),
                          goto out);
        }
        break;

        case CL_AMS_ENTITY_TYPE_NODE:
        {
            ClAmsNodeConfigT nodeConfig = {{0}};
            snprintf(entity.name.value, sizeof(entity.name.value), "%s", WORKER1);
            entity.name.length = strlen(entity.name.value)+1;
            clDhaExmpExec(("NODE config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig) ) == CL_OK,
                          ("NODE config get returned [%#x]", rc),
                          goto out);
            memcpy(&nodeConfig, pEntityConfig, sizeof(nodeConfig));
            clHeapFree(pEntityConfig);
    
            /*
             * Set Node SU list with redundant SUs
             */

            targetEntity.type = CL_AMS_ENTITY_TYPE_SU;
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%sSU1", pBaseName);
            targetEntity.name.length = strlen(targetEntity.name.value) + 1;
            clDhaExmpExec(("Node set SU [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetNodeSUList(ccbHandle,
                                                          &entity,
                                                          &targetEntity)) == CL_OK,
                          ("Node set SU returned [%#x]", rc),
                          goto out);

            snprintf(entity.name.value, sizeof(entity.name.value), "%s", WORKER0);
            entity.name.length = strlen(entity.name.value)+1;
            clDhaExmpExec(("NODE config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig) ) == CL_OK,
                          ("NODE config get returned [%#x]", rc),
                          goto out);
            memcpy(&nodeConfig, pEntityConfig, sizeof(nodeConfig));
            clHeapFree(pEntityConfig);
    



            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%sSU0", pBaseName);
            targetEntity.name.length = strlen(targetEntity.name.value) + 1;
            clDhaExmpExec(("Node set SU [%s]", targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetNodeSUList(ccbHandle,
                                                          &entity,
                                                          &targetEntity)) == CL_OK,
                          ("Node set SU returned [%#x]", rc),
                          goto out);

            /*
             * Commit node to AMS db.
             */
            clDhaExmpExec(("Node set commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                          ("Node commit returned [%#x]", rc),
                          goto out);
        }
        break;

        case CL_AMS_ENTITY_TYPE_SU:
        {
            ClAmsSUConfigT suConfig = {{0}};
            ClUint64T bitMask = 0;
            snprintf(entity.name.value, sizeof(entity.name.value), "%sSU0", pBaseName);
            entity.name.length = strlen(entity.name.value) + 1;
            clDhaExmpExec(("SU config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig)) == CL_OK,
                          ("SU config get returned [%#x]", rc),
                          goto out);
            memcpy(&suConfig, pEntityConfig, sizeof(suConfig));
            clHeapFree(pEntityConfig);
            
            /*
             * Set num components.
             */
            suConfig.numComponents = 1;
            bitMask |= SU_CONFIG_NUM_COMPONENTS;
            clDhaExmpExec(("SU config set [%s]", entity.name.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &suConfig.entity,
                                                            bitMask)) == CL_OK,
                          ("SU config set returned [%#x]", rc),
                          goto out);

            snprintf(suConfig.entity.name.value, sizeof(suConfig.entity.name.value),
                     "%sSU1", pBaseName);
            suConfig.entity.name.length = strlen(suConfig.entity.name.value)+1;
            suConfig.numComponents = 1;
            clDhaExmpExec(("SU config set [%s]", suConfig.entity.name.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &suConfig.entity,
                                                            bitMask)) == CL_OK,
                          ("SU config set returned [%#x]", rc),
                          goto out);
            
            /*
             * Set SU comp list.
             */
            targetEntity.type = CL_AMS_ENTITY_TYPE_COMP;
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%s0", NEW_COMP_PREFIX);
            targetEntity.name.length = strlen(targetEntity.name.value) + 1;
            clDhaExmpExec(("SU [%s] add comp [%s]", entity.name.value, targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSUCompList(ccbHandle,
                                                          &entity,
                                                          &targetEntity)) == CL_OK,
                          ("SU add comp returned [%#x]", rc),
                          goto out);
            
            snprintf(targetEntity.name.value, sizeof(targetEntity.name.value),
                     "%s1", NEW_COMP_PREFIX);
            targetEntity.name.length = strlen(targetEntity.name.value) + 1;
            clDhaExmpExec(("SU [%s] add comp [%s]", suConfig.entity.name.value,
                           targetEntity.name.value),
                          (rc = clAmsMgmtCCBSetSUCompList(ccbHandle,
                                                          &suConfig.entity,
                                                          &targetEntity)) == CL_OK,
                          ("SU add comp returned [%#x]", rc),
                          goto out);

            /* 
             * Commit to AMS db. 
             */
            clDhaExmpExec(("SU set commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                          ("SU commit returned [%#x]", rc),
                          goto out);
        }
        break;

        case CL_AMS_ENTITY_TYPE_COMP:
        {
            ClAmsCompConfigT compConfig = {{0}};
            ClUint64T bitMask = 0;
            ClNameT supportedCSIType = { 0 };
            snprintf(entity.name.value, sizeof(entity.name.value), "%s0", NEW_COMP_PREFIX);
            entity.name.length = strlen(entity.name.value) + 1;
            clDhaExmpExec(("COMP config get [%s]", entity.name.value),
                          (rc = clAmsMgmtEntityGetConfig(mgmtHandle,
                                                         &entity,
                                                         &pEntityConfig)) == CL_OK,
                          ("COMP config get returned [%#x]", rc),
                          goto out);
            memcpy(&compConfig, pEntityConfig, sizeof(compConfig));
            clHeapFree(pEntityConfig);
            
            bitMask |= COMP_CONFIG_CAPABILITY_MODEL | COMP_CONFIG_TIMEOUTS | COMP_CONFIG_RECOVERY_ON_TIMEOUT;
            compConfig.capabilityModel = CL_AMS_COMP_CAP_X_ACTIVE_OR_Y_STANDBY;
            compConfig.timeouts.instantiate = 30000;
            compConfig.timeouts.terminate = 30000;
            compConfig.timeouts.cleanup = 30000;
            compConfig.timeouts.quiescingComplete = 30000;
            compConfig.timeouts.csiSet = 30000;
            compConfig.timeouts.csiRemove = 30000;
            compConfig.timeouts.instantiateDelay = 10000;
            compConfig.recoveryOnTimeout = CL_AMS_RECOVERY_COMP_FAILOVER;
            
            bitMask |= COMP_CONFIG_SUPPORTED_CSI_TYPE;
            if(compConfig.pSupportedCSITypes)
                clHeapFree(compConfig.pSupportedCSITypes);
            
            compConfig.numSupportedCSITypes = 1;
            compConfig.pSupportedCSITypes = &supportedCSIType;
            
            snprintf(supportedCSIType.value, sizeof(supportedCSIType.value),
                     "%sCSIType", pBaseName);
            supportedCSIType.length = strlen(supportedCSIType.value) + 1;
            
            /*
             * invoke this process with dummy as the arg.
             */
            bitMask |= COMP_CONFIG_INSTANTIATE_COMMAND;
            snprintf(compConfig.instantiateCommand, sizeof(compConfig.instantiateCommand),
                     "dummyComp");
            clDhaExmpExec(("Comp config set [%s]", entity.name.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &compConfig.entity,
                                                            bitMask) ) == CL_OK,
                          ("Comp config set returned [%#x]", rc),
                          goto out);
            
            /*
             *Set similar config to second comp.
             */
            snprintf(compConfig.entity.name.value, sizeof(compConfig.entity.name.value),
                     "%s1", NEW_COMP_PREFIX);
            compConfig.entity.name.length = strlen(compConfig.entity.name.value)+1;
            clDhaExmpExec(("Comp config set [%s]", compConfig.entity.name.value),
                          (rc = clAmsMgmtCCBEntitySetConfig(ccbHandle,
                                                            &compConfig.entity,
                                                            bitMask)) == CL_OK,
                          ("Comp config set returned [%#x]", rc),
                          goto out);
            
            /* 
             * Commit to AMS db.
             */
            clDhaExmpExec(("Comp set commit"),
                          (rc = clAmsMgmtCCBCommit(ccbHandle)) == CL_OK,
                          ("Comp commit returned [%#x]", rc),
                          goto out);

        }
        break;
        
        default:
            assert(0);
    }
out:
    return rc;
}


static ClRcT clAmsMgmtTestUnlock(ClAmsMgmtHandleT mgmtHandle,
                                 ClAmsMgmtCCBHandleT ccbHandle,
                                 const ClCharT *pBaseName)
{
    ClRcT rc = CL_OK;
    ClAmsEntityT entity = {0};

    /*
     * Step 1 - Unlock SUs
     */
    entity.type = CL_AMS_ENTITY_TYPE_SU;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU0", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("LockA [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                      &entity)) == CL_OK,
                  ("LockA returned [%#x]", rc),
                  goto out);

    clDhaExmpExec(("Unlock [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityUnlock(mgmtHandle,
                                              &entity)) == CL_OK,
                  ("Unlock returned [%#x]", rc),
                  goto out);

    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU1", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec(("LockA [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                      &entity)) == CL_OK,
                  ("LockA returned [%#x]", rc),
                  goto out);

    clDhaExmpExec(("Unlock [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityUnlock(mgmtHandle,
                                              &entity)) == CL_OK,
                  ("Unlock returned [%#x]", rc),
                  goto out);

    /*
     * Step 2 - Unlock SI
     */

    entity.type = CL_AMS_ENTITY_TYPE_SI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec(("Unlock SI [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityUnlock(mgmtHandle,
                                              &entity)) == CL_OK,
                  ("Unlock returned [%#x]", rc),
                  goto out);

    /*
     * Step 3 - Unlock SG
     */

    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec (("LockA SG [%s]", entity.name.value),
                   (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                       &entity)) == CL_OK,
                   ("LockA returned [%#x]", rc),
                   goto out);

    clDhaExmpExec(("Unlock SG [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityUnlock(mgmtHandle,
                                              &entity)) == CL_OK,
                  ("Unlock returned [%#x]", rc),
                  goto out);

out:
    return rc;
}


static ClRcT clAmsMgmtTestLockI(ClAmsMgmtHandleT mgmtHandle,
                                ClAmsMgmtCCBHandleT ccbHandle,
                                const ClCharT *pBaseName)
{
    ClRcT rc = CL_OK;
    ClAmsEntityT entity = {0};

    /*
     * Step 1 - Lock, Lock_I SUs
     */
    entity.type = CL_AMS_ENTITY_TYPE_SU;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU0", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;

    clDhaExmpExec(("LockA [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                      &entity)) == CL_OK,
                  ("LockA returned [%#x]", rc),
                  goto out);

    clDhaExmpExec(("LockI [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockInstantiation(mgmtHandle,
                                                         &entity)) == CL_OK,
                  ("LockI returned [%#x]", rc),
                  goto out);

    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSU1", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec(("LockA [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                      &entity)) == CL_OK,
                  ("LockA returned [%#x]", rc),
                  goto out);

    clDhaExmpExec(("LockI [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockInstantiation(mgmtHandle,
                                                         &entity)) == CL_OK,
                  ("LockI returned [%#x]", rc),
                  goto out);

    /*
     * Step 2 - Lock SI
     */

    entity.type = CL_AMS_ENTITY_TYPE_SI;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSI", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec(("LockA SI [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                      &entity)) == CL_OK,
                  ("LockA returned [%#x]", rc),
                  goto out);

    /*
     * Step 3 - Lock, Lock_I SG
     */

    entity.type = CL_AMS_ENTITY_TYPE_SG;
    snprintf(entity.name.value, sizeof(entity.name.value),
             "%sSG", pBaseName);
    entity.name.length = strlen(entity.name.value)+1;
    
    clDhaExmpExec (("LockA SG [%s]", entity.name.value),
                   (rc = clAmsMgmtEntityLockAssignment(mgmtHandle,
                                                       &entity)) == CL_OK,
                   ("LockA returned [%#x]", rc),
                   goto out);

    clDhaExmpExec(("LockI SG [%s]", entity.name.value),
                  (rc = clAmsMgmtEntityLockInstantiation(mgmtHandle,
                                                         &entity)) == CL_OK,
                  ("LockI returned [%#x]", rc),
                  goto out);

out:
    return rc;
}



/*
 * ---END_APPLICATION_CODE---
 */

