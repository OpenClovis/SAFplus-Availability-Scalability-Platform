/******************************************************************************
 *
 * clCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2006 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component. Application
 * specific code should be added between the ---BEGIN_APPLICATION_CODE--- and
 * ---END_APPLICATION_CODE--- separators.
 *
 * Template Version: 1.0
 *
 ***************************** Editor Commands ********************************
 * For vi/vim
 * :set shiftwidth=4
 * :set softtabstop=4
 * :set expandtab
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

/*
 * Basic ASP Includes.
 */

#include <clCommon.h>
#include <clOsalApi.h>
#include <clIocServices.h>

/*
 * ASP Client Includes.
 */

#include <clRmdApi.h>
#include <clDebugApi.h>
#include <clOmApi.h>
#include <clOampRtApi.h>
#include <clProvApi.h>
#include <clAlarmApi.h>

#include <clEoApi.h>
#include <clCpmApi.h>
#include <clIdlApi.h>


/*
 * ---BEGIN_APPLICATION_CODE---
 */
#include <sys/socket.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include <string.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <sys/socket.h>       /* for AF_INET */
#include <netdb.h>

#include "clCompAppMain.h"

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This is necessary if the component wishes to provide a service that will
 * be used by other components.
 */

#if HAS_EO_SERVICES

extern ClRcT clApp2plus1_EOClientInstall(void);

#endif

/*
 * This template has a few default clprintfs. These can be disabled by 
 * changing clprintf to a null function
 */
 
#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

pid_t mypid;
ClCpmHandleT cpmHandle;

/*
 * ---BEGIN_APPLICATION_CODE---
 */
enum
  {
  VipFieldLen = 64
  };

typedef struct
{
  char ip[VipFieldLen];
  char dev[VipFieldLen];
  char netmask[VipFieldLen];
} VirtualIpAddress;

VirtualIpAddress gVirtualIp;

/* From the RFC
    Ethernet packet data:
        16.bit: (ar$hrd) Hardware address space (e.g., Ethernet,
                         Packet Radio Net.)
        16.bit: (ar$pro) Protocol address space.  For Ethernet
                         hardware, this is from the set of type
                         fields ether_typ$<protocol>.
         8.bit: (ar$hln) byte length of each hardware address
         8.bit: (ar$pln) byte length of each protocol address
        16.bit: (ar$op)  opcode (ares_op$REQUEST | ares_op$REPLY)
        nbytes: (ar$sha) Hardware address of sender of this
                         packet, n from the ar$hln field.
        mbytes: (ar$spa) Protocol address of sender of this
                         packet, m from the ar$pln field.
        nbytes: (ar$tha) Hardware address of target of this
                         packet (if known).
        mbytes: (ar$tpa) Protocol address of target.
*/

typedef struct
{
  ClUint8T  dstMac[6];
  ClUint8T  myMac[6];
  ClUint16T type;

  ClUint16T hrd;
  ClUint16T pro;
  ClUint8T  hln;
  ClUint8T  pln;
  ClUint16T op;
  ClUint8T  sha[6];
  ClUint8T  spa[4];
  ClUint8T  tha[6];
  ClUint8T  tpa[4];
} EthIpv4ArpPacket;

enum
  {
    ArpRequest = 1,
    ArpReply   = 2,
    ArpHwTypeEthernet = 1,

    IpProtoType = 0x0800,
    //ArpAddressResolutionType = 
    MacAddrLen  = 6
  };

ClRcT DevToMac(const char* dev, char mac[6])
{
  struct ifreq req;

  int sd = socket(AF_INET, SOCK_STREAM, 0);

  memset(&req, 0, sizeof(struct ifreq));
  strcpy(req.ifr_name, dev);
  req.ifr_addr.sa_family = AF_UNSPEC;
  ioctl(sd, SIOCGIFHWADDR, &req);
  memcpy(mac, &(req.ifr_addr.sa_data), 6); 

  close(sd);
  return CL_OK;
}

ClRcT HostToIp(const char* myHost, unsigned int* ip)
{
  struct hostent* host = NULL;
  struct hostent hostdata;
  char buf[128];
  int errnum = 0;
  
  if (gethostbyname_r(myHost,&hostdata,buf,128,&host,&errnum) ||
      !host)
    {
      return CL_ERR_LIBRARY;
    }
 
  *ip = *((unsigned int*) host->h_addr_list[0]);
  return CL_OK; 
}

ClRcT SendArp(const char* host, const char* dev)
{
  int i;
  char myMac[MacAddrLen];
  unsigned int myIp = 0;
  EthIpv4ArpPacket pkt;
  ClRcT rc = CL_OK;

  DevToMac(dev,myMac);
  if( (rc = HostToIp(host,&myIp)) != CL_OK) return rc;

  for (i = ArpRequest; i<= ArpRequest; i++)
    {

      memcpy(pkt.myMac, myMac, MacAddrLen);
      memset(pkt.dstMac, 0xFF, MacAddrLen);
      pkt.type = htons(ETHERTYPE_ARP);

      pkt.hrd = htons(ArpHwTypeEthernet);
      pkt.pro = htons(IpProtoType); //htons(ETHERTYPE_IP); //htons(ETH_P_IP); //ArpAddressResolutionType;
      pkt.hln = MacAddrLen;  /* ETH_HW_ADDR_LEN; Length in bytes of ethernet address */
      pkt.pln = 4; // IP_ADDR_LEN;
      pkt.op  = htons(i);     // htons(ARPOP_REQUEST);

      memcpy(pkt.sha,myMac,MacAddrLen);
      memset(pkt.tha, 0xFF, MacAddrLen);
      memcpy(pkt.spa,&myIp,4);
      memcpy(pkt.tpa,&myIp,4);

      if (1)
        {
          int             sd;
          struct sockaddr_ll sal; 

          bzero(&sal,sizeof(sal)); 
          sal.sll_family    = AF_PACKET; 
          sal.sll_protocol  = htons(ETH_P_ARP); 
          sal.sll_ifindex   = 2; 
          sal.sll_hatype    = htons(i); 
          sal.sll_pkttype   = PACKET_BROADCAST; 
          memcpy(sal.sll_addr, myMac, MacAddrLen); 
          sal.sll_halen     = MacAddrLen;

          if ((sd = socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ARP))) < 0) 
            { perror("socket"); return CL_ERR_LIBRARY; }

          if (sendto(sd,&pkt,sizeof(pkt),0,(struct sockaddr *)&sal,sizeof(sal)) < 0)
            { 
              perror("sendto"); 
              return CL_ERR_LIBRARY; 
            }
          close(sd);
        }
    }
  return CL_OK;
}


void GetVirtualAddressInfo(ClAmsCSIDescriptorT csiDescriptor, VirtualIpAddress* vip)
{
  int i;
  vip->ip[0] = 0;
  vip->netmask[0] = 0;
  vip->dev[0] = 0;

  /* Pull the appropriate values out of the workload dictionary */
  for (i = 0; i < csiDescriptor.csiAttributeList.numAttributes; i++)
    {
      if (strcmp((const char*) csiDescriptor.csiAttributeList.attribute[i].attributeName,"VirtualIpAddress") == 0) 
        strncpy(vip->ip, (const char*) csiDescriptor.csiAttributeList.attribute[i].attributeValue, VipFieldLen);
      if (strcmp((const char*) csiDescriptor.csiAttributeList.attribute[i].attributeName,"VirtualNetMask") == 0)   
        strncpy(vip->netmask, (const char*) csiDescriptor.csiAttributeList.attribute[i].attributeValue,VipFieldLen);
      if (strcmp((const char*) csiDescriptor.csiAttributeList.attribute[i].attributeName,"VirtualDevice") == 0) 
        strncpy(vip->dev, (const char*) csiDescriptor.csiAttributeList.attribute[i].attributeValue,VipFieldLen);
    }
}

void AddRemVirtualAddress(const char *cmd,const VirtualIpAddress* vip)
{
  if (vip->ip && vip->dev && vip->netmask)
    {
      char exec[81];
      snprintf(exec,80,"%s/virtualIp %s %s %s %s ", CL_APP_BINDIR, cmd,vip->ip,vip->netmask,vip->dev);
      system(exec);

      if (cmd[0] == 'u')  /* If we are coming up, do a gratuitous arp */
        SendArp(vip->ip,vip->dev);
    }
}

/*
 * ---END_APPLICATION_CODE---
 */

/*
 * Description of this EO
 */

ClEoConfigT clEoConfig =
{
    COMP_EO_NAME,               /* EO Name                                  */
    COMP_EO_THREAD_PRIORITY,    /* EO Thread Priority                       */
    COMP_EO_NUM_THREAD,         /* No of EO thread needed                   */
    COMP_IOC_PORT,              /* Required Ioc Port                        */
    COMP_EO_USER_CLIENT_ID, 
    COMP_EO_USE_THREAD_MODEL,   /* Thread Model                             */
    clCompAppInitialize,        /* Application Initialize Callback          */
    clCompAppFinalize,          /* Application Terminate Callback           */
    clCompAppStateChange,       /* Application State Change Callback        */
    clCompAppHealthCheck,       /* Application Health Check Callback        */
};

/*
 * Basic libraries used by this EO. The first 6 libraries are mandatory, the
 * others can be enabled or disabled by setting to CL_TRUE or CL_FALSE.
 */

ClUint8T clEoBasicLibs[] =
{
    COMP_EO_BASICLIB_OSAL,      /* Lib: Operating System Adaptation Layer   */
    COMP_EO_BASICLIB_TIMER,     /* Lib: Timer                               */
    COMP_EO_BASICLIB_BUFFER,    /* Lib: Buffer Management                   */
    COMP_EO_BASICLIB_IOC,       /* Lib: Intelligent Object Communication    */
    COMP_EO_BASICLIB_RMD,       /* Lib: Remote Method Dispatch              */
    COMP_EO_BASICLIB_EO,        /* Lib: Execution Object                    */
    COMP_EO_BASICLIB_OM,        /* Lib: Object Management                   */
    COMP_EO_BASICLIB_HAL,       /* Lib: Hardware Adaptation Layer           */
    COMP_EO_BASICLIB_DBAL,      /* Lib: Database Adaptation Layer           */
};

/*
 * Client libraries used by this EO. All are optional and can be enabled
 * or disabled by setting to CL_TRUE or CL_FALSE.
 */

ClUint8T clEoClientLibs[] =
{
    COMP_EO_CLIENTLIB_COR,      /* Lib: Common Object Repository            */
    COMP_EO_CLIENTLIB_CM,       /* Lib: Chassis Management                  */
    COMP_EO_CLIENTLIB_NAME,     /* Lib: Name Service                        */
    COMP_EO_CLIENTLIB_LOG,      /* Lib: Log Service                         */
    COMP_EO_CLIENTLIB_TRACE,    /* Lib: Trace Service                       */
    COMP_EO_CLIENTLIB_DIAG,     /* Lib: Diagnostics                         */
    COMP_EO_CLIENTLIB_TXN,      /* Lib: Transaction Management              */
    CL_FALSE,                   /* NA */
    COMP_EO_CLIENTLIB_PROV,     /* Lib: Provisioning Management             */
    COMP_EO_CLIENTLIB_ALARM,    /* Lib: Alarm Management                    */
    COMP_EO_CLIENTLIB_DEBUG,    /* Lib: Debug Service                       */
    COMP_EO_CLIENTLIB_GMS,       /* Lib: Cluster/Group Membership Service    */
    COMP_EO_CLIENTLIB_PM        /* Lib: Performance Management              */
};

/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/

/*
 * clCompAppInitialize
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

ClRcT
clCompAppInitialize(
    ClUint32T argc,
    ClCharT *argv[])
{
    ClNameT             appName;
    ClCpmCallbacksT     callbacks;
    ClVersionT          version;
    ClIocPortT          iocPort;
    ClRcT               rc = CL_OK;

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * Declare other local variables here.
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the version of
     * AMF with which this application would like to interface. 'callbacks'
     * is used to register the callbacks this component expects to receive.
     */

    version.releaseCode                         = 'B';
    version.majorVersion                        = 01;
    version.minorVersion                        = 01;
    
    callbacks.appHealthCheck                    = NULL;
    callbacks.appTerminate                      = clCompAppTerminate;
    callbacks.appCSISet                         = clCompAppAMFCSISet;
    callbacks.appCSIRmv                         = clCompAppAMFCSIRemove;
    callbacks.appProtectionGroupTrack           = NULL;
        
    /*
     * Get IOC Address, Port and Name. Register with AMF.
     */

    clEoMyEoIocPortGet(&iocPort);

    if ( (rc = clCpmClientInitialize(&cpmHandle, &callbacks, &version)) ) 
        goto errorexit;

    /*
     * If this component will provide a service, register it now.
     */

#if HAS_EO_SERVICES


    rc = clApp2plus1_EOClientInstall();

#endif

    /*
     * Do the application specific initialization here.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = clCpmComponentNameGet(cpmHandle, &appName)) ) 
        goto errorexit;
    if ( (rc = clCpmComponentRegister(cpmHandle, &appName, NULL)) ) 
        goto errorexit;

    /*
     * Print out standard information for this component.
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Initializing\n", appName.value, mypid);
    clprintf (CL_LOG_SEV_INFO, "   IOC Address             : 0x%x\n", clIocLocalAddressGet());
    clprintf (CL_LOG_SEV_INFO, "   IOC Port                : 0x%x\n", iocPort);

    /*
     * This is where the application code starts. If the main thread usage
     * policy is CL_EO_USE_THREAD_FOR_APP, then return from this fn only 
     * after the application terminates. If the main thread usage policy is
     * CL_EO_USE_THREAD_FOR_RECV, then return from this fn after doing the
     * application specific initialization and registration.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%d]. Initialization error [0x%x]\n",
              appName.value, mypid, rc);

    return rc;
}

/*
 * clCompAppFinalize
 * -----------------
 * This function is invoked when the application is to be terminated.
 */

ClRcT clCompAppFinalize()
{
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

ClRcT
clCompAppTerminate(
    ClInvocationT       invocation,
    const ClNameT       *compName)
{
    ClRcT rc = CL_OK;

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Terminating\n",
              compName->value, mypid);

    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */
    
    /*
     * Unregister with AMF and send back a response
     */

    if ( (rc = clCpmComponentUnregister(cpmHandle, compName, NULL)) )
        goto errorexit;
    if ( (rc = clCpmClientFinalize(cpmHandle)) )
        goto errorexit;

    clCpmResponse(cpmHandle, invocation, CL_OK);

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. Terminated\n", compName->value, mypid);

    return rc;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%d]. Termination error [0x%x]\n",
              compName->value, mypid, rc);

    return rc;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 *
 * WARNING: This function is deprecated, and may not be supported in the future.
 * Usage of this feature is discouraged.
 */

ClRcT
clCompAppStateChange(
    ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }

        case CL_EO_STATE_RESUME:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT
clCompAppHealthCheck(
    ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The defaults
     * indicate EO is healthy and polling interval is unaltered.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

ClRcT
clCompAppAMFCSISet(
    ClInvocationT       invocation,
    const ClNameT       *compName,
    ClAmsHAStateT       haState,
    ClAmsCSIDescriptorT csiDescriptor)
{
    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Print information about the CSI Set
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. CSI Set Received\n", 
              compName->value, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case CL_AMS_HA_STATE_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
         */
        if (csiDescriptor.csiFlags == CL_AMS_CSI_FLAG_TARGET_ALL)
          {
            ClRcT rc;
            ClCpmCompCSIRefT csiRef = { 0 };
            ClInt32T i;
            rc = clCpmCompCSIList(compName, &csiRef);
            if(rc != CL_OK)
              {
                clLogError("APP", "CSISET", "Comp CSI get returned [%#x]", rc);
              }
            else
              {
                for(i = 0; i < csiRef.numCSIs; ++i)
                  {
                    VirtualIpAddress temp;
                    ClCpmCompCSIT *pCSI = &csiRef.pCSIList[i];

                    clprintf(CL_LOG_SEV_INFO,"Comp [%.*s], CSI [%.*s], HA state [%s]",
                             compName->length,
                             compName->value, 
                             pCSI->csiDescriptor.csiName.length,
                             pCSI->csiDescriptor.csiName.value,
                             STRING_HA_STATE(pCSI->haState));

                    GetVirtualAddressInfo(pCSI->csiDescriptor, &temp);
                    AddRemVirtualAddress("up",&temp);

                  }
                if(csiRef.pCSIList)
                  clHeapFree(csiRef.pCSIList);
              }
          }
        else /* CL_AMS_CSI_FLAG_ADD_ONE */
          {
            GetVirtualAddressInfo(csiDescriptor, &gVirtualIp);
            AddRemVirtualAddress("up",&gVirtualIp);
          }

        /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */
            GetVirtualAddressInfo(csiDescriptor, &gVirtualIp);
            AddRemVirtualAddress("down",&gVirtualIp);  /* Bring it down just in case it is up from a prior run */
            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */
          if (csiDescriptor.csiFlags == CL_AMS_CSI_FLAG_TARGET_ONE)
            {
              AddRemVirtualAddress("down",&gVirtualIp);
            }           
          else if (csiDescriptor.csiFlags == CL_AMS_CSI_FLAG_TARGET_ALL)
          {                
            ClRcT rc;
            ClCpmCompCSIRefT csiRef = { 0 };
            ClInt32T i;
            rc = clCpmCompCSIList(compName, &csiRef);
            if(rc != CL_OK)
              {
                clLogError("APP", "CSISET", "Comp CSI get returned [%#x]", rc);
              }
            else
              {
                for(i = 0; i < csiRef.numCSIs; ++i)
                  {
                    VirtualIpAddress temp;
                    ClCpmCompCSIT *pCSI = &csiRef.pCSIList[i];

                    clprintf(CL_LOG_SEV_INFO,"Comp [%.*s], CSI [%.*s], HA state [%s]",
                                compName->length,
                                compName->value, 
                                pCSI->csiDescriptor.csiName.length,
                                pCSI->csiDescriptor.csiName.value,
                                STRING_HA_STATE(pCSI->haState));

                    GetVirtualAddressInfo(pCSI->csiDescriptor, &temp);
                    AddRemVirtualAddress("down",&temp);

                  }
                if(csiRef.pCSIList)
                  clHeapFree(csiRef.pCSIList);
              }
          }
          else /* CL_AMS_CSI_FLAG_ADD_ONE */
            {
              VirtualIpAddress temp;
              GetVirtualAddressInfo(csiDescriptor, &temp);
              AddRemVirtualAddress("down",&temp);
            }

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmCSIQuiescingComplete(cpmHandle, invocation, CL_OK);
            break;
        }

        default:
        {
            break;
        }
    }

    return CL_OK;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

ClRcT
clCompAppAMFCSIRemove(
    ClInvocationT       invocation,
    const ClNameT       *compName,
    const ClNameT       *csiName,
    ClAmsCSIFlagsT      csiFlags)
{
    /*
     * Print information about the CSI Remove
     */

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%d]. CSI Remove Received\n", 
              compName->value, mypid);

    clprintf (CL_LOG_SEV_INFO, "   CSI                     : %s\n", csiName->value);
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : 0x%x\n", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    AddRemVirtualAddress("down",&gVirtualIp);

    /*
     * ---END_APPLICATION_CODE---
     */

    clCpmResponse(cpmHandle, invocation, CL_OK);

    return CL_OK;
}

/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

ClRcT clCompAppAMFPrintCSI(ClAmsCSIDescriptorT csiDescriptor,
                           ClAmsHAStateT haState)
{
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : [%s]\n",
              STRING_CSI_FLAGS(csiDescriptor.csiFlags));

    if (CL_AMS_CSI_FLAG_TARGET_ALL != csiDescriptor.csiFlags)
    {
        clprintf (CL_LOG_SEV_INFO, "   CSI Name                : [%s]\n", 
                  csiDescriptor.csiName.value);
    }

    if (CL_AMS_CSI_FLAG_ADD_ONE == csiDescriptor.csiFlags)
    {
        ClUint32T i = 0;
        
        clprintf (CL_LOG_SEV_INFO, "   Name Value Pairs        : \n");
        for (i = 0; i < csiDescriptor.csiAttributeList.numAttributes; i++)
        {
            clprintf (CL_LOG_SEV_INFO, "       Name            : [%s]\n",
                      csiDescriptor.csiAttributeList.
                      attribute[i].attributeName);
            clprintf (CL_LOG_SEV_INFO, "       Value           : [%s]\n",
                      csiDescriptor.csiAttributeList.
                      attribute[i].attributeValue);
        }
    }
    
    clprintf (CL_LOG_SEV_INFO, "   HA State                : [%s]\n",
              STRING_HA_STATE(haState));

    if (CL_AMS_HA_STATE_ACTIVE == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "   Active Descriptor       : \n");
        clprintf (CL_LOG_SEV_INFO, "     Transition Descriptor : [%d]\n",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.transitionDescriptor);
        clprintf (CL_LOG_SEV_INFO, "       Active Component    : [%s]\n",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.activeCompName.value);
    }
    else if (CL_AMS_HA_STATE_STANDBY == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "   Standby Descriptor      : \n");
        clprintf (CL_LOG_SEV_INFO, "       Standby Rank        : [%d]\n",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.standbyRank);
        clprintf (CL_LOG_SEV_INFO, "       Active Component    : [%s]\n",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.activeCompName.value);
    }

    return CL_OK;
}

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Insert any other utility functions here.
 */

/*
 * ---END_APPLICATION_CODE---
 */

