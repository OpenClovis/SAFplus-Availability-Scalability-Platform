/******************************************************************************
 *
 * clCompAppProv.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2008 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component. Application
 * specific code should be added between the ---BEGIN_APPLICATION_CODE--- and
 * ---END_APPLICATION_CODE--- separators.
 *
 * Template Version: 1.0
 *
 ***************************** Editor Commands ********************************
 * For vi/vim
 * :set shiftwidth=4
 * :set softtabstop=4
 * :set expandtab
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

/*
 * Basic ASP Includes.
 */

#include <clCommon.h>
#include <clOsalApi.h>
#include <clIocServices.h>

/*
 * ASP Client Includes.
 */
#include <clLogApi.h>
#include <clCorUtilityApi.h>
#include <clProvApi.h>

/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#include "clCompAppProv.h"
#include "clAlarmApi.h"
#include "clAlarmUtils.h"
#include "clCorMetaStruct.h"
#include "clCorUtilityApi.h"
#include "clCorApi.h"
#include "clProvisioningUtils.h"

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Optional Features
 *****************************************************************************/

#define clprintf(severity, ...)   clAppLog(CL_LOG_HANDLE_APP, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---BEGIN_APPLICATION_CODE---
 */

extern ClCharT  appname [80] ;
extern ClProvisioningTimeT alarmTime, clockTime;
extern ClUint8T    compInit;
ClUint32T   doNothing = 0;

ClRcT _clProvisioningCompAlarmRaise(ClAlarmStateT alarmState)
{
    ClRcT   rc = CL_OK;
    ClAlarmInfoT *pAlarmInfo = {0};
    ClAlarmHandleT alarmHandle = {0};
    ClUint8T * pBuf = NULL;
    ClUint32T size = 0;
    ClAlarmUtilPayLoadListPtrT pPayloadList = NULL;
    ClUint32T   dummyVal = alarmState;
    ClCorMOIdT  moId ;
    ClCorObjectHandleT  objH = NULL; 
    ClNameT         compName = {0};

    
    clCorMoIdInitialize(&moId);
    clCorMoIdAppend(&moId, CLASS_CHASSIS_MO, 0);
    clCorMoIdAppend(&moId, CLASS_ALARMRESOURCE_MO, 0);
    clCorMoIdServiceSet(&moId, CL_COR_SVC_ID_ALARM_MANAGEMENT);
    
    rc = clCorObjectHandleGet(&moId, &objH);
    if (rc != CL_OK)
    {
        clOsalPrintf("[%s]: The Alarm Resource MO is not yet created. "
                "Please instantiate the Alarm Component.\n", appname);
        return CL_OK;
    }

    strncpy(compName.value, appname, CL_MAX_NAME_LENGTH);
    compName.length = strlen(appname) + 1;
    
    pPayloadList = clHeapAllocate(sizeof(ClAlarmUtilPayLoadListT));
    if (pPayloadList == NULL)
    {
        clOsalPrintf("[%s]. Failed to allocate the memory for the alarm payload list.", appname);
        return CL_ERR_NO_MEMORY;
    }

    pPayloadList->numPayLoadEnteries = 1;
    pPayloadList->pPayload = clHeapAllocate(sizeof(ClAlarmUtilPayLoadT));
    if (NULL == pPayloadList->pPayload)
    {
        clOsalPrintf("[%s]. Failed while allocating payload array.", appname);
        clHeapFree(pPayloadList);
        return CL_ERR_NO_MEMORY;
    }

    
    pPayloadList->pPayload[0].numTlvs = 1;
    clCorMoIdClone(&moId, &pPayloadList->pPayload[0].pMoId);

    pPayloadList->pPayload[0].pTlv = clHeapAllocate(sizeof(ClAlarmUtilTlvT));
    if (NULL == pPayloadList->pPayload[0].pTlv)
    {
        clOsalPrintf("[%s]. Failed while allocating the pTlv array. ", appname);
        clAlarmUtilPayloadListFree(pPayloadList);
        return CL_ERR_NO_MEMORY;
    }

    pPayloadList->pPayload[0].pTlv[0].type = CL_COR_UINT32;
    pPayloadList->pPayload[0].pTlv[0].value = clHeapAllocate(sizeof(ClUint32T));
    if (NULL == pPayloadList->pPayload[0].pTlv[0].value)
    {
        clOsalPrintf("[%s]. Failed while allocating the value for the attribute.", appname);
        clAlarmUtilPayloadListFree(pPayloadList);
        return CL_ERR_NO_MEMORY;
    }


    pPayloadList->pPayload[0].pTlv[0].length = sizeof(ClUint32T);

    memset(pPayloadList->pPayload[0].pTlv[0].value, 0, sizeof(ClUint32T));

    memcpy(pPayloadList->pPayload[0].pTlv[0].value, &dummyVal, sizeof(ClUint32T));


    rc = clAlarmUtilPayloadFlatten(pPayloadList, &size, &pBuf);
    if (CL_OK != rc)
    {
        clOsalPrintf("[%s]. Failed while getting the flat buffer for the payload. rc[0x%x]", 
                appname, rc);
        clAlarmUtilPayloadListFree(pPayloadList);
        return rc;
    }

    pAlarmInfo = clHeapAllocate (sizeof(ClAlarmInfoT) + size);
    if (NULL == pAlarmInfo)
    {
        clOsalPrintf("[%s]: Failed to allocate the memory for alarm information. \n", appname);
        clAlarmUtilPayloadListFree(pPayloadList);
        clAlarmUtilPayloadBufFree(pBuf);
        return CL_ERR_NO_MEMORY;
    }

    pAlarmInfo->moId = moId;
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_LOSS_OF_SIGNAL; 
    pAlarmInfo->severity = CL_ALARM_SEVERITY_MAJOR;
    memcpy (&pAlarmInfo->compName, &compName, sizeof(ClNameT));
    pAlarmInfo->alarmState = alarmState;
    pAlarmInfo->len = size;

    memcpy(pAlarmInfo->buff, pBuf, pAlarmInfo->len);

    clAlarmUtilPayloadListFree(pPayloadList);
    clAlarmUtilPayloadBufFree(pBuf);

    rc = clAlarmRaise (pAlarmInfo, &alarmHandle);
    if (CL_OK != rc)
    {
        clOsalPrintf("%s: ERROR [0x%x]: The alarm raise has failed. \n", appname, rc);
    }  

    clHeapFree(pAlarmInfo);
    return rc;
}
/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * ---END_APPLICATION_CODE---
 */


/******************************************************************************
 * Application Transaction Life Cycle Management Functions
 *****************************************************************************/

/*
 * clCompAppTxnStart
 * -----------------
 * This function is invoked before forwarding any of the transaction requests
 * to this application. Please refer the detailed documentation for this function
 * in clCompAppProv.h file.
 */

void
clCompAppProvTxnStart(ClHandleT txnHandle)
{
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO, "**** Inside the function : [%s] ****", __FUNCTION__);

    /*
     * ---END_APPLICATION_CODE---
     */
}

/*
 * clCompAppTxnEnd
 * ---------------
 * This function is invoked after all the transaction requests for this application
 * are completed. Please refer the detailed documentation for this function
 * in clCompAppProv.h file.
 */
void
clCompAppProvTxnEnd(ClHandleT txnHandle)
{
    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    static ClUint32T alarmState = 0;

    clprintf(CL_LOG_SEV_INFO, "**** Inside the function : [%s] ****", __FUNCTION__);

    if (doNothing == 1)
    {
        clOsalPrintf("[%s]: The time (clock or alarm) is not changed, doing no operation.\n", 
                appname);
        doNothing = 0;
        return;
    }

    if (compInit != 0)
    {
        if ((alarmTime.hour == clockTime.hour) && (alarmTime.min == clockTime.min))
        {
            if(alarmState == 0)
            {
                clOsalPrintf("[%s]: Raising the alarm \n", 
                    appname);
                _clProvisioningCompAlarmRaise(CL_ALARM_STATE_ASSERT);
                alarmState = 1;
            }
        }
        else if (alarmState == 1)
        {
            clOsalPrintf("[%s]: Clearing the alarm \n", 
                appname);
            _clProvisioningCompAlarmRaise(CL_ALARM_STATE_CLEAR);
            alarmState = 0;
        }
    }

    /*
     * ---END_APPLICATION_CODE---
     */
}

/**
 * This is used assign the Provisioning Transaction callbacks, which will be
 * called before and end of a transaction. Both are optional, it can be 
 * disabled by passing NULL for the callbacks.
 */
ClProvTxnCallbacksT clProvTxnCallbacks =
{
    clCompAppProvTxnStart,      /* Transaction start callback               */
    clCompAppProvTxnEnd         /* Transaction end callback                 */
};

