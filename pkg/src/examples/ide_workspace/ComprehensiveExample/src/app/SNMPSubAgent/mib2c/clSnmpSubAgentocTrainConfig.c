
#include <string.h>
#include <clLogApi.h>
#include <clSnmpLog.h>
#include <clDebugApi.h>
#include <clSnmpOp.h>
#include <clSnmpocTrainScalars.h>
#include <clSnmpocTrainTables.h>
#include <clSnmpocTrainNotifications.h>
#include <clSnmpocTrainUtil.h>
#include <clSnmpocTrainInstXlation.h>
#include <clSnmpSubAgentocTrainConfig.h>


/*
 * This structure contains information regarding oid of the table and the 
 * type of index. The index  can  either be  a string value or a non-string value.
 * Any SNMP type apart from string is treated as non-string.
 */

ClSnmpOidInfoT appOidInfo[] =
{
    {    CL_OCTRAIN_SCALARS, "1.3.6.1.4.1.103.1.1", 1, { { 0, 0 } }, NULL, clSnmpocTrainDefaultInstXlator, clSnmpocTrainDefaultInstCompare },
    {    CL_OCTRAIN_SCALARS, "1.3.6.1.4.1.103.1.2", 1, { { 0, 0 } }, NULL, clSnmpocTrainDefaultInstXlator, clSnmpocTrainDefaultInstCompare },
    {    CL_CLOCKTABLE, "1.3.6.1.4.1.103.2.1",
        1 /* no. of indexes */,
        {
            { CL_SNMP_NON_STRING_ATTR, 4 } ,
        },
        NULL, clSnmpclockTableInstXlator, clSnmpclockTableInstCompare
    },
    {    CL_TIMESETTABLE, "1.3.6.1.4.1.103.3.1",
        1 /* no. of indexes */,
        {
            { CL_SNMP_NON_STRING_ATTR, 4 } ,
        },
        NULL, clSnmptimeSetTableInstXlator, clSnmptimeSetTableInstCompare
    },
    {    CL_NAMETABLE, "1.3.6.1.4.1.103.4.1",
        1 /* no. of indexes */,
        {
            { CL_SNMP_NON_STRING_ATTR, 4 } ,
        },
        clSnmpnameTableIndexCorAttrGet, clSnmpnameTableInstXlator, clSnmpnameTableInstCompare
    },
    {0, NULL, 0, {{0,0}}, NULL, NULL}
};

/*
 * This provides mapping between trap oid and the notification call back function 
 * generated by mib2c. When an alarm is raised this mapping is used to call the
 * corresponding notification function.
 */
ClSnmpNtfyCallbackTableT clSnmpAppCallback[]= {
    {".1.3.6.1.4.1.103.5.1", clSnmpalarmTrapIndexGet, clSnmpSendalarmTrapTrap},    
    {NULL, NULL, NULL}
};

/*
 * This function needs to be written for every application MIB sub-agent. From
 * this function call the app MIB specific init functions. The app MIB
 * specific init functions are generated by mib2c
 */
 
void init_appMIB(void)
{
    

    /*Application needs to replace the below function with  mib2c generated init function.*/
    clSnmpocTrainScalarsInit();
    clSnmpocTrainTablesInit();
}

ClInt32T  clSnmpocTrainDefaultInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpclockTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLog(CL_LOG_DEBUG, CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Data1 : [%d] Data2 : [%d]", *(ClUint32T*)&pTabIdx1->index.clockTableInfo, *(ClUint32T*)&pTabIdx2->index.clockTableInfo);
    retVal = memcmp(&(pTabIdx1->index.clockTableInfo), 
                &(pTabIdx2->index.clockTableInfo), 
                sizeof(pTabIdx1->index.clockTableInfo));
    return retVal;
    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmptimeSetTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLog(CL_LOG_DEBUG, CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Data1 : [%d] Data2 : [%d]", *(ClUint32T*)&pTabIdx1->index.timeSetTableInfo, *(ClUint32T*)&pTabIdx2->index.timeSetTableInfo);
    retVal = memcmp(&(pTabIdx1->index.timeSetTableInfo), 
                &(pTabIdx2->index.timeSetTableInfo), 
                sizeof(pTabIdx1->index.timeSetTableInfo));
    return retVal;
    return 0;
}
/*
 * This function needs to be written for every table in the MIB.
 * The information for MIB table index is stored in container, so the user
 * needs to provide logic for key comparison of the container.
 */
ClInt32T  clSnmpnameTableInstCompare (CL_IN ClCntKeyHandleT key1,
                            CL_IN ClCntKeyHandleT key2)
{
    ClSNMPRequestInfoT *pTabIdx1 = NULL;
    ClSNMPRequestInfoT *pTabIdx2 = NULL;
    ClInt32T retVal = 0;
    
    if (key1 != 0) pTabIdx1 = (ClSNMPRequestInfoT *)key1;
    if (key2 != 0) pTabIdx2 = (ClSNMPRequestInfoT *)key2;

    if(!pTabIdx1 || !pTabIdx2)
    {
        /* return non-zero value  in case of error condition. */
        return(-1);
    }

    clLog(CL_LOG_DEBUG, CL_SNMP_AREA, CL_SNMP_GEN_CMP_COTX, "Data1 : [%d] Data2 : [%d]", *(ClUint32T*)&pTabIdx1->index.nameTableInfo, *(ClUint32T*)&pTabIdx2->index.nameTableInfo);
    retVal = memcmp(&(pTabIdx1->index.nameTableInfo), 
                &(pTabIdx2->index.nameTableInfo), 
                sizeof(pTabIdx1->index.nameTableInfo));
    return retVal;
    return 0;
}
