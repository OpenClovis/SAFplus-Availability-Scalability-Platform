/******************************************************************************
 *
 * clCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2006 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component. Application
 * specific code should be added between the ---BEGIN_APPLICATION_CODE--- and
 * ---END_APPLICATION_CODE--- separators.
 *
 * Template Version: 1.0
 *
 ***************************** Editor Commands ********************************
 * For vi/vim
 * :set shiftwidth=4
 * :set softtabstop=4
 * :set expandtab
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <assert.h>
#include <errno.h>
#include <arpa/inet.h>

/*
 * Basic ASP Includes.
 */

#include <clCommon.h>
#include <clLogApi.h>

/*
 * ASP Client Includes.
 */

#include <clDebugApi.h>
#include <clCpmApi.h>
#include <saAmf.h>

/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#include <saCkpt.h>
#include <clTaskPool.h>
#include "clCompAppMain.h"
#include "../ev/ev.h"

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This is necessary if the component wishes to provide a service that will
 * be used by other components.
 */

#if HAS_EO_SERVICES

extern ClRcT clcsa103CompEOClientInstall(void);

#endif

/*
 * This template has a few default clprintfs. These can be disabled by 
 * changing clprintf to a null function
 */
 
#define clprintf(severity, ...)   clAppLog(gEvalLogStream, severity, 10, \
                                  CL_LOG_AREA_UNSPECIFIED, CL_LOG_CONTEXT_UNSPECIFIED,\
                                  __VA_ARGS__)

/*
 * ---BEGIN_APPLICATION_CODE---
 */

static ClCharT        appname[80];  /* Component instance name               */
static ClUint32T      seq      = 0; /* Sequence number for print lines       */
static SaAmfHAStateT  ha_state; /* HA state           */

#define CKPT_NAME     "csa103Ckpt"  /* Checkpoint name for this application  */
static SaCkptHandleT  ckpt_svc_handle; /* Checkpointing service handle       */
static SaCkptCheckpointHandleT     ckpt_handle;  /* Checkpoint handle                     */
#define CKPT_SID_NAME "1"           /* Checkpoint section id                 */

static SaCkptSectionIdT ckpt_sid = { /* Section id for checkpoints           */
        (SaUint16T)sizeof(CKPT_SID_NAME)-1,
        (SaUint8T*)CKPT_SID_NAME
};
static ClRcT checkpoint_initialize(void);
static ClRcT checkpoint_finalize(void);
static ClRcT checkpoint_write_seq(ClUint32T);
static ClRcT checkpoint_read_seq(ClUint32T*);
static ClRcT checkpoint_replica_activate(void);

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

ClPidT mypid;
SaAmfHandleT amfHandle;
ClBoolT unblockNow = CL_FALSE;
ClLogStreamHandleT gEvalLogStream = CL_HANDLE_INVALID_VALUE;

/*
 * ---BEGIN_APPLICATION_CODE---
 */

/*
 * Declare other global variables here.
 */

static ClRcT csa103CkptTest(ClPtrT unused)
{
    ClRcT rc = CL_OK;

    clprintf(CL_LOG_SEV_INFO,"csa103: Instantiated as component instance %s.", appname);

    clprintf(CL_LOG_SEV_INFO,"%s: Waiting for CSI assignment...", appname);

    /* Main loop: Keep printing something unless we are suspended */
    if (ha_state != SA_AMF_HA_ACTIVE)
    {
        clprintf(CL_LOG_SEV_INFO,"%s: Waiting for CSI assignment...", appname);
    }
    if ((rc = checkpoint_initialize()) != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: Failed [0x%x] to initialize checkpoint",
                    appname, rc);
        return rc;
    }
    if ((rc = checkpoint_read_seq(&seq)) != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: Failed [0x%x] to read checkpoint",
                    appname, rc);
        checkpoint_finalize();
        return rc;
    }
#ifdef CL_INST
    if ((rc = clDataTapInit(DATA_TAP_DEFAULT_FLAGS, 103)) != CL_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: Failed [0x%x] to initialize data tap",
                    appname, rc);
    }
#endif
    while (!unblockNow)
    {
        if (ha_state == SA_AMF_HA_ACTIVE)
        {
            clprintf(CL_LOG_SEV_INFO,"%s: Hello World! (seq=%d)", appname, seq++);

#ifdef CL_INST
            if ((rc = clDataTapSend(seq)) != CL_OK && (rc != CL_ERR_INVALID_PARAMETER))
            {
                clprintf(CL_LOG_SEV_ERROR,"%s: Failed [0x%x] to send data tap data",
                        appname, rc);
            }
#endif
            
            /* Checkpoint new sequence number */
            rc = checkpoint_write_seq(seq);
            if (rc != CL_OK)
            {
                clprintf(CL_LOG_SEV_ERROR,"%s: ERROR: Checkpoint write failed. Exiting.", appname);
                // break;
            }
        }
        sleep(1);
    }
    return CL_OK;
}

static void csa103TestDispatcher(ClTaskPoolHandleT *pTestHandle)
{
    ClRcT rc = CL_OK;
    rc = clTaskPoolCreate(pTestHandle, 1, NULL, NULL);
    CL_ASSERT(rc == CL_OK);
    clTaskPoolRun(*pTestHandle, csa103CkptTest, NULL);
}

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/

/*
 * clCompAppInitialize
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

int main(int argc, char *argv[])
{
    SaNameT             appName;
    SaAmfCallbacksT     callbacks;
    SaVersionT          version;
    ClIocPortT          iocPort;
    ClRcT               rc = CL_OK;

    SaSelectionObjectT dispatch_fd;
    fd_set read_fds;
    ClTaskPoolHandleT testHandle = 0;

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * Declare other local variables here.
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the version of
     * AMF with which this application would like to interface. 'callbacks'
     * is used to register the callbacks this component expects to receive.
     */

    version.releaseCode                         = 'B';
    version.majorVersion                        = 01;
    version.minorVersion                        = 01;
    
    callbacks.saAmfHealthcheckCallback                    = NULL;
    callbacks.saAmfComponentTerminateCallback             = clCompAppTerminate;
    callbacks.saAmfCSISetCallback                         = clCompAppAMFCSISet;
    callbacks.saAmfCSIRemoveCallback                      = clCompAppAMFCSIRemove;
    callbacks.saAmfProtectionGroupTrackCallback           = NULL;
        
    if ( (rc = saAmfInitialize(&amfHandle, &callbacks, &version)) != SA_AIS_OK) 
        goto errorexit;

    FD_ZERO(&read_fds);

    /*
     * Get the AMF dispatch FD for the callbacks
     */
    if ( (rc = saAmfSelectionObjectGet(amfHandle, &dispatch_fd)) != SA_AIS_OK)
        goto errorexit;
    
    FD_SET(dispatch_fd, &read_fds);


    /*
     * Do the application specific initialization here.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    clprintf(CL_LOG_SEV_INFO,"csa103: Initializing and registering with AMF...");

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = saAmfComponentNameGet(amfHandle, &appName)) != SA_AIS_OK ) 
        goto errorexit;
    if ( (rc = saAmfComponentRegister(amfHandle, &appName, NULL)) != SA_AIS_OK ) 
        goto errorexit;

    /*
     * Get IOC Address
     */

    clEoMyEoIocPortGet(&iocPort);

    memset(appname, 0, sizeof(appname));
#define min(x,y) ((x) < (y) ? (x): (y))
    strncpy(appname, (const char *)appName.value, min(sizeof(appname)-1, appName.length));
    appname[min(sizeof appname - 1, appName.length)] = 0;

    /* Set up console redirection for demo purposes */
     clEvalAppLogStreamOpen(appname, &gEvalLogStream);
    /*
     * Print out standard information for this component.
     */

    clprintf(CL_LOG_SEV_INFO, "Component [%s] : PID [%ld]. Initializing", appname, mypid);
    clprintf(CL_LOG_SEV_INFO, "   IOC Address             : 0x%x", clIocLocalAddressGet());
    clprintf(CL_LOG_SEV_INFO, "   IOC Port                : 0x%x", iocPort);

    /*
     * This is where the application code starts. If the main thread usage
     * policy is CL_EO_USE_THREAD_FOR_APP, then return from this fn only 
     * after the application terminates. If the main thread usage policy is
     * CL_EO_USE_THREAD_FOR_RECV, then return from this fn after doing the
     * application specific initialization and registration. Main thread usage
     * policy can be set through IDE from Component porperty -> Eo properties.
     */
    
    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    csa103TestDispatcher(&testHandle);

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Block on AMF dispatch file descriptor for callbacks
     */
    do
    {
        if( select(dispatch_fd + 1, &read_fds, NULL, NULL, NULL) < 0)
        {
            if (EINTR == errno)
            {
                continue;
            }
		    clprintf (CL_LOG_SEV_ERROR, "Error in select()");
			perror("");
            break;
        }
        saAmfDispatch(amfHandle, SA_DISPATCH_ALL);
    }while(!unblockNow);      

    /*
     * Do the application specific finalization here.
     */
    clTaskPoolStop(testHandle);

    checkpoint_finalize();

    clEvalAppLogStreamClose(gEvalLogStream);
    
    if((rc = saAmfFinalize(amfHandle)) != SA_AIS_OK)
	{
        clprintf (CL_LOG_SEV_ERROR, "AMF finalization error[0x%X]", rc);
	}

    clprintf (CL_LOG_SEV_INFO, "AMF Finalized");

    return 0;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%ld]. Initialization error [0x%x]",
              appname, mypid, rc);

    return rc;
}

/*
 * clCompAppFinalize
 * -----------------
 * This function is invoked when the application is to be terminated.
 */

ClRcT clCompAppFinalize()
{
    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

void
clCompAppTerminate(
    SaInvocationT       invocation,
    const SaNameT       *compName)
{
    SaAisErrorT rc = SA_AIS_OK;

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%ld]. Terminating",
              compName->length, compName->value, mypid);

    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */

    /*
     * ---END_APPLICATION_CODE---
     */
    
    /*
     * Unregister with AMF and send back a response
     */

    if ( (rc = saAmfComponentUnregister(amfHandle, compName, NULL)) != SA_AIS_OK )
        goto errorexit;

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%ld]. Terminated", 
              compName->length, compName->value, mypid);

    unblockNow = CL_TRUE;

    return;

errorexit:

    clprintf (CL_LOG_SEV_ERROR, "Component [%s] : PID [%ld]. Termination error [0x%x]",
              compName->value, mypid, rc);

    return;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 *
 * WARNING: This function is deprecated, and may not be supported in the future.
 * Usage of this feature is discouraged.
 */

ClRcT
clCompAppStateChange(
    ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }

        case CL_EO_STATE_RESUME:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT
clCompAppHealthCheck(
    ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The defaults
     * indicate EO is healthy and polling interval is unaltered.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

void clCompAppAMFCSISet(SaInvocationT       invocation,
                        const SaNameT       *compName,
                        SaAmfHAStateT       haState,
                        SaAmfCSIDescriptorT csiDescriptor)
{
    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */
    ClCharT     compname[100]={0};

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Print information about the CSI Set
     */
    strncpy(compname, (const char*)compName->value, compName->length);

    clprintf (CL_LOG_SEV_INFO, "Component [%s] : PID [%ld]. CSI Set Received", 
              compname, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case SA_AMF_HA_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            clprintf(CL_LOG_SEV_INFO,"%s: Active state requested from state %d",
                        appname, ha_state);

            checkpoint_replica_activate();
            if (ha_state == SA_AMF_HA_STANDBY)
            {
                /* Read checkpoint, make our replica the active replica */
                clprintf(CL_LOG_SEV_INFO,"%s reading checkpoint", appname);
                checkpoint_read_seq(&seq);
                clprintf(CL_LOG_SEV_INFO,"%s read checkpoint: seq = %u", appname, seq);
            }
            
            ha_state = SA_AMF_HA_ACTIVE;


            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            clprintf(CL_LOG_SEV_INFO," Standby state requested from state %d",ha_state);
            
            ha_state = SA_AMF_HA_STANDBY;

            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            clprintf(CL_LOG_SEV_INFO,"%s: QUIESCED", appname);
            ha_state = haState;

            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfResponse(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        case SA_AMF_HA_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            clprintf(CL_LOG_SEV_INFO,"%s: QUIESCING", appname);
            ha_state = haState;

            /*
             * ---END_APPLICATION_CODE---
             */

            saAmfCSIQuiescingComplete(amfHandle, invocation, SA_AIS_OK);
            break;
        }

        default:
        {
            break;
        }
    }

    return;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

void clCompAppAMFCSIRemove(SaInvocationT  invocation,
                           const SaNameT  *compName,
                           const SaNameT  *csiName,
                           SaAmfCSIFlagsT csiFlags)
{
    /*
     * Print information about the CSI Remove
     */
    clprintf (CL_LOG_SEV_INFO, "Component [%.*s] : PID [%ld]. CSI Remove Received", 
              compName->length, compName->value, mypid);

    clprintf (CL_LOG_SEV_INFO, "   CSI                     : %.*s", csiName->length, csiName->value);
    clprintf (CL_LOG_SEV_INFO, "   CSI Flags               : 0x%x", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    saAmfResponse(amfHandle, invocation, SA_AIS_OK);

    return;
}

/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

void clCompAppAMFPrintCSI(SaAmfCSIDescriptorT csiDescriptor,
                          SaAmfHAStateT haState)
{
    clprintf (CL_LOG_SEV_INFO,
              "CSI Flags : [%s]",
              STRING_CSI_FLAGS(csiDescriptor.csiFlags));

    if (SA_AMF_CSI_TARGET_ALL != csiDescriptor.csiFlags)
    {
        clprintf (CL_LOG_SEV_INFO, "CSI Name : [%s]", 
                  csiDescriptor.csiName.value);
    }

    if (SA_AMF_CSI_ADD_ONE == csiDescriptor.csiFlags)
    {
        ClUint32T i = 0;
        
        clprintf (CL_LOG_SEV_INFO, "Name value pairs :");
        for (i = 0; i < csiDescriptor.csiAttr.number; i++)
        {
            clprintf (CL_LOG_SEV_INFO, "Name : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrName);
            clprintf (CL_LOG_SEV_INFO, "Value : [%s]",
                      csiDescriptor.csiAttr.
                      attr[i].attrValue);
        }
    }
    
    clprintf (CL_LOG_SEV_INFO, "HA state : [%s]",
              STRING_HA_STATE(haState));

    if (SA_AMF_HA_ACTIVE == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Active Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Transition Descriptor : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.transitionDescriptor);
        clprintf (CL_LOG_SEV_INFO,
                  "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  activeDescriptor.activeCompName.value);
    }
    else if (SA_AMF_HA_STANDBY == haState)
    {
        clprintf (CL_LOG_SEV_INFO, "Standby Descriptor :");
        clprintf (CL_LOG_SEV_INFO,
                  "Standby Rank : [%d]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.standbyRank);
        clprintf (CL_LOG_SEV_INFO, "Active Component : [%s]",
                  csiDescriptor.csiStateDescriptor.
                  standbyDescriptor.activeCompName.value);
    }
}

/*
 * ---BEGIN_APPLICATION_CODE---
 */

static ClRcT
checkpoint_initialize()
{
    SaAisErrorT      rc = CL_OK;
    SaVersionT ckpt_version = {'B', 1, 1};
    SaNameT    ckpt_name = { strlen(CKPT_NAME), CKPT_NAME };
    ClUint32T  seq_no;
    SaCkptCheckpointCreationAttributesT create_atts = {
        .creationFlags     = SA_CKPT_WR_ACTIVE_REPLICA_WEAK |
                             SA_CKPT_CHECKPOINT_COLLOCATED,
        .checkpointSize    = sizeof(ClUint32T),
        .retentionDuration = (ClTimeT)10, 
        .maxSections       = 2, // two sections 
        .maxSectionSize    = sizeof(ClUint32T),
        .maxSectionIdSize  = (ClSizeT)64
    };

    SaCkptSectionCreationAttributesT section_atts = {
        .sectionId = &ckpt_sid,
        .expirationTime = SA_TIME_END
    };
	  
    clprintf(CL_LOG_SEV_INFO,"%s: checkpoint_initialize", appname);
    /* Initialize checkpointing service instance */
    rc = saCkptInitialize(&ckpt_svc_handle,	/* Checkpoint service handle */
						  NULL,			    /* Optional callbacks table */
						  &ckpt_version);   /* Required verison number */
    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: ERROR: Failed to initialize checkpoint service with rc [%#x]",
                 appname, rc);
        return rc;
    }
    clprintf(CL_LOG_SEV_INFO,"%s: Checkpoint service initialized (handle=0x%llx)",
           appname, ckpt_svc_handle);
    
    //
    // Create the checkpoint for read and write.
    rc = saCkptCheckpointOpen(ckpt_svc_handle,      // Service handle
                              &ckpt_name,         // Checkpoint name
                              &create_atts,       // Optional creation attr.
                              (SA_CKPT_CHECKPOINT_READ |
                               SA_CKPT_CHECKPOINT_WRITE |
                               SA_CKPT_CHECKPOINT_CREATE),
                              (SaTimeT)-1,        // No timeout
                              &ckpt_handle);      // Checkpoint handle

    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: ERROR: Failed [0x%x] to open checkpoint",
                    appname, rc);
        (void)saCkptFinalize(ckpt_svc_handle);
        return rc;
    }
    clprintf(CL_LOG_SEV_INFO,"%s: Checkpoint opened (handle=0x%llx)", appname, ckpt_handle);
    
    /*
     * Try to create a section so that updates can operate by overwriting
     * the section over and over again.
     * If subsequent processes come through here, they will fail to create
     * the section.  That is OK, even though it will cause an error message
     * If the section create fails because the section is already there, then
     * read the sequence number
     */
    // Put data in network byte order
    seq_no = htonl(seq);

    // Creating the section
    checkpoint_replica_activate();
    rc = saCkptSectionCreate(ckpt_handle,           // Checkpoint handle
                             &section_atts,         // Section attributes
                             (SaUint8T*)&seq_no,    // Initial data
                             (SaSizeT)sizeof(seq_no)); // Size of data
    if (rc != SA_AIS_OK && (CL_GET_ERROR_CODE(rc) != SA_AIS_ERR_EXIST))
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: ERROR: Failed to create checkpoint section", appname);
        (void)saCkptCheckpointClose(ckpt_handle);
        (void)saCkptFinalize(ckpt_svc_handle);
        return rc;
    }
    else if (rc != SA_AIS_OK && (CL_GET_ERROR_CODE(rc) == SA_AIS_ERR_EXIST))
    {
        rc = checkpoint_read_seq(&seq);
        if (rc != CL_OK)
        {
            clprintf(CL_LOG_SEV_ERROR,"%s: ERROR: Failed [0x%x] to read checkpoint section",
                        appname, rc);
            (void)saCkptCheckpointClose(ckpt_handle);
            (void)saCkptFinalize(ckpt_svc_handle);
            return rc;
        }
    }
    else
    {
        clprintf(CL_LOG_SEV_INFO,"%s: Section created", appname);
    }

    return CL_OK;
}

static ClRcT 
checkpoint_finalize(void)
{
    SaAisErrorT rc;

    rc = saCkptCheckpointClose(ckpt_handle);
    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: failed: [0x%x] to close checkpoint handle 0x%llx",
                    appname, rc, ckpt_handle);
    }
    rc = saCkptFinalize(ckpt_svc_handle);
    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"%s: failed: [0x%x] to finalize checkpoint",
                    appname, rc);
    }
    return CL_OK;
}

static ClRcT
checkpoint_write_seq(ClUint32T seq)
{
    SaAisErrorT rc = SA_AIS_OK;
    ClUint32T seq_no;
    
    /* Putting data in network byte order */
    seq_no = htonl(seq);
    
    /* Write checkpoint */
    retry:
    rc = saCkptSectionOverwrite(ckpt_handle,
                                &ckpt_sid,
                                &seq_no,
                                sizeof(ClUint32T));
    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"Failed [0x%x] to write to section", rc);
        if(rc == SA_AIS_ERR_NOT_EXIST)
            rc = checkpoint_replica_activate();
        if(rc == CL_OK) goto retry;
    }
    else 
    {
        /*
         * Synchronize the checkpoint to all the replicas.
         */
        rc = saCkptCheckpointSynchronize(ckpt_handle, SA_TIME_END );
        if (rc != SA_AIS_OK)
        {
            clprintf(CL_LOG_SEV_ERROR,"Failed [0x%x] to synchronize the checkpoint", rc);
        }
    }

    return CL_OK;
}

static ClRcT
checkpoint_read_seq(ClUint32T *seq)
{
    ClRcT rc = CL_OK;
    ClUint32T err_idx; /* Error index in ioVector */
    ClUint32T seq_no = 0xffffffff;
    SaCkptIOVectorElementT iov = {
        .sectionId  = ckpt_sid,
        .dataBuffer = (ClPtrT)&seq_no,
        .dataSize   = sizeof(ClUint32T),
        .dataOffset = (ClOffsetT)0,
        .readSize   = sizeof(ClUint32T)
    };
        
    rc = saCkptCheckpointRead(ckpt_handle, &iov, 1, &err_idx);
    if (rc != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,"Error: [0x%x] from checkpoint read, err_idx = %u",
                    rc, err_idx);
    }

    /* FIXME: How to process this err_idx? */
    *seq = ntohl(seq_no);
    
    return CL_OK;
}

static ClRcT
checkpoint_replica_activate(void)
{
    SaAisErrorT rc = SA_AIS_OK;

    if ((rc = saCkptActiveReplicaSet(ckpt_handle)) != SA_AIS_OK)
    {
        clprintf(CL_LOG_SEV_ERROR,
                "checkpoint_replica_activate failed [0x%x] in ActiveReplicaSet",
                rc);
    }
    else rc = CL_OK;

    return rc;
}

/*
 * ---END_APPLICATION_CODE---
 */
