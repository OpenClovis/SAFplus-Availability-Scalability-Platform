#! /usr/bin/env python
################################################################################
#
#   Copyright (C) 2002-2009 by OpenClovis Inc. All Rights  Reserved.
# 
# The source code for  this program is not published  or otherwise 
# divested of  its trade secrets, irrespective  of  what  has been 
# deposited with the U.S. Copyright office.
# 
# This program is  free software; you can redistribute it and / or
# modify  it under  the  terms  of  the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the  hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
# 
# You  should  have  received  a  copy of  the  GNU General Public
# License along  with  this program. If  not,  write  to  the 
# Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
################################################################################
#
# Build: 4.2.0
#
################################################################################
# ModuleName  : idl
# File        : clIdlGen.py
################################################################################
# Description : Generates client and server side stubs for making
#               RMD calls.
################################################################################

'''
The working of the IDL script:

* Parse the XML document using minidom library and create a tree out
  of it. This tree has multiple levels at which relevant information
  is stored.

* Descend the various levels and at every level, consume information
  and generate code for it. At every higher level, the code generated
  by the lower level is substituted in templates to generate bigger
  constructs. At the highest level the code files are generated.

* This script uses dictionary and template mechanisms of python
  extensively to achieve the above.
'''

import sys
import os
import re
import fnmatch
import xml.dom.minidom
from string import Template

# Global variables

idl_version = '4.0.0'
options = None

# Templates -- begin

# Templates for generating Makefile related stuff -- begin

make_license= r"""###############################################################################
#
# Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
# 
# The source code for  this program is not published  or otherwise 
# divested of  its trade secrets, irrespective  of  what  has been 
# deposited with the U.S. Copyright office.
# 
# This program is  free software; you can redistribute it and / or
# modify  it under  the  terms  of  the GNU General Public License
# version 2 as published by the Free Software Foundation.
# 
# This program is distributed in the  hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
# General Public License for more details.
# 
# You  should  have  received  a  copy of  the  GNU General Public
# License along  with  this program. If  not,  write  to  the 
# Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################"""

# Makefile for all idl
idlMakeT = Template("""${license}

                                                                                                                             
##############################################################################
#
#
# This Makefile is auto-generated by OpenClovis IDE
# Makefile for components
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
# Date: ${DateTime}
# User: ${User}
#
################################################################################
# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server
SUBDIRS          = ${eo_list} 
#
# If you have any ordering dependence among subdirectories, list them as
# target-prerequisite pairs.
#
include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
                                                                                                                             
""")


# Template for top level Makefile.
topLevelMakeT = Template('''${license}
################################################################################
#
# Makefile for idl client library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = xdr client server

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')

topXdrMakeT = Template('''${license}
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#       - CLOVIS_ROOT environment variable is specified properly
#       - Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Subdirectories having Makefiles and need recursive escalation:
# common should always be before client and server

SUBDIRS          = xdr

include $(CLOVIS_ROOT)/ASP/mk/make-subdir.mk
''')

# Template for client and server Makefiles.
clientMakeT = Template('''${license}
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${eo_name}

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c) 

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${cap_eo_name}${lib_type}
CPPFLAGS    = -I ../xdr/ -I ../common/

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

# Template for xdr Makefile.
xdrMakeT = Template('''${license}
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${cap_comp}xdr 

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp}

# Library name:

LIB_NAMES	= libCl${cap_comp}Xdr

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

xdrOpenMakeT = Template('''${license}
################################################################################
#
# Makefile for tmpcomp component client library
#
# This Makefile assumes the following:
#	- CLOVIS_ROOT environment variable is specified properly
#	- Entire source tree under $(CLOVIS_ROOT)/ASP is checked out
#
################################################################################

# Component name (using all lowercase):\

COMPNAME	:= ${eo_name} 

# List local source files needed for the component server:

SRC_FILES	:= $(wildcard *.c)

# List other ASP components of which client libraries your component
# depends on:

DEP_COMP_LIST	:= utils osal timer buffer ioc cnt eo debug rmd idl name ${comp} 

# Library name:

LIB_NAMES	= libCl${cap_eo_name}${lib_type}

include $(CLOVIS_ROOT)/ASP/mk/make-client.mk
''')

# Templates for generating Makefile related stuff -- end

freeFileT = Template('''${license}
/*********************************************************************
* ModuleName  : idl
* File        : clIdlOpen.c
*********************************************************************/
/*********************************************************************
* Description : This file contains IDL related open functions.
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE.
*     
*********************************************************************/
#include <clCommonErrors.h>
#include <clOsalApi.h>
#include <clDebugApi.h>
#include <clXdrApi.h>
/*********************************************************************
 * Description: This function is used for freeing the server side
 *              memory allocated by server when called from IDL. The
 *              memory free mechanism used should be the same as used
 *              while allocating the memory. By default, clHeapFree is
 *              used, which should be replaced by user specific "free"
 *              function.
*********************************************************************/

ClRcT clIdlFree(void *pData)
{
    CL_DEBUG_PRINT(CL_DEBUG_WARN,("Warning! clIdlFree in file %s "
        "uses clHeapFree for freeing memory allocated by server "
        "function.\\n", __FILE__));
    clHeapFree(pData);
    return CL_OK;    
}
''')

pointerLengthWriteT = Template('''
    temp1 = htonl(${length_var});
    rc = clBufferNBytesWrite(${in_msg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        return rc;
    }
''')

pointerLengthReadT = Template('''
    temp2 = sizeof(ClUint32T);
    rc = clBufferNBytesRead(${out_msg}, (ClUint8T*)&temp1, &temp2);
    if (rc != CL_OK)
    {
        return rc;
    }
''')

# Template to marshall IN parameters.
inSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${member_func_type}(${marshall_entry}, ${in_msg}, 0);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

# Template to marshall INOUT parameters.
inoutSyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${member_func_type}(${marshall_entry}, ${in_msg}, 1);
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

# Template to unmarshall OUT parameters.
outSyncClientUnmarshallT = Template('''
    rc = clXdrUnmarshall${member_func_type}( ${out_msg}, ${unmarshall_entry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

createOutMsgT = Template('''
    ${rc} = clBufferCreate(&${out_msg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
''')

createInMsgT = Template('''

    ${rc} = clBufferCreate(&${in_msg});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')

deleteOutMsgT = Template('''\
clBufferDelete(&${out_msg});
    ''')

# Template for generating sync client stub.
syncClientT = Template('''
ClRcT ${name}ClientSync${version}(CL_IN ClIdlHandleT handle${decl})
{
    ClRcT rc = CL_OK;
    ClVersionT funcVer = {${rel}, ${major}, ${minor}};
    ClUint32T funcNo = ${func_no};
    ClBufferHandleT ${in_msg} = 0;
    ClBufferHandleT ${out_msg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClUint32T tempFlags = 0;

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if( rc != CL_OK )
    {
        return rc ;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            return rc;
        }
    }
    else
    {
        return CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
    }${create_in_msg}
${marshall_list}
${create_out_msg}
    tempFlags |= pHandleObj->flags |
                 (CL_RMD_CALL_NON_PERSISTENT${flag_need_reply});
    tempFlags &= ~CL_RMD_CALL_ASYNC;

    rc = clRmdWithMsgVer(address, &funcVer, funcNo, ${in_msg}, ${out_msg}, tempFlags, &(pHandleObj->options), NULL);
    if(CL_OK != rc)
    {
        ${delete_out_msg}return rc;
    }

${unmarshall_list}
    ${delete_out_msg}
    rc = clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;
}
''')

syncHeaderT = Template('''
ClRcT ${name}ClientSync${version}(CL_IN ClIdlHandleT handle${decl});
''')

asyncCreateOutMsgT = Template('''
        ${rc} = clBufferCreate(&${out_msg});
        if (CL_OK != ${rc})
        {
            goto L2;
        }
''')

asyncCreateInMsgT = Template('''

    ${rc} = clBufferCreate(&${in_msg});
    if (CL_OK != ${rc})
    {
        goto L;
    }''')

inAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${call_member_func_type}(${call_marshall_entry}, ${in_msg}, 0);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inoutAsyncClientMarshallT = Template('''
    ${rc} = clXdrMarshall${call_member_func_type}(${call_marshall_entry}, ${in_msg}, 1);
    if (CL_OK != ${rc})
    {
        goto L;
    }
''')

inAsyncUnmarshallT = Template('''
    retVal = clXdrUnmarshall${cb_member_func_type}(${in_msg}, ${cb_unmarshall_entry});
    if (CL_OK != retVal)
    {
        goto L${arg_num};
    }
''')

outAsyncUnmarshallT = Template('''
    if (CL_OK == rc)
    {
        retVal = clXdrUnmarshall${cb_member_func_type}(${out_msg}, ${cb_unmarshall_entry});
        if (CL_OK != retVal)
        {
            goto L${arg_num};
        }
    }
''')

asyncUnmarshallErrorEntryT = Template('''\
L${arg_num_plus_one}: 
''')

asyncPointerLengthWriteT = Template('''
    temp1 = htonl(${length_var});
    rc = clBufferNBytesWrite(${in_msg}, (ClUint8T*)&temp1, sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        goto L;
    }
''')

# Template for generating async client stub.
asyncClientT = Template('''
${async_callback}

ClRcT ${name}ClientAsync${version}(CL_IN ClIdlHandleT handle${call_decl}${cookie_callback})
{
    ClRcT rc = CL_OK;
    ClVersionT funcVer = {${rel}, ${major}, ${minor}};
    ClUint32T funcNo = ${func_no};
    ClBufferHandleT ${in_msg} = 0;
    ClBufferHandleT ${out_msg} = 0;
    ClIocAddressT address = {{0}};
    ClIdlHandleObjT* pHandleObj = NULL;
    ClRmdAsyncOptionsT asyncOptions;
    ClUint32T tempFlags = 0;
    ClIdlCookieT* pCookie = NULL;

    rc = clHandleCheckout(gIdlClnt.idlDbHdl,handle,(void **)&pHandleObj);
    if(rc != CL_OK)
    {
        return rc;
    }
    if (CL_IDL_ADDRESSTYPE_IOC == pHandleObj->address.addressType)
    {
        address = pHandleObj->address.address.iocAddress;
    }
    else if (CL_IDL_ADDRESSTYPE_NAME == pHandleObj->address.addressType)
    {
        rc = clNameToObjectReferenceGet(&(pHandleObj->address.address.nameAddress.name),
                                        pHandleObj->address.address.nameAddress.attrCount,
                                        pHandleObj->address.address.nameAddress.attr,
                                        pHandleObj->address.address.nameAddress.contextCookie,
                                        (ClUint64T*)&address);
        if (CL_OK != rc)
        {
            goto L;
        }
    }
    else
    {
        rc = CL_IDL_RC(CL_ERR_INVALID_PARAMETER);
        goto L;
    }${create_in_msg}
${call_marshall_list}
    if(fpAsyncCallback != NULL)
    {
        ${rmd_cookie}
        
        asyncOptions.pCookie = NULL;
        asyncOptions.fpCallback = NULL;
        ${create_out_msg}
        tempFlags |= pHandleObj->flags |
                     (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT${flag_need_reply});
        ${async_options_fill}
        rc = clRmdWithMsgVer(address, &funcVer, funcNo, ${in_msg}, ${out_msg}, tempFlags, &(pHandleObj->options), &asyncOptions);
        if (CL_OK != rc)
        {
            goto ${error_label};
         }
    }
    else
    {
        tempFlags |= pHandleObj->flags |
                         (CL_RMD_CALL_ASYNC | CL_RMD_CALL_NON_PERSISTENT);
        rc = clRmdWithMsgVer(address, &funcVer, funcNo, ${in_msg}, 0, tempFlags, &(pHandleObj->options),NULL);
        if(CL_OK != rc)
        {
               goto L;
        }
    }
    
${return}
}

''')

# Template for generating async callback.
asyncCallbackT = Template('''
static void ${name}AsyncCallback${version}(ClRcT rc, void *pIdlCookie, ClBufferHandleT ${in_msg}, ClBufferHandleT ${out_msg})
{
    ClIdlCookieT* pCookie = (ClIdlCookieT*)pIdlCookie;
    ClRcT retVal = CL_OK;
${cb_decl}
${cb_memset}
${cb_unmarshall_list}
    if (rc != CL_OK)
    {
        retVal = rc;
    }

    ((${eo_name}${cap_name}AsyncCallbackT${version})(pCookie->actualCallback))(pCookie->handle, ${arg_list}retVal, pCookie->pCookie);
    goto L${arg_num};

${cb_error_marshall_list}
L0:  clHeapFree(pCookie);
     clBufferDelete(&${out_msg});
     return;
}
''')

# This template is for the snippet that creates the rmd cookie from
# IDL user's cookie and callback.
asyncOptionsFillT = Template('''
        pCookie->pCookie = cookie;
        pCookie->actualCallback = (void(*)())fpAsyncCallback;
        pCookie->handle = handle;
        asyncOptions.pCookie = pCookie;
        asyncOptions.fpCallback = ${name}AsyncCallback${version};
''')

asyncHeaderT = Template('''
${async_callback_def}ClRcT ${name}ClientAsync${version}(CL_IN ClIdlHandleT handle${call_decl}${cookie_callback});
''')

dblPtrAsyncAllocateT = Template('''
    ${name} = (${type}*)clHeapAllocate(sizeof(${type}) * (${length_var}));
    if (NULL == ${name})
    {
        return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
''')
dblPtrAllocateT = Template('''
    *${name} = (${type}*)clHeapAllocate(sizeof(${type}) * (*${length_var}));
    if (NULL == *${name})
    {
        return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
''')

# Template to create function that installs server stubs to EO.
clientInstallT = Template('''
    ${rc} = clEoClientInstall(${pEoObj}, ${client_id}, ${client}, 0, (sizeof(${client})/sizeof(${client}[0])));
    if (CL_OK != ${rc})
    {
        return ${rc};
    }''')

# Template to create function that uninstalls server stubs from EO.
clientUninstallT = Template('''
    clEoClientUninstall(${pEoObj}, ${client_id});''');

# Template for the data structure that is passed to the functions
# above.
clientDefinitionT = Template('''
static ClEoPayloadWithReplyCallbackT ${eo}Client${Num}[] = {
${service_install_list}
};
''')

# Template for user defined data type member definition code.
memberT = Template('''\
    ${hdr_type}    ${name};
''')

memberT_comment = Template('''\
    ${hdr_type}    ${name}; ${comment}
''')

# Template for user defined data type member marshall code.
marshallStructMemberT = Template('''
    rc = clXdrMarshall${member_dt}(${marshall_entry},msg,isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }
''')

# Template for user defined data type member unmarshall code.
unmarshallStructMemberT = Template('''
    rc = clXdrUnmarshall${member_dt}(msg,${unmarshall_entry});
    if (CL_OK != rc)
    {
        return rc;
    }
''')

# Template for user defined structure definition code.
structMemberDefnT = Template('''
typedef struct _${type} {
${member_list}
}${type};
''')

license = r"""/*
 * Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office.
 * 
 * This program is  free software; you can redistribute it and / or
 * modify  it under  the  terms  of  the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You  should  have  received  a  copy of  the  GNU General Public
 * License along  with  this program. If  not,  write  to  the 
 * Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
"""

xdrHeaderT_version = Template('''\
struct _${type};
${udt_defn}

ClRcT  clXdrMarshall${type}(void *,ClBufferHandleT , ClUint32T);

ClRcT  clXdrUnmarshall${type}(ClBufferHandleT, void *);

#define clXdrMarshallArray${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallArray((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallArray${type}(msg,pointer, multiplicity) \\
clXdrUnmarshallArray((msg),(pointer), sizeof(${type}), (multiplicity), clXdrUnmarshall${type})

#define clXdrMarshallPointer${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallPointer((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallPointer${type}(msg,pointer) \\
clXdrUnmarshallPointer((msg),(pointer), sizeof(${type}), clXdrUnmarshall${type})

#define clXdrMarshallPtr${type}(pointer, multiplicity, msg, isDelete) \\
clXdrMarshallPtr((pointer), sizeof(${type}), (multiplicity), clXdrMarshall${type}, (msg), (isDelete))

#define clXdrUnmarshallPtr${type}(msg,pointer,multiplicity) \\
clXdrUnmarshallPtr((msg),(pointer), sizeof(${type}),multiplicity, clXdrUnmarshall${type})


''')

xdrHeaderT_backward_compat = Template('''\
typedef ${one} ${two};
''')

# Template for xdr header file
xdrHeaderT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the declarations for marshall 
*               and unmarshall funtions of ${type} 
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "clXdrApi.h"

${include_list}

''')

xdrMarshallStructCodeT_version = Template('''\
ClRcT clXdrMarshall${type}(void* pGenVar, ClBufferHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc         = CL_OK;
    ClUint32T length = 0;    

    if ((void*)0 == pVar)
    {
        clXdrMarshallClUint32T(&length, msg, 0);
    }
    else
    {
        length = 1;
        clXdrMarshallClUint32T(&length, msg, 0);
${marshalled_member_list}
    }

    return rc;
}


''')

xdrMarshallStructCodeT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Marshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#include "xdr${type1}.h"

''')

xdrUnMarshallStructCodeT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Unmarshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include "xdr${type1}.h"

''')

xdrUnMarshallStructCodeT_version = Template('''\
ClRcT clXdrUnmarshall${type}(ClBufferHandleT msg , void* pGenVar)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT     rc     = CL_OK;
    ClUint32T length = 0;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    clXdrUnmarshallClUint32T(msg, &length);
    if( 0 == length)
    {
        pGenVar = NULL;
    }
    else
    {
${unmarshalled_member_list}
    }

    return rc;
}


''')

xdrHeaderT_postamble = Template('''
#ifdef __cplusplus
}
#endif

#endif /*_XDR_${TYPE}_H_*/
''')

# Union member marshalling code snippet.
marshallUnionMemberT = Template('''
        case (ClInt32T)${discriminant}:
            rc = clXdrMarshall${member_dt}(${marshall_entry}, msg, isDelete);
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

# Union member unmarshalling code snippet.
unmarshallUnionMemberT = Template('''
        case (ClInt32T)${discriminant}:
            rc = clXdrUnmarshall${member_dt}(msg,${unmarshall_entry});
            if (CL_OK != rc)
            {
                return rc;
            }
        break;
''')

# Template for defining the union.
unionMemberDefnT = Template('''
typedef enum _${union_enum_type}
{
${enum_member_list}
} ${union_enum_type};

typedef struct _${type}
{
    ${union_enum_type} discriminant;
    union
    {
${member_list}
    }${union_name};
}${type};
''')

xdrMarshallUnionCodeT_version = Template('''\
ClRcT clXdrMarshall${type}(void *pGenVar,ClBufferHandleT msg, ClUint32T isDelete)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;
    ClUint32T length = 0;

    if ((void*)0 == pVar)
    {
        clXdrMarshallClUint32T(&length, msg, 0);
    }
    else
    {
        length = 1;
        clXdrMarshallClUint32T(&length, msg, 0);
    rc = clXdrMarshallClInt32T(&(pVar->discriminant),msg, isDelete);
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
${marshalled_member_list}
        default:
            return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }
    }

    return rc;
}


''')

xdrMarshallUnionCodeT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Marshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
                                  
#include <netinet/in.h>
#include "xdr${type1}.h"

''')

xdrUnMarshallUnionCodeT_version = Template('''\
ClRcT clXdrUnmarshall${type}(ClBufferHandleT msg , void *pGenVar)
{
    ${type}* pVar = (${type}*)pGenVar;
    ClRcT rc = CL_OK;
    ClUint32T  length = 0;

    if ((void*)0 == pVar)
    {
        return CL_XDR_RC(CL_ERR_NULL_POINTER);
    }

    if (0 == msg)
    {
        return CL_XDR_RC(CL_ERR_INVALID_BUFFER);
    }

    clXdrUnmarshallClUint32T(msg, &length);
    if( 0 == length)
    {
        pGenVar = NULL;
    }
    else
    {
    rc = clXdrUnmarshallClInt32T(msg,&(pVar->discriminant));
    if (CL_OK != rc)
    {
        return rc;
    }

    switch (pVar->discriminant)
    {
${unmarshalled_member_list}
        default:
            return CL_XDR_RC(CL_ERR_INVALID_STATE);
    }
    }

    return rc;
}


''')

xdrUnMarshallUnionCodeT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Unmarshall routine for ${type}
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
                                 
#include <netinet/in.h>        
#include "xdr${type1}.h"

''')

# Template for enum definition.
enumDefnT = Template('''
typedef enum _${type}
{
${member_list}
} ${type};
''')

xdrEnumHeaderT_backward_compat = xdrHeaderT_backward_compat

xdrEnumHeaderT_version = Template('''\
${udt_defn}

#define      clXdrMarshall${type}               clXdrMarshallClInt32T

#define      clXdrUnmarshall${type}             clXdrUnmarshallClInt32T

#define      clXdrMarshallArray${type}          clXdrMarshallArrayClInt32T

#define      clXdrUnmarshallArray${type}        clXdrUnmarshallArrayClInt32T

#define      clXdrMarshallPointer${type}        clXdrMarshallPointerClInt32T

#define      clXdrUnmarshallPointer${type}      clXdrUnmarshallPointerClInt32T

#define      clXdrMarshallPtr${type}            clXdrMarshallPtrClInt32T

#define      clXdrUnmarshallPtr${type}          clXdrUnmarshallPtrClInt32T

''')

# Template for xdr header for enum.
xdrEnumHeaderT = Template('''${license}

/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the declarations for marshall 
*               and unmarshall funtions of ${type} 
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _XDR_${TYPE}_H_
#define _XDR_${TYPE}_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "clXdrApi.h"
${include_list}

${xdrEnumHeaderT_version}

''')

# Template for xdr header.
clientIDHeader = Template('''${license}

#ifndef _CLIENTID_H_
#define _CLIENTID_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <clEoApi.h>

${client_ids}

#ifdef __cplusplus
}
#endif

#endif /*_CLIENTID_H_*/

''')

clientIDHeaderT = Template('''
#define ${clientId} (CL_EO_USER_CLIENT_ID_START + ${number})
''')

# Template for server side C file.
serverCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "${eo_name}${client}${group}Server.h"
#include "${eo_name}Server.h"

extern ClUint32T  ${eo_name}idlSyncKey;
extern ClHandleDatabaseHandleT  ${eo_name}idlDatabaseHdl;


${server_func_list}
''')

# Template for server side C file containing functions that need to be
# implemented by the user.
userCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : Server Stub routines that need to be implemented
*               by the user.
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#include "${eo_name}${client}${group}Server.h"

${user_func_list}
''')

# Template to create server header.
serverHFileT = Template('''
/*********************************************************************
* File: 
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for server stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _${Service1}${CLIENT}${GROUP}_SERVER_H_
#define _${Service1}${CLIENT}${GROUP}_SERVER_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include <ipi/clRmdIpi.h>
#include "../clientIDDefinitions.h"
${xdr_inc_list}

${server_decls}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}${CLIENT}${GROUP}_SERVER_H_*/
''')

# Template to create client C file.
clientCFileT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :ClientSide Stub routines
*
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*
*********************************************************************/

#include <netinet/in.h>
#include <string.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clIdlApi.h>
#include <clEoApi.h>
#include <clXdrApi.h>
#include <clHandleApi.h>
#include "${eo_name}${client}${group}Client.h"
extern ClIdlClntT gIdlClnt;

${sync_client_list}
''')

# Template to create client header.
clientHFileT = Template('''
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for client stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#ifndef _${Service1}_${CLIENT}_${GROUP}_CLIENT_H_
#define _${Service1}_${CLIENT}_${GROUP}_CLIENT_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include "../clientIDDefinitions.h"
${xdr_inc_list}

${sync_client_decl}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}_${CLIENT}_${GROUP}_CLIENT_H_*/
''')

commServerCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#undef __CLIENT__
#define __SERVER__

#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "${eo_name}${client}${group}Server.h"
#include "${eo_name}Server.h"
#include "${eo_name}FuncTable.h"

ClHandleDatabaseHandleT  ${eo_name}idlDatabaseHdl = 0;
ClUint32T                ${eo_name}idlSyncKey     = 0;

ClRcT cl${eo}IdlSyncDefer(ClIdlHandleT *pIdlHdl)
{
    return clIdlSyncDefer(${eo_name}idlDatabaseHdl, ${eo_name}idlSyncKey, pIdlHdl);
}    
    
ClRcT cl${eo}ClientInstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }

    rc = clEoClientInstallTables(${pEoObj},CL_EO_SERVER_SYM_MOD(gAspFuncTable,${eo}));
    if (CL_OK != rc)
    {
        return rc;
    }
    
    rc = clOsalTaskKeyCreate(&${eo_name}idlSyncKey,NULL);
    if (CL_OK != rc)
    {
        return rc;
    }

    rc = clHandleDatabaseCreate(NULL,&${eo_name}idlDatabaseHdl);

    return ${rc};
}

ClRcT cl${eo}ClientUninstall(void)
{
    ClEoExecutionObjT* ${pEoObj} = NULL;
    ClRcT ${rc} = CL_OK;

    ${rc} = clEoMyEoObjectGet(&${pEoObj});
    if (CL_OK != ${rc})
    {
        return ${rc};
    }
    rc = clOsalTaskKeyDelete(${eo_name}idlSyncKey);
    if (CL_OK != rc)
    {
        return rc;
    }
    rc = clHandleDatabaseDestroy(${eo_name}idlDatabaseHdl);
    if (CL_OK != rc)
    {
        return rc;
    }

    clEoClientUninstallTables(${pEoObj},CL_EO_SERVER_SYM_MOD(gAspFuncTable,${eo}));

    return ${rc};
}

    
''')

commServerHFileT = Template('''\
/*********************************************************************
* File: 
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for server stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _${Service1}_SERVER_H_
#define _${Service1}_SERVER_H_
#ifdef __cplusplus
extern "C" {
#endif
#include <clXdrApi.h>
#include <clIdlApi.h>
#include <ipi/clRmdIpi.h>
#include "../clientIDDefinitions.h"
${xdr_inc_list}


ClRcT cl${eo}IdlSyncDefer(ClIdlHandleT *pIdlHdl);
        
ClRcT cl${eo}ClientInstall(void);

ClRcT cl${eo}ClientUninstall(void);

${service_decl_list}

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}_SERVER_H_*/
''')

commClientCFileT = Template('''\
/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Client Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#undef __SERVER__
#define __CLIENT__

#include "${eo_name}Client.h"
#include "${eo_name}FuncTable.h"

ClRcT cl${eo}ClientTableRegister(ClIocPortT clientPort)
{
    ClRcT rc = CL_OK;

    rc = clEoClientTableRegister(CL_EO_CLIENT_SYM_MOD(gAspFuncTable, ${eo}),
                                 clientPort);
    if (CL_OK != rc)
    {
        return rc;
    }

    return rc;
}

ClRcT cl${eo}ClientTableDeregister(void)
{
    return CL_OK;
}

''')

commClientHFileT = Template('''\
/*********************************************************************
* File: 
*********************************************************************/
/*********************************************************************
* Description : This file contains the declartions for client stub
*               routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/

#ifndef _${Service1}_CLIENT_H_
#define _${Service1}_CLIENT_H_
#ifdef __cplusplus
extern "C" {
#endif

#include <clCommon.h>
#include <clIocApi.h>

ClRcT cl${eo}ClientTableRegister(ClIocPortT clientPort);

ClRcT cl${eo}ClientTableDeregister(void);

#ifdef __cplusplus
}
#endif
#endif /*_${Service1}_CLIENT_H_*/
''')

eoCallbackTableT = Template('''
CL_EO_CALLBACK_TABLE_DECL(g${eo}FuncList)[] =
{
${eo_callback_func_list}
};

CL_EO_CALLBACK_TABLE_LIST_DECL(gAspFuncTable, ${eo}) [] =
{
    CL_EO_CALLBACK_TABLE_LIST_DEF(${client_id}, g${eo}FuncList),
    CL_EO_CALLBACK_TABLE_LIST_DEF_NULL,
};
''')

eoFuncTableHFileT = Template('''\
#ifndef _${eo}_FUNC_TABLE_H_
#define _${eo}_FUNC_TABLE_H_

#if !defined (__SERVER__) && !defined (__CLIENT__)
#error "This file should be included from server or client. Define __SERVER__ or __CLIENT__ if you are server or client and then recompile"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <clEoApi.h>

${eo_callback_table_decl}

#ifdef __cplusplus
}
#endif
#endif /*_${eo}_FUNC_TABLE_H_*/
''')

# ----------------------------------------------------------------

serverHeaderT = Template('''
ClRcT ${name}${version}(${func_decl});

ClRcT ${name}ResponseSend${version}(CL_IN ClIdlHandleT idlHdl,CL_IN ClRcT retCode${out_func_decl});
''')

ptrAllocateT = Template('''
    ${name} = (${type}*)clHeapAllocate(sizeof(${type}) * ${length_var});
    if (NULL == ${name})
    {
        goto LL${arg_num};
    }
''')

# Error code snippet if error encountered during unmarshall.
unmarshallErrorEntryT = Template('''\
LL${arg_num}:  clXdrMarshall${member_func_type}(${marshall_entry}, 0, 1);
''')

# Error code snippet if error encountered during marshall.
marshallErrorEntryT = Template('''\
L${arg_num}:  clXdrMarshall${member_func_type}(${marshall_entry}, 0, 1);
''')

# Server unmarshalling snippet.
inServerUnmarshallT = Template('''
    ${rc} = clXdrUnmarshall${member_func_type}( ${in_msg},${unmarshall_entry});
    if (CL_OK != ${rc})
    {
        goto LL${arg_num};
    }
''')

# Server marshalling snippet.
inServerMarshallT = Template('''
    ${rc} = clXdrMarshall${member_func_type}(${marshall_entry}, ${out_msg}, ${is_delete});
    if (CL_OK != ${rc})
    {
        goto L${arg_num_plus_one};
    }
''')

unmarshallDblPtrErrorEntryT = Template('''\
''')

# Dummy template for double pointer.
inServerDblPtrUnmarshallT = Template('''
''')

marshallErrorNumEntryT = Template('''\
L${arg_err_num}:  clXdrMarshall${member_func_type}(${marshall_entry}, 0, 1);
''')

inArgServerMarshalT = Template('''
    ${rc} = clXdrMarshall${member_func_type}(${marshall_entry}, ${out_msg}, ${is_delete});
    if (CL_OK != ${rc})
    {
        goto L${arg_err_num};
    }
''')

# Template for generating user stub.

userT = Template('''
ClRcT ${name}${version}(${func_decl})
{
    return CL_OK;
}    
''')

# Template for generating server stub.

optional_1 = 'goto Label1; '
optional_2 = Template('''clHandleCheckin(${eo_name}idlDatabaseHdl, idlHdl);
    clHandleDestroy(${eo_name}idlDatabaseHdl, idlHdl);
    return rc;''')
optional_3 = 'Label1:'

serverT = Template('''
ClRcT ${name}Server${version}(ClEoDataT eoData, ClBufferHandleT ${in_msg}, ClBufferHandleT ${out_msg})
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT ${rc} = CL_OK;
${decl}
${memset}
${unmarshall_list}
    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(${eo_name}idlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    ${rc} = ${name}${version}(${arg_list});
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != ${rc})
    {
       goto L0;
    }
    ${in_marshall_list}
    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    ${out_marshall_list}
L${arg_num}:    return ${rc};

${unmarshall_error_list}
    return ${rc};

${in_marshall_error_list}
${out_marshall_error_list}
    return ${rc};
}

ClRcT ${name}ResponseSend${version}(ClIdlHandleT idlHdl,ClRcT retCode${out_func_decl})
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(${eo_name}idlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    ${out_arg_marshall_list}
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    ${optional_1}
${out_arg_marshall_error_list}
    ${optional_2}
${optional_3}
    clHandleCheckin(${eo_name}idlDatabaseHdl, idlHdl);
    clHandleDestroy(${eo_name}idlDatabaseHdl, idlHdl);
Label0:
    return rc;
}
''')

# Templates -- end

elem_types =\
[
    'ClCharT',
    'ClHandleT',
    'ClInt8T',
    'ClInt16T',
    'ClInt32T',
    'ClInt64T',
    'ClNameT',
    'ClUint8T',
    'ClUint16T',
    'ClUint32T',
    'ClUint64T',
    'ClVersionT',
    'ClWordT',
    'ClStringT',
]


entity_map =\
{ 
    'enum':
     {
        'tag': 'Enum',
        'entities': 'enums',
        'member': 'EnumMember',
        'attrs' : [],
     },
    'operation':
     {
        'tag': 'Operation',
        'entities': 'ops',
        'member': 'Argument',
        'attrs' : ['type'],
     },
    'struct':
     {
        'tag': 'Struct',
        'entities': 'structs',
        'member': 'DataMember',
        'attrs' : ['include'],
     },
    'union':
     {
        'tag': 'Union',
        'entities': 'unions',
        'member': 'DataMember',
        'attrs' : [],
     },
}

def typedef(f, dt):
    l = open(f)
    l = (e for e in l if '%s;'%dt in e)
    l = (e for e in l if 'typedef' in e)
    l = (e for e in l if ';' in e)
    l = (e for e in l if 'callback' not in e.lower())
    l = (e[:-1] for e in l)

    return list(l)
    
def find(d, pat):
    for root,dirs,files in os.walk(d):
        for f in files:
            if fnmatch.fnmatch(f, pat):
                yield os.path.join(root, f)

def find_typedef(s):
    global options
    d = options.asp_dir
    
    base_types =\
    [
    'ClCharT',
    'ClHandleT',
    'ClInt8T',
    'ClInt16T',
    'ClInt32T',
    'ClInt64T',
    'ClNameT',
    'ClUint8T',
    'ClUint16T',
    'ClUint32T',
    'ClUint64T',
    'ClVersionT',
    'ClWordT',
    ]

    l = []
    for i in xrange(5):
        if s in base_types:
            return s

        l = filter(None, (typedef(e, s) for e in find(d, '*.h')))
        if not l:
            return ''

        assert(len(l) == 1)
        s = l[0][0].split()[1]
    else:
        return ''

def create_tree_for(e, t, d):
    global options
    m = entity_map[e]
    entity_tag = m['tag']
    entities = m['entities']
    member = m['member']
    attrs = m['attrs']

    entity_names_set = set()
    for entity in t.getElementsByTagName(entity_tag):
        entity_name = entity.attributes['name'].value
        if entity_name in entity_names_set:
            entity_dict = [f for f in d[entities] if 'name' in f and f['name'] == entity_name]
            assert(len(entity_dict) == 1)
            entity_dict = entity_dict[0]
        else:
            entity_dict = {}
            entity_dict['name'] = entity_name
            entity_names_set.add(entity_name)
            d.setdefault(entities, []).append(entity_dict)

        try:
            entity_version = entity.attributes['version'].value
        except KeyError:
            entity_version = u'4.0.0'

        entity_dict.setdefault('versions', []).append(entity_version)
        entity_dict.setdefault(entity_version, {})
        
        entity_dict[entity_version]['members'] = []
        for m in entity.getElementsByTagName(member):
            member_name = m.attributes['name'].value
            memb_dict = dict(m.attributes.items())
            if 'type' in memb_dict and options.typedef:
                if memb_dict['type'] not in elem_types:
                    real_type = find_typedef(memb_dict['type'])
                    if real_type:
                        memb_dict['comment'] = '/* %s */' % memb_dict['type']
                        memb_dict['type'] = real_type
            entity_dict[entity_version]['members'].append(memb_dict)

        entity_dict[entity_version]['def_need'] = False
        if 'defNeed' in dict(entity.attributes.items()):
            if entity.attributes['defNeed'].value.lower() in ["true", "yes"]:
                entity_dict[entity_version]['def_need'] = True

        for attr in attrs:
            try:
                val = entity.attributes[attr].value
            except KeyError:
                val = None

            entity_dict[entity_version][attr] = val

    return d

def create_tree_for_xdr(t, d):
    for inc in t.getElementsByTagName('Include'):
        include = inc.attributes['name'].value
        d.setdefault('includes', []).append(include)

    for comp in t.getElementsByTagName('Comp'):
        comp_name = comp.attributes['name'].value
        d.setdefault('comps', []).append(comp_name)

    for entity in ['enum', 'struct', 'union']:
        d = create_tree_for(entity, t, d)

    return d

def create_tree_for_stubs(t, d):
    for p in t.getElementsByTagName('Port'):
        port_name = p.attributes['name'].value
        d[port_name] = {}
        use_native_table = p.attributes.get('useNativeTable', None)
        if use_native_table:
            if use_native_table.value.lower() == 'true':
                d[port_name]['use_native_table'] = True
        else:
            d[port_name]['use_native_table'] = False

        d[port_name]['id'] = p.attributes.get('ID').value

        for g in p.getElementsByTagName('Group'):
            group_name = g.attributes['name'].value
            d[port_name][group_name] = create_tree_for('operation', g, {})
            d[port_name].setdefault('groups', []).append(group_name)

        d.setdefault('ports', []).append(port_name)

    return d

def create_tree_for_idl(t, d):
    for e in t.getElementsByTagName('Service'):
        service = e.attributes['name'].value
        d[service] = {}
        d[service]['name'] = service
        xdr_tree = create_tree_for_xdr(e, {})
        stubs_tree = create_tree_for_stubs(e, {})
        d[service].update(xdr_tree)
        d[service].update(stubs_tree)
        d.setdefault('services', []).append(service)

    return d

def create_tree(file_name):
    d = {}
    
    t = xml.dom.minidom.parse(file_name)

    stubs_needed = len(t.getElementsByTagName('Service')) > 0

    if stubs_needed:
        d = create_tree_for_idl(t, d)
    else:
        d = create_tree_for_xdr(t, d)

    d['stubs_needed'] = stubs_needed

    return d

def create_dir_structure(tree, dir_name):
    dir_name = os.path.abspath(dir_name)
    tree['top_dir'] = dir_name
    need_stubs = tree['stubs_needed']
    
    if need_stubs:
        l = []
        subdirs = ['client', 'common', 'server', 'xdr']
        for service in tree['services']:
            m = [os.path.sep.join([dir_name, service, e])
                 for e in subdirs]
            l += m
            for subdir,e in zip(subdirs, m):
                tree[service]['%s_dir'%subdir] = e
            
            tree[service]['service_dir'] = os.path.sep.join([dir_name, service])
    else:
        subdirs = ['xdr']
        l = [os.path.sep.join([dir_name, e]) for e in subdirs]
        for subdir,e in zip(subdirs, l):
            tree['%s_dir' % subdir] = e

    [os.makedirs(e) for e in l if not os.path.exists(e)]
    for e in l: assert(os.path.exists(e))

def get_ver_suffix(ver):
    return '_' + ver.replace('.', '_')

def get_memb_ver(member):
    if 'version' in member:
        return member['version']
    else:
        return idl_version

def get_eo_func_header_name(eo):
    return eo + 'FuncTable.h'

def get_h_file_name(s):
    return 'xdr' + s[0].upper() + s[1:] + '.h'

def get_c_file_name(s):
    return 'xdr' + s[0].upper() + s[1:] + '.c'

def parse_data_member(tree, s, member, ver, prepend=''):
    memb_attr_map = {}
    memb_attr_map['name'] = member['name']

    if member['type'] in elem_types:
        memb_attr_map['type'] = member['type']
        memb_attr_map['include_list'] = ''
    else:
        memb_attr_map['type'] = member['type'] + get_ver_suffix(get_memb_ver(member))
        memb_attr_map['include_list'] = ''.join(['#include "', get_h_file_name(member['type']), '"\n'])

    if 'comment' in member:
        memb_attr_map['comment'] = member['comment']

    memb_attr_map['member_dt'] = memb_attr_map['type']
    memb_attr_map['marshall_entry'] = ''.join(['pVar', '->', prepend, member['name']])
    memb_attr_map['unmarshall_entry'] = ''.join(['pVar', '->', prepend, member['name']])

    if 'pointer' in member:
        if member['pointer'] == 'Single':
            memb_attr_map['type'] += '*'
            memb_attr_map['member_dt'] = 'Ptr' + memb_attr_map['member_dt']
            if 'lengthVar' in member:
                memb_attr_map['marshall_entry'] += ''.join([', ', 'pVar', '->', member['lengthVar']])    
                memb_attr_map['unmarshall_entry'] = ''.join(['(void**)&(',
                                                             memb_attr_map['unmarshall_entry'],
                                                             ')',
                                                             ',',
                                                             'pVar',
                                                             '->',
                                                             member['lengthVar']
                                                             ])
            else:
                memb_attr_map['marshall_entry'] += ', 1'
                memb_attr_map['unmarshall_entry'] = ''.join(['(void**)&(',
                                                             memb_attr_map['unmarshall_entry'],
                                                             ')',
                                                             ',',
                                                             '1',
                                                             ])
    if 'multiplicity' in member:
        memb_attr_map['member_dt'] = 'Array' + memb_attr_map['member_dt']
        memb_attr_map['marshall_entry'] += ''.join([', ', member['multiplicity']])
        memb_attr_map['unmarshall_entry'] += ''.join([', ', member['multiplicity']])
        memb_attr_map['name'] += ''.join(['[', member['multiplicity'], ']'])
    else:
        if 'pointer' not in member:
            memb_attr_map['marshall_entry'] = ''.join(['&(', memb_attr_map['marshall_entry'], ')'])
            memb_attr_map['unmarshall_entry'] = ''.join(['&(', memb_attr_map['unmarshall_entry'], ')'])

    # Check for self referential member
    if s['name'] == member['type']:
        memb_attr_map['hdr_type'] = ''.join(['struct _', memb_attr_map['type']])
    else:
        memb_attr_map['hdr_type'] = memb_attr_map['type']

    return memb_attr_map

def get_headers_define(s):
    s = re.sub('(?<=[a-z0-9])([A-Z])', r'_\1', s)
    s = re.sub('(?<=[A-Z])([A-Z])([a-z0-9])', r'_\1\2', s)
    return s.upper()

def write_xdr_h_preamble(h_file, xdr_attr_map):
    h_file.write(xdrHeaderT.safe_substitute(xdr_attr_map))

def write_xdr_c_preamble(c_file, entity, func_type, xdr_attr_map):
    d = {'struct':
         {'marshall': xdrMarshallStructCodeT,
          'unmarshall': xdrUnMarshallStructCodeT
         },
         'union':
         {'marshall': xdrMarshallUnionCodeT,
          'unmarshall': xdrUnMarshallUnionCodeT
         }
        }

    template = d[entity][func_type]
    c_file.write(template.safe_substitute(xdr_attr_map))

def write_xdr_h_file(h_file, s, ver, xdr_attr_map):
    h_file.write(xdrHeaderT_version.safe_substitute(xdr_attr_map))
    if ver == idl_version:
        base_type = s['name']
        versioned_type = xdr_attr_map['type']
        if s[ver]['def_need']:
            h_file.write(xdrHeaderT_backward_compat.safe_substitute(one=versioned_type,
                                                                    two=base_type,
                                                                    base_type=base_type,
                                                                    versioned_type=versioned_type))
        else:
            h_file.write(xdrHeaderT_backward_compat.safe_substitute(one=base_type,
                                                                    two=versioned_type,
                                                                    base_type=base_type,
                                                                    versioned_type=versioned_type))
        h_file.write('\n\n')

def write_xdr_marshall_c_file(c_file, entity, ver, xdr_attr_map):
    if entity == 'struct':
        template = xdrMarshallStructCodeT_version
    elif entity == 'union':
        template = xdrMarshallUnionCodeT_version

    c_file.write(template.safe_substitute(xdr_attr_map))

def write_xdr_unmarshall_c_file(c_file, entity, ver, xdr_attr_map):
    if entity == 'struct':
        template = xdrUnMarshallStructCodeT_version
    elif entity == 'union':
        template = xdrUnMarshallUnionCodeT_version
        
    c_file.write(template.safe_substitute(xdr_attr_map))

def write_xdr_h_postamble(h_file, name):
    h_file.write(xdrHeaderT_postamble.safe_substitute(TYPE=get_headers_define(name)))

def get_norm_inc_list(s):
    l = [e.strip() for e in list(set(s.split())) if e != '#include']

    l1 = ['#include %s' % e for e in l if e.startswith('"cl')]
    l2 = ['#include %s' % e for e in l if not e.startswith('"cl')]

    return '\n'.join(l1+l2)

def get_struct_xdr_attr_map_ver(tree, s, ver):
    st = s[ver]['members']
    fix_len_members = [e for e in st if "lengthVar" not in e]
    var_len_members = [e for e in st if "lengthVar" in e]
    fix_len_members += var_len_members

    xdr_attr_map = {}
    for key in ['member_list', 'marshalled_member_list', 'unmarshalled_member_list']:
        xdr_attr_map[key] = ''

    for member in fix_len_members:
        memb_attr_map = parse_data_member(tree, s, member, ver)
        if 'comment' in memb_attr_map:
            xdr_attr_map['member_list'] += memberT_comment.safe_substitute(memb_attr_map)
        else:
            xdr_attr_map['member_list'] += memberT.safe_substitute(memb_attr_map)

        xdr_attr_map['marshalled_member_list'] += marshallStructMemberT.safe_substitute(memb_attr_map)
        xdr_attr_map['unmarshalled_member_list'] += unmarshallStructMemberT.safe_substitute(memb_attr_map)

    xdr_attr_map['type'] = ''.join([s['name'], '_', ver.replace('.', '_')])
    xdr_attr_map['type1'] = ''.join([s['name'][0].upper(), s['name'][1:]])
    xdr_attr_map['TYPE'] = get_headers_define(s['name'])

    if s[ver]['def_need']:
        xdr_attr_map['udt_defn'] = structMemberDefnT.safe_substitute(xdr_attr_map)
    else:
        xdr_attr_map['udt_defn'] = ''

    return xdr_attr_map

def gen_code_for_struct_or_union(s, ver, entity, h_file, marshall_c_file, unmarshall_c_file, xdr_attr_map):
    write_xdr_h_file(h_file, s, ver, xdr_attr_map)
    write_xdr_marshall_c_file(marshall_c_file, entity, ver, xdr_attr_map)
    write_xdr_unmarshall_c_file(unmarshall_c_file, entity, ver, xdr_attr_map)

def get_preamble_dict(tree, s, entity):
    d = {}
    d['license'] = license
    d['type'] = s['name']
    d['type1'] = ''.join([s['name'][0].upper(), s['name'][1:]])
    d['TYPE'] = get_headers_define(s['name'])
    d['include_list'] = ''

    if 'includes' in tree and entity != 'union':
        d['include_list'] = '\n'.join(['#include "%s"'% e
                                       for e in tree['includes']]) + '\n'
    for ver in s['versions']:
        st = s[ver]['members']
        fix_len_members = [e for e in st if "lengthVar" not in e]
        var_len_members = [e for e in st if "lengthVar" in e]
        fix_len_members += var_len_members

        for member in fix_len_members:
            memb_attr_map = parse_data_member(tree, s, member, ver)
            d['include_list'] += '\n' + memb_attr_map['include_list']

        if 'include' in s[ver] and s[ver]['include']:
            include_file = s[ver]['include']
            d['include_list'] += ''.join(['#include "', include_file, '"', '\n'])

        d['include_list'] = get_norm_inc_list(d['include_list'])

    return d

def gen_code_for_struct(tree, s):
    """Generate marshalling and unmarshalling functions for a structure.

       Generate xdr<struct_name>[Marshall|UnMarshall].c and
       xdr<struct_name>.h files per structure.
    """

    h_file = open(os.path.join(tree['xdr_dir'], get_h_file_name(s['name'])), 'w')
    marshall_c_file = open(os.path.join(tree['xdr_dir'], get_c_file_name(s['name']+'Marshall')), 'w')
    unmarshall_c_file = open(os.path.join(tree['xdr_dir'], get_c_file_name(s['name']+'UnMarshall')), 'w')

    d = get_preamble_dict(tree, s, 'struct')
    write_xdr_h_preamble(h_file, d)
    write_xdr_c_preamble(marshall_c_file, 'struct', 'marshall', d)
    write_xdr_c_preamble(unmarshall_c_file, 'struct', 'unmarshall', d)
    
    for ver in s['versions']:
        xdr_attr_map = get_struct_xdr_attr_map_ver(tree, s, ver)
        gen_code_for_struct_or_union(s,
                                     ver,
                                     'struct',
                                     h_file,
                                     marshall_c_file,
                                     unmarshall_c_file,
                                     xdr_attr_map)

    write_xdr_h_postamble(h_file, s['name'])

    h_file.close()
    marshall_c_file.close()
    unmarshall_c_file.close()

def get_union_xdr_attr_map_ver(tree, u, ver):
    un = u[ver]['members']

    xdr_attr_map = {}
    for key in ['member_list', 'enum_member_list', 'marshalled_member_list', 'unmarshalled_member_list']:
        xdr_attr_map[key] = ''

    xdr_attr_map['type'] = ''.join([u['name'], '_', ver.replace('.', '_')])
    xdr_attr_map['type1'] = ''.join([u['name'][0].upper(), u['name'][1:]])
    xdr_attr_map['TYPE'] = get_headers_define(u['name'])
    xdr_attr_map['union_enum_type'] = ''.join([u['name'], 'EnumT', get_ver_suffix(ver)])
    xdr_attr_map['union_name'] = ''.join([u['name'][0].lower(), u['name'][1:]])

    for i,member in enumerate(un):
        memb_attr_map = parse_data_member(tree, u, member, ver, ''.join([xdr_attr_map['union_name'], '.']))
        if memb_attr_map['hdr_type'] not in elem_types:
            if 'pointer' in member and member['pointer'] == 'Single':
                memb_attr_map['hdr_type'] = memb_attr_map['hdr_type'][:-1] + "*"

        memb_attr_map['discriminant'] = (u['name']+member['name']).upper()
        xdr_attr_map['member_list'] += '    ' + memberT.safe_substitute(memb_attr_map)
        if i == 0:
            xdr_attr_map['enum_member_list'] += '    ' +\
                                                memb_attr_map['discriminant'] +\
                                                ' = 1' + ''',
'''
        else:
            xdr_attr_map['enum_member_list'] += '    ' +\
                                                memb_attr_map['discriminant'] +\
                                                ''',
'''
        xdr_attr_map['marshalled_member_list'] += marshallUnionMemberT.safe_substitute(memb_attr_map)
        xdr_attr_map['unmarshalled_member_list'] += unmarshallUnionMemberT.safe_substitute(memb_attr_map)

    xdr_attr_map['udt_defn'] = unionMemberDefnT.safe_substitute(xdr_attr_map)
    xdr_attr_map['enum_member_list'] += xdr_attr_map['enum_member_list'][:-2]

    return xdr_attr_map

def gen_code_for_union(tree, u):
    """Generate marshalling and unmarshalling functions for a union.

       Generate xdr<struct_name>[Marshall|UnMarshall].c and
       xdr<struct_name>.h files per union.
    """

    h_file = open(os.path.join(tree['xdr_dir'], get_h_file_name(u['name'])), 'w')
    marshall_c_file = open(os.path.join(tree['xdr_dir'], get_c_file_name(u['name']+'Marshall')), 'w')
    unmarshall_c_file = open(os.path.join(tree['xdr_dir'], get_c_file_name(u['name']+'UnMarshall')), 'w')

    d = get_preamble_dict(tree, u, 'union')
    write_xdr_h_preamble(h_file, d)
    write_xdr_c_preamble(marshall_c_file, 'union', 'marshall', d)
    write_xdr_c_preamble(unmarshall_c_file, 'union', 'unmarshall', d)

    for ver in u['versions']:
        xdr_attr_map = get_union_xdr_attr_map_ver(tree, u, ver)
        gen_code_for_struct_or_union(u,
                                     ver,
                                     'union',
                                     h_file,
                                     marshall_c_file,
                                     unmarshall_c_file,
                                     xdr_attr_map)

    write_xdr_h_postamble(h_file, u['name'])
    
    h_file.close()
    marshall_c_file.close()
    unmarshall_c_file.close()

def write_xdr_enum_h_file(h_file, enum, ver, xdr_attr_map):
    if ver == idl_version:
        xdr_attr_map['license'] = license
        xdr_attr_map['xdrEnumHeaderT_version'] = xdrEnumHeaderT_version.safe_substitute(xdr_attr_map)
        h_file.write(xdrEnumHeaderT.safe_substitute(xdr_attr_map))
        base_type = enum['name']
        versioned_type = xdr_attr_map['type']
        if enum[ver]['def_need']:
            h_file.write(xdrHeaderT_backward_compat.safe_substitute(one=versioned_type,
                                                                    two=base_type,
                                                                    base_type=base_type,
                                                                    versioned_type=versioned_type))
        else:
            h_file.write(xdrHeaderT_backward_compat.safe_substitute(one=base_type,
                                                                    two=versioned_type,
                                                                    base_type=base_type,
                                                                    versioned_type=versioned_type))
        h_file.write('\n\n')
    else:
        h_file.write(xdrHeaderT_version.safe_substitute(xdr_attr_map))

def gen_code_for_enum(tree, enum):
    """Generate marshalling and unmarshalling functions for an enum.

       Generate xdr<enum_name>.h file per enum.
    """

    ename = enum['name']
    h_file = open(os.path.join(tree['xdr_dir'], get_h_file_name(ename)), 'w')
    for ver in enum['versions']:
        if 'members' in enum[ver]:
            en = enum[ver]['members']
        else:
            en = []

        xdr_attr_map = {}
        xdr_attr_map['member_list'] = ''
        xdr_attr_map['include_list'] = ''
        if 'includes' in tree:
            xdr_attr_map['include_list'] = '\n'.join(['#include "%s"'% e
                                                      for e in tree['includes']]) + '\n'

        for member in en:
            if 'value' in member:
                xdr_attr_map['member_list'] += ''.join(['    ',
                                                        member['name'],
                                                        ' = ',
                                                        member['value'],
                                                        ''',
'''
                                                        ])
            else:
                xdr_attr_map['member_list'] += ''.join(['    ', member['name'], ''',
'''])

        xdr_attr_map['member_list'] = xdr_attr_map['member_list'][:-2]
        xdr_attr_map['type'] = ''.join([ename, get_ver_suffix(ver)])
        xdr_attr_map['TYPE'] = get_headers_define(ename)

        if enum[ver]['def_need']:
            xdr_attr_map['udt_defn'] = enumDefnT.safe_substitute(xdr_attr_map)
        else:
            xdr_attr_map['udt_defn'] = ''

        if 'include' in enum[ver] and enum[ver]['include']:
            include_file = enum[ver]['include']
            xdr_attr_map['include_list'] += ''.join(['#include "', include_file, '"', '\n'])

        xdr_attr_map['include_list'] = get_norm_inc_list(xdr_attr_map['include_list'])

        write_xdr_enum_h_file(h_file, enum, ver, xdr_attr_map)

    write_xdr_h_postamble(h_file, ename)

def create_stub(op, ver, service_no, client_id, gen_template, type_needed, eo, flag):
    arg_map = {}
    for k, v in zip(['in', 'inout', 'out'], ['CL_IN', 'CL_INOUT', 'CL_OUT']):
        arg_map[k] = [arg for arg in op[ver]['members']
                      if arg['ParameterType'] == v]

    in_ptr = 0
    inout_ptr = 0
    out_ptr = 0
    ptr_num = dict([('in', in_ptr), ('inout', inout_ptr), ('out', out_ptr)])

    reply_needed = 0
    in_msg_needed = 0
    unused = 0

    reply = dict([('in', unused), ('inout', reply_needed), ('out', reply_needed)])
    in_msg = dict([('in', in_msg_needed), ('inout', in_msg_needed), ('out', unused)])

    arg_num = 0

    def get_arg_type(a):
        d = {
                'CL_IN': 'in',
                'CL_OUT': 'out',
                'CL_INOUT': 'inout'
        }
        return d[a]

    def get_arg_version(arg):
        if 'version' in arg:
            return arg['version']
        return idl_version

    func_attr_map = {}
    gen_template['init'](func_attr_map)

    for arg in op[ver]['members']:
        arg_type = get_arg_type(arg['ParameterType'])

        arg_attr_map = {}
        arg_attr_map['is_decl'] = '1'
        arg_attr_map['name'] = arg['name']

        if arg['type'] in elem_types:
            arg_attr_map['type'] = arg['type']
        else:
            arg_attr_map['type'] = arg['type'] + get_ver_suffix(get_arg_version(arg))

        arg_attr_map['arg_num'] = arg_num

        if 'pointer' in arg:
            if arg['pointer'] == 'Single':
                if 'lengthVar' in arg:
                    if arg_type == 'inout':
                        print 'Error: CL_INOUT is not allowed for '\
                              'buffer variable which has lengthVar variable.\n' +\
                              arg['name'] + ' is having lengthVar, so CL_INOUT is not allowed'
                        raise SystemExit

                    check_list = [e for e in op[ver]['members']
                                  if e['name'] == arg['lengthVar'] and
                                  e['ParameterType'] == 'CL_IN']
                    if not check_list:
                        print 'Error: Invalid argument. %(name) is a single pointer. '\
                              'So the lengthVar should not be CL_INOUT or CL_OUT '\
                              'or %(name) should be a double pointer' % {'name': arg['name']}
                        # TODO print function name and argument having pointer attribute
                        raise SystemExit

                    arg_attr_map['length_var'] = arg['lengthVar']
                    for var in check_list:
                        arg_attr_map['length_var_type'] = var['ParameterType'] + ' ' + var['type'] + ' ' + var['name']

                    gen_template['decl_append'](func_attr_map, gen_template['as_ptr_with_length'][arg_type](arg_attr_map))
                else:
                    gen_template['decl_append'](func_attr_map, gen_template['by_ref'][arg_type](arg_attr_map))
            elif arg['pointer'] == 'Double':
                if 'lengthVar' in arg:
                    if arg_type == 'inout':
                        print 'Error: CL_INOUT is not allowed for buffer variable '\
                              'which has lengthVar variable.\n' +\
                              arg['name'] + 'is having lengthVar, so CL_INOUT is not allowed'
                        raise SystemExit

                    arg_attr_map['length_var'] = arg['lengthVar']
                    check_list = [e for e in op[ver]['members']
                                  if e['name'] == arg['lengthVar']]
                    gen_template['decl_append'](func_attr_map, gen_template['as_double_ptr'][arg_type](arg_attr_map))
        else:
            gen_template['decl_append'](func_attr_map, gen_template['by_val'][arg_type](arg_attr_map))

    param_map = {}
    for arg_type in ['in', 'inout', 'out']:
        if not arg_map[arg_type]:
            continue

        param_map['fixed'] = [e for e in arg_map[arg_type]
                              if 'lengthVar' not in e]
        param_map['variable'] = [e for e in arg_map[arg_type]
                                 if 'lengthVar' in e]

        arg_type_num = 0

        for param_type in ['fixed', 'variable']:
            if not param_map[param_type]:
                continue

            for arg in param_map[param_type]:
                arg_attr_map = {}
                arg_attr_map['is_decl'] = '0'
                arg_attr_map['eo'] = None # TODO fill in proper variable
                arg_attr_map['name'] = arg['name']

                if arg['type'] in elem_types:
                    arg_attr_map['type'] = arg['type']
                else:
                    arg_attr_map['type'] = arg['type'] + get_ver_suffix(get_arg_version(arg))
                    type_needed[arg['type']] = True

                arg_attr_map['arg_num'] = arg_num
                arg_attr_map['arg_type_num'] = arg_type_num

                if 'pointer' in arg:
                    if arg['pointer'] == 'Single':
                        if 'lengthVar' in arg:
                            ptr_num[arg_type] += 1
                            arg_attr_map['length_var'] = arg['lengthVar']
                            gen_template['append'](func_attr_map, gen_template['as_ptr_with_length'][arg_type](arg_attr_map))
                        else:
                            gen_template['append'](func_attr_map, gen_template['by_ref'][arg_type](arg_attr_map))
                    elif arg['pointer'] == 'Double':
                        if 'lengthVar' in arg:
                            ptr_num[arg_type] += 1
                            arg_attr_map['length_var'] = arg['lengthVar']
                            gen_template['append'](func_attr_map, gen_template['as_double_ptr'][arg_type](arg_attr_map))
                else:
                    gen_template['append'](func_attr_map, gen_template['by_val'][arg_type](arg_attr_map))

                arg_num += 1
                arg_type_num += 1
                in_msg[arg_type] += 1
                reply[arg_type] += 1

    func_attr_map['func_no'] = ''.join(['CL_EO_GET_FULL_FN_NUM(', client_id, ', ', str(service_no), ')'])
    func_attr_map['name'] = op['name'] # TODO is this same as previous service.attributes['name'].value ?
    func_attr_map['in_ptr'] = ptr_num['in']
    func_attr_map['inout_ptr'] = ptr_num['inout']
    func_attr_map['out_ptr'] = ptr_num['out']
    func_attr_map['reply_needed'] = reply['out'] + reply['inout']
    func_attr_map['in_msg_needed'] = in_msg['in'] + reply['inout']
    func_attr_map['arg_num'] = arg_num
    func_attr_map['eo_name'] = eo
    func_attr_map['version'] = get_ver_suffix(ver)
    rel, major, minor = ver.split('.')
    func_attr_map['rel'] = rel
    func_attr_map['major'] = major
    func_attr_map['minor'] = minor

    if flag == 2:
        last_arg_index = func_attr_map['func_decl'][:-2]
        func_attr_map['func_decl'] = '' 
        func_attr_map['func_decl'] += last_arg_index
        last_arg_index = func_attr_map['arg_list'][:-2]
        func_attr_map['arg_list'] = '' 
        func_attr_map['arg_list'] += last_arg_index

    if len(arg_map['out']):
        func_attr_map['optional_1'] = optional_1
        func_attr_map['optional_2'] = optional_2.safe_substitute(func_attr_map)
        func_attr_map['optional_3'] = optional_3
    else:
        for i in range(1, 4):
            func_attr_map['optional_%s' % i] = ''
        
    func_output = {}
    func_output['code'] = gen_template['function'](func_attr_map)
    func_output['header'] = gen_template['header'].safe_substitute(func_attr_map)

    if 'user_function' in gen_template:
        func_output['user_code'] = gen_template['user_function'](func_attr_map)
    else:
        func_output['user_code'] = ''

    if ver == idl_version and gen_template.get('backward_compat'):
        func_output['header'] += gen_template['backward_compat'].safe_substitute(func_attr_map)

    return func_output
                
def server_as_ptr_with_length(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outServerAsPointerwithLength is
    made into a function and called in the respective functions.
    '''

    data_type =  arg_attr_map['type'] + '*'

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] =  data_type + '  ' + arg_attr_map['name']
        func_attr_map['memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + data_type + '))'
        func_attr_map['arg_list'] = arg_attr_map['name']
        func_attr_map['func_decl'] = d['arg_type'] + func_attr_map['decl']
        func_attr_map['unmarshall_error_list'] = ''
        func_attr_map['marshall_error_list'] = ''
        func_attr_map['unmarshall_list'] = ''
        func_attr_map['marshall_list'] = ''
        func_attr_map['out_func_decl'] = ''

        if d['arg_type'] != 'CL_IN ':
            func_attr_map['out_func_decl'] += ',' + arg_attr_map['length_var_type'] + ',' + func_attr_map['func_decl']
    else:
        func_attr_map['decl'] = '' 
        func_attr_map['memset'] = ''
        func_attr_map['arg_list'] = ''
        func_attr_map['func_decl'] = ''
        d['member_func_type'] = 'Ptr' + arg_attr_map['type']
        d['unmarshall_entry'] = '(void**)&(' + arg_attr_map['name'] + ')' + ', ' + arg_attr_map['length_var']
        d['marshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        d['is_delete'] = '1'
        d['arg_num'] = arg_attr_map['arg_num']
        d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1
        func_attr_map['unmarshall_error_list'] = unmarshallErrorEntryT.safe_substitute(d)
        func_attr_map['out_arg_marshall_error_list'] = ''
        func_attr_map['out_arg_marshall_list'] = ''

        if d['arg_type'] == 'CL_IN ':
            func_attr_map['in_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['out_marshall_list'] = ''
            func_attr_map['in_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
            func_attr_map['out_marshall_error_list'] = '' 
        else:
            func_attr_map['out_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['in_marshall_list'] = ''
            func_attr_map['in_marshall_error_list'] = ''
            func_attr_map['out_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
            d['arg_err_num'] = d['arg_num'] + 1
            func_attr_map['out_arg_marshall_error_list'] += marshallErrorNumEntryT.safe_substitute(d)
            d['arg_err_num'] = d['arg_num'] + 1
            func_attr_map['out_arg_marshall_list'] += inArgServerMarshalT.safe_substitute(d)

        func_attr_map['unmarshall_list'] = inServerUnmarshallT.safe_substitute(d)

def in_server_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type IN,
    pointer with length variable for server stub.
    '''

    func_attr_map = {}
    d = {}
    d['arg_type'] = 'CL_IN '
    d['out_msg'] = '0'

    server_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    return func_attr_map

def inout_server_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT,
    pointer with length variable for server stub.
    '''

    func_attr_map = {}
    d = {}
    d['arg_type'] = 'CL_INOUT '

    server_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    return func_attr_map

def out_server_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type OUT,
    pointer with length variable for server stub.
    '''

    func_attr_map = {}
    d = {}
    d['arg_type'] = 'CL_OUT '

    server_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    func_attr_map['unmarshall_list'] = ptrAllocateT.safe_substitute(arg_attr_map)

    return func_attr_map

def server_by_ref(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outServerByReference is made into a
    function and called in the respective functions.
    '''

    data_type =  arg_attr_map['type']
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] =  data_type + '  ' + arg_attr_map['name']
        func_attr_map['memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + data_type + '))'
        func_attr_map['arg_list'] = '&(' + arg_attr_map['name'] + ')'
        func_attr_map['func_decl'] = d['arg_type'] + arg_attr_map['type'] + '*  ' + arg_attr_map['name']
        func_attr_map['unmarshall_error_list'] = '' 
        func_attr_map['marshall_error_list'] = ''
        func_attr_map['unmarshall_list'] = '' 
        func_attr_map['marshall_list'] = ''
        func_attr_map['out_func_decl'] = ''

        if d['arg_type'] != 'CL_IN ':
            func_attr_map['out_func_decl'] += ','+ d['arg_type'] + ' ' + func_attr_map['decl']
    else:
        d['is_delete'] = '1'
        func_attr_map['decl'] = ''
        func_attr_map['memset'] = ''
        func_attr_map['arg_list'] = '' 
        func_attr_map['func_decl'] = '' 
        d['member_func_type'] = arg_attr_map['type']
        d['unmarshall_entry'] = '&(' + arg_attr_map['name'] + ')'
        d['marshall_entry'] = '&(' + arg_attr_map['name'] + ')'
        d['arg_num'] = arg_attr_map['arg_num']
        d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1
        func_attr_map['unmarshall_error_list'] = unmarshallErrorEntryT.safe_substitute(d)
        func_attr_map['unmarshall_list'] = inServerUnmarshallT.safe_substitute(d)
        func_attr_map['out_arg_marshall_error_list'] = ''
        func_attr_map['out_arg_marshall_list'] = ''
        if d['arg_type'] == 'CL_IN ':
            func_attr_map['in_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['out_marshall_list'] = ''
            func_attr_map['in_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
            func_attr_map['out_marshall_error_list'] = ''
        else:
            func_attr_map['out_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['in_marshall_list'] = '' 
            func_attr_map['in_marshall_error_list'] = ''
            func_attr_map['out_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
            d['arg_err_num'] = d['arg_num'] + 1
            func_attr_map['out_arg_marshall_error_list'] += marshallErrorNumEntryT.safe_substitute(d)
            d['arg_err_num'] = d['arg_num'] + 1
            func_attr_map['out_arg_marshall_list'] += inArgServerMarshalT.safe_substitute(d)

    return func_attr_map

def in_server_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type IN,
    reference for server stub.
    '''
    
    func_attr_map = {}

    d = {}
    d['arg_type'] = 'CL_IN '
    d['out_msg'] = '0'

    server_by_ref(func_attr_map, arg_attr_map, d)

    return func_attr_map

def inout_server_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT,
    reference for server stub.
    '''

    func_attr_map = {}

    d = {}
    d['arg_type'] = 'CL_INOUT '

    server_by_ref(func_attr_map, arg_attr_map, d)

    return func_attr_map

def out_server_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type OUT,
    reference for server stub.
    '''

    func_attr_map = {}

    d = {}
    d['arg_type'] = 'CL_OUT '

    server_by_ref(func_attr_map, arg_attr_map, d)

    # dirty, dirty
    func_attr_map['unmarshall_list'] = ''
    func_attr_map['unmarshall_error_list'] = ''

    return func_attr_map

def in_server_by_val(arg_attr_map):
    '''Collating code snippets for parameter of type IN,
    value for server stub.
    '''
    
    func_attr_map = {}
    if arg_attr_map['is_decl'] == '1':        
        data_type =  arg_attr_map['type']

        func_attr_map['decl'] =  data_type + '  ' + arg_attr_map['name']
        func_attr_map['memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + data_type + '))'
        func_attr_map['arg_list'] = arg_attr_map['name']
        func_attr_map['func_decl'] = 'CL_IN ' + func_attr_map['decl']
        func_attr_map['unmarshall_error_list'] = '' 
        func_attr_map['marshall_error_list'] = '' 
        func_attr_map['unmarshall_list'] = '' 
        func_attr_map['in_marshall_list'] = '' 
        func_attr_map['out_marshall_list'] = '' 
        func_attr_map['out_func_decl'] = ''
    else:
        func_attr_map['decl'] = '' 
        func_attr_map['memset'] = ''
        func_attr_map['arg_list'] = ''
        func_attr_map['func_decl'] = ''

        d = {}
        d['member_func_type'] = arg_attr_map['type']
        d['unmarshall_entry'] = '&(' + arg_attr_map['name'] + ')'
        d['marshall_entry'] = '&(' + arg_attr_map['name'] + ')'
        d['out_msg'] = '0'
        d['is_delete'] = '1'
        d['arg_num'] = arg_attr_map['arg_num']
        d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1

        func_attr_map['unmarshall_error_list'] = unmarshallErrorEntryT.safe_substitute(d)
        func_attr_map['in_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
        func_attr_map['out_marshall_error_list'] = '' 
        func_attr_map['out_arg_marshall_error_list'] = '' 
        func_attr_map['out_arg_marshall_list'] = '' 
        func_attr_map['unmarshall_list'] = inServerUnmarshallT.safe_substitute(d)
        func_attr_map['in_marshall_list'] = inServerMarshallT.safe_substitute(d)
        func_attr_map['out_marshall_list'] = '' 

    return func_attr_map

def do_nothing(arg_attr_map):
    return None

def server_as_double_ptr(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outServerAsPointerwithLength is
    made into a function and called in the respective functions.
    '''
    
    if arg_attr_map['is_decl'] == '1':
        data_type =  arg_attr_map['type'] + '*'

        func_attr_map['decl'] =  data_type + '  ' + arg_attr_map['name']
        func_attr_map['memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + data_type + '))'
        func_attr_map['arg_list'] = '&'+ arg_attr_map['name']
        func_attr_map['func_decl'] = d['arg_type'] + data_type + '*' + ' ' + arg_attr_map['name']
        func_attr_map['unmarshall_error_list'] = '' 
        func_attr_map['marshall_error_list'] = '' 
        func_attr_map['unmarshall_list'] = '' 
        func_attr_map['marshall_list'] = '' 
        func_attr_map['out_func_decl'] = ''
        
        if(d['arg_type'] != 'CL_IN '):
            func_attr_map['out_func_decl'] += ','+ func_attr_map['decl']
    else:
        func_attr_map['decl'] = '' 
        func_attr_map['memset'] = ''
        func_attr_map['arg_list'] = '' 
        func_attr_map['func_decl'] = '' 
        
        d['member_func_type'] = 'Ptr' + arg_attr_map['type']
        d['marshall_entry'] =  arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        d['is_delete'] = '1'
        d['arg_num'] = arg_attr_map['arg_num']
        d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1
        
        func_attr_map['unmarshall_error_list'] = unmarshallDblPtrErrorEntryT.safe_substitute(d)
        func_attr_map['unmarshall_list'] = inServerDblPtrUnmarshallT.safe_substitute(d)
        func_attr_map['out_arg_marshall_error_list'] = ''
        func_attr_map['out_arg_marshall_list'] = ''

        if d['arg_type'] == 'CL_IN ':
            func_attr_map['in_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['out_marshall_list'] = ''
            func_attr_map['in_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)
            func_attr_map['out_marshall_error_list'] = ''
        else:
            func_attr_map['out_marshall_list'] = inServerMarshallT.safe_substitute(d)
            func_attr_map['in_marshall_list'] = '' 
            func_attr_map['in_marshall_error_list'] = ''
            func_attr_map['out_marshall_error_list'] = marshallErrorEntryT.safe_substitute(d)

            d['arg_err_num'] = d['arg_num']+1
            func_attr_map['out_arg_marshall_error_list'] += marshallErrorNumEntryT.safe_substitute(d)

            d['arg_err_num'] = d['arg_num']+1
            func_attr_map['out_arg_marshall_list'] += inArgServerMarshalT.safe_substitute(d)
        
def out_server_by_double_ptr(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, pointer with
    length variable for server stub.
    '''
    func_attr_map = {}
    d = {}
    d['arg_type'] = 'CL_OUT '

    server_as_double_ptr(func_attr_map, arg_attr_map, d)

    return func_attr_map

def create_user_func(func_attr_map):
    return userT.safe_substitute(func_attr_map)

def create_server_func(func_attr_map):
    return serverT.safe_substitute(func_attr_map)

def server_append(func_attr_map, arg_entry_to_add):
    l = ['in_marshall_list',
         'out_marshall_list',
         'out_arg_marshall_list',
         'unmarshall_list',
         'in_marshall_error_list',
         'out_marshall_error_list',
         'out_arg_marshall_error_list',
        ]

    for key in l:
        func_attr_map[key] += arg_entry_to_add[key]

    func_attr_map['unmarshall_error_list'] = arg_entry_to_add['unmarshall_error_list'] +\
                                             func_attr_map['unmarshall_error_list'] # :-(


def server_decl_append(func_attr_map, arg_entry_to_add):
        func_attr_map['decl'] += '    ' + arg_entry_to_add['decl'] + ''';
'''
        func_attr_map['memset'] += '    ' + arg_entry_to_add['memset'] + ''';
'''
        func_attr_map['func_decl'] += arg_entry_to_add['func_decl'] + ', '
        
        s = arg_entry_to_add['out_func_decl'][1:].find(',') 
        if func_attr_map['out_func_decl'].find(arg_entry_to_add['out_func_decl'][:s]) == -1:
            func_attr_map['out_func_decl'] += arg_entry_to_add['out_func_decl']
        else:
            func_attr_map['out_func_decl'] += arg_entry_to_add['out_func_decl'][s+1:]

        func_attr_map['arg_list'] += arg_entry_to_add['arg_list'] + ', '

def server_init(func_attr_map):
    l = ['name',
         'decl',
         'memset',
         'func_decl',
         'out_func_decl',
         'arg_list',
         'marshall_list',
         'in_marshall_list',
         'out_marshall_list',
         'out_arg_marshall_list',
         'unmarshall_list',
         'in_marshall_error_list',
         'out_marshall_error_list',
         'out_arg_marshall_error_list',
         'unmarshall_error_list',
         ]
         
    for key in l:
        func_attr_map[key] = ''

def create_server_stub(s, ver, service_no, client_id, type_needed, e):
    """Needs to be documented."""

    gen_template = {
            'init' : server_init,
            
            'decl_append': server_decl_append,
            
            'append': server_append,
            
            'as_ptr_with_length': {
                    'in': in_server_as_ptr_with_length,

                    'inout': inout_server_as_ptr_with_length,

                    'out': out_server_as_ptr_with_length,
            },

            'by_ref': {
                    'in': in_server_by_ref,

                    'inout': inout_server_by_ref,

                    'out': out_server_by_ref,
            },

            'by_val': {
                    'in': in_server_by_val,

                    'inout': do_nothing,

                    'out': do_nothing,
            },

            'as_double_ptr': {
                    'in': do_nothing,

                    'inout': do_nothing,

                    'out': out_server_by_double_ptr,
            },

            'function': create_server_func,

            'user_function': create_user_func,

            'header': serverHeaderT,
    }

    return create_stub(s, ver, service_no, client_id, gen_template, type_needed, e, 2)

def async_init(func_attr_map):
    l = ['name',
         'cb_decl',
         'func_no',
         'call_marshall_list',
         'cb_error_marshall_list',
         'cb_unmarshall_list',
         'cb_memset',
         'arg_list',
         'temp1',
         'temp2',
         'ptr_checks',
         'out_msg_create',
         'out_msg_delete',
         'in_msg_create',
         'flag_need_reply',
         ]

    for key in l:
        func_attr_map[key] = ''

    func_attr_map['call_decl'] = ', ' ## FIXME


def async_decl_append(func_attr_map, arg_entry_to_add):
    func_attr_map['call_decl'] += arg_entry_to_add['call_decl'] + ', '
    func_attr_map['cb_decl'] += '    ' + arg_entry_to_add['cb_decl'] + ''';
'''
    func_attr_map['cb_memset'] += '    ' + arg_entry_to_add['cb_memset'] + ''';
'''
    func_attr_map['arg_list'] += arg_entry_to_add['arg_list'] + ', '

def async_append(func_attr_map, arg_entry_to_add):
    func_attr_map['call_marshall_list'] += arg_entry_to_add['call_marshall_list']
    func_attr_map['cb_unmarshall_list'] += arg_entry_to_add['cb_unmarshall_list']
    func_attr_map['cb_error_marshall_list'] = arg_entry_to_add['cb_error_marshall_list'] + func_attr_map['cb_error_marshall_list']

def in_async_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type IN, pointer with
    length variable for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_IN '

    d = {}
    async_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] += inAsyncClientMarshallT.safe_substitute(d)
        func_attr_map['cb_unmarshall_list'] = inAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def inout_async_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT pointer
    with length variable for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_INOUT '

    d = {}
    async_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] += inoutAsyncClientMarshallT.safe_substitute(d)
        func_attr_map['cb_unmarshall_list'] = outAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def out_async_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, pointer with
    length variable for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_OUT '

    d = {}
    async_as_ptr_with_length(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] = ''
        func_attr_map['cb_unmarshall_list'] = outAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def in_async_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type IN, reference for
    async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_IN '

    d = {}
    async_by_ref(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] = inAsyncClientMarshallT.safe_substitute(d)
        func_attr_map['cb_unmarshall_list'] = inAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def inout_async_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT, reference
    for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_INOUT '

    d = {}
    async_by_ref(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] = inoutAsyncClientMarshallT.safe_substitute(d)
        func_attr_map['cb_unmarshall_list'] = outAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def out_async_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, reference
    for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_OUT '

    d = {}
    async_by_ref(func_attr_map, arg_attr_map, d)

    if arg_attr_map['is_decl'] != '1':
        func_attr_map['call_marshall_list'] = ''
        func_attr_map['cb_unmarshall_list'] = outAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def in_async_by_val(arg_attr_map):
    '''Collating code snippets for parameter of type IN, value for
    async client stub.
    '''

    func_attr_map = {}

    d = {}
    d['call_member_func_type'] = arg_attr_map['type']
    d['call_marshall_entry'] = '&(' + arg_attr_map['name'] + ')'
    d['cb_member_func_type'] = arg_attr_map['type']
    d['cb_unmarshall_entry'] = d['call_marshall_entry']
    d['cb_error_marshall_entry'] = d['cb_unmarshall_entry']
    d['arg_num'] = arg_attr_map['arg_num']
    d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['call_decl'] = 'CL_IN ' + arg_attr_map['type'] + '  ' + arg_attr_map['name']
        func_attr_map['cb_decl'] = arg_attr_map['type'] + '  ' + arg_attr_map['name']
        func_attr_map['cb_memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + arg_attr_map['type'] + '))'
        func_attr_map['arg_list'] = arg_attr_map['name']
    else:                
        func_attr_map['cb_error_marshall_list'] = asyncUnmarshallErrorEntryT.safe_substitute(d)
        func_attr_map['call_marshall_list'] = inAsyncClientMarshallT.safe_substitute(d)
        func_attr_map['cb_unmarshall_list'] = inAsyncUnmarshallT.safe_substitute(d)

    return func_attr_map

def out_async_as_double_ptr(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, pointer with
    length variable for async client stub.
    '''

    func_attr_map = {}
    func_attr_map['call_decl'] = 'CL_OUT '

    async_as_double_ptr(func_attr_map, arg_attr_map, {})

    return func_attr_map

def create_async_func(func_attr_map):
    func_attr_map['call_decl'] = func_attr_map['call_decl'][:-2]
    func_attr_map['eo_name'] = func_attr_map['eo_name'][0].upper() + func_attr_map['eo_name'][1:]
    func_attr_map['cap_name'] = func_attr_map['name'][0].upper() + func_attr_map['name'][1:]

    in_ptr = func_attr_map['in_ptr'] + func_attr_map['inout_ptr']
    if in_ptr > 0:
        func_attr_map['temp1'] = '''
        ClUint32T temp1 = 0;'''
    else:
        func_attr_map['temp1'] = ''
    func_attr_map['rmd_cookie'] = '''

        pCookie = clHeapAllocate(sizeof(ClIdlCookieT));
        if (NULL == pCookie)
        {
            return CL_IDL_RC(CL_ERR_NO_MEMORY);
        }'''

    func_attr_map['create_out_msg'] = asyncCreateOutMsgT.safe_substitute()
    func_attr_map['delete_out_msg'] = deleteOutMsgT.safe_substitute()
    func_attr_map['flag_need_reply'] = ' | CL_RMD_CALL_NEED_REPLY'
    func_attr_map['cookie_callback'] = ',CL_IN ' + func_attr_map['eo_name'] + func_attr_map['cap_name'] + 'AsyncCallbackT%s fpAsyncCallback, CL_IN void *cookie' % func_attr_map['version']
    func_attr_map['async_callback_def'] = 'typedef void (*' + func_attr_map['eo_name'] + func_attr_map['cap_name'] + 'AsyncCallbackT%s) (CL_IN ClIdlHandleT handle' % func_attr_map['version'] + func_attr_map['call_decl'] + ''', CL_IN ClRcT rc, CL_IN void* pCookie);

'''
    if get_ver_suffix(idl_version) == func_attr_map['version']:
        func_attr_map['async_callback_def'] += 'typedef ' + func_attr_map['eo_name'] + func_attr_map['cap_name'] + 'AsyncCallbackT' + func_attr_map['version'] + ' ' + func_attr_map['eo_name'] + func_attr_map['cap_name'] + '''AsyncCallbackT;

'''                
    func_attr_map['async_callback'] = asyncCallbackT.safe_substitute(func_attr_map)
    func_attr_map['async_options_fill'] = asyncOptionsFillT.safe_substitute(func_attr_map)
    func_attr_map['return'] = '''    
    clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;

LL: clBufferDelete(&${out_msg});
L2:  clHeapFree(pCookie);
L:
     clHandleCheckin(gIdlClnt.idlDbHdl,handle);
    return rc;'''

    func_attr_map['error_label'] = 'LL'

    if func_attr_map['in_msg_needed'] > 0:
        func_attr_map['create_in_msg'] = asyncCreateInMsgT.safe_substitute()
    else:
        func_attr_map['create_in_msg'] = ''

    return asyncClientT.safe_substitute(func_attr_map)

def async_by_ref(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outAsyncByReference is made into a
    function and called in the respective functions.
    '''

    d['call_member_func_type'] = arg_attr_map['type']
    d['call_marshall_entry'] = arg_attr_map['name']
    d['cb_member_func_type'] = arg_attr_map['type']
    d['cb_unmarshall_entry'] = '&(' + arg_attr_map['name'] + ')'
    d['cb_error_marshall_entry'] = d['cb_unmarshall_entry']
    d['arg_num'] = arg_attr_map['arg_num']
    d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['call_decl'] += arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['cb_decl'] = arg_attr_map['type'] + '  ' + arg_attr_map['name']
        func_attr_map['cb_memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + arg_attr_map['type'] + '))'
        func_attr_map['arg_list'] = '&(' + arg_attr_map['name'] + ')'
    else:                
        func_attr_map['cb_error_marshall_list'] = asyncUnmarshallErrorEntryT.safe_substitute(d)

def async_as_ptr_with_length(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outAsyncAsPointerwithLength is made
    into a function and called in the respective functions.
    '''

    d['call_member_func_type'] = 'Array' + arg_attr_map['type']
    d['call_marshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
    d['cb_member_func_type'] = 'Ptr' + arg_attr_map['type']
    d['cb_unmarshall_entry'] = '(void**)&(' + arg_attr_map['name'] + '), '+ arg_attr_map['length_var']
    d['cb_error_marshall_entry'] = d['call_marshall_entry']
    d['arg_num'] = arg_attr_map['arg_num']
    d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1
    d['length_var'] = arg_attr_map['length_var']

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['call_decl'] += arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['cb_decl'] = arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['cb_memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + arg_attr_map['type'] + '*))'
        func_attr_map['arg_list'] = arg_attr_map['name']
    else:                
        func_attr_map['call_marshall_list'] = '' 
        func_attr_map['cb_error_marshall_list'] = asyncUnmarshallErrorEntryT.safe_substitute(d)

def async_as_double_ptr(func_attr_map, arg_attr_map, d):
    '''The common part of in/inout/outAsyncAsPointerwithLength is made
    into a function and called in the respective functions.
    '''

    d['call_member_func_type'] = 'Array' + arg_attr_map['type']
    d['call_marshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
    d['cb_member_func_type'] = 'Ptr' + arg_attr_map['type']
    d['cb_unmarshall_entry'] = '(void**)&(' + arg_attr_map['name'] + '), '+ arg_attr_map['length_var']
    d['cb_error_marshall_entry'] = d['call_marshall_entry']
    d['arg_num'] = arg_attr_map['arg_num']
    d['arg_num_plus_one'] = arg_attr_map['arg_num'] + 1
    d['length_var'] = arg_attr_map['length_var']

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['call_decl'] += arg_attr_map['type'] + '** ' + arg_attr_map['name']
        func_attr_map['cb_decl'] = arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['cb_memset'] = 'memset(&(' + arg_attr_map['name'] + '), 0, sizeof(' + arg_attr_map['type'] + '*))'
        func_attr_map['arg_list'] = '&'+ arg_attr_map['name']                
    else:
        func_attr_map['call_marshall_list'] = '' 
        func_attr_map['cb_error_marshall_list'] = asyncUnmarshallErrorEntryT.safe_substitute(d)
        func_attr_map['call_marshall_list'] = ''
        func_attr_map['cb_unmarshall_list'] = outAsyncUnmarshallT.safe_substitute(d)

def create_async_stub(s, ver, service_no, client_id, type_needed, e):
    '''This function creates the map gen_template with appropriate
    templates/functions and calls the create_stub to generate async
    client stub.
    '''

    gen_template = {
            'init' : async_init,
            
            'decl_append': async_decl_append,
            
            'append': async_append,
            
            'as_ptr_with_length': {
                    'in': in_async_as_ptr_with_length,

                    'inout': inout_async_as_ptr_with_length,

                    'out': out_async_as_ptr_with_length,
            },

            'by_ref': {
                    'in': in_async_by_ref,

                    'inout': inout_async_by_ref,

                    'out': out_async_by_ref,
            },

            'by_val': {
                    'in': in_async_by_val,

                    'inout': do_nothing,

                    'out': do_nothing,
            },

            'as_double_ptr': {
                    'in': do_nothing,

                    'inout': do_nothing,

                    'out': out_async_as_double_ptr,
            },

            'function': create_async_func,

            'header': asyncHeaderT,
    }
    return create_stub(s, ver, service_no, client_id, gen_template, type_needed, e, 1)

def sync_init(func_attr_map):
    l = ['name',
         'decl',
         'func_no',
         'marshall_list',
         'unmarshall_list',
         'temp1',
         'temp2',
         'ptr_checks',
         'out_msg_create',
         'out_msg_delete',
         'in_msg_create',
         'flag_need_reply',
        ]

    for key in l:
        func_attr_map[key] = ''

def sync_decl_append(func_attr_map, arg_entry_to_add):
    func_attr_map['decl'] += ', ' + arg_entry_to_add['decl']

def sync_append(func_attr_map, arg_entry_to_add):
    func_attr_map['marshall_list'] += arg_entry_to_add['marshall_list']
    func_attr_map['unmarshall_list'] += arg_entry_to_add['unmarshall_list']

#we have 7 types of parameters. They are described as follows:
# IN by value
# IN by reference
# IN as pointer with length variable
# INOUT by reference
# INOUT as pointer with length variable
# OUT by reference
# OUT as pointer with length variable
#There are subtle differences as to the code snippet generated
#for each of these parameter types. Therfore we have different
#functions for each of these types.

def in_sync_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type IN, pointer with
    length variable for sync client stub.
    '''

    func_attr_map = {}

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_IN ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = '' 
        func_attr_map['unmarshall_list'] = ''
    else:
        func_attr_map['decl'] = '' 
        marshall_map = {}
        marshall_map['member_func_type'] = 'Array' + arg_attr_map['type']
        marshall_map['marshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        marshall_map['unmarshall_entry'] = ''
        marshall_map['length_var'] = arg_attr_map['length_var']
        func_attr_map['marshall_list'] = inSyncClientMarshallT.safe_substitute(marshall_map)
        func_attr_map['unmarshall_list'] = ''

    return func_attr_map

def inout_sync_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT, pointer
    with length variable for sync client stub.
    '''

    func_attr_map = {}

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_INOUT ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = '' 
        func_attr_map['unmarshall_list'] = '' 
    else:
        func_attr_map['decl'] = ''
        marshall_map = {}
        marshall_map['member_func_type'] = 'Array' + arg_attr_map['type']
        marshall_map['marshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        marshall_map['unmarshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        marshall_map['length_var'] = arg_attr_map['length_var']
        func_attr_map['marshall_list'] = inoutSyncClientMarshallT.safe_substitute(marshall_map)
        func_attr_map['unmarshall_list'] = outSyncClientUnmarshallT.safe_substitute(marshall_map)

    return func_attr_map

def out_sync_as_ptr_with_length(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, pointer with
    length variable for sync client stub.
    '''

    func_attr_map = {}

    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_OUT ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['unmarshall_list'] = '' 
        func_attr_map['marshall_list'] = ''
    else:
        func_attr_map['decl'] = ''
        marshall_map = {}
        marshall_map['member_func_type'] = 'Array' + arg_attr_map['type']
        marshall_map['marshall_entry'] = ''
        marshall_map['unmarshall_entry'] = arg_attr_map['name'] + ', ' + arg_attr_map['length_var']
        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = outSyncClientUnmarshallT.safe_substitute(marshall_map)

    return func_attr_map

def in_sync_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type IN, reference for
    sync client stub.
    '''

    func_attr_map = {}
    marshall_map = {}
    marshall_map['member_func_type'] = arg_attr_map['type']
    marshall_map['marshall_entry'] = arg_attr_map['name']
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_IN ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = ''
    else:        
        func_attr_map['decl'] ='' 
        func_attr_map['marshall_list'] = inSyncClientMarshallT.safe_substitute(marshall_map)
        func_attr_map['unmarshall_list'] = ''

    return func_attr_map

def inout_sync_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type INOUT, reference
    for sync client stub.
    '''

    func_attr_map = {}
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_INOUT ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = '' 
        func_attr_map['unmarshall_list'] = ''
    else:
        func_attr_map['decl'] = '' 

        marshall_map = {}
        marshall_map['member_func_type'] = arg_attr_map['type']
        marshall_map['marshall_entry'] = arg_attr_map['name']
        marshall_map['unmarshall_entry'] = arg_attr_map['name']

        func_attr_map['marshall_list'] = inoutSyncClientMarshallT.safe_substitute(marshall_map)
        func_attr_map['unmarshall_list'] = outSyncClientUnmarshallT.safe_substitute(marshall_map)

    return func_attr_map

def out_sync_by_ref(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, reference
    for sync client stub.
    '''

    func_attr_map = {}
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_OUT ' + arg_attr_map['type'] + '* ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = '' 
    else:
        func_attr_map['decl'] = '' 

        marshall_map = {}
        marshall_map['member_func_type'] = arg_attr_map['type']
        marshall_map['unmarshall_entry'] = arg_attr_map['name']

        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = outSyncClientUnmarshallT.safe_substitute(marshall_map)

    return func_attr_map

def in_sync_by_val(arg_attr_map):
    '''Collating code snippets for parameter of type IN, value for
    sync client stub.
    '''

    func_attr_map = {}
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_IN ' + arg_attr_map['type'] + ' ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = '' 
        func_attr_map['unmarshall_list'] = ''
    else:
        func_attr_map['decl'] = ''

        marshall_map = {}
        marshall_map['member_func_type'] = arg_attr_map['type']
        marshall_map['marshall_entry'] = '&(' + arg_attr_map['name'] + ')'

        func_attr_map['marshall_list'] = inSyncClientMarshallT.safe_substitute(marshall_map)
        func_attr_map['unmarshall_list'] = ''

    return func_attr_map

def out_sync_as_double_ptr(arg_attr_map):
    '''Collating code snippets for parameter of type OUT, pointer with
    length variable for sync client stub.
    '''

    func_attr_map = {}
    if arg_attr_map['is_decl'] == '1':
        func_attr_map['decl'] = 'CL_OUT ' + arg_attr_map['type'] + '** ' + arg_attr_map['name']
        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = '' 
    else:
        func_attr_map['decl'] = '' 

        marshall_map = {}
        marshall_map['member_func_type'] = 'Ptr' + arg_attr_map['type']
        marshall_map['marshall_entry'] = ''
        marshall_map['unmarshall_entry'] = "(void **)"+ arg_attr_map['name'] + ', ' + '*'+ arg_attr_map['length_var']

        func_attr_map['marshall_list'] = ''
        func_attr_map['unmarshall_list'] = outSyncClientUnmarshallT.safe_substitute(marshall_map)

    return func_attr_map

def create_sync_func(func_attr_map):
    in_ptr = func_attr_map['in_ptr'] + func_attr_map['inout_ptr']
    out_ptr = func_attr_map['out_ptr'] + func_attr_map['inout_ptr']

    if out_ptr > 0:
        func_attr_map['temp1'] = '''
        ClUint32T temp1 = 0;'''
        func_attr_map['temp2'] = '''
        ClUint32T temp2 = 0;'''
    elif in_ptr > 0:
        func_attr_map['temp1'] = '''
        ClUint32T temp1 = 0;'''
        func_attr_map['temp2'] = ''
    else:
        func_attr_map['temp1'] = ''
        func_attr_map['temp2'] = ''

    if func_attr_map['reply_needed'] > 0:
        func_attr_map['create_out_msg'] = createOutMsgT.safe_substitute()
        func_attr_map['delete_out_msg'] = deleteOutMsgT.safe_substitute()
        func_attr_map['flag_need_reply'] = ' | CL_RMD_CALL_NEED_REPLY'
    else:
        func_attr_map['create_out_msg'] = ''
        func_attr_map['delete_out_msg'] = ''
        func_attr_map['delete_out_msg'] = ''
    if func_attr_map['in_msg_needed'] > 0:
        func_attr_map['create_in_msg'] = createInMsgT.safe_substitute()
    else:
        func_attr_map['create_in_msg'] = ''

    return syncClientT.safe_substitute(func_attr_map)

def create_sync_stub(s, ver, service_no, client_id, type_needed, e):
    '''This function creates the map gen_template with appropriate
    templates/functions and calls the createStub to generate sync
    stub.
    '''

    gen_template = {
            'init' : sync_init,
            
            'decl_append': sync_decl_append,
            
            'append': sync_append,
            
            'as_ptr_with_length': {
                    'in': in_sync_as_ptr_with_length,

                    'inout': inout_sync_as_ptr_with_length,

                    'out': out_sync_as_ptr_with_length,
            },

            'by_ref': {
                    'in': in_sync_by_ref,

                    'inout': inout_sync_by_ref,

                    'out': out_sync_by_ref,
            },

            'by_val': {
                    'in': in_sync_by_val,

                    'inout': do_nothing,

                    'out': do_nothing,
            },

            'as_double_ptr': {
                    'in': do_nothing,

                    'inout': do_nothing,

                    'out': out_sync_as_double_ptr,
            },

            'function': create_sync_func,

            'header': syncHeaderT,
    }

    return create_stub(s, ver, service_no, client_id, gen_template, type_needed, e, 0)

def gen_code_for_stub(tree, service):
    global options
    
    number = 0
    client_ids = ''

    type_needed = {}

    service_decl_list = ''
    eo_callback_func_list = ''

    server_map = {}

    for port_name in service['ports']:
        port = service[port_name]
        if port['use_native_table']:
            client_id = 'CL_EO_NATIVE_COMPONENT_TABLE_ID'
        else:
            client_id = port['id']

        if client_id != 'CL_EO_NATIVE_COMPONENT_TABLE_ID':
            def get_client_ids(port, client_id, number):
                reserved = port.get('def_need', None)
                if reserved and reserved.value.lower() == "yes":
                    client_id_def = clientIDHeaderT.safe_substitute(client_id=client_id,
                                                                    number=number)
                    return client_id_def

                return ''

            client_ids += get_client_ids(port, client_id, number)
            number += 1

        if 'start_func_id' in port:
            service_no = int(port[start_func_id])
        else:
            service_no = 0

        eo_callback_func_list = '\n'.join(["VSYM_EMPTY(NULL, %s(%s))" %
                                           (get_headers_define(port_name), i)
                                           for i in range(service_no)])

        for group_name in port['groups']:
            user_func_list = ''
            server_func_list = ''
            server_decls = ''
            sync_client_list = ''
            sync_client_decl = ''
            group = port[group_name]
            for op in group['ops']:
                for ver in op['versions']:
                    stub_gen = create_server_stub(op, ver, service_no, client_id, type_needed, service['name'])
                    server_func_list += stub_gen['code']
                    server_decls += stub_gen['header']
                    user_func_list += stub_gen['user_code']
                    service_decl_list += ''.join(['extern ClRcT ',
                                                  op['name'],
                                                  '''Server%s(ClEoDataT eoData, ClBufferHandleT inmSgHdl , ClBufferHandleT outMsgHdl);
''' % get_ver_suffix(ver)])

                    rel, maj, minor = ver.split('.')
                    eo_callback_func_list += ''.join(['\tVSYM_VER(%s, %s, %s, %s, %s),\n' %
                                                      (op['name']+'Server',
                                                       rel,
                                                       maj,
                                                       minor,
                                                       ''.join(['CL_EO_GET_FULL_FN_NUM(',
                                                                client_id,
                                                                ', ',
                                                                str(service_no),
                                                                ')']))])
                
                    stub_type = op[ver]['type']
                    if stub_type:
                        if stub_type == "sync":
                            stub_gen = create_sync_stub(op, ver, service_no, client_id, type_needed, service['name'])
                        elif stub_type == "async":
                            stub_gen = create_async_stub(op, ver, service_no, client_id, type_needed, service['name'])
                        else:
                            print stub_type
                            assert(0)

                        # TODO change name sync_client_list and
                        # sync_client_decl to client_list and
                        # client_decl resply.
                        sync_client_list += stub_gen['code']
                        sync_client_decl += stub_gen['header']
                    else:
                        for fn in [create_sync_stub, create_async_stub]:
                            stub_gen = fn(op, ver, service_no, client_id, type_needed, service['name'])
                            sync_client_list += stub_gen['code']
                            sync_client_decl += stub_gen['header']
                service_no += 1

            service_dir = os.path.dirname(service['xdr_dir'])
            common_h_file = open(os.path.join(service_dir, 'clientIDDefinitions.h'), 'w')
            common_h_file.write(clientIDHeader.safe_substitute(client_ids=client_ids, license=license))
            common_h_file.close()

            inc_list = ''.join([''.join(['#include "',
                                         get_h_file_name(udt),
                                         '''"
'''])
                            for udt in type_needed.keys()])
            
            symbol_map = {'rc': 'rc',
                          'in_msg': 'inMsgHdl',
                          'out_msg': 'outMsgHdl',
                          'pEoObj': 'pEoObj',
                          }

            server_map['server_func_list'] = server_func_list
            server_map['user_func_list'] = user_func_list
            server_map['service_decl_list'] = service_decl_list
            server_map['server_decls'] = server_decls
            server_map['eo'] = service['name'][0].upper() + service['name'][1:]
            server_map['eo_name'] = service['name']
            server_map['client'] = port_name
            server_map['group'] = group_name

            server_map['Service1'] = service['name'].upper()
            server_map['CLIENT'] = port_name.upper()
            server_map['GROUP'] = group_name.upper()
            server_map['xdr_inc_list'] = inc_list

            serverCodeT = Template(serverCFileT.safe_substitute(server_map))
            server_c_file = open(os.path.join(service['server_dir'], service['name']+port_name+group_name+'Server.c'), 'w')
            server_c_file.write(serverCodeT.safe_substitute(symbol_map))
            server_c_file.close()

            if options.user_func:
                userCodeT = Template(userCFileT.safe_substitute(server_map))
                user_c_file = open(os.path.join(service['server_dir'],
                                                  service['name']+port_name+group_name+'ServerStub.c'), 'w')
                user_c_file.write(userCodeT.safe_substitute(symbol_map))
                user_c_file.close()

            server_h_file = open(os.path.join(service['server_dir'], service['name']+port_name+group_name+'Server.h'), 'w')
            server_h_file.write(serverHFileT.safe_substitute(server_map))
            server_h_file.close()

            client_map = {}
            client_map['sync_client_list'] = sync_client_list
            client_map['sync_client_decl'] = sync_client_decl
            client_map['eo'] = service['name'][0].upper() + service['name'][1:]
            client_map['eo_name'] = service['name']
            client_map['client'] = port_name
            client_map['group'] = group_name
        
            client_map['CLIENT'] = get_headers_define(port_name)
            client_map['GROUP'] = get_headers_define(group_name)
            client_map['Service1'] = get_headers_define(service['name'])
            client_map['xdr_inc_list'] = inc_list
        
            clientCodeT = Template(clientCFileT.safe_substitute(client_map))
            client_c_file = open(os.path.join(service['client_dir'], service['name']+port_name+group_name+'Client.c'), 'w')
            client_c_file.write(clientCodeT.safe_substitute(symbol_map))
            client_c_file.close()
        
            client_h_file = open(os.path.join(service['client_dir'], service['name']+port_name+group_name+'Client.h'), 'w')
            client_h_file.write(clientHFileT.safe_substitute(client_map))
            client_h_file.close()

        commServerCodeT = Template(commServerCFileT.safe_substitute(server_map))
        comm_server_c_file = open(os.path.join(service['server_dir'], service['name']+'Server.c'), 'w')
        comm_server_c_file.write(commServerCodeT.safe_substitute(symbol_map))
        comm_server_c_file.close()
                                      
        comm_server_h_file = open(os.path.join(service['server_dir'], service['name']+'Server.h'), 'w')
        comm_server_h_file.write(commServerHFileT.safe_substitute(server_map))
        comm_server_h_file.close()

        commClientCodeT = Template(commClientCFileT.safe_substitute(client_map))
        comm_client_c_file = open(os.path.join(service['client_dir'], service['name']+'Client.c'), 'w')
        comm_client_c_file.write(commClientCodeT.safe_substitute(symbol_map))
        comm_client_c_file.close()

        comm_client_h_file = open(os.path.join(service['client_dir'], service['name']+'Client.h'), 'w')
        comm_client_h_file.write(commClientHFileT.safe_substitute(client_map))
        comm_client_h_file.close()

        eo_callback_table_map = {}
        eo_callback_table_map['eo'] = service['name'][0].upper() + service['name'][1:]
        eo_callback_table_map['eo_callback_func_list'] = eo_callback_func_list
        eo_callback_table_map['client_id'] = client_id

        eo_func_table_map = {}
        eo_func_table_map['eo'] = get_headers_define(service['name'])
        eo_func_table_map['eo_callback_table_decl'] = eoCallbackTableT.safe_substitute(eo_callback_table_map)
        eo_func_table_header = open(os.path.join(service['common_dir'], get_eo_func_header_name(service['name'])), 'w')
        eo_func_table_header.write(eoFuncTableHFileT.safe_substitute(eo_func_table_map))
        eo_func_table_header.close()

def write_make_files(tree):
    make_map = {}
    make_map['license'] = make_license

    if tree['stubs_needed']:
        for service in tree['services']:
            make_map['eo_name'] = service
            make_map['cap_eo_name'] = make_map['eo_name'][0].upper() + make_map['eo_name'][1:]
            make_map['svr_name'] = make_map['eo_name']

            top_mk_file = open(os.path.join(tree[service]['service_dir'], 'Makefile'), 'w')
            top_mk_file.write(topLevelMakeT.safe_substitute(make_map))
            top_mk_file.close()

            make_map['comp'] = ''
            make_map['lib_type'] = 'IdlOpen'
            
            if 'comps' in tree[service]:
                for comp in tree[service]['comps']:
                    make_map['comp'] += ' ' + comp

            xdr_mk_file = open(os.path.join(tree[service]['xdr_dir'], 'Makefile'), 'w')
            xdr_mk_file.write(xdrOpenMakeT.safe_substitute(make_map))
            xdr_mk_file.close()

            make_map['lib_type'] = 'Client'
            client_mk_file = open(os.path.join(tree[service]['client_dir'], 'Makefile'), 'w')
            client_mk_file.write(clientMakeT.safe_substitute(make_map))
            client_mk_file.close()

            make_map['lib_type'] = 'Server'
            server_mk_file = open(os.path.join(tree[service]['server_dir'], 'Makefile'), 'w')
            server_mk_file.write(clientMakeT.safe_substitute(make_map)) # ??
            server_mk_file.close()

            free_file = open(os.path.join(tree[service]['xdr_dir'], 'clIdlOpen.c'), 'w')
            free_file.write(freeFileT.safe_substitute(license=license))
            free_file.close()

        eo_name_list = ' '.join([e for e in tree['services']])
        top_idl_mk_file = open(os.path.join(tree['top_dir'], 'Makefile'), 'w')
        top_idl_mk_file.write(idlMakeT.safe_substitute(eo_list=eo_name_list, license=make_license))
        top_idl_mk_file.close()
    else:
        top_mk_file = open(os.path.join(tree['top_dir'], 'Makefile'), 'w')
        top_mk_file.write(topXdrMakeT.safe_substitute(make_map))
        top_mk_file.close()

        if 'comps' in tree:
            for comp in tree['comps']:
                make_map['comp'] = comp
                make_map['cap_comp'] = comp[0].upper() + comp[1:]

        xdr_mk_file = open(os.path.join(tree['xdr_dir'], 'Makefile'), 'w')
        xdr_mk_file.write(xdrMakeT.safe_substitute(make_map))
        xdr_mk_file.close()

        free_file = open(os.path.join(tree['xdr_dir'], 'clIdlOpen.c'), 'w')
        free_file.write(freeFileT.safe_substitute(license=license))
        free_file.close()

def delete_gen_files(d):
    if os.path.exists(d):
        os.system('find %s -iname \'*.[ch]\' -exec rm -f {} \;' % d)

def generate_code(tree):
    need_stubs = tree['stubs_needed']
    if need_stubs:
        for service in tree['services']:
            if 'structs' in tree[service]:
                for struct in tree[service]['structs']:
                    gen_code_for_struct(tree[service], struct)
            if 'unions' in tree[service]:
                for union in tree[service]['unions']:
                    gen_code_for_union(tree[service], union)
            if 'enums' in tree[service]:
                for enum in tree[service]['enums']:
                    gen_code_for_enum(tree[service], enum)

            gen_code_for_stub(tree, tree[service])
    else:
        if 'structs' in tree:
            for struct in tree['structs']:
                gen_code_for_struct(tree, struct)
        if 'unions' in tree:
            for union in tree['unions']:
                gen_code_for_union(tree, union)
        if 'enums' in tree:
            for enum in tree['enums']:
                gen_code_for_enum(tree, enum)

    write_make_files(tree)

def main():
    global options
    import optparse

    usage = 'usage: %prog [options] idl_file.xml directory-name'
    parser = optparse.OptionParser(usage)
    parser.add_option('-a', '--asp-dir',
                      action='store',
                      dest='asp_dir',
                      default=None,
                      metavar='path-to-asp-dir',
                      help='path to the ASP location')
    parser.add_option('-p',
                      action='store_true',
                      dest='print_tree',
                      default=False,
                      help='print parse tree and exit')
    parser.add_option('-u', '--user-func-template',
                      action='store_true',
                      dest='user_func',
                      default=False,
                      help='generate empty user server stubs')
    parser.add_option('-t', '--typedef',
                      action='store_true',
                      dest='typedef',
                      default=False,
                      help='automatically convert typedefs')

    options, args = parser.parse_args()

    if len(args) != 2:
        parser.error('too few arguments.')

    if options.typedef and not options.asp_dir:
        parser.error('-t argument requires -a argument.')

    if os.path.splitext(args[0])[1] != '.xml':
        parser.error('IDL file does not have xml as its extension.')

    idl_file = args[0]
    dir_name = os.path.abspath(args[1])

    tree = create_tree(idl_file)
    create_dir_structure(tree, dir_name)
    if options.print_tree:
        import pprint
        pprint.pprint(tree)
        sys.exit(0)

    delete_gen_files(dir_name)
    generate_code(tree)

if __name__ == '__main__':
    sys.exit(main())

# Local Variables:
# indent-tabs-mode: nil
# End:
