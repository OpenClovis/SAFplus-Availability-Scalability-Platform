/*
 * Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office
 * 
 * This program is  free software; you can redistribute it and / or
 * modify  it under  the  terms  of  the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You  should  have  received  a  copy of  the  GNU General Public
 * License along  with  this program. If  not,  write  to  the 
 * Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/******************************************************************************
 *
 * clCompAppMain.c
 *
 ***************************** Legal Notice ***********************************
 *
 * This file is autogenerated by OpenClovis IDE, Copyright (C) 2002-2006 by 
 * OpenClovis. All rights reserved.
 *
 ***************************** Description ************************************
 *
 * This file provides a skeleton for writing a SAF aware component. Application
 * specific code should be added between the ---BEGIN_APPLICATION_CODE--- and
 * ---END_APPLICATION_CODE--- separators.
 *
 * Template Version: 1.0
 *
 ***************************** Editor Commands ********************************
 * For vi/vim
 * :set shiftwidth=4
 * :set softtabstop=4
 * :set expandtab
 *****************************************************************************/

/******************************************************************************
 * Include files needed to compile this file
 *****************************************************************************/

/*
 * POSIX Includes.
 */
 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>

/*
 * Basic ASP Includes.
 */

#include <clCommon.h>
#include <clOsalApi.h>
#include <clIocServices.h>

/*
 * ASP Client Includes.
 */

#include <clRmdApi.h>
#include <clDebugApi.h>
#include <clOmApi.h>
#include <clOampRtApi.h>
#include <clProvApi.h>
#include <clAlarmApi.h>
#include <clEventExtApi.h>
#include <clCorUtilityApi.h>

#include <clEoApi.h>
#include <clCpmApi.h>
#include <clIdlApi.h>


/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#include "./clCompAppMainTest.h"
#include "clAlarmErrors.h"
#include "clAlarmIpi.h"

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Optional Features
 *****************************************************************************/

/*
 * This is necessary if the component wishes to provide a service that will
 * be used by other components.
 */

#if HAS_EO_SERVICES

extern ClRcT idlClientInstall(void);

#endif

/*
 * This template has a few default clprintfs. These can be disabled by 
 * changing clprintf to a null function
 */

/*
 * ---BEGIN_APPLICATION_CODE---
 */
 
#define clprintf(...)   printf(__VA_ARGS__)

/*
 * ---END_APPLICATION_CODE---
 */

/******************************************************************************
 * Global Variables.
 *****************************************************************************/

pid_t mypid;
ClCpmHandleT cpmHandle;
ClTimerHandleT gComponentTimerHandle;

/*
 * Description of this EO
 */

ClEoConfigT clEoConfig =
{
    COMP_EO_NAME,               /* EO Name                                  */
    COMP_EO_THREAD_PRIORITY,    /* EO Thread Priority                       */
    COMP_EO_NUM_THREAD,         /* No of EO thread needed                   */
    COMP_IOC_PORT,              /* Required Ioc Port                        */
    COMP_EO_USER_CLIENT_ID, 
    COMP_EO_USE_THREAD_MODEL,   /* Thread Model                             */
    clCompAppInitialize,        /* Application Initialize Callback          */
    clCompAppFinalize,          /* Application Terminate Callback           */
    clCompAppStateChange,       /* Application State Change Callback        */
    clCompAppHealthCheck,       /* Application Health Check Callback        */
};

/*
 * Basic libraries used by this EO. The first 6 libraries are mandatory, the
 * others can be enabled or disabled by setting to CL_TRUE or CL_FALSE.
 */

ClUint8T clEoBasicLibs[] =
{
    COMP_EO_BASICLIB_OSAL,      /* Lib: Operating System Adaptation Layer   */
    COMP_EO_BASICLIB_TIMER,     /* Lib: Timer                               */
    COMP_EO_BASICLIB_BUFFER,    /* Lib: Buffer Management                   */
    COMP_EO_BASICLIB_IOC,       /* Lib: Intelligent Object Communication    */
    COMP_EO_BASICLIB_RMD,       /* Lib: Remote Method Dispatch              */
    COMP_EO_BASICLIB_EO,        /* Lib: Execution Object                    */
    COMP_EO_BASICLIB_OM,        /* Lib: Object Management                   */
    COMP_EO_BASICLIB_HAL,       /* Lib: Hardware Adaptation Layer           */
    COMP_EO_BASICLIB_DBAL,      /* Lib: Database Adaptation Layer           */
};

/*
 * Client libraries used by this EO. All are optional and can be enabled
 * or disabled by setting to CL_TRUE or CL_FALSE.
 */

ClUint8T clEoClientLibs[] =
{
    COMP_EO_CLIENTLIB_COR,      /* Lib: Common Object Repository            */
    COMP_EO_CLIENTLIB_CM,       /* Lib: Chassis Management                  */
    COMP_EO_CLIENTLIB_NAME,     /* Lib: Name Service                        */
    COMP_EO_CLIENTLIB_LOG,      /* Lib: Log Service                         */
    COMP_EO_CLIENTLIB_TRACE,    /* Lib: Trace Service                       */
    COMP_EO_CLIENTLIB_DIAG,     /* Lib: Diagnostics                         */
    COMP_EO_CLIENTLIB_TXN,      /* Lib: Transaction Management              */
    CL_FALSE,                   /* NA */
    COMP_EO_CLIENTLIB_PROV,     /* Lib: Provisioning Management             */
    COMP_EO_CLIENTLIB_ALARM,    /* Lib: Alarm Management                    */
    COMP_EO_CLIENTLIB_DEBUG,    /* Lib: Debug Service                       */
    COMP_EO_CLIENTLIB_GMS       /* Lib: Cluster/Group Membership Service    */
};

/******************************************************************************
 * Application Life Cycle Management Functions
 *****************************************************************************/
/*
 * Global timer handle 
 */
ClTimerHandleT gTimerHandle;

/*
 * This test case will run successfully with the assumption that the 
 * moid on which this alarm is going to be raised has already been created
 */

ClRcT clComponentCallBack(void *arg)
{

    ClRcT rc = CL_OK;
    struct timeval alarmTime;
    ClAlarmHandleT alarmHandle;
    ClNameT moidName = {strlen("\\Chassis:0\\GigeBlade:0"),
                        "\\Chassis:0\\GigeBlade:0"};
    ClNameT moidName2 = {strlen("\\Chassis:0\\GigeBlade:0\\GigePort:0"),
                        "\\Chassis:0\\GigeBlade:0\\GigePort:0"};

    ClAlarmInfoT *pAlarmInfo;
    ClCorMOIdT   moId;
    ClNameT      moIdName = {0};

    pAlarmInfo = clHeapAllocate(sizeof(ClAlarmInfoT)+strlen("HelloHelloHelloHelloHelloHelloHelloHello")+1);
    if(pAlarmInfo == NULL)
    {
        clOsalPrintf("Failed while allocating the memory for the alamr information.");
        return CL_ALARM_RC(CL_ERR_NO_MEMORY);
    }

    clCpmComponentNameGet(0,&(pAlarmInfo->compName));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, (" CompName : %s\n", pAlarmInfo->compName.value));
    clCorMoIdNameToMoIdGet(&moidName,&(pAlarmInfo->moId));

    pAlarmInfo->alarmState      = CL_ALARM_STATE_ASSERT;
    pAlarmInfo->category        = CL_ALARM_CATEGORY_QUALITY_OF_SERVICE;
    pAlarmInfo->specificProblem = 0;
    pAlarmInfo->severity        = CL_ALARM_SEVERITY_CRITICAL;
    gettimeofday(&alarmTime,NULL);
    pAlarmInfo->eventTime       = alarmTime.tv_sec;
    pAlarmInfo->len = strlen("HelloHelloHelloHelloHelloHelloHelloHello")+1;
    memcpy(pAlarmInfo->buff,"HelloHelloHelloHelloHelloHelloHelloHello",pAlarmInfo->len);

    ClEoExecutionObjT* peoObj=(ClEoExecutionObjT *)arg;
    if ( (rc = clEoMyEoObjectSet(peoObj)) != CL_OK)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, (" clEoMyEoObjectSet failed, rc:0x%x \n", rc));
        return rc;
    }

	/**
	  * Raising alarm for :
	  * MOId -  /Chassis:0/GigeBlade:0
	  * Category - CL_ALARM_CATEGORY_QUALITY_OF_SERVICE
	  * Probable Cause - CL_ALARM_PROB_CAUSE_BANDWIDTH_REDUCED
	  */
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Raising alarm for [%s] and the probable cause\
			[%d]", moidName.value, CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME));
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_BANDWIDTH_REDUCED;
    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);

	/**
	  * Raising alarm for :
	  * MOId - /Chassis:0/GigeBlade:0
	  * Category -  CL_ALARM_CATEGORY_QUALITY_OF_SERVICE
	  * Probable Cause - CL_ALARM_PROB_CAUSE_RESPONSE_TIME_EXCESSIVE
	  */
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_RESPONSE_TIME_EXCESSIVE;
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Raising alarm for [%s] and the probable \
		cause [%d]", moidName.value, CL_ALARM_PROB_CAUSE_RESPONSE_TIME_EXCESSIVE));
    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm Category : %d \n",pAlarmInfo->category ));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm severity: %d \n",pAlarmInfo->severity));

    rc = clAlarmClientResourceInfoGet(alarmHandle, &moId);
    if ( CL_OK != rc)
    {
        clOsalPrintf("Failed while asking the moid for the alarm handle [%d]. rc[0x%x] \n", alarmHandle, rc);
        return rc;
    }

    rc = clCorMoIdToMoIdNameGet(&moId, &moIdName);
    if(CL_OK != rc)
    {
        clOsalPrintf("Failed while getting the mOId name from moid . rc[0x%x]", rc) ;
        return rc;
    }

    clOsalPrintf("The MOID for the alarm handle is [%d] is [%s]\n", alarmHandle, moIdName.value);
	/**
	  * Raising alarm for :
	  * MOId - /Chassis:0/GigeBlade:0/GigePort:0
	  * Category - CL_ALARM_CATEGORY_QUALITY_OF_SERVICE
	  * Probable Cause - CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME
	  */
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Raising alarm for [%s] and the probable \
				cause [%d]", moidName2.value, CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME));
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME;
    clCorMoIdNameToMoIdGet(&moidName2,&(pAlarmInfo->moId));

    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm Category : %d \n",pAlarmInfo->category ));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm severity: %d \n",pAlarmInfo->severity));

    rc = clAlarmClientResourceInfoGet(alarmHandle, &moId);
    if ( CL_OK != rc)
    {
        clOsalPrintf("Failed while asking the moid for the alarm handle [%d]. rc[0x%x] \n", alarmHandle, rc);
        return rc;
    }

    rc = clCorMoIdToMoIdNameGet(&moId, &moIdName);
    if(CL_OK != rc)
    {
        clOsalPrintf("Failed while getting the mOId name from moid . rc[0x%x]", rc) ;
        return rc;
    }

    clOsalPrintf("The MOID for the alarm handle is [%d] is [%s]\n", alarmHandle, moIdName.value);
	/**
	  * Raising alarm for :
	  * MOId -  /Chassis:0/GigeBlade:0/GigePort:0
	  * Category - CL_ALARM_CATEGORY_QUALITY_OF_SERVICE 
	  * Probable Cause - CL_ALARM_PROB_CAUSE_MULTIPLEXER_PROBLEM 
	  */
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Raising alarm for [%s] and the probable \
				cause [%d]", moidName2.value, CL_ALARM_PROB_CAUSE_MULTIPLEXER_PROBLEM));
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_MULTIPLEXER_PROBLEM;
    clCorMoIdNameToMoIdGet(&moidName2,&(pAlarmInfo->moId));
    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm Category : %d \n",pAlarmInfo->category ));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm severity: %d \n",pAlarmInfo->severity));


	/**
	  * Clearing alarm for :
	  * MOId - /Chassis:0/GigeBlade:0/GigePort:0 
	  * Category - CL_ALARM_CATEGORY_QUALITY_OF_SERVICE
	  * Probable Cause - CL_ALARM_PROB_CAUSE_MULTIPLEXER_PROBLEM
	  */
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Clearing alarm for [%s] and the probable \
				cause [%d]", moidName.value, CL_ALARM_PROB_CAUSE_MULTIPLEXER_PROBLEM));
    pAlarmInfo->alarmState = CL_ALARM_STATE_CLEAR;
    clCorMoIdNameToMoIdGet(&moidName2,&(pAlarmInfo->moId));
    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm Category : %d \n",pAlarmInfo->category ));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm severity: %d \n",pAlarmInfo->severity));

	/**
	  * Clearing alarm for :
	  * MOId - /Chassis:0/GigeBlade:0/GigePort:0 
	  * Category - CL_ALARM_CATEGORY_QUALITY_OF_SERVICE
	  * Probable Cause - CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME
	  */
    CL_DEBUG_PRINT(CL_DEBUG_ERROR,("Raising alarm for [%s] and the probable \
				cause [%d]", moidName.value, CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME));
    pAlarmInfo->probCause = CL_ALARM_PROB_CAUSE_LOSS_OF_FRAME;
    rc = clAlarmRaise(pAlarmInfo,&alarmHandle);
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm Category : %d \n",pAlarmInfo->category ));
    CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("Alarm severity: %d \n",pAlarmInfo->severity));
    return rc;
}
ClRcT clComponentTimerInit(ClEoExecutionObjT* peoObj)
{
    ClRcT    rc = CL_OK;
    ClTimerTimeOutT     ComponentTimeOut = {0,0};
    

    ComponentTimeOut.tsSec = 0;
    ComponentTimeOut.tsMilliSec = COMPONENT_CALLBACK_TIME;
    
    rc= clTimerCreate(ComponentTimeOut,
                      CL_TIMER_ONE_SHOT,
                      CL_TIMER_SEPARATE_CONTEXT,
                      clComponentCallBack,
                      (void*)peoObj,
                      &gComponentTimerHandle);

    if (CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, (" clTimerCreate failed with rc: 0x%x \n", rc));
        return rc;
    }

    rc = clTimerStart(gComponentTimerHandle);
    if (CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, (" clTimerStart failed with rc: 0x%x \n", rc));
        return rc;
    }

    return rc;
}

/*
 * clCompAppInitialize
 * -------------------
 * This function is invoked when the application is to be initialized.
 */

ClRcT
clCompAppInitialize(
    ClUint32T argc,
    ClCharT *argv[])
{
    ClNameT             appName;
    ClCpmCallbacksT     callbacks;
    ClVersionT          version;
    ClIocPortT          iocPort;
    ClRcT               rc = CL_OK;

    ClEoExecutionObjT*   eoObj;
    
    rc = clEoMyEoObjectGet(&eoObj);
    if(CL_OK != rc)
    {
        CL_DEBUG_PRINT(CL_DEBUG_ERROR, ("clEoMyEoObjectGet failed [%x]",rc));
        CL_FUNC_EXIT();
        return rc;
    }

    /*
     * Get the pid for the process and store it in global variable.
     */

    mypid = getpid();

    /*
     * Initialize and register with CPM. 'version' specifies the version of
     * AMF with which this application would like to interface. 'callbacks'
     * is used to register the callbacks this component expects to receive.
     */

    version.releaseCode                         = 'B';
    version.majorVersion                        = 01;
    version.minorVersion                        = 01;
    
    callbacks.appHealthCheck                    = NULL;
    callbacks.appTerminate                      = clCompAppTerminate;
    callbacks.appCSISet                         = clCompAppAMFCSISet;
    callbacks.appCSIRmv                         = clCompAppAMFCSIRemove;
    callbacks.appProtectionGroupTrack           = NULL;
        
    /*
     * Get IOC Address, Port and Name. Register with AMF.
     */

    clEoMyEoIocPortGet(&iocPort);

    if ( (rc = clCpmClientInitialize(&cpmHandle, &callbacks, &version)) ) 
        goto errorexit;

    /*
     * If this component will provide a service, register it now.
     */

#if HAS_EO_SERVICES
    idlClientInstall();
#endif

    /*
     * Do the application specific initialization here.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    /*
     * Now register the component with AMF. At this point it is
     * ready to provide service, i.e. take work assignments.
     */

    if ( (rc = clCpmComponentNameGet(cpmHandle, &appName)) ) 
        goto errorexit;
    if ( (rc = clCpmComponentRegister(cpmHandle, &appName, NULL)) ) 
        goto errorexit;
    sleep(25);
    if ( (rc = clComponentTimerInit(eoObj)) ) 
        goto errorexit;

    /*
     * Print out standard information for this component.
     */

    clprintf ("Component [%s] : PID [%d]. Initializing\n", appName.value, mypid);
    clprintf ("   IOC Address             : 0x%x\n", clIocLocalAddressGet());
    clprintf ("   IOC Port                : 0x%x\n", iocPort);

    /*
     * This is where the application code starts. If the main thread usage
     * policy is CL_EO_USE_THREAD_FOR_APP, then return from this fn only 
     * after the application terminates. If the main thread usage policy is
     * CL_EO_USE_THREAD_FOR_RECV, then return from this fn after doing the
     * application specific initialization and registration.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

      clOsalPrintf("Coming here .. in the alamr test comp2 ............. ####### \n \n");
    /*
     * ---END_APPLICATION_CODE---
     */

    return rc;

errorexit:

    clprintf ("Component [%s] : PID [%d]. Initialization error [0x%x]\n",
              appName.value, mypid, rc);

    return rc;
}

/*
 * clCompAppFinalize
 * -----------------
 * This function is invoked when the application is to be terminated.
 */

ClRcT clCompAppFinalize()
{
    return CL_OK;
}

/*
 * clCompAppTerminate
 * ------------------
 * This function is invoked when the application is to be terminated.
 */

ClRcT
clCompAppTerminate(
    ClInvocationT       invocation,
    const ClNameT       *compName)
{
    ClRcT rc = CL_OK;

    clprintf ("Component [%s] : PID [%d]. Terminating\n",
              compName->value, mypid);

    /*
     * ---BEGIN_APPLICATION_CODE--- 
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */
    
    /*
     * Unregister with AMF and send back a response
     */

    if ( (rc = clCpmComponentUnregister(cpmHandle, compName, NULL)) )
        goto errorexit;
    if ( (rc = clCpmClientFinalize(cpmHandle)) )
        goto errorexit;

    clCpmResponse(cpmHandle, invocation, CL_OK);

    clprintf ("Component [%s] : PID [%d]. Terminated\n", compName->value, mypid);

    return rc;

errorexit:

    clprintf ("Component [%s] : PID [%d]. Termination error [0x%x]\n",
              compName->value, mypid, rc);

    return rc;
}

/*
 * clCompAppStateChange
 * ---------------------
 * This function is invoked to change the state of an EO.
 */

ClRcT
clCompAppStateChange(
    ClEoStateT eoState)
{
    switch (eoState)
    {
        case CL_EO_STATE_SUSPEND:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }

        case CL_EO_STATE_RESUME:
        {
            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            break;
        }
        
        default:
        {
            break;
        }
    }
 
    return CL_OK;
}

/*
 * clCompAppHealthCheck
 * --------------------
 * This function is invoked to perform a healthcheck on the application. The
 * health check logic is application specific.
 */

ClRcT
clCompAppHealthCheck(
    ClEoSchedFeedBackT* schFeedback)
{
    /*
     * Add code for application specific health check below. The defaults
     * indicate EO is healthy and polling interval is unaltered.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */
    
    schFeedback->freq   = CL_EO_DEFAULT_POLL; 
    schFeedback->status = CL_CPM_EO_ALIVE;

    /*
     * ---END_APPLICATION_CODE---
     */

    return CL_OK;
}

/******************************************************************************
 * Application Work Assignment Functions
 *****************************************************************************/

/*
 * clCompAppAMFCSISet
 * ------------------
 * This function is invoked when a CSI assignment is made or the state
 * of a CSI is changed.
 */

ClRcT
clCompAppAMFCSISet(
    ClInvocationT       invocation,
    const ClNameT       *compName,
    ClAmsHAStateT       haState,
    ClAmsCSIDescriptorT csiDescriptor)
{
    /*
     * Print information about the CSI Set
     */

    clprintf ("Component [%s] : PID [%d]. CSI Set Received\n", 
              compName->value, mypid);

    clCompAppAMFPrintCSI(csiDescriptor, haState);

    /*
     * Take appropriate action based on state
     */

    switch ( haState )
    {
        case CL_AMS_HA_STATE_ACTIVE:
        {
            /*
             * AMF has requested application to take the active HA state 
             * for the CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_STANDBY:
        {
            /*
             * AMF has requested application to take the standby HA state 
             * for this CSI.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCED:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active or quiescing HA state. The application 
             * must stop work associated with the CSI immediately.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmResponse(cpmHandle, invocation, CL_OK);
            break;
        }

        case CL_AMS_HA_STATE_QUIESCING:
        {
            /*
             * AMF has requested application to quiesce the CSI currently
             * assigned the active HA state. The application must stop work
             * associated with the CSI gracefully and not accept any new
             * workloads while the work is being terminated.
             */

            /*
             * ---BEGIN_APPLICATION_CODE---
             */

            // ...

            /*
             * ---END_APPLICATION_CODE---
             */

            clCpmCSIQuiescingComplete(cpmHandle, invocation, CL_OK);
            break;
        }

        default:
        {
            /*
             * Should never happen. Ignore.
             */
        }
    }

    return CL_OK;
}

/*
 * clCompAppAMFCSIRemove
 * ---------------------
 * This function is invoked when a CSI assignment is to be removed.
 */

ClRcT
clCompAppAMFCSIRemove(
    ClInvocationT       invocation,
    const ClNameT       *compName,
    const ClNameT       *csiName,
    ClAmsCSIFlagsT      csiFlags)
{
    /*
     * Print information about the CSI Remove
     */

    clprintf ("Component [%s] : PID [%d]. CSI Remove Received\n", 
              compName->value, mypid);

    clprintf ("   CSI                     : %s\n", csiName->value);
    clprintf ("   CSI Flags               : 0x%x\n", csiFlags);

    /*
     * Add application specific logic for removing the work for this CSI.
     */

    /*
     * ---BEGIN_APPLICATION_CODE---
     */

    // ...

    /*
     * ---END_APPLICATION_CODE---
     */

    clCpmResponse(cpmHandle, invocation, CL_OK);

    return CL_OK;
}

/******************************************************************************
 * Utility functions 
 *****************************************************************************/

/*
 * clCompAppAMFPrintCSI
 * --------------------
 * Print information received in a CSI set request.
 */

ClRcT
clCompAppAMFPrintCSI(
    ClAmsCSIDescriptorT csiDescriptor,
    ClAmsHAStateT haState)
{
    clprintf ("   CSI                     : %s\n", 
            csiDescriptor.csiName.value);
    clprintf ("   HA State                : %s\n",
            STRING_HA_STATE(haState));
    clprintf ("   CSI Flags               : 0x%x\n",
            csiDescriptor.csiFlags);
    clprintf ("   Active Descriptor       : \n");
    clprintf ("       Active Component    : %s\n",
        csiDescriptor.csiStateDescriptor.activeDescriptor.activeCompName.value);
    clprintf ("   Standby Descriptor      : \n");
    clprintf ("       Standby Rank        : %d\n",
        csiDescriptor.csiStateDescriptor.standbyDescriptor.standbyRank);
    clprintf ("       Active Component    : %s\n",
        csiDescriptor.csiStateDescriptor.standbyDescriptor.activeCompName.value);

    clprintf ("   Name Value Pairs        : \n");
    for (ClUint32T i = 0; i < csiDescriptor.csiAttributeList.numAttributes; i++)
    {
        clprintf ("       Name            : %s\n",
                csiDescriptor.csiAttributeList.attribute[i].attributeName);
        clprintf ("       Value           : %s\n",
                csiDescriptor.csiAttributeList.attribute[i].attributeValue);
    }

    return CL_OK;
}

