/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "ckptEockptServerPeerPeerServer.h"
#include "ckptEoServer.h"

extern ClUint32T  ckptEoidlSyncKey;
extern ClHandleDatabaseHandleT  ckptEoidlDatabaseHdl;



ClRcT clCkptAllReplicaPresenceListUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  inVersion;
    ClHandleT  ckptActiveHdl;
    ClUint32T  peerAddr;

    memset(&(inVersion), 0, sizeof(ClVersionT));
    memset(&(ckptActiveHdl), 0, sizeof(ClHandleT));
    memset(&(peerAddr), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(inVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptActiveHdl));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptAllReplicaPresenceListUpdate_4_0_0(inVersion, ckptActiveHdl, peerAddr);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(inVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
LL1:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
LL0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(inVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
L2:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);


    return rc;
}

ClRcT clCkptAllReplicaPresenceListUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptRemSvrWelcomeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClUint32T  peerAddr;
    ClUint8T  credential;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(peerAddr), 0, sizeof(ClUint32T));
    memset(&(credential), 0, sizeof(ClUint8T));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint8T( inMsgHdl,&(credential));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptRemSvrWelcome_4_0_0(&(pVersion), peerAddr, credential);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint8T(&(credential), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
LL1:  clXdrMarshallClUint8T(&(credential), 0, 1);
LL0:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
L1:  clXdrMarshallClUint8T(&(credential), 0, 1);

L2:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;
}

ClRcT clCkptRemSvrWelcomeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  ClVersionT  pVersion)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClVersionT(&(pVersion), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L3:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptRemSvrByeServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  pVersion;
    ClUint32T  peerAddr;
    ClUint32T  portId;
    ClUint32T  flags;

    memset(&(pVersion), 0, sizeof(ClVersionT));
    memset(&(peerAddr), 0, sizeof(ClUint32T));
    memset(&(portId), 0, sizeof(ClUint32T));
    memset(&(flags), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(peerAddr));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(portId));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(flags));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptRemSvrBye_4_0_0(pVersion, peerAddr, portId, flags);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(pVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(peerAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(portId), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(flags), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L4:    return rc;

LL3:  clXdrMarshallClUint32T(&(flags), 0, 1);
LL2:  clXdrMarshallClUint32T(&(portId), 0, 1);
LL1:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
LL0:  clXdrMarshallClVersionT(&(pVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(pVersion), 0, 1);
L1:  clXdrMarshallClUint32T(&(peerAddr), 0, 1);
L2:  clXdrMarshallClUint32T(&(portId), 0, 1);
L3:  clXdrMarshallClUint32T(&(flags), 0, 1);


    return rc;
}

ClRcT clCkptRemSvrByeResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptNackReceiveServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClVersionT  version;
    ClUint32T  nackId;

    memset(&(version), 0, sizeof(ClVersionT));
    memset(&(nackId), 0, sizeof(ClUint32T));


    rc = clXdrUnmarshallClVersionT( inMsgHdl,&(version));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(nackId));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptNackReceive_4_0_0(version, nackId);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClVersionT(&(version), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(nackId), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L2:    return rc;

LL1:  clXdrMarshallClUint32T(&(nackId), 0, 1);
LL0:  clXdrMarshallClVersionT(&(version), 0, 1);

    return rc;

L0:  clXdrMarshallClVersionT(&(version), 0, 1);
L1:  clXdrMarshallClUint32T(&(nackId), 0, 1);


    return rc;
}

ClRcT clCkptNackReceiveResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clCkptMasterStatusInfoGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  ckptActiveHdl;
    ClInt64T  time;
    ClUint32T  actAddr;
    ClUint32T  refCount;
    ClUint8T  flag;

    memset(&(ckptActiveHdl), 0, sizeof(ClHandleT));
    memset(&(time), 0, sizeof(ClInt64T));
    memset(&(actAddr), 0, sizeof(ClUint32T));
    memset(&(refCount), 0, sizeof(ClUint32T));
    memset(&(flag), 0, sizeof(ClUint8T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(ckptActiveHdl));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(ckptEoidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clCkptMasterStatusInfoGet_4_0_0(ckptActiveHdl, &(time), &(actAddr), &(refCount), &(flag));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClInt64T(&(time), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(actAddr), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(refCount), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint8T(&(flag), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

L5:    return rc;

LL0:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(ckptActiveHdl), 0, 1);

L1:  clXdrMarshallClInt64T(&(time), 0, 1);
L2:  clXdrMarshallClUint32T(&(actAddr), 0, 1);
L3:  clXdrMarshallClUint32T(&(refCount), 0, 1);
L4:  clXdrMarshallClUint8T(&(flag), 0, 1);

    return rc;
}

ClRcT clCkptMasterStatusInfoGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClInt64T  time,CL_OUT  ClUint32T  actAddr,CL_OUT  ClUint32T  refCount,CL_OUT  ClUint8T  flag)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(ckptEoidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClInt64T(&(time), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(actAddr), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClUint32T(&(refCount), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint8T(&(flag), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L2:  clXdrMarshallClInt64T(&(time), 0, 1);
L3:  clXdrMarshallClUint32T(&(actAddr), 0, 1);
L4:  clXdrMarshallClUint32T(&(refCount), 0, 1);
L5:  clXdrMarshallClUint8T(&(flag), 0, 1);

    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(ckptEoidlDatabaseHdl, idlHdl);
    clHandleDestroy(ckptEoidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

