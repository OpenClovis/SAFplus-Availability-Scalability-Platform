/*
 * Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office.
 * 
 * This program is  free software; you can redistribute it and / or
 * modify  it under  the  terms  of  the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You  should  have  received  a  copy of  the  GNU General Public
 * License along  with  this program. If  not,  write  to  the 
 * Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*
 * Build: 4.2.0
 */
/*******************************************************************************
 * ModuleName  : amf
 * File        : clAmsMgmtClientRmd.c
 *******************************************************************************/

/*******************************************************************************
 * Description :
 * High-level RMD functions for the AMS client side.  These should be
 * eventually autogenerated, but for now written by hand.
 *****************************************************************************/

#include <clCommon.h>
#include <clCommonErrors.h>
#include <clDebugApi.h>
#include <clBufferApi.h>
#include <clAmsDebug.h>
#include <clAmsErrors.h>
#include <clAmsMgmtClientRmd.h>
#include <clCpmApi.h>
#include <xdrClAmsMgmtCCBEntitySetConfigRequestT.h>
#include <clAmsXdrHeaderFiles.h>
#include <clAmsUtils.h>
#include <clNodeCache.h>

ClEoPayloadWithReplyCallbackT
        cl_Ams_client_callback_list[CL_AMS_CLIENT_CALLBACKS];

/******************************************************************************
 * Common RMD Call Wrapper
 *****************************************************************************/

#ifdef AMS_EMULATE_RMD_CALLS

#include <clAmsMgmtServerApi.h>

static ClRcT 
emulate_rmd_call(
        CL_IN ClUint32T versionCode,
        CL_IN  ClUint32T  fn_id,
        CL_IN  ClBufferHandleT  in_buffer,
        CL_OUT  ClBufferHandleT  out_buffer);

#endif /* AMS_EMULATE_RMD_CALLS */

/*
 * The common RMD call
 */

static __inline__ ClUint32T cl_ams_get_fn_id(ClUint32T client_id)
{
    static ClUint32T serviceIdTable[] = { CL_AMS_MGMT_SERVER_TABLE_ID,
                                          CL_AMS_MGMT_SERVER_TABLE2_ID,
    };
    ClInt32T index = (client_id >> CL_EO_CLIENT_BIT_SHIFT);
    if(index >= (ClInt32T)sizeof(serviceIdTable)/sizeof(serviceIdTable[0]))
    {
        return 0;
    }
    return CL_EO_GET_FULL_FN_NUM(serviceIdTable[index], client_id & CL_EO_FN_MASK);
}

static ClRcT
cl_ams_call_rmd_ver(
        CL_IN  ClUint32T  fn_id,  /* RMD function identifier */
        CL_IN  ClPtrT  req,  /* Pointer to input argument root */
        CL_IN  ClRcT  (*marshal_req) (ClPtrT, ClBufferHandleT),
        /* Marshaling function pointer */
        CL_OUT  ClPtrT  *res,  /* Pointer to response argument root */
        CL_IN  ClRcT  (*unmarshal_res) (ClBufferHandleT, ClPtrT*),
        CL_IN  ClUint32T versionCode)
    /* Unmarshaling function pointer */
{

    ClRcT  rc = CL_OK;
    ClBufferHandleT  in_buffer = 0;
    ClBufferHandleT  out_buffer = 0;
#ifndef AMS_EMULATE_RMD_CALLS

    ClIocAddressT  dest_addr;
    ClUint32T  rmd_flags;
    ClRmdOptionsT  rmd_options = CL_RMD_DEFAULT_OPTIONS;
    ClInt32T tries = 0;
    ClTimerTimeOutT delay = {.tsSec = 1, .tsMilliSec = 0 };
    ClVersionT version = {0};
#endif

    /* Argument (sanity) checking */

    AMS_CHECKPTR_SILENT( !req);
    AMS_CHECKPTR_SILENT( !res );

    if(!(fn_id = cl_ams_get_fn_id(fn_id) ))
        return CL_AMS_RC(CL_ERR_OUT_OF_RANGE);

    /* Prepare the input data */

    AMS_CHECK_RC_ERROR ( clBufferCreate(&in_buffer) );

    /* Allocate the output buffer */

    AMS_CHECK_RC_ERROR( clBufferCreate(&out_buffer) );

    /* Call the marshaling function to marshal the request data */
    AMS_CHECK_RC_ERROR( (*marshal_req)(req, in_buffer) );

#ifndef AMS_EMULATE_RMD_CALLS
    version.releaseCode =  CL_VERSION_RELEASE(versionCode);
    version.majorVersion = CL_VERSION_MAJOR(versionCode);
    version.minorVersion = CL_VERSION_MINOR(versionCode);

    /*
     * FIXME: This now uses the physical address, instead of a logical
     * address.
     */
    do
    {
        rc = clCpmMasterAddressGet( &dest_addr.iocPhyAddress.nodeAddress);
    } while(rc != CL_OK && ++tries < 3 && clOsalTaskDelay(delay) == CL_OK);

    if(rc != CL_OK) return rc;

    dest_addr.iocPhyAddress.portId = CL_IOC_CPM_PORT;
    rmd_options.timeout = CL_AMS_RMD_DEFAULT_TIMEOUT;
    rmd_options.retries = CL_AMS_RMD_DEFAULT_RETRIES;
    rmd_flags = CL_RMD_CALL_NEED_REPLY;

    AMS_CHECK_RC_ERROR( clRmdWithMsgVer( dest_addr, &version,
                fn_id, in_buffer, out_buffer, rmd_flags, &rmd_options, NULL) );

#else

    AMS_CHECK_RC_ERROR( emulate_rmd_call(versionCode, fn_id, in_buffer, out_buffer) );

#endif /* AMS_EMULATE_RMD_CALLS */

    AMS_CHECK_RC_ERROR( (*unmarshal_res)(out_buffer, res) );

exitfn:


    clBufferDelete(&out_buffer);
    clBufferDelete(&in_buffer);

    return rc;

}

static ClRcT
cl_ams_call_rmd(
        CL_IN  ClUint32T  fn_id,  /* RMD function identifier */
        CL_IN  ClPtrT  req,  /* Pointer to input argument root */
        CL_IN  ClRcT  (*marshal_req) (ClPtrT, ClBufferHandleT),
        /* Marshaling function pointer */
        CL_OUT  ClPtrT  *res,  /* Pointer to response argument root */
        CL_IN  ClRcT  (*unmarshal_res) (ClBufferHandleT, ClPtrT*))
{
    return cl_ams_call_rmd_ver(fn_id, req, marshal_req, res, unmarshal_res,
                               CL_VERSION_CODE(CL_RELEASE_VERSION, CL_MAJOR_VERSION, CL_MINOR_VERSION));
}


/******************************************************************************/

static ClRcT
marshalClAmsMgmtDebugGet(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf )
{
    return VDECL_VER(clXdrMarshallclAmsMgmtDebugGetRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtDebugGet(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtDebugGetResponseT  **res = (clAmsMgmtDebugGetResponseT **)pptr;

    *res = (clAmsMgmtDebugGetResponseT*)clHeapAllocate(sizeof(**res));
    AMS_CHECK_NO_MEMORY (*res);

    AMS_CHECK_RC_ERROR( 
            VDECL_VER(clXdrUnmarshallclAmsMgmtDebugGetResponseT, 4, 0, 0)(buf, (ClPtrT)*res));

    return CL_OK;

exitfn:

    clAmsFreeMemory(*res);
    return rc;

}

ClRcT
cl_ams_mgmt_debug_get(
        CL_IN  clAmsMgmtDebugGetRequestT  *req,
        CL_OUT  clAmsMgmtDebugGetResponseT  **res)
{

    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_DEBUG_GET,
            (ClPtrT)req, &marshalClAmsMgmtDebugGet,
            (ClPtrT*)res, &unmarshalClAmsMgmtDebugGet);

}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtDebugDisable(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtDebugDisableRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtDebugDisable(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;

}

ClRcT
cl_ams_mgmt_debug_disable(
        CL_IN  clAmsMgmtDebugDisableRequestT  *req,
        CL_OUT  clAmsMgmtDebugDisableResponseT  **res)
{

    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_DEBUG_DISABLE,
            (ClPtrT)req, &marshalClAmsMgmtDebugDisable,
            (ClPtrT*)res, &unmarshalClAmsMgmtDebugDisable);

}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtDebugEnable(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtDebugEnableRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtDebugEnable(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}


ClRcT
cl_ams_mgmt_debug_enable(
        CL_IN  clAmsMgmtDebugEnableRequestT  *req,
        CL_OUT  clAmsMgmtDebugEnableResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_DEBUG_ENABLE,
            (ClPtrT)req, &marshalClAmsMgmtDebugEnable,
            (ClPtrT*)res, &unmarshalClAmsMgmtDebugEnable);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtDebugEnableLogToConsole(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtDebugEnableLogToConsoleRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtDebugEnableLogToConsole(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_debug_enable_log_to_console(
        CL_IN   clAmsMgmtDebugEnableLogToConsoleRequestT   *req,
        CL_OUT  clAmsMgmtDebugEnableLogToConsoleResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_DEBUG_ENABLE_LOG_TO_CONSOLE,
            (ClPtrT)req, &marshalClAmsMgmtDebugEnableLogToConsole,
            (ClPtrT*)res, &unmarshalClAmsMgmtDebugEnableLogToConsole);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtDebugDisableLogToConsole(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtDebugDisableLogToConsoleRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtDebugDisableLogToConsole(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_debug_disable_log_to_console(
        CL_IN  clAmsMgmtDebugDisableLogToConsoleRequestT  *req,
        CL_OUT  clAmsMgmtDebugDisableLogToConsoleResponseT  **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_DEBUG_DISABLE_LOG_TO_CONSOLE,
            (ClPtrT)req, &marshalClAmsMgmtDebugDisableLogToConsole,
            (ClPtrT*)res, &unmarshalClAmsMgmtDebugDisableLogToConsole);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCSISetNVP(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    clAmsMgmtCSISetNVPRequestT  *req = (clAmsMgmtCSISetNVPRequestT *)ptr;

    AMS_CHECKPTR_SILENT(!req);

    return clBufferNBytesWrite(buf, (ClPtrT)req, sizeof(*req));

}

static ClRcT
unmarshalClAmsMgmtCSISetNVP(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_csi_set_nvp(
        CL_IN  clAmsMgmtCSISetNVPRequestT  *req,
        CL_OUT  clAmsMgmtCSISetNVPResponseT  **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_CSI_SET_NVP,
            (ClPtrT)req, &marshalClAmsMgmtCSISetNVP,
            (ClPtrT*)res, &unmarshalClAmsMgmtCSISetNVP);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtEntitySetRef(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    clAmsMgmtEntitySetRefRequestT *req = (clAmsMgmtEntitySetRefRequestT *)ptr;

    AMS_CHECKPTR_SILENT(!req);

    return clBufferNBytesWrite(buf, (ClPtrT)req, sizeof(*req));

}

static ClRcT
unmarshalClAmsMgmtEntitySetRef(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_set_ref(
        CL_IN  clAmsMgmtEntitySetRefRequestT  *req,
        CL_OUT  clAmsMgmtEntitySetRefResponseT  **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_ENTITY_SET_REF,
            (ClPtrT)req, &marshalClAmsMgmtEntitySetRef,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetRef);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtInitialize(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtInitializeRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtInitialize(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    ClRcT rc = CL_OK;

    clAmsMgmtInitializeResponseT **res = (clAmsMgmtInitializeResponseT **)pptr;

    *res = (clAmsMgmtInitializeResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY (*res);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallclAmsMgmtInitializeResponseT, 4, 0, 0)(buf, 
                (ClPtrT)*res));

    return CL_OK;

exitfn:

    clAmsFreeMemory (*res);
    return rc;
}

ClRcT
cl_ams_mgmt_initialize(
        CL_IN  clAmsMgmtInitializeRequestT  *req,
        CL_OUT  clAmsMgmtInitializeResponseT  **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_INITIALIZE,
            (ClPtrT)req, &marshalClAmsMgmtInitialize,
            (ClPtrT*)res, &unmarshalClAmsMgmtInitialize);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtFinalize(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtFinalizeRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtFinalize(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_finalize(
        CL_IN  clAmsMgmtFinalizeRequestT  *req,
        CL_OUT  clAmsMgmtFinalizeResponseT  **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_MGMT_FINALIZE,
            (ClPtrT)req, &marshalClAmsMgmtFinalize,
            (ClPtrT*)res, &unmarshalClAmsMgmtFinalize);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtEntityInstantiate(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return clBufferNBytesWrite(buf, (ClPtrT)ptr, 
            sizeof(clAmsMgmtEntityInstantiateRequestT));
}

static ClRcT
unmarshalClAmsMgmtEntityInstantiate(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_instantiate(
        CL_IN  clAmsMgmtEntityInstantiateRequestT  *req,
        CL_OUT  clAmsMgmtEntityInstantiateResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_CREATE,
            (ClPtrT)req, &marshalClAmsMgmtEntityInstantiate,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityInstantiate);
}


/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityTerminate(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return clBufferNBytesWrite(buf, (ClPtrT)ptr, 
            sizeof(clAmsMgmtEntityTerminateRequestT));
}

static ClRcT
unmarshalClAmsMgmtEntityTerminate(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_terminate(
        CL_IN  clAmsMgmtEntityTerminateRequestT  *req,
        CL_OUT  clAmsMgmtEntityTerminateResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_DELETE,
            (ClPtrT)req, &marshalClAmsMgmtEntityTerminate,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityTerminate);
}


/******************************************************************************/

static ClRcT
VDECL_VER(marshalClAmsMgmtEntitySetConfig, 4, 0, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntitySetConfigRequestT  *req = 
        (clAmsMgmtEntitySetConfigRequestT *)ptr;  

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
VDECL_VER(marshalClAmsMgmtEntitySetConfig, 5, 0, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntitySetConfigRequestT  *req = 
        (clAmsMgmtEntitySetConfigRequestT *)ptr;  

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 5, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
VDECL_VER(marshalClAmsMgmtEntitySetConfig, 4, 1, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntitySetConfigRequestT  *req = 
        (clAmsMgmtEntitySetConfigRequestT *)ptr;  

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 4, 1, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
marshalClAmsMgmtEntitySetAlphaFactor(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntitySetAlphaFactorRequestT  *req = 
        (clAmsMgmtEntitySetAlphaFactorRequestT *)ptr;  

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtEntitySetAlphaFactorRequestT, 4, 0, 0)(ptr,
                buf,0) );
exitfn:

    return rc;
}

static ClRcT
marshalClAmsMgmtEntitySetBetaFactor(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntitySetBetaFactorRequestT  *req = 
        (clAmsMgmtEntitySetBetaFactorRequestT *)ptr;  

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtEntitySetBetaFactorRequestT, 4, 0, 0)(ptr,
                buf,0) );
exitfn:

    return rc;
}

static ClRcT
unmarshalClAmsMgmtEntitySetConfig(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

static ClRcT
unmarshalClAmsMgmtEntitySetAlphaFactor(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

static ClRcT
unmarshalClAmsMgmtEntitySetBetaFactor(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_set_config(
                              CL_IN  clAmsMgmtEntitySetConfigRequestT  *req,
                              CL_OUT  clAmsMgmtEntitySetConfigResponseT  **res)
{
    ClUint32T minVersion = CL_VERSION_CODE(CL_RELEASE_VERSION, CL_MAJOR_VERSION, CL_MINOR_VERSION);
    clNodeCacheMinVersionGet(NULL, &minVersion);
    switch(minVersion)
    {
    case CL_VERSION_CODE(5, 0, 0):
        return cl_ams_call_rmd_ver(( ClUint32T)CL_AMS_MGMT_ENTITY_SET_CONFIG,
                                   (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtEntitySetConfig, 
                                                          5, 0, 0),
                                   (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetConfig,
                                   CL_VERSION_CODE(5, 0, 0));
        
    case CL_VERSION_CODE(4, 1, 0):
        return cl_ams_call_rmd_ver(( ClUint32T)CL_AMS_MGMT_ENTITY_SET_CONFIG,
                                   (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtEntitySetConfig, 
                                                          4, 1, 0),
                                   (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetConfig,
                                   CL_VERSION_CODE(4, 1, 0));

    default:
        break;
    }

    return cl_ams_call_rmd_ver(( ClUint32T)CL_AMS_MGMT_ENTITY_SET_CONFIG,
                               (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtEntitySetConfig, 
                                                      CL_RELEASE_VERSION_BASE, 
                                                      CL_MAJOR_VERSION_BASE,
                                                      CL_MINOR_VERSION_BASE),
                               (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetConfig,
                               minVersion);
}

ClRcT
cl_ams_mgmt_entity_set_alpha_factor(
        CL_IN  clAmsMgmtEntitySetAlphaFactorRequestT  *req,
        CL_OUT  clAmsMgmtEntitySetAlphaFactorResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_SET_ALPHA_FACTOR,
            (ClPtrT)req, &marshalClAmsMgmtEntitySetAlphaFactor,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetAlphaFactor);
}

ClRcT 
cl_ams_mgmt_entity_set_beta_factor(
        CL_IN   clAmsMgmtEntitySetBetaFactorRequestT   *req,
        CL_OUT  clAmsMgmtEntitySetBetaFactorResponseT **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_SET_BETA_FACTOR,
            (ClPtrT)req, &marshalClAmsMgmtEntitySetBetaFactor,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntitySetBetaFactor);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityLockAssignment(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityLockAssignmentRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityLockAssignment(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_lock_assignment(
        CL_IN  clAmsMgmtEntityLockAssignmentRequestT  *req,
        CL_OUT  clAmsMgmtEntityLockAssignmentResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_LOCK_ASSIGNMENT,
            (ClPtrT)req, &marshalClAmsMgmtEntityLockAssignment,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityLockAssignment);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityLockInstantiation(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityLockInstantiationRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityLockInstantiation(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_lock_instantiation(
        CL_IN  clAmsMgmtEntityLockInstantiationRequestT  *req,
        CL_OUT  clAmsMgmtEntityLockInstantiationResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_LOCK_INSTANTIATION,
            (ClPtrT)req, &marshalClAmsMgmtEntityLockInstantiation,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityLockInstantiation);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityUnlock(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityUnlockRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityUnlock(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_unlock(
        CL_IN  clAmsMgmtEntityUnlockRequestT  *req,
        CL_OUT  clAmsMgmtEntityUnlockResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_UNLOCK,
            (ClPtrT)req, &marshalClAmsMgmtEntityUnlock,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityUnlock);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityShutdown(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityShutdownRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityShutdown(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_shutdown(
        CL_IN  clAmsMgmtEntityShutdownRequestT  *req,
        CL_OUT  clAmsMgmtEntityShutdownResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_SHUTDOWN,
            (ClPtrT)req, &marshalClAmsMgmtEntityShutdown,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityShutdown);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityRestart(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityRestartRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityRestart(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_restart(
        CL_IN  clAmsMgmtEntityRestartRequestT  *req,
        CL_OUT  clAmsMgmtEntityRestartResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_RESTART,
            (ClPtrT)req, &marshalClAmsMgmtEntityRestart,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityRestart);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityRepaired(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityRepairedRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtEntityRepaired(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_repaired(
        CL_IN  clAmsMgmtEntityRepairedRequestT  *req,
        CL_OUT  clAmsMgmtEntityRepairedResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_REPAIRED,
            (ClPtrT)req, &marshalClAmsMgmtEntityRepaired,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityRepaired);
}

static ClRcT marshalClAmsMgmtSISwap(
                                    CL_IN ClPtrT ptr,
                                    CL_INOUT ClBufferHandleT buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtSISwapRequestT, 4, 0, 0)(ptr, buf, 0);
}

static ClRcT 
unmarshalClAmsMgmtSISwap(CL_IN ClBufferHandleT buf,
                         CL_INOUT ClPtrT *pptr)
{
    return CL_OK;
}
                         
ClRcT
cl_ams_mgmt_si_swap(
        CL_IN  clAmsMgmtSISwapRequestT  *req,
        CL_OUT  clAmsMgmtSISwapResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_SI_SWAP,
            (ClPtrT)req, &marshalClAmsMgmtSISwap,
            (ClPtrT*)res, &unmarshalClAmsMgmtSISwap);
}


static ClRcT marshalClAmsMgmtSGAdjust(
                                    CL_IN ClPtrT ptr,
                                    CL_INOUT ClBufferHandleT buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtSGAdjustPreferenceRequestT, 4, 0, 0)(ptr, buf, 0);
}

static ClRcT 
unmarshalClAmsMgmtSGAdjust(CL_IN ClBufferHandleT buf,
                           CL_INOUT ClPtrT *pptr)
{
    return CL_OK;
}
                         
ClRcT
cl_ams_mgmt_sg_adjust(
                      CL_IN  clAmsMgmtSGAdjustPreferenceRequestT *req,
                      CL_OUT clAmsMgmtSGAdjustPreferenceResponseT **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_SG_ADJUST_PREFERENCE,
                           (ClPtrT)req, &marshalClAmsMgmtSGAdjust,
                           (ClPtrT*)res, &unmarshalClAmsMgmtSGAdjust);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtSGAdjustPreference(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return clBufferNBytesWrite(buf, (ClPtrT)ptr, 
            sizeof(clAmsMgmtSGAdjustPreferenceRequestT));
}

static ClRcT
unmarshalClAmsMgmtSGAdjustPreference(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_sg_adjust_preference(
        CL_IN  clAmsMgmtSGAdjustPreferenceRequestT  *req,
        CL_OUT  clAmsMgmtSGAdjustPreferenceResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_SG_ADJUST_PREFERENCE,
            (ClPtrT)req, &marshalClAmsMgmtSGAdjustPreference,
            (ClPtrT*)res, &unmarshalClAmsMgmtSGAdjustPreference);
}

/******************************************************************************/

ClRcT
marshalClAmsMgmtEntityListEntityRefAdd(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return clBufferNBytesWrite(buf, (ClPtrT) ptr, 
            sizeof(clAmsMgmtEntityListEntityRefAddRequestT));
}

static ClRcT
unmarshalClAmsMgmtEntityListEntityRefAdd(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_entity_list_entity_ref_add(
        CL_IN  clAmsMgmtEntityListEntityRefAddRequestT  *req,
        CL_OUT  clAmsMgmtEntityListEntityRefAddResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T)CL_AMS_MGMT_ENTITY_LIST_ENTITY_REF_ADD,
            (ClPtrT)req, &marshalClAmsMgmtEntityListEntityRefAdd,
            (ClPtrT*)res, &unmarshalClAmsMgmtEntityListEntityRefAdd);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBInitialize(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBInitializeRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBInitialize(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtCCBInitializeResponseT  **res = 
        (clAmsMgmtCCBInitializeResponseT **)pptr;

    /* We have clAmsMgmtCCBInitializeResponseT buffer from the server */

    *res = (clAmsMgmtCCBInitializeResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY(*res);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallclAmsMgmtCCBInitializeResponseT, 4, 0, 0)(buf,
                (ClPtrT)*res) );

    return rc;

exitfn:

    clHeapFree((ClPtrT)*res);
    return rc;
}

ClRcT
cl_ams_mgmt_ccb_initialize(
        CL_IN  clAmsMgmtCCBInitializeRequestT  *req,
        CL_OUT  clAmsMgmtCCBInitializeResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_INITIALIZE,
            (ClPtrT)req, &marshalClAmsMgmtCCBInitialize,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBInitialize);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBFinalize(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBFinalizeRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBFinalize(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_finalize(
        CL_IN  clAmsMgmtCCBFinalizeRequestT  *req,
        CL_OUT  clAmsMgmtCCBFinalizeResponseT  **res)
{
    return cl_ams_call_rmd((ClUint32T) CL_AMS_MGMT_CCB_FINALIZE,
            (ClPtrT)req, &marshalClAmsMgmtCCBFinalize,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBFinalize);
}

/******************************************************************************/

static ClRcT
VDECL_VER(marshalClAmsMgmtCCBEntitySetConfig, 4, 0, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtCCBEntitySetConfigRequestT  *req = 
        (clAmsMgmtCCBEntitySetConfigRequestT *)ptr;

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtCCBEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
VDECL_VER(marshalClAmsMgmtCCBEntitySetConfig, 5, 0, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtCCBEntitySetConfigRequestT  *req = 
        (clAmsMgmtCCBEntitySetConfigRequestT *)ptr;

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtCCBEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 5, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
VDECL_VER(marshalClAmsMgmtCCBEntitySetConfig, 4, 1, 0)(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtCCBEntitySetConfigRequestT  *req = 
        (clAmsMgmtCCBEntitySetConfigRequestT *)ptr;

    AMS_CHECKPTR_SILENT( !req );

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrMarshallclAmsMgmtCCBEntitySetConfigRequestT, 4, 0, 0)(ptr,
                buf,0) );

    /*
     * Send the configuration specific to the AMS entity based on its type
     */

    switch (req->entityConfig->type)

    {
        case CL_AMS_ENTITY_TYPE_NODE:
            {
                rc = VDECL_VER(clXdrMarshallClAmsNodeConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SG:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSGConfigT, 4, 1, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SU:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSUConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_SI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_COMP:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCompConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }

        case CL_AMS_ENTITY_TYPE_CSI:
            {
                rc = VDECL_VER(clXdrMarshallClAmsCSIConfigT, 4, 0, 0)(req->entityConfig,buf,0);
                break;
            }
        
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                break;
            } 
    } 

exitfn:

    return rc;
}

static ClRcT
unmarshalClAmsMgmtCCBEntitySetConfig(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_entity_set_config(
                                  CL_IN  clAmsMgmtCCBEntitySetConfigRequestT  *req,
                                  CL_OUT  clAmsMgmtCCBEntitySetConfigResponseT  **res)
{
    ClUint32T minVersion = CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE);
    clNodeCacheMinVersionGet(NULL, &minVersion);
    switch(minVersion)
    {
    case CL_VERSION_CODE(5, 0, 0):
        return cl_ams_call_rmd_ver((ClUint32T) CL_AMS_MGMT_CCB_ENTITY_SET_CONFIG,
                                   (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtCCBEntitySetConfig,
                                                          5, 0, 0),
                                   (ClPtrT*)res, &unmarshalClAmsMgmtCCBEntitySetConfig,
                                   CL_VERSION_CODE(5, 0, 0));

    case CL_VERSION_CODE(4, 1, 0):
        return cl_ams_call_rmd_ver((ClUint32T) CL_AMS_MGMT_CCB_ENTITY_SET_CONFIG,
                                   (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtCCBEntitySetConfig,
                                                          4, 1, 0),
                                   (ClPtrT*)res, &unmarshalClAmsMgmtCCBEntitySetConfig,
                                   CL_VERSION_CODE(4, 1, 0));

    default:
        break;
    }


    return cl_ams_call_rmd_ver((ClUint32T) CL_AMS_MGMT_CCB_ENTITY_SET_CONFIG,
                               (ClPtrT)req, VDECL_VER(&marshalClAmsMgmtCCBEntitySetConfig,
                                                      CL_RELEASE_VERSION_BASE,
                                                      CL_MAJOR_VERSION_BASE,
                                                      CL_MINOR_VERSION_BASE),
                               (ClPtrT*)res, &unmarshalClAmsMgmtCCBEntitySetConfig,
                               minVersion);

}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBCSISetNVP(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBCSISetNVPRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBCSISetNVP(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_csi_set_nvp(
        CL_IN  clAmsMgmtCCBCSISetNVPRequestT  *req,
        CL_OUT  clAmsMgmtCCBCSISetNVPResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T) CL_AMS_MGMT_CCB_CSI_SET_NVP,
            (ClPtrT)req, &marshalClAmsMgmtCCBCSISetNVP,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBCSISetNVP);
}

ClRcT
cl_ams_mgmt_ccb_csi_delete_nvp(
        CL_IN  clAmsMgmtCCBCSIDeleteNVPRequestT  *req,
        CL_OUT  clAmsMgmtCCBCSIDeleteNVPResponseT  **res)
{
    return cl_ams_call_rmd(( ClUint32T) CL_AMS_MGMT_CCB_CSI_DELETE_NVP,
            (ClPtrT)req, &marshalClAmsMgmtCCBCSISetNVP,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBCSISetNVP);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetNodeDependency(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetNodeDependencyRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetNodeDependency(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_node_dependency(
        CL_IN  clAmsMgmtCCBSetNodeDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetNodeDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_SET_NODE_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetNodeDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetNodeDependency);
}

ClRcT
cl_ams_mgmt_ccb_delete_node_dependency(
        CL_IN  clAmsMgmtCCBSetNodeDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetNodeDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_DELETE_NODE_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetNodeDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetNodeDependency);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetNodeSUList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetNodeSUListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetNodeSUList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_node_su_list(
        CL_IN  clAmsMgmtCCBSetNodeSUListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetNodeSUListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_SET_NODE_SU_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetNodeSUList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetNodeSUList);
}

ClRcT
cl_ams_mgmt_ccb_delete_node_su_list(
        CL_IN  clAmsMgmtCCBSetNodeSUListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetNodeSUListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_DELETE_NODE_SU_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetNodeSUList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetNodeSUList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetSGSUList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSGSUListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSGSUList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_sg_su_list(
        CL_IN  clAmsMgmtCCBSetSGSUListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSGSUListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_SET_SG_SU_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSGSUList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSGSUList);
}

ClRcT
cl_ams_mgmt_ccb_delete_sg_su_list(
        CL_IN  clAmsMgmtCCBSetSGSUListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSGSUListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_DELETE_SG_SU_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSGSUList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSGSUList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetSGSIList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSGSIListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSGSIList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_sg_si_list(
        CL_IN  clAmsMgmtCCBSetSGSIListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSGSIListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_SET_SG_SI_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSGSIList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSGSIList);
}

ClRcT
cl_ams_mgmt_ccb_delete_sg_si_list(
        CL_IN  clAmsMgmtCCBSetSGSIListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSGSIListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_DELETE_SG_SI_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSGSIList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSGSIList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetSUCompList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSUCompListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSUCompList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_su_comp_list(
        CL_IN  clAmsMgmtCCBSetSUCompListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSUCompListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_SET_SU_COMP_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSUCompList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSUCompList);
}

ClRcT
cl_ams_mgmt_ccb_delete_su_comp_list(
        CL_IN  clAmsMgmtCCBSetSUCompListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSUCompListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_CCB_DELETE_SU_COMP_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSUCompList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSUCompList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetSISURankList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSISURankListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSISURankList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_si_su_rank_list(
        CL_IN  clAmsMgmtCCBSetSISURankListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSISURankListResponseT  **res)
{
    return cl_ams_call_rmd((ClUint32T)CL_AMS_MGMT_CCB_SET_SI_SU_RANK_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSISURankList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSISURankList);
}


ClRcT
cl_ams_mgmt_ccb_delete_si_su_rank_list(
        CL_IN  clAmsMgmtCCBSetSISURankListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSISURankListResponseT  **res)
{
    return cl_ams_call_rmd((ClUint32T)CL_AMS_MGMT_CCB_DELETE_SI_SU_RANK_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSISURankList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSISURankList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetSISIDependency(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSISIDependencyRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSISIDependency(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_si_si_dependency(
        CL_IN  clAmsMgmtCCBSetSISIDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSISIDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_SET_SI_SI_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSISIDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSISIDependency);
}


ClRcT
cl_ams_mgmt_ccb_delete_si_si_dependency(
        CL_IN  clAmsMgmtCCBSetSISIDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSISIDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_DELETE_SI_SI_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSISIDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSISIDependency);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBSetCSICSIDependency(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetCSICSIDependencyRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetCSICSIDependency(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_csi_csi_dependency(
        CL_IN  clAmsMgmtCCBSetCSICSIDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetCSICSIDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_SET_CSI_CSI_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetCSICSIDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetCSICSIDependency);
}

ClRcT
cl_ams_mgmt_ccb_delete_csi_csi_dependency(
        CL_IN  clAmsMgmtCCBSetCSICSIDependencyRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetCSICSIDependencyResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_DELETE_CSI_CSI_DEPENDENCY,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetCSICSIDependency,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetCSICSIDependency);
}

static ClRcT
marshalClAmsMgmtCCBSetSICSIList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBSetSICSIListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBSetSICSIList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_set_si_csi_list(
        CL_IN  clAmsMgmtCCBSetSICSIListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSICSIListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_SET_SI_CSI_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSICSIList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSICSIList);
}


ClRcT
cl_ams_mgmt_ccb_delete_si_csi_list(
        CL_IN  clAmsMgmtCCBSetSICSIListRequestT  *req,
        CL_OUT  clAmsMgmtCCBSetSICSIListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_DELETE_SI_CSI_LIST,
            (ClPtrT)req, &marshalClAmsMgmtCCBSetSICSIList,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBSetSICSIList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBEntityCreate(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBEntityCreateRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBEntityCreate(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_entity_create(
        CL_IN  clAmsMgmtCCBEntityCreateRequestT  *req,
        CL_OUT  clAmsMgmtCCBEntityCreateResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_ENTITY_CREATE,
            (ClPtrT)req, &marshalClAmsMgmtCCBEntityCreate,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBEntityCreate);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBEntityDelete(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return  VDECL_VER(clXdrMarshallclAmsMgmtCCBEntityDeleteRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBEntityDelete(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_entity_delete(
        CL_IN  clAmsMgmtCCBEntityDeleteRequestT  *req,
        CL_OUT  clAmsMgmtCCBEntityDeleteResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_ENTITY_DELETE,
            (ClPtrT)req, &marshalClAmsMgmtCCBEntityDelete,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBEntityDelete);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtCCBCommit(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtCCBCommitRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtCCBCommit(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_mgmt_ccb_commit(
        CL_IN  clAmsMgmtCCBCommitRequestT  *req,
        CL_OUT  clAmsMgmtCCBCommitResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T)CL_AMS_MGMT_CCB_COMMIT,
            (ClPtrT)req, &marshalClAmsMgmtCCBCommit,
            (ClPtrT*)res, &unmarshalClAmsMgmtCCBCommit);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtEntityGet(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityGetRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGet, 4, 0, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetResponseT  **res = (clAmsMgmtEntityGetResponseT **)pptr;
    ClAmsEntityTypeT  entityType = CL_AMS_ENTITY_TYPE_ENTITY;
    ClAmsEntityT  *entity = NULL;
    ClUint32T  configSize,statusSize,entitySize;

    /* We have clAmsMgmtEntityGetResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    (*res)->entity = clHeapAllocate(sizeof(ClAmsEntityT));

    AMS_CHECK_NO_MEMORY_AND_EXIT ((*res)->entity);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallclAmsMgmtEntityGetResponseT, 4, 0, 0)(
                buf, (ClPtrT)*res) );

    AMS_CHECKPTR_AND_EXIT( !((*res)->entity) );

    entityType = (*res)->entity->type;

    AMS_CHECK_RC_ERROR( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory((*res)->entity);


    entity  = clHeapAllocate(entitySize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entity);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                goto exitfn;
            }
    }


    (*res)->entity = entity;

    return rc;

exitfn:

    if ((*res) && ((*res)->entity))
    {
        clAmsFreeMemory ( (*res)->entity);
    }

    clAmsFreeMemory((*res));
    clAmsFreeMemory (entity);

    return rc;
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGet, 5, 0, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetResponseT  **res = (clAmsMgmtEntityGetResponseT **)pptr;
    ClAmsEntityTypeT  entityType = CL_AMS_ENTITY_TYPE_ENTITY;
    ClAmsEntityT  *entity = NULL;
    ClUint32T  configSize,statusSize,entitySize;

    /* We have clAmsMgmtEntityGetResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    (*res)->entity = clHeapAllocate(sizeof(ClAmsEntityT));

    AMS_CHECK_NO_MEMORY_AND_EXIT ((*res)->entity);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallclAmsMgmtEntityGetResponseT, 4, 0, 0)(
                buf, (ClPtrT)*res) );

    AMS_CHECKPTR_AND_EXIT( !((*res)->entity) );

    entityType = (*res)->entity->type;

    AMS_CHECK_RC_ERROR( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory((*res)->entity);


    entity  = clHeapAllocate(entitySize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entity);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGT, 5, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                goto exitfn;
            }
    }


    (*res)->entity = entity;

    return rc;

exitfn:

    if ((*res) && ((*res)->entity))
    {
        clAmsFreeMemory ( (*res)->entity);
    }

    clAmsFreeMemory((*res));
    clAmsFreeMemory (entity);

    return rc;
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGet, 4, 1, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetResponseT  **res = (clAmsMgmtEntityGetResponseT **)pptr;
    ClAmsEntityTypeT  entityType = CL_AMS_ENTITY_TYPE_ENTITY;
    ClAmsEntityT  *entity = NULL;
    ClUint32T  configSize,statusSize,entitySize;

    /* We have clAmsMgmtEntityGetResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    (*res)->entity = clHeapAllocate(sizeof(ClAmsEntityT));

    AMS_CHECK_NO_MEMORY_AND_EXIT ((*res)->entity);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallclAmsMgmtEntityGetResponseT, 4, 0, 0)(
                buf, (ClPtrT)*res) );

    AMS_CHECKPTR_AND_EXIT( !((*res)->entity) );

    entityType = (*res)->entity->type;

    AMS_CHECK_RC_ERROR( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory((*res)->entity);


    entity  = clHeapAllocate(entitySize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entity);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGT, 4, 1, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompT, 4, 0, 0)(buf, entity) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIT, 4, 0, 0)(buf, entity) );
                break;
            }
        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY;
                goto exitfn;
            }
    }


    (*res)->entity = entity;

    return rc;

exitfn:

    if ((*res) && ((*res)->entity))
    {
        clAmsFreeMemory ( (*res)->entity);
    }

    clAmsFreeMemory((*res));
    clAmsFreeMemory (entity);

    return rc;
}

ClRcT
cl_ams_mgmt_entity_get(
                       CL_IN  clAmsMgmtEntityGetRequestT  *req,
                       CL_OUT  clAmsMgmtEntityGetResponseT **res)
{
    ClUint32T minVersion = CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE);
    clNodeCacheMinVersionGet(NULL, &minVersion);

    switch(minVersion)
    {
    case CL_VERSION_CODE(5, 0, 0):
        return cl_ams_call_rmd_ver( (ClUint32T) CL_AMS_MGMT_ENTITY_GET,
                                    (ClPtrT)req, &marshalClAmsMgmtEntityGet,
                                    (ClPtrT*)res, 
                                    VDECL_VER(&unmarshalClAmsMgmtEntityGet,
                                              5, 0, 0),
                                    CL_VERSION_CODE(5, 0, 0));

    case CL_VERSION_CODE(4, 1, 0):
        return cl_ams_call_rmd_ver( (ClUint32T) CL_AMS_MGMT_ENTITY_GET,
                                    (ClPtrT)req, &marshalClAmsMgmtEntityGet,
                                    (ClPtrT*)res, 
                                    VDECL_VER(&unmarshalClAmsMgmtEntityGet,
                                              4, 1, 0),
                                    CL_VERSION_CODE(4, 1, 0));

    default:
        break;
    }

    return cl_ams_call_rmd_ver( (ClUint32T) CL_AMS_MGMT_ENTITY_GET,
                                (ClPtrT)req, &marshalClAmsMgmtEntityGet,
                                (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGet,
                                                        CL_RELEASE_VERSION_BASE,
                                                        CL_MAJOR_VERSION_BASE,
                                                        CL_MINOR_VERSION_BASE),
                                minVersion);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtEntityGetConfig(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityGetConfigRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGetConfig, 4, 0, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetConfigResponseT  **res = 
        (clAmsMgmtEntityGetConfigResponseT **)pptr;
    ClAmsEntityTypeT  entityType;
    ClAmsEntityConfigT  *entityConfig = NULL;

    /* We have clAmsMgmtEntityGetConfigResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetConfigResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY (*res);

    (*res)->entityConfig = clHeapAllocate(sizeof(ClAmsEntityConfigT));

    AMS_CHECK_NO_MEMORY_AND_EXIT( (*res)->entityConfig );
    
    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf,(ClPtrT)(*res)->entityConfig) );

    entityType = (*res)->entityConfig->type;
    ClUint32T  configSize,statusSize,entitySize;

    AMS_CHECK_RC_ERROR ( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory( (*res)->entityConfig );

    entityConfig  = clHeapAllocate(configSize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entityConfig);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        default:
            {
                break;
            }
    }

    (*res)->entityConfig = entityConfig;

    return rc;

exitfn:

    if ( *res != NULL )
    {
        clAmsFreeMemory ( (*res)->entityConfig );
    }

    clAmsFreeMemory (entityConfig);
    clAmsFreeMemory(*res);
    return rc;
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGetConfig, 5, 0, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetConfigResponseT  **res = 
        (clAmsMgmtEntityGetConfigResponseT **)pptr;
    ClAmsEntityTypeT  entityType;
    ClAmsEntityConfigT  *entityConfig = NULL;

    /* We have clAmsMgmtEntityGetConfigResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetConfigResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY (*res);

    (*res)->entityConfig = clHeapAllocate(sizeof(ClAmsEntityConfigT));

    AMS_CHECK_NO_MEMORY_AND_EXIT( (*res)->entityConfig );
    
    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf,(ClPtrT)(*res)->entityConfig) );

    entityType = (*res)->entityConfig->type;
    ClUint32T  configSize,statusSize,entitySize;

    AMS_CHECK_RC_ERROR ( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory( (*res)->entityConfig );

    entityConfig  = clHeapAllocate(configSize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entityConfig);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGConfigT, 5, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        default:
            {
                break;
            }
    }

    (*res)->entityConfig = entityConfig;

    return rc;

exitfn:

    if ( *res != NULL )
    {
        clAmsFreeMemory ( (*res)->entityConfig );
    }

    clAmsFreeMemory (entityConfig);
    clAmsFreeMemory(*res);
    return rc;
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGetConfig, 4, 1, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetConfigResponseT  **res = 
        (clAmsMgmtEntityGetConfigResponseT **)pptr;
    ClAmsEntityTypeT  entityType;
    ClAmsEntityConfigT  *entityConfig = NULL;

    /* We have clAmsMgmtEntityGetConfigResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetConfigResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY (*res);

    (*res)->entityConfig = clHeapAllocate(sizeof(ClAmsEntityConfigT));

    AMS_CHECK_NO_MEMORY_AND_EXIT( (*res)->entityConfig );
    
    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf,(ClPtrT)(*res)->entityConfig) );

    entityType = (*res)->entityConfig->type;
    ClUint32T  configSize,statusSize,entitySize;

    AMS_CHECK_RC_ERROR ( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    clAmsFreeMemory( (*res)->entityConfig );

    entityConfig  = clHeapAllocate(configSize);

    AMS_CHECK_NO_MEMORY_AND_EXIT (entityConfig);

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGConfigT, 4, 1, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIConfigT, 4, 0, 0)(buf, 
                            entityConfig) );
                break;
            }
        default:
            {
                break;
            }
    }

    (*res)->entityConfig = entityConfig;

    return rc;

exitfn:

    if ( *res != NULL )
    {
        clAmsFreeMemory ( (*res)->entityConfig );
    }

    clAmsFreeMemory (entityConfig);
    clAmsFreeMemory(*res);
    return rc;
}

ClRcT
cl_ams_mgmt_entity_get_config(
                              CL_IN   clAmsMgmtEntityGetConfigRequestT   *req,
                              CL_OUT  clAmsMgmtEntityGetConfigResponseT **res)
{
    ClUint32T minVersion = CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE);

    clNodeCacheMinVersionGet(NULL, &minVersion);
    switch(minVersion)
    {
    case CL_VERSION_CODE(5, 0, 0):
        return cl_ams_call_rmd_ver((
                                    ClUint32T)CL_AMS_MGMT_ENTITY_GET_CONFIG,
                                   (ClPtrT)req, &marshalClAmsMgmtEntityGetConfig,
                                   (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGetConfig,
                                                           5, 0, 0),
                                   CL_VERSION_CODE(5, 0, 0));

    case CL_VERSION_CODE(4, 1, 0):
        return cl_ams_call_rmd_ver((
                                    ClUint32T)CL_AMS_MGMT_ENTITY_GET_CONFIG,
                                   (ClPtrT)req, &marshalClAmsMgmtEntityGetConfig,
                                   (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGetConfig,
                                                           4, 1, 0),
                                   CL_VERSION_CODE(4, 1, 0));
        
    default:
        break;
    }


    return cl_ams_call_rmd_ver((
                                ClUint32T)CL_AMS_MGMT_ENTITY_GET_CONFIG,
                               (ClPtrT)req, &marshalClAmsMgmtEntityGetConfig,
                               (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGetConfig,
                                                       CL_RELEASE_VERSION_BASE,
                                                       CL_MAJOR_VERSION_BASE,
                                                       CL_MINOR_VERSION_BASE), minVersion);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtEntityGetStatus(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtEntityGetStatusRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGetStatus, 4, 0, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetStatusResponseT  **res = 
        (clAmsMgmtEntityGetStatusResponseT **)pptr;
    ClAmsEntityTypeT  entityType;
    ClAmsEntityStatusT  *entityStatus = NULL;

    /* We have clAmsMgmtEntityGetStatusResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetStatusResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf,(ClPtrT)&(*res)->entity));

    entityType = (*res)->entity.type;

    ClUint32T  configSize,statusSize,entitySize;

    AMS_CHECK_RC_ERROR( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    entityStatus  = clHeapCalloc(1, statusSize);

    AMS_CHECK_NO_MEMORY_AND_EXIT( entityStatus );

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGStatusT, 4, 0, 0)(buf, 
                                                                                      entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        default:
            {
                break;
            }
    }

    (*res)->entityStatus= entityStatus;

    return rc;

exitfn:

    clAmsFreeMemory((*res));
    clAmsFreeMemory(entityStatus);
    return rc;

}

static ClRcT
VDECL_VER(unmarshalClAmsMgmtEntityGetStatus, 4, 1, 0)(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtEntityGetStatusResponseT  **res = 
        (clAmsMgmtEntityGetStatusResponseT **)pptr;
    ClAmsEntityTypeT  entityType;
    ClAmsEntityStatusT  *entityStatus = NULL;

    /* We have clAmsMgmtEntityGetStatusResponseT buffer from the server */

    *res = (clAmsMgmtEntityGetStatusResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf,(ClPtrT)&(*res)->entity));

    entityType = (*res)->entity.type;

    ClUint32T  configSize,statusSize,entitySize;

    AMS_CHECK_RC_ERROR( clAmsGetEntitySize( &entityType, &configSize, 
                &statusSize, &entitySize) );

    entityStatus  = clHeapCalloc(1, statusSize);

    AMS_CHECK_NO_MEMORY_AND_EXIT( entityStatus );

    switch (entityType)
    {

        case CL_AMS_ENTITY_TYPE_NODE:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsNodeStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SG:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSGStatusT, 4, 1, 0)(buf, 
                                                                                      entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SU:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_SI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSIStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_COMP:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        case CL_AMS_ENTITY_TYPE_CSI:
            {
                AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSIStatusT, 4, 0, 0)(buf, 
                            entityStatus) );
                break;
            }
        default:
            {
                break;
            }
    }

    (*res)->entityStatus= entityStatus;

    return rc;

exitfn:

    clAmsFreeMemory((*res));
    clAmsFreeMemory(entityStatus);
    return rc;

}

ClRcT
cl_ams_mgmt_entity_get_status(
                              CL_IN   clAmsMgmtEntityGetStatusRequestT   *req,
                              CL_OUT  clAmsMgmtEntityGetStatusResponseT **res)
{
    ClUint32T minVersion = CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE);
    clNodeCacheMinVersionGet(NULL, &minVersion);
    switch(minVersion)
    {
    case CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE):
        return cl_ams_call_rmd_ver((
                                    ClUint32T)CL_AMS_MGMT_ENTITY_GET_STATUS,
                                   (ClPtrT)req, &marshalClAmsMgmtEntityGetStatus,
                                   (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGetStatus,
                                                           CL_RELEASE_VERSION_BASE,
                                                           CL_MAJOR_VERSION_BASE,
                                                           CL_MINOR_VERSION_BASE), minVersion);
    default:
        break;
    }

    return cl_ams_call_rmd_ver((
                                ClUint32T)CL_AMS_MGMT_ENTITY_GET_STATUS,
                               (ClPtrT)req, &marshalClAmsMgmtEntityGetStatus,
                               (ClPtrT*)res, VDECL_VER(&unmarshalClAmsMgmtEntityGetStatus,
                                                       CL_RELEASE_VERSION,
                                                       1,
                                                       CL_MINOR_VERSION), minVersion);
}

/******************************************************************************/


static ClRcT
marshalClAmsMgmtGetCSINVPList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtGetCSINVPListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtGetCSINVPList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    ClRcT  rc = CL_OK;
    clAmsMgmtGetCSINVPListResponseT  **res = 
        (clAmsMgmtGetCSINVPListResponseT **)pptr;
    ClUint32T  i=0;
    ClUint32T  count = 0;

    /* We have clAmsMgmtGetCSINVPListResponseT buffer from the server */

    AMS_CHECK_RC_ERROR( clXdrUnmarshallClUint32T(buf, (ClPtrT)&count) );

    *res = (clAmsMgmtGetCSINVPListResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY_AND_EXIT (*res);

    (*res)->count = count;

    (*res)->nvp = clHeapAllocate(count*sizeof(ClAmsCSINVPT));

    AMS_CHECK_NO_MEMORY_AND_EXIT( (*res)->nvp );

    for ( i = 0; i< count; i++ )
    {
        AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCSINVPT, 4, 0, 0)(buf,&((*res)->nvp[i])));
    }

    return CL_OK;

exitfn:

    if ( (*res) && (*res)->nvp )
    {
        clAmsFreeMemory ((*res)->nvp)
    }

    clAmsFreeMemory (*res);
    return rc;
}

ClRcT
cl_ams_mgmt_get_csi_nvp_list(
        CL_IN  clAmsMgmtGetCSINVPListRequestT  *req,
        CL_OUT  clAmsMgmtGetCSINVPListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_GET_CSI_NVP_LIST,
            (ClPtrT)req, &marshalClAmsMgmtGetCSINVPList,
            (ClPtrT*)res, &unmarshalClAmsMgmtGetCSINVPList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtGetEntityList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtGetEntityListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtGetEntityList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtGetEntityListResponseT  **res = 
        (clAmsMgmtGetEntityListResponseT **)pptr;
    ClUint32T  i=0;
    ClUint32T  count = 0;

    /* We have clAmsMgmtGetEntityListResponseT buffer from the server */

    *res = (clAmsMgmtGetEntityListResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY (*res);

    AMS_CHECK_RC_ERROR( clXdrUnmarshallClUint32T(buf, (ClPtrT)&count) );

    (*res)->count = count;
    (*res)->entity = clHeapAllocate(count*sizeof(ClAmsEntityT));

    AMS_CHECK_NO_MEMORY_AND_EXIT ( (*res)->entity );

    for ( i = 0; i< count; i++ )
    {
        AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityConfigT, 4, 0, 0)(buf, 
                    &((*res)->entity[i])) );
    }

    return CL_OK;

exitfn:

    if ( (*res) && ((*res)->entity) )
    {
        clAmsFreeMemory((*res)->entity);
    }
    clAmsFreeMemory(*res);
    return rc;
}

ClRcT
cl_ams_mgmt_get_entity_list(
        CL_IN  clAmsMgmtGetEntityListRequestT  *req,
        CL_OUT  clAmsMgmtGetEntityListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_GET_ENTITY_LIST,
            (ClPtrT)req, &marshalClAmsMgmtGetEntityList,
            (ClPtrT*)res, &unmarshalClAmsMgmtGetEntityList);
}

/******************************************************************************/

static ClRcT
marshalClAmsMgmtGetOLEntityList(
        CL_IN  ClPtrT  ptr,
        CL_INOUT  ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallclAmsMgmtGetOLEntityListRequestT, 4, 0, 0)(ptr,buf,0);
}

static ClRcT
unmarshalClAmsMgmtGetOLEntityList(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{

    ClRcT  rc = CL_OK;
    clAmsMgmtGetOLEntityListResponseT  **res = 
        (clAmsMgmtGetOLEntityListResponseT **)pptr;
    ClUint32T  i=0;
    ClUint32T  count = 0;
    ClUint32T  size = 0;
    ClAmsEntityListTypeT  entityListType;

    /* We have clAmsMgmtGetOLEntityListResponseT buffer from the server */

    *res = (clAmsMgmtGetOLEntityListResponseT*)clHeapAllocate(sizeof(**res));

    AMS_CHECK_NO_MEMORY(*res);

    AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsEntityListTypeT, 4, 0, 0)(buf, 
                &entityListType) );

    switch (entityListType)
    {

        case CL_AMS_SU_STATUS_SI_LIST:
            {
                size =  sizeof (ClAmsSUSIRefT);
                break;
            }

        case CL_AMS_SI_STATUS_SU_LIST:
            {
                size =  sizeof (ClAmsSISURefT);
                break;
            }

        case CL_AMS_COMP_STATUS_CSI_LIST:
            {
                size =  sizeof (ClAmsCompCSIRefT);
                break;
            }

        default:
            {
                rc = CL_AMS_ERR_INVALID_ENTITY_LIST;
                goto exitfn;
            }

    }

    AMS_CHECK_RC_ERROR( clXdrUnmarshallClUint32T(buf, (ClPtrT)&count) );

    (*res)->count = count;
    (*res)->entityRef = clHeapAllocate(count*size);

    AMS_CHECK_NO_MEMORY_AND_EXIT((*res)->entityRef);

    for ( i = 0; i< count; i++ )
    {

        if ( entityListType == CL_AMS_SU_STATUS_SI_LIST )
        {
            AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSUSIRefT, 4, 0, 0)(buf, 
                        ((ClInt8T *)(*res)-> entityRef) + i*size));
        }

        else if ( entityListType == CL_AMS_SI_STATUS_SU_LIST )
        {
            AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsSISURefT, 4, 0, 0)(buf, 
                        ((ClInt8T *)(*res)-> entityRef) + i*size));
        }

        else if ( entityListType == CL_AMS_COMP_STATUS_CSI_LIST )
        {

            ClAmsCompCSIRefT  *compcsiRef = 
                (ClAmsCompCSIRefT *)(((ClInt8T *)(*res)-> entityRef) + i*size );

            compcsiRef->activeComp = clHeapAllocate (sizeof(ClAmsEntityT));

            AMS_CHECK_NO_MEMORY_AND_EXIT (compcsiRef->activeComp);

            AMS_CHECK_RC_ERROR( VDECL_VER(clXdrUnmarshallClAmsCompCSIRefT, 4, 0, 0)(buf, 
                        compcsiRef));

        }

    }

    return CL_OK;

exitfn:

    if ( (*res) &&  ((*res)->entityRef) )
    {
        clAmsFreeMemory ((*res)->entityRef);
    }

    clAmsFreeMemory (*res);

    return rc;

}

ClRcT
cl_ams_mgmt_get_ol_entity_list(
        CL_IN  clAmsMgmtGetOLEntityListRequestT  *req,
        CL_OUT  clAmsMgmtGetOLEntityListResponseT  **res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_GET_OL_ENTITY_LIST,
            (ClPtrT)req, &marshalClAmsMgmtGetOLEntityList,
            (ClPtrT*)res, &unmarshalClAmsMgmtGetOLEntityList);
}

ClRcT
clAmsGetEntitySize(
        CL_IN  ClAmsEntityTypeT  *entityType,
        CL_OUT  ClUint32T  *configSize,
        CL_OUT  ClUint32T  *statusSize,
        CL_OUT  ClUint32T  *entitySize )
{

    if (!entityType || !configSize || !statusSize || !entitySize )
    {
        return CL_ERR_NULL_POINTER;
    }

    switch ( *entityType )
    {

        case CL_AMS_ENTITY_TYPE_ENTITY:
            {

                ClAmsEntityT  entity;
                *configSize = sizeof (ClAmsEntityT);
                *statusSize = 0; 
                *entitySize = sizeof (entity);

                break;

            }

        case CL_AMS_ENTITY_TYPE_NODE:
            {

                ClAmsNodeT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            }

        case CL_AMS_ENTITY_TYPE_SG:
            {

                ClAmsSGT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            } 
    
       case CL_AMS_ENTITY_TYPE_SU:
            {

                ClAmsSUT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            }
       
       case CL_AMS_ENTITY_TYPE_SI:
            {

                ClAmsSIT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            }

       case CL_AMS_ENTITY_TYPE_COMP:
            {

                ClAmsCompT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            } 
       
       case CL_AMS_ENTITY_TYPE_CSI:
            {

                ClAmsCSIT  entity;
                *configSize = sizeof (entity.config);
                *statusSize = sizeof (entity.status);
                *entitySize = sizeof (entity);

                break;

            } 

       default:
            {
            }
    
    } 

    return CL_OK;

}

static ClRcT 
marshallClAmsMgmtMigrateRequest(ClPtrT req,
                                ClBufferHandleT inMsgHdl)
{
    return VDECL_VER(clXdrMarshallClAmsMgmtMigrateRequestT, 4, 0, 0)(req, inMsgHdl, 0);
}

static ClRcT
unmarshallClAmsMgmtMigrateResponse(ClBufferHandleT inMsgHdl,
                                   ClPtrT *pRes)
{
    ClPtrT res = (ClPtrT)pRes;
    return VDECL_VER(clXdrUnmarshallClAmsMgmtMigrateResponseT, 4, 0, 0)(inMsgHdl, res);
}

ClRcT
cl_ams_mgmt_migrate_sg(
                       ClAmsMgmtMigrateRequestT *req,
                       ClAmsMgmtMigrateResponseT *res)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_MIGRATE_SG,
                            (ClPtrT)req, &marshallClAmsMgmtMigrateRequest,
                            (ClPtrT*)res, &unmarshallClAmsMgmtMigrateResponse);
}

static ClRcT
marshallClAmsMgmtUserDataSetRequest(ClPtrT req,
                                    ClBufferHandleT inMsgHdl)
{
    ClAmsMgmtUserDataSetRequestT *request = req;
    ClRcT rc = CL_OK;
    rc = VDECL_VER(clXdrMarshallClAmsEntityConfigT, 4, 0, 0)(request->entity, inMsgHdl, 0);
    if(rc != CL_OK) return rc;
    if(request->key)
    {
        rc = clXdrMarshallClNameT(request->key, inMsgHdl, 0);
        if(rc != CL_OK) return rc;
    }
    rc = clXdrMarshallClUint32T(&request->len, inMsgHdl, 0);
    if(rc != CL_OK) return rc;
    if(request->len)
    {
        rc = clXdrMarshallArrayClCharT(request->data, request->len, inMsgHdl, 0);
    }
    return rc;
}

static ClRcT
unmarshallClAmsMgmtUserDataResponse(ClBufferHandleT inMsgHdl,
                                    ClPtrT *res)
{
    return CL_OK;
}

static ClRcT
marshallClAmsMgmtUserDataGetRequest(ClPtrT req,
                                    ClBufferHandleT inMsgHdl)
{
    ClRcT rc = CL_OK;
    ClAmsMgmtUserDataGetRequestT *request = req;
    rc = VDECL_VER(clXdrMarshallClAmsEntityConfigT, 4, 0, 0)(request->entity, inMsgHdl, 0);
    if(rc != CL_OK) return rc;
    if(request->key)
    {
        rc = clXdrMarshallClNameT(request->key, inMsgHdl, 0);
    }
    return rc;
}

static ClRcT
unmarshallClAmsMgmtUserDataGetRequest(ClBufferHandleT inMsgHdl,
                                      ClPtrT *res)
{
    ClAmsMgmtUserDataGetRequestT *request = (ClAmsMgmtUserDataGetRequestT*)res;
    ClRcT rc = CL_OK;
    rc = clXdrUnmarshallClUint32T(inMsgHdl, request->len);
    if(rc != CL_OK) return rc;
    if(request->data && *request->len)
    {
        *request->data = NULL;
        *request->data = clHeapCalloc(1, *request->len);
        CL_ASSERT(*request->data);
        rc = clXdrUnmarshallArrayClCharT(inMsgHdl, *request->data, *request->len);
        if(rc != CL_OK)
        {
            clHeapFree(*request->data);
            *request->data = NULL;
            return rc;
        }
    }
    return rc;
}

static ClRcT marshallClAmsMgmtUserDataDeleteRequest(ClPtrT req,
                                            ClBufferHandleT inMsgHdl)
{
    ClAmsMgmtUserDataDeleteRequestT *request = req;
    ClRcT rc = CL_OK;
    rc = VDECL_VER(clXdrMarshallClAmsEntityConfigT, 4, 0, 0)(request->entity, inMsgHdl, 0);
    if(rc != CL_OK) return rc;
    if(request->key)
    {
        rc = clXdrMarshallClNameT(request->key, inMsgHdl, 0);
        if(rc != CL_OK)
            return rc;
    }
    else
    {
        rc = clXdrMarshallClUint16T(&request->clear, inMsgHdl, 0);
        if(rc != CL_OK) return rc;
    }
    return rc;
}

ClRcT cl_ams_mgmt_user_data_set(ClAmsMgmtUserDataSetRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_SET,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataSetRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataResponse);
}

ClRcT cl_ams_mgmt_user_data_setkey(ClAmsMgmtUserDataSetRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_SETKEY,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataSetRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataResponse);
}

ClRcT cl_ams_mgmt_user_data_get(ClAmsMgmtUserDataGetRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_GET,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataGetRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataGetRequest);
}

ClRcT cl_ams_mgmt_user_data_getkey(ClAmsMgmtUserDataGetRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_GETKEY,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataGetRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataGetRequest);
}

ClRcT cl_ams_mgmt_user_data_delete(ClAmsMgmtUserDataDeleteRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_DELETE,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataDeleteRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataResponse);
}

ClRcT cl_ams_mgmt_user_data_deletekey(ClAmsMgmtUserDataDeleteRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_DELETEKEY,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataDeleteRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataResponse);
}

ClRcT cl_ams_mgmt_user_data_deleteall(ClAmsMgmtUserDataDeleteRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_ENTITY_USER_DATA_DELETE,
                            (ClPtrT)req, &marshallClAmsMgmtUserDataDeleteRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtUserDataResponse);
}

static ClRcT
marshallClAmsMgmtSIAssignSUCustomRequest(
        CL_IN  ClPtrT  ptr,
        CL_INOUT ClBufferHandleT  buf)
{
    return VDECL_VER(clXdrMarshallClAmsMgmtSIAssignSUCustomRequestT, 4, 0, 0)(ptr, buf, 0);
}

static ClRcT
unmarshallClAmsMgmtSIAssignSUCustomResponse(
        CL_IN  ClBufferHandleT  buf,
        CL_INOUT  ClPtrT  *pptr)
{
    return CL_OK;
}

ClRcT cl_ams_mgmt_si_assign_su_custom(ClAmsMgmtSIAssignSUCustomRequestT *req)
{
    return cl_ams_call_rmd( (ClUint32T) CL_AMS_MGMT_SI_ASSIGN_SU_CUSTOM,
                            (ClPtrT)req, &marshallClAmsMgmtSIAssignSUCustomRequest,
                            (ClPtrT*)req, &unmarshallClAmsMgmtSIAssignSUCustomResponse);
}

#ifdef AMS_EMULATE_RMD_CALLS

static ClRcT
emulate_rmd_call(
        CL_IN ClUint32T versionCode,
        CL_IN  ClUint32T  fn_id,
        CL_IN  ClBufferHandleT  in_buffer,
        CL_OUT  ClBufferHandleT  out_buffer)
{
    ClRcT rc = CL_OK;
    ClEoDataT data = 0;

    switch (fn_id)
    {

        case CL_AMS_MGMT_INITIALIZE:
            {
                rc = VDECL(_clAmsMgmtInitialize)(data,in_buffer, out_buffer);
                break;
            }
        
        case CL_AMS_MGMT_FINALIZE:
            {
                rc = VDECL(_clAmsMgmtFinalize)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_CREATE:
            {
                rc = VDECL(_clAmsMgmtEntityCreate)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_DELETE:
            {
                rc = VDECL(_clAmsMgmtEntityDelete)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_SET_CONFIG:
            {
                rc = VDECL(_clAmsMgmtEntitySetConfig)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_LOCK_ASSIGNMENT:
            {
                rc = VDECL(_clAmsMgmtEntityLockAssignment)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_LOCK_INSTANTIATION:
            {
                rc = VDECL(_clAmsMgmtEntityLockInstantiation)(data, in_buffer, 
                                                              out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_UNLOCK:
            {
                rc = VDECL(_clAmsMgmtEntityUnlock)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_SHUTDOWN:
            {
                rc = VDECL(_clAmsMgmtEntityShutdown)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_RESTART:
            {
                rc = VDECL(_clAmsMgmtEntityRestart)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_REPAIRED:
            {
                rc = VDECL(_clAmsMgmtEntityRepaired)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_SG_ADJUST_PREFERENCE:
            {
                rc = VDECL(_clAmsMgmtSGAdjustPreference)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_SI_SWAP:
            {
                rc = VDECL(_clAmsMgmtSISwap)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_LIST_ENTITY_REF_ADD:
            {
                rc = VDECL(_clAmsMgmtEntityListEntityRefAdd)(data, in_buffer, 
                                                             out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_SET_REF:
            {
                rc = VDECL(_clAmsMgmtEntitySetRef)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CSI_SET_NVP:
            {
                rc = VDECL(_clAmsMgmtCSISetNVP)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_DEBUG_ENABLE:
            {
                rc = VDECL(_clAmsMgmtDebugEnable)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_DEBUG_DISABLE:
            {
                rc = VDECL(_clAmsMgmtDebugDisable)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_DEBUG_GET:
            {
                rc = VDECL(_clAmsMgmtDebugGet)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_DEBUG_ENABLE_LOG_TO_CONSOLE:
            {
                rc = VDECL(_clAmsMgmtDebugEnableLogToConsole)(data, in_buffer, 
                                                              out_buffer);
                break;
            }

        case CL_AMS_MGMT_DEBUG_DISABLE_LOG_TO_CONSOLE:
            {
                rc = VDECL(_clAmsMgmtDebugDisableLogToConsole)(data, in_buffer, 
                                                               out_buffer);
                break;
            }


        case CL_AMS_MGMT_CCB_INITIALIZE:
            {
                rc = VDECL(_clAmsMgmtCCBInitialize)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_FINALIZE:
            {
                rc = VDECL(_clAmsMgmtCCBFinalize)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_ENTITY_SET_CONFIG:
            {
                switch(versionCode)
                {
                case CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE):
                    rc = VDECL_VER(_clAmsMgmtCCBEntitySetConfig, 4, 0, 0)(data, in_buffer, out_buffer);
                    break;
                case CL_VERSION_CODE(4, 1, 0):
                    rc = VDECL_VER(_clAmsMgmtCCBEntitySetConfig, 4, 1, 0)(data, in_buffer, out_buffer);
                    break;
                default:
                    rc = VDECL_VER(_clAmsMgmtCCBEntitySetConfig, 5, 0, 0)(data, in_buffer, out_buffer);
                    break;
                }
                break;
            }

        case CL_AMS_MGMT_CCB_CSI_SET_NVP:
            {
                rc = VDECL(_clAmsMgmtCCBCSISetNVP)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_CSI_DELETE_NVP:
            {
                rc = VDECL(_clAmsMgmtCCBCSIDeleteNVP)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_NODE_DEPENDENCY:
            {
                rc = VDECL(_clAmsMgmtCCBSetNodeDependency)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_NODE_SU_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetNodeSUList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SG_SU_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetSGSUList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SG_SI_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetSGSIList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SU_COMP_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetSUCompList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SI_SU_RANK_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetSISURankList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SI_SI_DEPENDENCY:
            {
                rc = VDECL(_clAmsMgmtCCBSetSISIDependency)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_SET_SI_CSI_LIST:
            {
                rc = VDECL(_clAmsMgmtCCBSetSICSIList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_ENTITY_CREATE:
            {
                rc = VDECL(_clAmsMgmtCCBEntityCreate)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_ENTITY_DELETE:
            {
                rc = VDECL(_clAmsMgmtCCBEntityDelete)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_CCB_COMMIT:
            {
                rc = VDECL(_clAmsMgmtCCBCommit)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_GET:
            {
                switch(versionCode)
                {
                case CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE):
                    rc = VDECL_VER(_clAmsMgmtEntityGet, 4, 0, 0)(data, in_buffer, out_buffer);
                    break;
                case CL_VERSION_CODE(4, 1, 0):
                    rc = VDECL_VER(_clAmsMgmtEntityGet, 4, 1, 0)(data, in_buffer, out_buffer);
                    break;
                default:
                    rc = VDECL_VER(_clAmsMgmtEntityGet, 5, 0, 0)(data, in_buffer, out_buffer);
                    break;
                }
                break;
            }

        case CL_AMS_MGMT_ENTITY_GET_CONFIG:
            {
                switch(versionCode)
                {
                case CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE):
                    rc = VDECL_VER(_clAmsMgmtEntityGetConfig, 4, 0, 0)(data, in_buffer, out_buffer);
                    break;
                case CL_VERSION_CODE(4, 1, 0):
                    rc = VDECL_VER(_clAmsMgmtEntityGetConfig, 4, 1, 0)(data, in_buffer, out_buffer);
                    break;
                default:
                    rc = VDECL_VER(_clAmsMgmtEntityGetConfig, 5, 0, 0)(data, in_buffer, out_buffer);
                    break;
                }
                break;
            }

        case CL_AMS_MGMT_ENTITY_GET_STATUS:
            {
                switch(versionCode)
                {
                case CL_VERSION_CODE(CL_RELEASE_VERSION_BASE, CL_MAJOR_VERSION_BASE, CL_MINOR_VERSION_BASE):
                    rc = VDECL_VER(_clAmsMgmtEntityGetStatus, 4, 0, 0)(data,in_buffer, out_buffer);
                    break;
                default:
                    rc = VDECL_VER(_clAmsMgmtEntityGetStatus, 4, 1, 0)(data,in_buffer, out_buffer);
                    break;
                }
                break;
            }

        case CL_AMS_MGMT_GET_CSI_NVP_LIST:
            {
                rc = VDECL(_clAmsMgmtGetCSINVPList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_GET_ENTITY_LIST:
            {
                rc = VDECL(_clAmsMgmtGetEntityList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_GET_OL_ENTITY_LIST:
            {
                rc = VDECL(_clAmsMgmtGetOLEntityList)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_SET_ALPHA_FACTOR:
            {
                rc = VDECL(_clAmsMgmtEntitySetAlphaFactor)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_ENTITY_SET_BETA_FACTOR:
            {
                rc = VDECL(_clAmsMgmtEntitySetBetaFactor)(data,in_buffer, out_buffer);
                break;
            }

        case CL_AMS_MGMT_SI_ASSIGN_SU_CUSTOM:
            {
                rc = VDECL(_clAmsMgmtSIAssignSUCustom)(data, in_buffer, out_buffer);
                break;
            }

        default:
            {
                rc = CL_AMS_ERR_INVALID_OPERATION;
            } 
    
    }

    return rc;
}

#endif

