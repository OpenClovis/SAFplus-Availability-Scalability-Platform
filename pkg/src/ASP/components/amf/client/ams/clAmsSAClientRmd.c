/*
 * Copyright (C) 2002-2009 by OpenClovis Inc. All  Rights Reserved.
 * 
 * The source code for  this program is not published  or otherwise 
 * divested of  its trade secrets, irrespective  of  what  has been 
 * deposited with the U.S. Copyright office.
 * 
 * This program is  free software; you can redistribute it and / or
 * modify  it under  the  terms  of  the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * 
 * This program is distributed in the  hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied  warranty  of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * You  should  have  received  a  copy of  the  GNU General Public
 * License along  with  this program. If  not,  write  to  the 
 * Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*
 * Build: 4.2.0
 */
/*******************************************************************************
 * ModuleName  : amf
 * File        : clAmsSAClientRmd.c
 *******************************************************************************/

/*******************************************************************************
 * Description :
 * High-level RMD functions for the AMS client side.  These should be
 * eventually autogenerated, but for now written by hand.
 *****************************************************************************/

#include <clCommon.h>
#include <clCommonErrors.h>
#include <clDebugApi.h>
#include <clBufferApi.h>

#include <clAmsDebug.h>
#include <clAmsErrors.h>
#include <clAmsSAClientRmd.h>
#include <clAmsUtils.h>

/******************************************************************************
 * Common RMD Call Wrapper
 *****************************************************************************/

#ifdef AMS_EMULATE_RMD_CALLS

#include "../../server/ams/clAmsSAServerApi.h"

static ClRcT emulate_rmd_call(
        CL_IN       ClUint32T fn_id,
        CL_IN       ClBufferHandleT in_buffer,
        CL_OUT      ClBufferHandleT out_buffer);

#endif /* AMS_EMULATE_RMD_CALLS */

/*
 * The common RMD call
 */
static ClRcT
cl_ams_call_rmd(
        CL_IN  ClUint32T  fn_id,            /* RMD function identifier */
        CL_IN  void      *req,              /* Pointer to input argument root */
        CL_IN  ClRcT    (*marshal_req)(void*, ClBufferHandleT),
        /* Marshaling function pointer */
        CL_OUT void     **res,              /* Pointer to response argument root */
        CL_IN  ClRcT    (*unmarshal_res)(ClBufferHandleT, void**))
    /* Unmarshaling function pointer */
{
    ClRcT                       rc = CL_OK;
    ClBufferHandleT      in_buffer;
    ClBufferHandleT      out_buffer;
    ClIocAddressT               dest_addr;
    ClUint32T                   rmd_flags;
    ClRmdOptionsT               rmd_options = CL_RMD_DEFAULT_OPTIONS;

    /* Argument (sanity) checking */

    CL_ASSERT(req!=NULL);
    CL_ASSERT(res!=NULL);

    /* Prepare the input data */

    rc = clBufferCreate(&in_buffer);
    if (rc != CL_OK)
    {
        return rc;
    }

    /* Call the marshaling function to marshal the request data */
    rc = (*marshal_req)(req, in_buffer);
    if (rc != CL_OK)
    {
        goto error_free_inbuffer;
    }

    /* Allocate the output buffer */

    rc = clBufferCreate(&out_buffer);
    if (rc != CL_OK)
    {
        goto error_free_inbuffer;
    }

    /*
     * FIXME: This now uses the physical address, instead of a logical
     * address.
     */
    dest_addr.iocPhyAddress.nodeAddress = 1/*(clIocLocalAddressGet()*/;
    dest_addr.iocPhyAddress.portId = CL_IOC_AMS_PORT;
    rmd_options.timeout = CL_AMS_RMD_DEFAULT_TIMEOUT;
    rmd_options.retries = CL_AMS_RMD_DEFAULT_RETRIES;
    rmd_flags = CL_RMD_CALL_NEED_REPLY;

#ifndef AMS_EMULATE_RMD_CALLS
    rc = clRmdWithMsg(dest_addr, fn_id, in_buffer, out_buffer,
            rmd_flags, &rmd_options, NULL);
#else
    rc = emulate_rmd_call(fn_id, in_buffer, out_buffer);
#endif /* AMS_EMULATE_RMD_CALLS */

    if (rc != CL_OK)
    {
        goto error_free_both_buffers;
    }

    /* Process returned data */

    rc = (*unmarshal_res)(out_buffer, res);

error_free_both_buffers:
    clBufferDelete(&out_buffer);

error_free_inbuffer:
    clBufferDelete(&in_buffer);

    return rc;
}

/******************************************************************************/

static ClRcT
marshalClAmsClientInitialize(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientInitializeRequestT *req = (clAmsClientInitializeRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientInitialize(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_client_initialize(
        CL_IN   clAmsClientInitializeRequestT   *req,
        CL_OUT  clAmsClientInitializeResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_INITIALIZE,
            (void*)req, &marshalClAmsClientInitialize,
            (void**)res, &unmarshalClAmsClientInitialize);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientFinalize(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientFinalizeRequestT *req = (clAmsClientFinalizeRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientFinalize(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    return CL_OK;
}

ClRcT
cl_ams_client_finalize(
        CL_IN   clAmsClientFinalizeRequestT   *req,
        CL_OUT  clAmsClientFinalizeResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_FINALIZE,
            (void*)req, &marshalClAmsClientFinalize,
            (void**)res, &unmarshalClAmsClientFinalize);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientCSIHAStateGet(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientCSIHAStateGetRequestT *req = (clAmsClientCSIHAStateGetRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientCSIHAStateGet(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    clAmsClientCSIHAStateGetResponseT **res = (clAmsClientCSIHAStateGetResponseT **)pptr;
    ClUint32T len;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_AMS_RC(CL_AMS_ERR_UNMARSHALING_FAILED);
    }

    /* We have clAmsClientCSIHAStateGetResponseT buffer from the server */
    *res = (clAmsClientCSIHAStateGetResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_AMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
    return rc;

error_exit:
    clHeapFree((void*)*res);
    return rc;
}

ClRcT
cl_ams_client_csi_ha_state_get(
        CL_IN   clAmsClientCSIHAStateGetRequestT   *req,
        CL_OUT  clAmsClientCSIHAStateGetResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_CSI_HA_STATE_GET,
            (void*)req, &marshalClAmsClientCSIHAStateGet,
            (void**)res, &unmarshalClAmsClientCSIHAStateGet);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientCSIQuiescingComplete(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientCSIQuiescingCompleteRequestT *req = (clAmsClientCSIQuiescingCompleteRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientCSIQuiescingComplete(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    clAmsClientCSIQuiescingCompleteResponseT **res = (clAmsClientCSIQuiescingCompleteResponseT **)pptr;
    ClUint32T len;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_AMS_RC(CL_AMS_ERR_UNMARSHALING_FAILED);
    }

    /* We have clAmsClientCSIQuiescingCompleteResponseT buffer from the server */
    *res = (clAmsClientCSIQuiescingCompleteResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_AMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
    return rc;

error_exit:
    clHeapFree((void*)*res);
    return rc;
}

ClRcT
cl_ams_client_csi_quiescing_complete(
        CL_IN   clAmsClientCSIQuiescingCompleteRequestT   *req,
        CL_OUT  clAmsClientCSIQuiescingCompleteResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_CSI_QUIESCING_COMPLETE,
            (void*)req, &marshalClAmsClientCSIQuiescingComplete,
            (void**)res, &unmarshalClAmsClientCSIQuiescingComplete);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientPGTrack(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientPGTrackRequestT *req = (clAmsClientPGTrackRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientPGTrack(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    clAmsClientPGTrackResponseT **res = (clAmsClientPGTrackResponseT **)pptr;
    ClUint32T len;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_AMS_RC(CL_AMS_ERR_UNMARSHALING_FAILED);
    }

    /* We have clAmsClientPGTrackResponseT buffer from the server */
    *res = (clAmsClientPGTrackResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_AMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
    return rc;

error_exit:
    clHeapFree((void*)*res);
    return rc;
}

ClRcT
cl_ams_client_pg_track(
        CL_IN   clAmsClientPGTrackRequestT   *req,
        CL_OUT  clAmsClientPGTrackResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_PG_TRACK,
            (void*)req, &marshalClAmsClientPGTrack,
            (void**)res, &unmarshalClAmsClientPGTrack);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientPGTrackStop(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientPGTrackStopRequestT *req = (clAmsClientPGTrackStopRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientPGTrackStop(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    clAmsClientPGTrackStopResponseT **res = (clAmsClientPGTrackStopResponseT **)pptr;
    ClUint32T len;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_AMS_RC(CL_AMS_ERR_UNMARSHALING_FAILED);
    }

    /* We have clAmsClientPGTrackStopResponseT buffer from the server */
    *res = (clAmsClientPGTrackStopResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_AMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
    return rc;

error_exit:
    clHeapFree((void*)*res);
    return rc;
}

ClRcT
cl_ams_client_pg_track_stop(
        CL_IN   clAmsClientPGTrackStopRequestT   *req,
        CL_OUT  clAmsClientPGTrackStopResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_PG_TRACK_STOP,
            (void*)req, &marshalClAmsClientPGTrackStop,
            (void**)res, &unmarshalClAmsClientPGTrackStop);
}
/******************************************************************************/

static ClRcT
marshalClAmsClientResponse(
        CL_IN   void   *ptr,
        CL_INOUT ClBufferHandleT     buf)
{
    ClRcT rc = CL_OK;
    clAmsClientResponseRequestT *req = (clAmsClientResponseRequestT *)ptr;

    CL_ASSERT(req!=NULL);

    rc = clBufferNBytesWrite(buf, (void*)req, sizeof(*req));
    return rc;
}

static ClRcT
unmarshalClAmsClientResponse(
        CL_IN    ClBufferHandleT     buf,
        CL_INOUT void                     **pptr)
{
    ClRcT rc = CL_OK;
    clAmsClientResponseResponseT **res = (clAmsClientResponseResponseT **)pptr;
    ClUint32T len;

    rc = clBufferLengthGet(buf, &len);
    if (rc != CL_OK || len < sizeof(**res))
    {
        return CL_AMS_RC(CL_AMS_ERR_UNMARSHALING_FAILED);
    }

    /* We have clAmsClientResponseResponseT buffer from the server */
    *res = (clAmsClientResponseResponseT*)clHeapAllocate(sizeof(**res));
    if (*res == NULL)
    {
        return CL_AMS_RC(CL_ERR_NO_MEMORY);
    }

    len = sizeof(**res);
    rc = clBufferNBytesRead(buf, (void*)*res, &len);
    if (rc != CL_OK)
    {
        goto error_exit;
    }
    CL_ASSERT(len == sizeof(**res)); /* to never happen */
    return rc;

error_exit:
    clHeapFree((void*)*res);
    return rc;
}

ClRcT
cl_ams_client_response(
        CL_IN   clAmsClientResponseRequestT   *req,
        CL_OUT  clAmsClientResponseResponseT **res)
{
    return cl_ams_call_rmd((
                ClUint32T)CL_AMS_CLIENT_RESPONSE,
            (void*)req, &marshalClAmsClientResponse,
            (void**)res, &unmarshalClAmsClientResponse);
}
/******************************************************************************/

#ifdef AMS_EMULATE_RMD_CALLS

static ClRcT
emulate_rmd_call(
        CL_IN       ClUint32T fn_id,
        CL_IN       ClBufferHandleT in_buffer,
        CL_OUT      ClBufferHandleT out_buffer)
{
    ClRcT rc = CL_OK;

    switch (fn_id)
    {
        case CL_AMS_CLIENT_INITIALIZE:
            return CL_OK;
            break;
        case CL_AMS_CLIENT_FINALIZE:
            return CL_OK;
            break;
        default:
            AMS_LOG(CL_DEBUG_ERROR,("%s:: function id %d not implemented \n",__FUNCTION__,fn_id));
    }
    return rc;
}

#endif
