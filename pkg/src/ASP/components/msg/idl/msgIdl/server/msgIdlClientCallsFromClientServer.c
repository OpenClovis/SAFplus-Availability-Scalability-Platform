/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "msgIdlClientCallsFromClientServer.h"
#include "msgIdlServer.h"

extern ClUint32T  msgIdlidlSyncKey;
extern ClHandleDatabaseHandleT  msgIdlidlDatabaseHdl;



ClRcT clMsgClientInitServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClUint32T  pVersion;
    ClHandleT  clientHandle;
    ClHandleT  pMsgHandle;

    memset(&(pVersion), 0, sizeof(ClUint32T));
    memset(&(clientHandle), 0, sizeof(ClHandleT));
    memset(&(pMsgHandle), 0, sizeof(ClHandleT));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(pVersion));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(clientHandle));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientInit_4_0_0(&(pVersion), clientHandle, &(pMsgHandle));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(pVersion), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClHandleT(&(clientHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClHandleT(&(pMsgHandle), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL1:  clXdrMarshallClHandleT(&(clientHandle), 0, 1);
LL0:  clXdrMarshallClUint32T(&(pVersion), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(pVersion), 0, 1);
L1:  clXdrMarshallClHandleT(&(clientHandle), 0, 1);

L2:  clXdrMarshallClHandleT(&(pMsgHandle), 0, 1);

    return rc;
}

ClRcT clMsgClientInitResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClHandleT  pMsgHandle)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClHandleT(&(pMsgHandle), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L3:  clXdrMarshallClHandleT(&(pMsgHandle), 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgClientFinServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  msgHandle;

    memset(&(msgHandle), 0, sizeof(ClHandleT));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientFin_4_0_0(msgHandle);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L1:    return rc;

LL0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);


    return rc;
}

ClRcT clMsgClientFinResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgClientMessageSendServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  msgHandle;
    ClNameT  pDestination;
    SaMsgMessageT_4_0_0  pMessage;
    ClInt64T  sendTime;
    ClInt64T  timeout;

    memset(&(msgHandle), 0, sizeof(ClHandleT));
    memset(&(pDestination), 0, sizeof(ClNameT));
    memset(&(pMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(sendTime), 0, sizeof(ClInt64T));
    memset(&(timeout), 0, sizeof(ClInt64T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pDestination));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pMessage));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(sendTime));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientMessageSend_4_0_0(msgHandle, &(pDestination), &(pMessage), sendTime, timeout);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pDestination), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClInt64T(&(sendTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L5:    return rc;

LL4:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
LL2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
LL1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
LL0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
L1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
L2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
L3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
L4:  clXdrMarshallClInt64T(&(timeout), 0, 1);


    return rc;
}

ClRcT clMsgClientMessageSendResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgClientMessageGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  qHandle;
    SaMsgMessageT_4_0_0  pMessage;
    ClInt64T  pSendTime;
    ClUint64T  pSenderId;
    ClInt64T  timeout;

    memset(&(qHandle), 0, sizeof(ClHandleT));
    memset(&(pMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(pSendTime), 0, sizeof(ClInt64T));
    memset(&(pSenderId), 0, sizeof(ClUint64T));
    memset(&(timeout), 0, sizeof(ClInt64T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(qHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pMessage));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientMessageGet_4_0_0(qHandle, &(pMessage), &(pSendTime), &(pSenderId), timeout);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(qHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClInt64T(&(pSendTime), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint64T(&(pSenderId), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

L5:    return rc;

LL2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
LL1:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL0:  clXdrMarshallClHandleT(&(qHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(qHandle), 0, 1);
L1:  clXdrMarshallClInt64T(&(timeout), 0, 1);

L2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
L3:  clXdrMarshallClInt64T(&(pSendTime), 0, 1);
L4:  clXdrMarshallClUint64T(&(pSenderId), 0, 1);

    return rc;
}

ClRcT clMsgClientMessageGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  SaMsgMessageT_4_0_0  pMessage,CL_OUT  ClInt64T  pSendTime,CL_OUT  ClUint64T  pSenderId)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClInt64T(&(pSendTime), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint64T(&(pSenderId), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L3:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
L4:  clXdrMarshallClInt64T(&(pSendTime), 0, 1);
L5:  clXdrMarshallClUint64T(&(pSenderId), 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgClientMessageSendReceiveServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  msgHandle;
    ClNameT  pDestination;
    SaMsgMessageT_4_0_0  pSendMessage;
    ClInt64T  sendTime;
    SaMsgMessageT_4_0_0  pRecvMessage;
    ClInt64T  replySendTime;
    ClInt64T  timeout;

    memset(&(msgHandle), 0, sizeof(ClHandleT));
    memset(&(pDestination), 0, sizeof(ClNameT));
    memset(&(pSendMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(sendTime), 0, sizeof(ClInt64T));
    memset(&(pRecvMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(replySendTime), 0, sizeof(ClInt64T));
    memset(&(timeout), 0, sizeof(ClInt64T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pDestination));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pSendMessage));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(sendTime));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pRecvMessage));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(replySendTime));
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientMessageSendReceive_4_0_0(msgHandle, &(pDestination), &(pSendMessage), sendTime, &(pRecvMessage), &(replySendTime), timeout);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pDestination), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pSendMessage), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClInt64T(&(sendTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pRecvMessage), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClInt64T(&(replySendTime), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

L7:    return rc;

LL6:  clXdrMarshallClInt64T(&(replySendTime), 0, 1);
LL5:  clXdrMarshallSaMsgMessageT_4_0_0(&(pRecvMessage), 0, 1);
LL4:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
LL2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pSendMessage), 0, 1);
LL1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
LL0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
L1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
L2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pSendMessage), 0, 1);
L3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
L4:  clXdrMarshallClInt64T(&(timeout), 0, 1);

L5:  clXdrMarshallSaMsgMessageT_4_0_0(&(pRecvMessage), 0, 1);
L6:  clXdrMarshallClInt64T(&(replySendTime), 0, 1);

    return rc;
}

ClRcT clMsgClientMessageSendReceiveResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_INOUT  SaMsgMessageT_4_0_0  pRecvMessage,CL_INOUT  ClInt64T  replySendTime)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pRecvMessage), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallClInt64T(&(replySendTime), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    
L6:  clXdrMarshallSaMsgMessageT_4_0_0(&(pRecvMessage), 0, 1);
L7:  clXdrMarshallClInt64T(&(replySendTime), 0, 1);

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgClientMessageReplyServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClHandleT  msgHandle;
    SaMsgMessageT_4_0_0  pReplyMessage;
    ClInt64T  sendTime;
    ClHandleT  pSenderId;
    ClInt64T  timeout;

    memset(&(msgHandle), 0, sizeof(ClHandleT));
    memset(&(pReplyMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(sendTime), 0, sizeof(ClInt64T));
    memset(&(pSenderId), 0, sizeof(ClHandleT));
    memset(&(timeout), 0, sizeof(ClInt64T));


    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(msgHandle));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pReplyMessage));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(sendTime));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(pSenderId));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgClientMessageReply_4_0_0(msgHandle, &(pReplyMessage), sendTime, pSenderId, timeout);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClHandleT(&(msgHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pReplyMessage), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClInt64T(&(sendTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClHandleT(&(pSenderId), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L5:    return rc;

LL4:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL3:  clXdrMarshallClHandleT(&(pSenderId), 0, 1);
LL2:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
LL1:  clXdrMarshallSaMsgMessageT_4_0_0(&(pReplyMessage), 0, 1);
LL0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);

    return rc;

L0:  clXdrMarshallClHandleT(&(msgHandle), 0, 1);
L1:  clXdrMarshallSaMsgMessageT_4_0_0(&(pReplyMessage), 0, 1);
L2:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
L3:  clXdrMarshallClHandleT(&(pSenderId), 0, 1);
L4:  clXdrMarshallClInt64T(&(timeout), 0, 1);


    return rc;
}

ClRcT clMsgClientMessageReplyResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

