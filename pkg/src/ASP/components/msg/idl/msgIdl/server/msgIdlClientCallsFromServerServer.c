/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "msgIdlClientCallsFromServerServer.h"
#include "msgIdlServer.h"

extern ClUint32T  msgIdlidlSyncKey;
extern ClHandleDatabaseHandleT  msgIdlidlDatabaseHdl;



ClRcT clMsgMessageReceivedServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClUint32T  sendType;
    ClNameT  pDestination;
    SaMsgMessageT_4_0_0  pMessage;
    ClInt64T  sendTime;
    ClHandleT  senderHandle;
    ClInt64T  timeout;

    memset(&(sendType), 0, sizeof(ClUint32T));
    memset(&(pDestination), 0, sizeof(ClNameT));
    memset(&(pMessage), 0, sizeof(SaMsgMessageT_4_0_0));
    memset(&(sendTime), 0, sizeof(ClInt64T));
    memset(&(senderHandle), 0, sizeof(ClHandleT));
    memset(&(timeout), 0, sizeof(ClInt64T));


    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(sendType));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pDestination));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaMsgMessageT_4_0_0( inMsgHdl,&(pMessage));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(sendTime));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(senderHandle));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClInt64T( inMsgHdl,&(timeout));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgMessageReceived_4_0_0(sendType, &(pDestination), &(pMessage), sendTime, senderHandle, timeout);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint32T(&(sendType), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pDestination), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClInt64T(&(sendTime), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClHandleT(&(senderHandle), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClInt64T(&(timeout), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L6:    return rc;

LL5:  clXdrMarshallClInt64T(&(timeout), 0, 1);
LL4:  clXdrMarshallClHandleT(&(senderHandle), 0, 1);
LL3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
LL2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
LL1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
LL0:  clXdrMarshallClUint32T(&(sendType), 0, 1);

    return rc;

L0:  clXdrMarshallClUint32T(&(sendType), 0, 1);
L1:  clXdrMarshallClNameT(&(pDestination), 0, 1);
L2:  clXdrMarshallSaMsgMessageT_4_0_0(&(pMessage), 0, 1);
L3:  clXdrMarshallClInt64T(&(sendTime), 0, 1);
L4:  clXdrMarshallClHandleT(&(senderHandle), 0, 1);
L5:  clXdrMarshallClInt64T(&(timeout), 0, 1);


    return rc;
}

ClRcT clMsgMessageReceivedResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQDatabaseUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClMsgSyncActionT_4_0_0  syncupType;
    ClNameT  pQName;
    ClIocPhysicalAddressT_4_0_0  pCompAddr;
    ClIocPhysicalAddressT_4_0_0  pNewOwner;

    memset(&(syncupType), 0, sizeof(ClMsgSyncActionT_4_0_0));
    memset(&(pQName), 0, sizeof(ClNameT));
    memset(&(pCompAddr), 0, sizeof(ClIocPhysicalAddressT_4_0_0));
    memset(&(pNewOwner), 0, sizeof(ClIocPhysicalAddressT_4_0_0));


    rc = clXdrUnmarshallClMsgSyncActionT_4_0_0( inMsgHdl,&(syncupType));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClIocPhysicalAddressT_4_0_0( inMsgHdl,&(pCompAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClIocPhysicalAddressT_4_0_0( inMsgHdl,&(pNewOwner));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQDatabaseUpdate_4_0_0(syncupType, &(pQName), &(pCompAddr), &(pNewOwner));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pNewOwner), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L4:    return rc;

LL3:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pNewOwner), 0, 1);
LL2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);
LL1:  clXdrMarshallClNameT(&(pQName), 0, 1);
LL0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);

    return rc;

L0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);
L1:  clXdrMarshallClNameT(&(pQName), 0, 1);
L2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);
L3:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pNewOwner), 0, 1);


    return rc;
}

ClRcT clMsgQDatabaseUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgGroupDatabaseUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClMsgSyncActionT_4_0_0  syncupType;
    ClNameT  pGroupName;
    SaMsgQueueGroupPolicyT_4_0_0  policy;

    memset(&(syncupType), 0, sizeof(ClMsgSyncActionT_4_0_0));
    memset(&(pGroupName), 0, sizeof(ClNameT));
    memset(&(policy), 0, sizeof(SaMsgQueueGroupPolicyT_4_0_0));


    rc = clXdrUnmarshallClMsgSyncActionT_4_0_0( inMsgHdl,&(syncupType));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallSaMsgQueueGroupPolicyT_4_0_0( inMsgHdl,&(policy));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgGroupDatabaseUpdate_4_0_0(syncupType, &(pGroupName), policy);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(policy), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(policy), 0, 1);
LL1:  clXdrMarshallClNameT(&(pGroupName), 0, 1);
LL0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);

    return rc;

L0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncupType), 0, 1);
L1:  clXdrMarshallClNameT(&(pGroupName), 0, 1);
L2:  clXdrMarshallSaMsgQueueGroupPolicyT_4_0_0(&(policy), 0, 1);


    return rc;
}

ClRcT clMsgGroupDatabaseUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgGroupMembershipUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClMsgSyncActionT_4_0_0  syncAct;
    ClNameT  pGroupName;
    ClNameT  pQueueName;

    memset(&(syncAct), 0, sizeof(ClMsgSyncActionT_4_0_0));
    memset(&(pGroupName), 0, sizeof(ClNameT));
    memset(&(pQueueName), 0, sizeof(ClNameT));


    rc = clXdrUnmarshallClMsgSyncActionT_4_0_0( inMsgHdl,&(syncAct));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pGroupName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQueueName));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgGroupMembershipUpdate_4_0_0(syncAct, &(pGroupName), &(pQueueName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClMsgSyncActionT_4_0_0(&(syncAct), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pGroupName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClNameT(&(pQueueName), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClNameT(&(pQueueName), 0, 1);
LL1:  clXdrMarshallClNameT(&(pGroupName), 0, 1);
LL0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncAct), 0, 1);

    return rc;

L0:  clXdrMarshallClMsgSyncActionT_4_0_0(&(syncAct), 0, 1);
L1:  clXdrMarshallClNameT(&(pGroupName), 0, 1);
L2:  clXdrMarshallClNameT(&(pQueueName), 0, 1);


    return rc;
}

ClRcT clMsgGroupMembershipUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgGetDatabasesServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClUint8T*  ppData;
    ClUint32T  pSize;

    memset(&(ppData), 0, sizeof(ClUint8T*));
    memset(&(pSize), 0, sizeof(ClUint32T));



    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgGetDatabases_4_0_0(&ppData, &(pSize));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClUint32T(&(pSize), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallPtrClUint8T(ppData, pSize, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

L2:    return rc;


    return rc;


L0:  clXdrMarshallClUint32T(&(pSize), 0, 1);
L1:  clXdrMarshallPtrClUint8T(ppData, pSize, 0, 1);

    return rc;
}

ClRcT clMsgGetDatabasesResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,ClUint8T*  ppData,CL_OUT  ClUint32T  pSize)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClUint32T(&(pSize), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallPtrClUint8T(ppData, pSize, outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L1:  clXdrMarshallClUint32T(&(pSize), 0, 1);
L2:  clXdrMarshallPtrClUint8T(ppData, pSize, 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueInfoGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  pQName;
    ClUint32T  openFlags;
    SaMsgQueueCreationAttributesT_4_0_0  pQAttrs;

    memset(&(pQName), 0, sizeof(ClNameT));
    memset(&(openFlags), 0, sizeof(ClUint32T));
    memset(&(pQAttrs), 0, sizeof(SaMsgQueueCreationAttributesT_4_0_0));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(openFlags));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueInfoGet_4_0_0(&(pQName), openFlags, &(pQAttrs));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(openFlags), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pQAttrs), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

L3:    return rc;

LL1:  clXdrMarshallClUint32T(&(openFlags), 0, 1);
LL0:  clXdrMarshallClNameT(&(pQName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(pQName), 0, 1);
L1:  clXdrMarshallClUint32T(&(openFlags), 0, 1);

L2:  clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pQAttrs), 0, 1);

    return rc;
}

ClRcT clMsgQueueInfoGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  SaMsgQueueCreationAttributesT_4_0_0  pQAttrs)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pQAttrs), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L3:  clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pQAttrs), 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueMoveMessagesServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  pQName;
    ClUint32T  openFlags;
    ClIocPhysicalAddressT_4_0_0  pCompAddr;

    memset(&(pQName), 0, sizeof(ClNameT));
    memset(&(openFlags), 0, sizeof(ClUint32T));
    memset(&(pCompAddr), 0, sizeof(ClIocPhysicalAddressT_4_0_0));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(openFlags));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClIocPhysicalAddressT_4_0_0( inMsgHdl,&(pCompAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueMoveMessages_4_0_0(&(pQName), openFlags, &(pCompAddr));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(openFlags), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L3:    return rc;

LL2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);
LL1:  clXdrMarshallClUint32T(&(openFlags), 0, 1);
LL0:  clXdrMarshallClNameT(&(pQName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(pQName), 0, 1);
L1:  clXdrMarshallClUint32T(&(openFlags), 0, 1);
L2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddr), 0, 1);


    return rc;
}

ClRcT clMsgQueueMoveMessagesResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueUnlinkServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  pQName;

    memset(&(pQName), 0, sizeof(ClNameT));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueUnlink_4_0_0(&(pQName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L1:    return rc;

LL0:  clXdrMarshallClNameT(&(pQName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(pQName), 0, 1);


    return rc;
}

ClRcT clMsgQueueUnlinkResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueStatusGetServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  pQName;
    SaMsgQueueStatusT_4_0_0  pQueueStatus;

    memset(&(pQName), 0, sizeof(ClNameT));
    memset(&(pQueueStatus), 0, sizeof(SaMsgQueueStatusT_4_0_0));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueStatusGet_4_0_0(&(pQName), &(pQueueStatus));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallSaMsgQueueStatusT_4_0_0(&(pQueueStatus), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

L2:    return rc;

LL0:  clXdrMarshallClNameT(&(pQName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(pQName), 0, 1);

L1:  clXdrMarshallSaMsgQueueStatusT_4_0_0(&(pQueueStatus), 0, 1);

    return rc;
}

ClRcT clMsgQueueStatusGetResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  SaMsgQueueStatusT_4_0_0  pQueueStatus)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallSaMsgQueueStatusT_4_0_0(&(pQueueStatus), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L2:  clXdrMarshallSaMsgQueueStatusT_4_0_0(&(pQueueStatus), 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgQueueAllocateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClUint8T  newQ;
    ClNameT  pQName;
    ClIocPhysicalAddressT_4_0_0  pCompAddress;
    SaMsgQueueOpenFlagsT_4_0_0  openFlags;
    SaMsgQueueCreationAttributesT_4_0_0  pCreationAttributes;
    ClHandleT  pQueueHandle;

    memset(&(newQ), 0, sizeof(ClUint8T));
    memset(&(pQName), 0, sizeof(ClNameT));
    memset(&(pCompAddress), 0, sizeof(ClIocPhysicalAddressT_4_0_0));
    memset(&(openFlags), 0, sizeof(SaMsgQueueOpenFlagsT_4_0_0));
    memset(&(pCreationAttributes), 0, sizeof(SaMsgQueueCreationAttributesT_4_0_0));
    memset(&(pQueueHandle), 0, sizeof(ClHandleT));


    rc = clXdrUnmarshallClUint8T( inMsgHdl,&(newQ));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClIocPhysicalAddressT_4_0_0( inMsgHdl,&(pCompAddress));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallSaMsgQueueOpenFlagsT_4_0_0( inMsgHdl,&(openFlags));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallSaMsgQueueCreationAttributesT_4_0_0( inMsgHdl,&(pCreationAttributes));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgQueueAllocate_4_0_0(newQ, &(pQName), &(pCompAddress), openFlags, &(pCreationAttributes), &(pQueueHandle));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint8T(&(newQ), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddress), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallSaMsgQueueOpenFlagsT_4_0_0(&(openFlags), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pCreationAttributes), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
    rc = clXdrMarshallClHandleT(&(pQueueHandle), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

L6:    return rc;

LL4:  clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pCreationAttributes), 0, 1);
LL3:  clXdrMarshallSaMsgQueueOpenFlagsT_4_0_0(&(openFlags), 0, 1);
LL2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddress), 0, 1);
LL1:  clXdrMarshallClNameT(&(pQName), 0, 1);
LL0:  clXdrMarshallClUint8T(&(newQ), 0, 1);

    return rc;

L0:  clXdrMarshallClUint8T(&(newQ), 0, 1);
L1:  clXdrMarshallClNameT(&(pQName), 0, 1);
L2:  clXdrMarshallClIocPhysicalAddressT_4_0_0(&(pCompAddress), 0, 1);
L3:  clXdrMarshallSaMsgQueueOpenFlagsT_4_0_0(&(openFlags), 0, 1);
L4:  clXdrMarshallSaMsgQueueCreationAttributesT_4_0_0(&(pCreationAttributes), 0, 1);

L5:  clXdrMarshallClHandleT(&(pQueueHandle), 0, 1);

    return rc;
}

ClRcT clMsgQueueAllocateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode,CL_OUT  ClHandleT  pQueueHandle)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clXdrMarshallClHandleT(&(pQueueHandle), outMsgHdl, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    goto Label1; 
L6:  clXdrMarshallClHandleT(&(pQueueHandle), 0, 1);

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
    return rc;
Label1:
    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clMsgFailoverQMovedInfoUpdateServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  pQName;

    memset(&(pQName), 0, sizeof(ClNameT));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(pQName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(msgIdlidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clMsgFailoverQMovedInfoUpdate_4_0_0(&(pQName));
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(pQName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L1:    return rc;

LL0:  clXdrMarshallClNameT(&(pQName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(pQName), 0, 1);


    return rc;
}

ClRcT clMsgFailoverQMovedInfoUpdateResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(msgIdlidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(msgIdlidlDatabaseHdl, idlHdl);
    clHandleDestroy(msgIdlidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

