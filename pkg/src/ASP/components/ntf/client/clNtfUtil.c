#include <clNtfApi.h>
#include <clNtfUtil.h>

ClFdT  clNtfNotificationIdFileOpen()
{
    ClFdT       fd = -1;
    ClCharT     *env = NULL;
    ClCharT     filename[MAX_FILE_NAME] = "";
    ClCharT     buf[20] = "";
    struct flock fl;

    env = getenv("ASP_RUNDIR");
    if (env == NULL)
    {
        clLogError("NTF","NID","ASP_RUNDIR variable is not set");
        return -1;
    } else {
        clLogDebug("NTF","NID","ASP_RUNDIR variable value is %s",env);
    }

    snprintf(filename, MAX_FILE_NAME, "%s/notificationIdCounter.txt", env);

    fd = open(filename, O_CREAT|O_RDWR, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
    if (fd < 0)
    {
        clLogError("NTF","NID","File open failed for [%s], system error [%s]", filename, strerror(errno));
        return -1;
    }

    /* Now take the lock on the file and write a 0 value into it */

    /* Take a mandatory lock on the file */
    fl.l_type   = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start  = 0;
    fl.l_len    = 0;
    fl.l_pid    = getpid();

    if (fcntl(fd, F_SETLKW, &fl) < 0)
    {
        clLogError("NTF","NID","Couldnt acquire write lock on the notification ID file. %s",strerror(errno));
        close(fd);
        return -1;
    }

    if (0 > read(fd, buf, sizeof(buf)))
    {
        clLogError("NTF","NID","Read error while generating notificationID. %s",strerror(errno));
        fl.l_type = F_UNLCK;
        fcntl(fd, F_SETLK, &fl);
        close(fd);
        return -1;
    }

    if (!strncmp(buf, "", sizeof(buf)))
    {
        snprintf(buf,sizeof(buf),"0");

        if (0 > write(fd, buf, sizeof(buf)))
        {
            clLogError("NTF","NID","Write error while generating notificationID. %s",strerror(errno));
            fcntl(fd, F_SETLK, &fl);
            close(fd);
            return -1;
        }
    }

    fl.l_type = F_UNLCK;
    if (fcntl(fd, F_SETLK, &fl) < 0)
    {
        clLogError("NTF","","Couldnt release write lock on the notification ID file. %s",strerror(errno));
        close(fd);
        return -1;
    }

    return fd;
}

void  clNtfNotificationIdFileClose(ClFdT fd)
{
    clLogDebug("NTF","NID","Closing the notification ID file descriptor");
    close(fd);
}

/* This function opens the notificationIdCounter.txt file with
 * a write lock using fctnl, it acquires the existing counter value,
 * creates the notificationID with this counter value, increments
 * the counter and writes back to the file, and finally releases the
 * lock. 
 * The notificationID is generated by using first 32 bits for the nodeID
 * and second 32Bits for the counter value. This way the notificationID
 * is unique across the cluster
 */
SaNtfIdentifierT clNtfNotificationIdGenerate(ClFdT fd, ClIocNodeAddressT nodeId)
{
    struct      flock fl;
    ClCharT     buf[20] = "";
    ClUint32T   counter=0;
    SaNtfIdentifierT ret = SA_NTF_IDENTIFIER_UNUSED;

    if (fd < 0)
    {
        clLogError("NTF","NID","notification counter generation file is not open");
        return SA_NTF_IDENTIFIER_UNUSED;
    }

    /* Take a mandatory lock on the file */
    fl.l_type   = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start  = 0;
    fl.l_len    = 0;
    fl.l_pid    = getpid();

    if (fcntl(fd, F_SETLKW, &fl) < 0)
    {
        clLogError("NTF","NID","Couldnt acquire write lock on the notification ID file. %s",strerror(errno));
        return SA_NTF_IDENTIFIER_UNUSED;
    }

    /* Move the file pointer to start and read the current counter value */
    if (0 > lseek(fd, SEEK_SET,0))
    {
        clLogError("NTF","NID","lseek error while generating notificationID. %s",strerror(errno));
        ret = SA_NTF_IDENTIFIER_UNUSED;
        goto unlock_return;
    }

    if (0 > read(fd, buf, sizeof(buf)))
    {
        clLogError("NTF","NID","Read error while generating notificationID. %s",strerror(errno));
        ret = SA_NTF_IDENTIFIER_UNUSED;
        goto unlock_return;
    }

    counter = atoi(buf);

    clLogDebug("NTF","NID","Got notification ID counter value %d",counter);

    ret = (SaNtfIdentifierT) nodeId;
    ret = (ret << 32);
    ret = ret | counter;

    clLogDebug("NTF","NID","Generated notification ID %lld",ret);

    counter++;

    snprintf(buf, sizeof(buf), "%d",counter);

    /* Move the file pointer to start and write the new counter value */
    if (0 > lseek(fd, SEEK_SET,0))
    {
        clLogError("NTF","NID","lseek error while generating notificationID. %s",strerror(errno));
        ret = SA_NTF_IDENTIFIER_UNUSED;
        goto unlock_return;
    }

    if (0 > write(fd, buf, sizeof(buf)))
    {
        clLogError("NTF","NID","Write error while generating notificationID. %s",strerror(errno));
        ret = SA_NTF_IDENTIFIER_UNUSED;
        goto unlock_return;
    }

unlock_return:
    fl.l_type = F_UNLCK;
    if (fcntl(fd, F_SETLK, &fl) < 0)
    {
        clLogError("NTF","NID","Couldnt release write lock on the notification ID file. %s",strerror(errno));
        return SA_NTF_IDENTIFIER_UNUSED;
    }

    return ret;
}
