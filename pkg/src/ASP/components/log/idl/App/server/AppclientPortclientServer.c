/*********************************************************************
* ModuleName  : idl
*********************************************************************/
/*********************************************************************
* Description :Server Stub routines
*     
* THIS FILE IS AUTO-GENERATED BY OPENCLOVIS IDE. EDIT THIS FILE AT
* YOUR OWN RISK. ANY CHANGE TO THIS FILE WILL BE OVERWRITTEN ON
* RE-GENERATION.
*     
*********************************************************************/
#include <netinet/in.h>
#include <clBufferApi.h>
#include <clRmdApi.h>
#include <clEoApi.h>
#include <ipi/clRmdIpi.h>
#include <string.h>
#include "AppclientPortclientServer.h"
#include "AppServer.h"

extern ClUint32T  AppidlSyncKey;
extern ClHandleDatabaseHandleT  AppidlDatabaseHdl;



ClRcT clLogClientFilterSetNotifyServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClNameT  streamName;
    ClUint32T  streamScope;
    ClNameT  streamScopeNode;
    ClLogFilterT_4_0_0  filter;

    memset(&(streamName), 0, sizeof(ClNameT));
    memset(&(streamScope), 0, sizeof(ClUint32T));
    memset(&(streamScopeNode), 0, sizeof(ClNameT));
    memset(&(filter), 0, sizeof(ClLogFilterT_4_0_0));


    rc = clXdrUnmarshallClNameT( inMsgHdl,&(streamName));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(streamScope));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClNameT( inMsgHdl,&(streamScopeNode));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClLogFilterT_4_0_0( inMsgHdl,&(filter));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(AppidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clLogClientFilterSetNotify_4_0_0(streamName, streamScope, streamScopeNode, filter);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClNameT(&(streamName), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(streamScope), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClNameT(&(streamScopeNode), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClLogFilterT_4_0_0(&(filter), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L4:    return rc;

LL3:  clXdrMarshallClLogFilterT_4_0_0(&(filter), 0, 1);
LL2:  clXdrMarshallClNameT(&(streamScopeNode), 0, 1);
LL1:  clXdrMarshallClUint32T(&(streamScope), 0, 1);
LL0:  clXdrMarshallClNameT(&(streamName), 0, 1);

    return rc;

L0:  clXdrMarshallClNameT(&(streamName), 0, 1);
L1:  clXdrMarshallClUint32T(&(streamScope), 0, 1);
L2:  clXdrMarshallClNameT(&(streamScopeNode), 0, 1);
L3:  clXdrMarshallClLogFilterT_4_0_0(&(filter), 0, 1);


    return rc;
}

ClRcT clLogClientFilterSetNotifyResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(AppidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(AppidlDatabaseHdl, idlHdl);
    clHandleDestroy(AppidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

ClRcT clLogClntFileHdlrDataReceiveServer_4_0_0(ClEoDataT eoData, ClBufferHandleT inMsgHdl, ClBufferHandleT outMsgHdl)
{
    ClIdlContextInfoT *pIdlCtxInfo = NULL;
    ClRcT rc = CL_OK;
    ClUint64T  streamMcaseAddr;
    ClUint32T  seqNum;
    ClUint32T  srcAddr;
    ClHandleT  hFlusher;
    ClUint32T  nRecords;
    ClUint32T  buffLen;
    ClUint8T*  pBuffer;

    memset(&(streamMcaseAddr), 0, sizeof(ClUint64T));
    memset(&(seqNum), 0, sizeof(ClUint32T));
    memset(&(srcAddr), 0, sizeof(ClUint32T));
    memset(&(hFlusher), 0, sizeof(ClHandleT));
    memset(&(nRecords), 0, sizeof(ClUint32T));
    memset(&(buffLen), 0, sizeof(ClUint32T));
    memset(&(pBuffer), 0, sizeof(ClUint8T*));


    rc = clXdrUnmarshallClUint64T( inMsgHdl,&(streamMcaseAddr));
    if (CL_OK != rc)
    {
        goto LL0;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(seqNum));
    if (CL_OK != rc)
    {
        goto LL1;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(srcAddr));
    if (CL_OK != rc)
    {
        goto LL2;
    }

    rc = clXdrUnmarshallClHandleT( inMsgHdl,&(hFlusher));
    if (CL_OK != rc)
    {
        goto LL3;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(nRecords));
    if (CL_OK != rc)
    {
        goto LL4;
    }

    rc = clXdrUnmarshallClUint32T( inMsgHdl,&(buffLen));
    if (CL_OK != rc)
    {
        goto LL5;
    }

    rc = clXdrUnmarshallPtrClUint8T( inMsgHdl,(void**)&(pBuffer), buffLen);
    if (CL_OK != rc)
    {
        goto LL6;
    }

    pIdlCtxInfo = (ClIdlContextInfoT *)clHeapAllocate(sizeof(ClIdlContextInfoT));
    if(pIdlCtxInfo == NULL)
    {
       return CL_IDL_RC(CL_ERR_NO_MEMORY);
    }
    memset(pIdlCtxInfo, 0, sizeof(ClIdlContextInfoT));
    pIdlCtxInfo->idlDeferMsg = outMsgHdl; 
    pIdlCtxInfo->inProgress  = CL_FALSE;
    rc = clIdlSyncPrivateInfoSet(AppidlSyncKey, (void *)pIdlCtxInfo);
    if (CL_OK != rc)
    {
        clHeapFree(pIdlCtxInfo);
        goto L0;
    }
    rc = clLogClntFileHdlrDataReceive_4_0_0(streamMcaseAddr, seqNum, srcAddr, hFlusher, nRecords, buffLen, pBuffer);
    if(pIdlCtxInfo->inProgress == CL_FALSE)
    {
      clHeapFree(pIdlCtxInfo);
      pIdlCtxInfo = NULL;
    }
    if (CL_OK != rc)
    {
       goto L0;
    }
    
    rc = clXdrMarshallClUint64T(&(streamMcaseAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L1;
    }

    rc = clXdrMarshallClUint32T(&(seqNum), 0, 1);
    if (CL_OK != rc)
    {
        goto L2;
    }

    rc = clXdrMarshallClUint32T(&(srcAddr), 0, 1);
    if (CL_OK != rc)
    {
        goto L3;
    }

    rc = clXdrMarshallClHandleT(&(hFlusher), 0, 1);
    if (CL_OK != rc)
    {
        goto L4;
    }

    rc = clXdrMarshallClUint32T(&(nRecords), 0, 1);
    if (CL_OK != rc)
    {
        goto L5;
    }

    rc = clXdrMarshallClUint32T(&(buffLen), 0, 1);
    if (CL_OK != rc)
    {
        goto L6;
    }

    rc = clXdrMarshallPtrClUint8T(pBuffer, buffLen, 0, 1);
    if (CL_OK != rc)
    {
        goto L7;
    }

    if(pIdlCtxInfo != NULL)
    {
      clHeapFree(pIdlCtxInfo);
      return rc;
    }
    
L7:    return rc;

LL6:  clXdrMarshallPtrClUint8T(pBuffer, buffLen, 0, 1);
LL5:  clXdrMarshallClUint32T(&(buffLen), 0, 1);
LL4:  clXdrMarshallClUint32T(&(nRecords), 0, 1);
LL3:  clXdrMarshallClHandleT(&(hFlusher), 0, 1);
LL2:  clXdrMarshallClUint32T(&(srcAddr), 0, 1);
LL1:  clXdrMarshallClUint32T(&(seqNum), 0, 1);
LL0:  clXdrMarshallClUint64T(&(streamMcaseAddr), 0, 1);

    return rc;

L0:  clXdrMarshallClUint64T(&(streamMcaseAddr), 0, 1);
L1:  clXdrMarshallClUint32T(&(seqNum), 0, 1);
L2:  clXdrMarshallClUint32T(&(srcAddr), 0, 1);
L3:  clXdrMarshallClHandleT(&(hFlusher), 0, 1);
L4:  clXdrMarshallClUint32T(&(nRecords), 0, 1);
L5:  clXdrMarshallClUint32T(&(buffLen), 0, 1);
L6:  clXdrMarshallPtrClUint8T(pBuffer, buffLen, 0, 1);


    return rc;
}

ClRcT clLogClntFileHdlrDataReceiveResponseSend_4_0_0(ClIdlHandleT idlHdl,ClRcT retCode)
{
    ClIdlSyncInfoT    *pIdlSyncDeferInfo = NULL;
    ClRcT              rc                = CL_OK;
    ClBufferHandleT outMsgHdl     = 0;
    
    rc = clHandleCheckout(AppidlDatabaseHdl,idlHdl,(void **)&pIdlSyncDeferInfo);
    if( rc != CL_OK)
    {
      goto Label0; 
    }
    outMsgHdl = pIdlSyncDeferInfo->idlRmdDeferMsg;
    
    rc = clIdlSyncResponseSend(pIdlSyncDeferInfo->idlRmdDeferHdl,outMsgHdl,
                                retCode);
    

    

    clHandleCheckin(AppidlDatabaseHdl, idlHdl);
    clHandleDestroy(AppidlDatabaseHdl, idlHdl);
Label0:
    return rc;
}

