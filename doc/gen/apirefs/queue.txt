/**
 *  \defgroup queue Queue Library
 *  \brief The OpenClovis Queue Library provides implementation for a 
 *  queue of arbitrary data elements. It supports enqueuing, dequeuing, 
 *  retrieval of queue elements (nodes).
 *
 */
  
//-----------------------------------------------------------
 
/**
 *  \defgroup queue_intro Functional Description
 *  \brief Description of the Queue Library.
 *  \ingroup queue
 *
 *  \section queueintro1 Overview
 *  FIFO, another name for a queue, is an acronym for the way it works,
 *  First-In-First-Out. The standard interface to the FIFO queue consists
 *  of ENQUEUE()function, to add new elements, and a DEQUEUE(), function, which
 *  removes the oldest element. Enqueue adds an element at the rear(end) of the queue.
 *  Dequeue removes an element from the front (start) of the queue. The following
 *  are the operations, supported on queues: 
 *
 *  \arg Creates a queue
 *  \arg Enqueues an element into the queue.
 *  \arg Dequeues an element from the queue.
 *  \arg Walks through the queue.
 *  \arg Returns the number of elements in the queue.
 *  \arg Destroys the queue. 
 *
 *
 *  When creating a queue, you need to specify maximum size for the queue.
 *  If the maximum size is specified as 0, then you can enqueue any number of elements.
 *  Otherwise the number of elements you can enqueue is limited to the maximum size.
 *  That is, at any instant of time, the queue can have a maximum of \e maxSize number of elements,
 *  specified at the time of creation of queue.\n
 *
 *  This file contains the definitions and function prototypes for Queues.
 *
 *  \section queueintro2 Interaction with other components
 *  Queue APIs depend on Operating System Abstraction Layer (OSAL) for
 *  memory allocation and free functions.
 */

//-----------------------------------------------------------

/**
 *  \defgroup queue_usage  API Usage Examples
 *  \brief Code Examples.
 *  \ingroup queue
 *
 *   \code
 *   ClRcT      rc           = CL_OK;
 *   ClQueueT   queueHandle  = CL_HANDLE_INVALID_VALUE;
 *   
 *   // Queue should be created before using, creating the queue of 256
 *   // elements
 *   rc = clQueueCreate(256, clTstEnqCallback, clTstEnqCallback, 
 *                      &queueHandle)), 
 *   if( \c CL_OK != rc )
 *   {
 *     // Queue create failed, nothing can be done, take appropriate action 
 *   }
 *
 *   // add a node to the queue. 
 *   ClQueueDataT qData = YYYY; // could be simple data or complex  
 *
 *   rc = clQueueNodeInsert(queueHandle, qData);
 *   if(\c CL_OK != rc)
 *   {
 *		// error occurred. Take appropriate action
 *   }
 *   
 *   ClQueueDataT  qData = CL_HANDLE_INVALID_VALUE;
 *   //the first node will be deleted and the data will be returned on the
 *   //data 
 *   rc = clQueueNodeDelete(queueHandle, &qData);
 *   if( \c CL_OK != rc)
 *   {
 *       //Error occured. Take appropriate action.
 *   }
 *
 *   ClUint32T  size = 0;
 *   // Getting the size of the Queue
 *   rc = clQueueSizeGet(queueHandle, &size);
 *   if( \c CL_OK != rc )
 *   {
 *       //Error occured. Take appropriate action.
 *   }
 *
 *   //Queue should be deleted during finalize of system, otherwise it may
 *   //lead to memory leaks, for each node deletion the QueueDestroyCallback
 *   //will be called.
 *   rc = clQueueDelete(queueHandle);
 *   if(\c CL_OK != rc) 
 *   {
 *      // Error occured. Take appropriate action.
 *   }
 *   // to walk through all the elements on the queue, the following
 *   // operation should be performed.
 *
 *   // the queuewalk callback function is getting called while walking
 *   //through all the queue elements.
 *   void clTstQueueWalkCb(ClQueueT  qData, void *pData)
 *   {
 *      // Data of the walk thru node.
 *      // Cookie of the QueueWalk function.
 *   } 
 *
 *   rc = clQueueWalk(queueHandle, clTstQueueWalkCb, pCookie);
 *   if( \c CL_OK != rc )
 *   {
 *     // Error occured. Take appropriate action.
 *   }
 *  \endcode
 */

//-----------------------------------------------------------

/**
 *  \defgroup queue_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup queue
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting Queue Library 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_QUEUE "Queue Library Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup queue_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup queue
 */

//-----------------------------------------------------------
