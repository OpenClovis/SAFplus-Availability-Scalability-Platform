/**
 *  \defgroup cpm Component Manager
 *
 *  \brief The Availability Management Framework(AMF) in the ASP world is
 *         collectively implemented in the Availability Management Service(AMS)
 *         and Component Manager(CPM) software entities. The CPM is the
 *         operational manager entity and is responsible for actually managing
 *         the various components through their life cycle, based on configured
 *         policy as well as directions from the AMS.
 */
 
//-----------------------------------------------------------

/**

\defgroup cpm_intro Functional Description
\brief Description of CPM.
\ingroup cpm

If you have not already done so, please read the high availability section of
OpenClovis SDK user guide to get an idea of the architecture of the AMF in
general and CPM in particular.

\section sec_cpm_intro_2 The functions exposed by the CPM

The functions exposed by the CPM can be classified as SAF APIs and non SAF
APIs. Non SAF APIs include other utility APIs provided by the CPM.

\subsection subsec_cpm_saf SAF APIs

CPM exposes most of the SAF defined interfaces, which can be used by the
application developers to develop highly available applications.

\note In the following sections the term AMF is used whenever providing the API
functionality involves both the CPM and AMS, even if the exposed API name
contains only CPM. For e.g. clCpmHAStateGet() APIs is actually serviced by AMS,
even though the name indicates that it is a CPM's exposed API. This is true for
most of the SAF APIs exposed by the CPM.

The APIs in this section fall into various category as defined in the SAF AMF
specification.

\subsubsection subsubsec_cpm_llc Library Life Cycle.

The application begins its life cycle by calling clCpmClientInitialize() API. It
can call the clCpmSelectionObjectGet() to get a OS specific object on which to
wait for the callbacks that are or will be invoked by the CPM. To actually
execute the callback in the applications context, the application can call
clCpmDispatch() API. When the process is terminating gracefully, it should call
the clCpmClientFinalize() API to indicate its end of association with the CPM
client.

\subsubsection subsubsec_cpm_reg Component Registration and Unregistration

The application can call clCpmComponentRegister() to notify to the AMF that it
is now ready to provide service. It should call the clCpmComponentUnregister
while terminating. The clCpmComponentNameGet() API returns the name of calling
component. This is the name that should be used while registration and
unregistration.

\subsubsection subsubsec_cpm_csi Component Service Instance Management

The application can call clCpmHAStateGet() API to query AMF about the HA state
of the component for a particular component service instance. The application
should call the clCpmCSIQuiescingComplete() API to indicate to AMF that it has
serviced all the pending requests since being moved to the quiesced state and
can now be terminated. \sa ClCpmCSISetCallbackT, ClCpmCSIRmvCallbackT and \ref
subsubsec_cpm_callbacks.

\subsubsection subsubsec_cpm_clc Component Life Cycle

\sa \ref subsubsec_cpm_callbacks

\subsubsection subsubsec_cpm_pg Protection Group Management

To request the AMF to track the changes in the protection group associated with
a component service instance, the application should call
clCpmProtectionGroupTrack() API. Different kinds of track are supported via
different flags. To request the AMF to stop tracking the changes in the
protection group associated with a component service instance, the application
should call clCpmProtectionGroupTrackStop() API. \sa
ClCpmProtectionGroupTrackCallbackT

\subsubsection subsubsec_cpm_err Error Reporting

A component can report error on either itself or some other component using the
clCpmComponentFailureReport() API.

\subsubsection subsubsec_cpm_resp Component Response to Framework Requests

The application can call clCpmResponse() API to indicate the status of carrying
out the AMFs request (\ref subsubsec_cpm_callbacks) in the applications context.
a
\subsubsection subsubsec_cpm_callbacks Callbacks invoked by the CPM

The AMF assigns work to a component by invoking ::ClCpmCSISetCallbackT. To be more
specific, the AMF requests the application to assume a particular HA state for
component on behalf of a component service instance by invoking this
callback. Depending on the HA state which is passed by this callback, the
application can start providing service.

The AMF removes work assigned to a component by invoking
::ClCpmCSIRmvCallbackT. The AMF requests that the component stop providing service
for a particular component service instance, by invoking this callback.

The AMF invokes the ::ClCpmProtectionGroupTrackCallbackT in the applications
context, whenever there is a change in the protection group associated with a
component service instance and the application has called
clCpmProtectionGroupTrack() API to track changes in the same protection group.

The AMF requests the component to gracefully terminate by invoking
::ClCpmTerminateCallbackT. The application is supposed to call
clCpmComponentUnregister() and clCpmClientFinalize() API after doing all the
component specific finalization.

The AMF requests a proxy component to instantiate a proxied component by
invoking ::ClCpmProxiedComponentInstantiateCallbackT callback of the \b proxy
component.

The AMF requests a proxy component to abruptly terminate a proxied component by
invoking ::ClCpmProxiedComponentCleanupCallbackT callback of the \b proxy
component.

\subsection subsec_cpm_nonsaf Non SAF APIs

The clCpmComponentIdGet() API returns an ID which is guaranteed to be unique in
the cluster.

The clCpmComponentAddressGet() API can be called by the application to find out
the communication port of some other component, by giving the name of the
component and address of the node where the component is present.

To find out the address of the active system controller node in the cluster the
application can call clCpmMasterAddressGet() API. To check whether it is running
on active system controller node it can call clCpmIsMaster() API. To find the
name of the node where the application is running it can call the
clCpmLocalNodeNameGet() API.

*/
 
//-----------------------------------------------------------


/**
 *  \defgroup cpm_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup cpm
 *
 *  \section sec_cpm_usage_saf SAF API usage
 *
 *  The usage of the SAF APIs exposed by the CPM makes sense only when used in a
 * holistic manner. So let us walk through some sample code to understand the
 * usage of the CPM APIs.
 *
 *
 * Before you proceed, however we strongly recommend that you refer to the SA
 * forum overview document (SAI-Overview-B.02.01.pdf section 3.1), which
 * contains excellent description of the programmming model used here. While
 * reading the document read the API names as clCpm<api-name> wherever
 * saAmf<api-name> is given.
 *
 *
 * \dontinclude clCompAppMain.c
 * First we need to register the callbacks that we wish to be invoked with the
 * AMF :
 * \skipline callbacks.appHealthCheck
 * \until callbacks.appProtectionGroupTrack
 *
 * Register these callbacks and get the handle representing the association with
 * the AMF library using this call:
 * \skipline clCpmClientInitialize(
 * \until goto
 *
 * After initializing the client library, next step is to do the application
 * initialization, in the application template starting from this comment block:
 *
 * \skipline /*
 * \skipline * ---BEGIN_APPLICATION_CODE---
 * \until /
 *
 * and ending in
 * \skipline /*
 * \skipline * ---END_APPLICATION_CODE---
 * \until /
 * 
 * Now register the component with AMF. By calling this function the component
 * is saying that it is ready to provide service i.e. take work assignments.
 * \skipline clCpmComponentNameGet
 * \until goto
 * \skipline clCpmComponentRegister
 * \until goto
 *
 * The AMF requests the application to gracefully terminate by calling its
 * terminate callback:
 * \skipline clCompAppTerminate(
 * \until return rc;
 * \skipline errorexit:
 * \until }
 *
 * The application should do its finalization in this callback and call
 * clCpmComponentUnregister() and clCpmClientFinalize() to end its association
 * with the AMF library. It should also call clCpmResponse() function to
 * indicate whether it was successful in finalizing itself.
 *
 * Once the application has registered itself with the AMF, it will be assumed
 * by the AMF to be instantiated and ready to provide service. The AMF indicates
 * the work assignment to the component by calling its CSI set callback:
 * \skipline clCompAppAMFCSISet(
 * \until return CL_OK;
 * \line }
 * 
 * The application is supposed to check with what \e haState the CSI set
 * callback was called and correspondingly take appropriate actions. For e.g. if
 * the CSI set was called with \e haState set to ::CL_AMS_HA_STATE_ACTIVE then
 * it should start providing service, if \e haState is
 * ::CL_AMS_HA_STATE_QUIESCING then it is supposed to stop work associated with
 * the CSI gracefully, not accept any new workloads and respond with the
 * clCpmCSIQuiescingComplete() function whenever it is done serving the pending
 * requests. For more information on the HA states that can be assigned to the
 * component and the expected behavior of the component please refer to the SA
 * forum AMF specification. (SAI-AIS-AMF-B.02.01.pdf section 3.3.1.5)
 * 
 * The AMF removes the work assigned to the component during the
 *  ::ClCpmCSISetCallbackT by invoking its CSI remove callback:
 * \skipline clCompAppAMFCSIRemove(
 * \until return CL_OK;
 * \line }
 *
 * Note that in each of these callbacks the application should respond with the
 * status of executing the AMF request through calling clCpmResponse() call. If
 * the application did not call this function within a specified time limit,
 * then it will be considered as a fault by AMF and appropriate recovery actions
 * are taken.
 *
 * \note OpenClovis AMF also supports the invocation of pending callbacks using
 * the SAF programming model. (SAI-Overview-B.02.01.pdf section 3.1). For
 * e.g. the saAmfSelectionObjectGet() call corresponds to the
 * clCpmSelectionObjectGet() API and so on.
 *
 * \section sec_cpm_usage_non_saf Non SAF API usage
 *
 * \sa \ref subsec_cpm_nonsaf and \ref cpm_apis
 */

//-----------------------------------------------------------

/**
 *  \defgroup cpm_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup cpm
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting CPM generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_CPM "CPM Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_cpm
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

//-----------------------------------------------------------

/**
 *  \defgroup cpm_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions. 
 *  \ingroup cpm
 */

//-----------------------------------------------------------

/**
 *  \defgroup cpm_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup cpm
 */

//-----------------------------------------------------------
