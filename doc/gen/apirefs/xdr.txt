/**
 *  \defgroup xdr External Data Representation (XDR) 
 *  \brief External Data Representation (XDR) is a standard for the description
 *  and encoding of data.
 *  It is useful for transferring data between different
 *  computer architectures, and has been used to communicate data between
 *  diverse machines. 
 *  XDR fits into the ISO presentation layer.
 *  
 */

//-----------------------------------------------------------
 
/**
 *  \defgroup xdr_intro Functional Description
 *  \brief OpenClovis XDR library. 
 *  \ingroup xdr
 *  
 *  XDR uses a language to describe data formats. The language can
 *  only be used only to describe data. It is not a programming language.
 *  This language allows one to describe intricate data formats in a
 *  concise manner. 
 *  
 *  The OpenClovis XDR library provides the APIs to transform the data 
 *  (marshall) into the standard XDR format before it is transmitted over 
 *  a network so that the data can transcend network boundaries.
 *  The data can be unmarshalled at the recieving side using data unmarshall
 *  APIs of OpenClovis.
 * 
 */

//-----------------------------------------------------------

/**

\defgroup xdr_usage API Usage Examples
\brief Code Examples.
\ingroup xdr

Marshall the data, array and pointer of type ClUint8T 

\code 

ClRcT           rc          =   CL_OK;
ClBufferHandleT inMsgHdl    =   0;
ClBufferHandleT outMsgHdl   =   0;

ClUint8T     uint8Data      =   120;

ClUint8T     uint8Arr[10]   =   {0};
                  
ClUint8T     *uint8Ptr      =   NULL;
ClUint32T   i               =   0;

ClUint32T   funcNo          =   CL_EO_GET_FULL_FN_NUM
                                (CL_EO_NATIVE_COMPONENT_TABLE_ID, 1);

ClUint32T   rmdFlags        =   0;

ClIocAddressT address       = {{0}};

ClRmdOptionsT rmdOptions    = CL_RMD_DEFAULT_OPTIONS;


/*Allocate Pointer*/

uint8Ptr = (ClUint8T*)clHeapAllocate (10*sizeof(ClUint8T)); 
if(NULL != uint8Ptr)
{
   clLogError("EXP","XDR", "Memory allocation Failed.");
   return CL_ERR_NO_MEMORY;
}

for(i = 0; i < 10; i++) 
{ 
    uint8Arr[i] = i;
    uint8Ptr[i] = 10 - i; 
}

/*inMsgHdl buffer create*/
rc = clBufferCreate(&inMsgHdl);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Buffer creation Failed.");
   return rc;
}

/* Marshall ClUint8T data */
rc = clXdrMarshallClUint8T(&uint8Data, inMsgHdl, 0);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Marshalling of ClUint8T data Failed.");
   return rc;
}

/*Marshall ClUint8T array*/
rc = clXdrMarshallArrayClUint8T(uint8Arr, sizeof(uint8Arr) /
                              sizeof(ClUint8T), inMsgHdl, 0);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Marshalling of ClUint8T array Failed.");
   return rc;
}

/*Marshall ClUint8T ptr*/
rc = clXdrMarshallPtrClUint8T(uint8Ptr, 10, inMsgHdl, 1);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Marshalling of ClUint8T pointer Failed.");
   return rc;
}

rmdFlags |= (CL_RMD_CALL_NON_PERSISTENT | CL_RMD_CALL_NEED_REPLY);
rmdFlags &= ~CL_RMD_CALL_ASYNC;

address.iocPhyAddress.portId = /*Fill this with the appropriate port id 
                                 for rmd call*/
                                 

/*Master Addr get*/
rc = clCpmMasterAddressGet (&address.iocPhyAddress.nodeAddress);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Failed to get master address.");
   return rc;
}

/*outMsgHdl buffer create*/
rc = clBufferCreate(&outMsgHdl);
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Buffer creation Failed.");
   return rc;
}

/*RMD for ClUint8T*/
rc = clRmdWithMsg(address, funcNo, inMsgHdl, outMsgHdl,
                 rmdFlags, &rmdOptions, NULL);

if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Rmd call Failed.");
   return rc;
}
clBufferDelete(&outMsgHdl);
\endcode

Unmarshall the data, array and pointer of type ClUint8T

\code 
/*Get the in-message-handle 'inMsgHdl' and out-message-handle 'outMsgHdl'
from RMD receieve function. */

ClRcT       rc              =   CL_OK; 
ClUint8T    recvData        =   0;
ClUint8T    recvArr[10]     =   {0}; 
ClUint8T    *recvPtr        =   NULL; 

/*Unmarshall data, it will get stored in recvData*/
rc = clXdrUnmarshallClUint8T(inMsgHdl, &recvData); 
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Unmarshalling of Uint8T data Failed.");
   return rc;
}
/*Unmarshall 10 array elements, it will get stored in recvArr*/
rc = clXdrUnmarshallArrayClUint8T(inMsgHdl, &recvArr, 10); 
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Unmarshalling of Uint8T array Failed.");
   return rc;
}

/*Unmarshall 10 elements of type ClUint8T, it will get stored in recvPtr*/
rc = clXdrUnmarshallPtrClUint8T(inMsgHdl, (void**)&recvPtr, 10); 
if(rc != CL_OK)
{
   clLogError("EXP","XDR", "Unmarshalling of Uint8T pointer Failed.");
   return rc;
}
if(rc == CL_OK)
{   
   /*Free the pointer allocated in clXdrUnmarshallPtrClUint8T()*/
   clHeapFree(recvPtr);
}
\endcode 

*/

//-----------------------------------------------------------

/**
 *  \defgroup xdr_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup xdr
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting XDR Library 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_XDR "XDR Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

//-----------------------------------------------------------

/**
 *  \defgroup xdr_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup xdr
 */

//-----------------------------------------------------------

