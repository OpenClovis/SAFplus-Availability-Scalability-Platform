/**
 *  \defgroup ckpt Checkpointing Service
 *
 *  \brief The OpenClovis Checkpoint Service offered by OpenClovis ASP is a high 
 *  availability infrastructure component that provides synchronization of 
 *  run-time data and context to ensure a seamless failover or switchover of 
 *  applications.
 *
 *  It allows the application to store its internal state and retrieve the 
 *  information either immediately or at regular interval or in case of 
 *  failover or switchover. It provides a facility for processes to record 
 *  checkpoint data incrementally, which can be used to protect an application 
 *  against failures. When recovering from fail-over or switch-over situations,
 *  the checkpoint data can be retrieved, and execution can be resumed from 
 *  the state recorded before the failure.
 *
 *  Checkpointing Service supports Non-transparent mode of Checkpointing 
 *  where an application has to trigger the checkpoint write and checkpoint 
 *  read.
 *
 *  A checkpoint can be replicated immediately on a different blade and stored 
 *  indefinitely or consumed immediately. When a failure occurs, CPS helps to 
 *  restart, failover or switchover the services quickly by restoring the 
 *  earlier checkpointed state.
 *
 */
 
/**
 *  \defgroup ckpt_intro Functional Description
 *  \brief Description of the Checkpointing Service.
 *  \ingroup ckpt
 * 
 */

/**
 *  \defgroup ckpt_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup ckpt
 * 
 */

/**
 *  \defgroup ckpt_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup ckpt
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting Checkpointing Service 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_CKPT "Checkpointing Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

/**
 *  \defgroup ckpt_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup ckpt
 */

/**
 *  \defgroup ckpt_apis_server Server Based Ckeckpointing
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup ckpt_apis
 */

/**
 *  \defgroup ckpt_apis_library File/Library Based Ckeckpointing
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup ckpt_apis
 */
 
/**
 *  \defgroup ckpt_glossary Glossary
 *  \brief Glossary of OpenClovis Checkpoint Service Terms.
 *  \ingroup ckpt
 */

/**
 *  \defgroup ckpt_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup ckpt
 *
 */
  
//-----------------------------------------------------------
//-----------------------------------------------------------

/**

\addtogroup ckpt_intro
\brief Description of the Checkpointing Service.

The OpenClovis Checkpoint Service (CPS) is a high availability infrastructure
component that provides synchronization of run-time data and context that 
ensures a seamless failover or switchover of applications. CPS allows the 
application to store its internal state and retrieve the information immediately,
at regular intervals, during a failover, a switchover, or at a restart. 
It provides the facility for processes to record Checkpoint data incrementally
to protect an application against failures. While recovering from fail-over,
restart, or switch-over situations, the Checkpoint data can be retrieved and 
execution can be resumed from the state recorded before the failure. 
CPS maintains at least one backup replica for a Checkpoint (provided resource), so that the information is not lost. A Checkpoint can be 
replicated immediately on a different blade and stored indefinitely, or it can 
be consumed immediately. 

CPS provides two types of Checkpointing:
\arg
<b> File-based/Library-based Checkpointing </b> - The Checkpoint is stored in 
the persistent memory. Such Checkpoints survive through node restart, 
application restart or failover conditions.
\arg
<b> Server based Checkpointing </b> - The Checkpoint in stored in the main 
memory. Such Checkpoints survive through application restart/failover situations
only.

\section sec_ckpt_intro_1 Usage Model

The users of CPS are usually highly available applications.  The active
application checkpoints data sufficient to recreate its internal state as
indicated by application specific logic.  Standby components read the
checkpointed data when activated, or as otherwise indicated by application
specific logic.

CPS neither interprets the stored information nor provides any logic on when 
to read or write a Checkpoint (an application that has registered for 
immediate consumption, is an exception.) The application is responsible for
interpreting the checkpointed data as well as deciding when to read or write
that data.

The Checkpointed information is replicated by CPS in persistent memory 
(in case of file based Checkpointing) or in replica nodes (server-based 
Checkpointing.)

The users can also choose for a trigger from CPS, by registering a callback 
function. This callback function is invoked when the Checkpoint that the user 
is interested in, is updated.
This is also referred to as registering for immediate consumption.

\subsection sec_ckpt_intro_11 Use cases

\par File/Library  based Checkpointing
CPS replicates the information in the persistent memory. This implies that 
the user application can survive application restart and node restart scenarios.
Typically, this form of Checkpointing is used  when there are no other nodes 
in the system where the replicas can be stored.

\par Server based Checkpointing
CPS replicates the information on other nodes in the system where the replicas 
can be stored (if it is available). Typically, this form of Checkpointing is 
used by the applications that need to recover from  fail-over or switch-over 
situations. Server based Checkpointing supports three types of Checkpoints:
\arg
Synchronous Checkpoints - CPS ensures that such Checkpoints provides consistency
of data across replicas. 
\arg
Asynchronous non-collocated Checkpoints -  CPS does not ensure consistency of 
data across replicas but the performance while writing to a Checkpoint (speed) 
is faster. In asynchronous non-collocated Checkpoints, the CPS decides where 
the active replica resides. 
\arg
Asynchronous collocated Checkpoints - These are similar to asynchronous 
non-collocated Checkpoints except that the control where the active replica 
 lies with the user application.

\section sec_ckpt_intro_2 Service Description

CPS provides a service to store information that can be read by users 
immediately, or, later depending on the logic of the user application. 
The CPS functional description can be divided into the following sections 
based on the type of service used.

\arg File/Library-based Checkpointing
\arg Server-based Checkpointing


\subsection sec_ckpt_intro_21 File/Library based Checkpointing

\par Checkpoint Life cycle
For using the services of CPS, the application has to initialize the CPS using 
the clCkptLibraryInitialize() function. clCkptLibraryInitialize() returns a 
handle, ::ClCkptSvcHdlT, that can be used in subsequent operations on the CPS to 
identify the initialization. When this handle is not required, the association 
can be closed using the clCkptLibraryFinalize() and all the allocated resources
are freed. In order to use File/Library based checkpointing, the application
should be linked with DBAL library, because checkpoint library internally uses DBAL
library to persist the data into database. While modeling checkpoint library
applications, DBAL library should be enabled.  

\par Checkpoint Management
An application can create a Checkpoint by using the clCkptLibraryCkptCreate()
function. When a Checkpoint is created, the datasets within the Checkpoint can 
be created using the clCkptLibraryCkptDataSetCreate() function. The data is 
stored and retrieved from these datasets. While creating a dataset, the user 
has to specify the serializer and deserializer functions that 
contain the logic for packing and unpacking the Checkpointed information, 
respectively. CPS does not interpret the Checkpointed information.
\par
The existence of datasets can be checked by using clCkptLibraryDoesDatasetExist() 
function. The corresponding function for checking the existence of a Checkpoint
is clCkptLibraryDoesCkptExist().
\par
An element in a dataset is created using the clCkptLibraryCkptElementCreate() 
function. The user has to specify the element serialiser and deserializer 
functions for packing and unpacking the element form a Checkpoint. The element
can be deleted using clCkptLibraryCkptElementDelete() function, a dataset 
is deleted using the clCkptLibraryCkptDataSetDelete() function and a Checkpoint
can be deleted using clCkptLibraryCkptDelete().
\end

\par Data access
CPS provides clCkptLibraryCkptDataSetWrite() function to write the entire 
dataset into the database. An element is to be written to a dataset using the
clCkptLibraryCkptElementWrite() function. CPS invokes the corresponding 
serializer function and provides a buffer into which the user has to 
pack the information to be Checkpointed. CPS then stores this buffer into the 
database.
\par
The contents of a dataset can be read using the clCkptLibraryCkptDataSetRead() 
function. CPS invokes the corresponding deserializer function and provides a 
buffer containing the data that was stored earlier. There is no provision for 
reading a particular element in a dataset.

\par Persistence
CPS stores the Checkpointed data in the main memory using database configured 
by the user in clDbalConfig.xml. 


\subsection sec_ckpt_intro_22 Server Based Checkpointing

\par Checkpoint Life cycle
To use the services of CPS, the application has to initialize the CPS using the
clCkptInitialize() function. The clCkptInitialize() function returns a handle,
ckptSvcHandle, that can be used in subsequent operations on the CPS to 
identify the initialization. When this handle is not required, the 
association can be closed using the clCkptFinalize() function.
\par
CPS provides a selection object based approach for handling pending callbacks.
Applications can use the clCkptSelectionObjectGet() and clCkptDispatch() 
functions for the same.

\par Checkpoint Management
After the CPS is initialized, the application can open a Checkpoint in 
create/read/write mode using the clCkptCheckpointOpen() or 
clCkptCheckpointOpenAsync() functions. A handle, CheckpointHandle, that 
identifies this Checkpoint is returned and the other Checkpoint management and
data access functions can use this handle for accessing the Checkpoint.
\par
The applications that have opened the Checkpoint in read/write mode can close 
the Checkpoint using the clCkptCheckpointClose() function. If the Checkpoint
is not required and the clCkptCheckpointDelete() function is not called, the 
retention timer (specified during the Checkpoint open) is started. When the
timer expires, the Checkpoint is deleted. This is performed to avoid the 
accumulation of unused Checkpoints in the system. The application can update 
the retention time of the Checkpoint using the 
clCkptCheckpointRetentionDurationSet() function.
\par
Checkpoints can be deleted using the clCkptCheckpointDelete() function. But the
Checkpointed data is retained till it is in use. For an asynchronous collocated
Checkpoint, the decision where the active replica should reside, lies with the 
user application. The application can set a particular replica as an active 
replica using the clCkptActiveReplicaSet() function. The user application can 
also inquire the status (various attributes) of the Checkpoint using the 
clCkptCheckpointStatusGet() function.

\par Section management
A Checkpoint can have one or more sections. By default, CPS creates a section 
(called as default section) for every Checkpoint. The information to be 
Checkpointed is stored in these sections. Associated with each section is a 
section identifier that identifies a particular section. The user application 
can create a section in a Checkpoint using the clCkptSectionCreate() function 
and delete a section using the clCkptSectionDelete() function.
\par
A section created by the user application is deleted automatically after
section expiration time (that is specified in clCkptSectionCreate()) has
passed. This expiry time can be modified using the
clCkptSectionExpirationTimeSet() function.
The user can also iterate through the sections of a Checkpoint to search for 
infinite expiry time, expiry time greater than a particular value, or for a 
corrupted section. ClCkptSectionIterationInitialize(), 
clCkptSectionIterationNext(), and clCkptSectionIterationFinalize() functions 
provide this facility.

\par Data Access
CPS uses ioVectors to read and write data to a Checkpoint. CPS provides 
two functions to write data: clCkptCheckpointWrite() for writing to multiple 
sections in a Checkpoint and clCkptSectionOverwrite() for updating a particular
section of a Checkpoint.
\par
The data can be read from a Checkpoint using the clCkptCheckpointRead() 
function. CPS does not ensure consistency of data across replicas of 
asynchronous Checkpoints. The Checkpoint data at replicas can be synchronized 
using the clCkptCheckpointSynchronize() or clCkptCheckpointSynchronizeAsync() 
functions.  
\par
CPS also provides notification of immediate consumption to the users. To receive
this notification, users can register their callback functions using 
the clCkptImmediateConsumptionRegister() function. The callback is invoked 
when a change in Checkpointed data occurs.

\par Replica management
CPS ensures that there exists atleast one more replica of a Checkpoint in the
system provided resource exists, is there. If only the System controller is present,
the checkpoint is not replicated anywhere, in this scenario, checkpoint service doesn't 
support restart. CPS marks the local replica (where the Checkpoint is opened in create mode)
as the active replica for all Checkpoints other than asynchronous collocated Checkpoints.

*/
 
//-----------------------------------------------------------

/**

\addtogroup ckpt_usage

The below code example shows the usage of server based checkpointing.
The usage model of this example is to to have 2 applications running
in 1+1 redundancy on 2 worker nodes. The Active application keeps
writing a counter value inthe checkpoint and the standby application 
will be idle. After some time we kill the node running the active instance,
which triggers the standby application to now take over as Active. At 
this point the new active application reads the checkpoint, and starts 
updating counter from the point where the old active had left it.

Note that the below code snippets are been tested. However please follow
the instructions given in the comment blocks before each function.
\code
#include "ckptTest.h"

/*********************************************************************
 *  Definitions: Below are the datastructure definitions used 
 *  in this application
 *********************************************************************/

#define CKPT_NAME "SampleCkptTest"   /* Checkpoint Name              */
#define CKPT_SID_NAME "1"            /* Checkpoint section id        */

ClUint32T      seq;                  /* The sequence no which will be
                                        written into the checkpoint  */
ClCkptSvcHdlT  ckpt_svc_handle;      /* Checkpointing service handle */
ClCkptHdlT     ckpt_handle;          /* Checkpoint handle            */
ClCkptSectionIdT ckpt_sid = {        /* Section id for checkpoints   */
        (ClUint16T)sizeof(CKPT_SID_NAME)-1,
        (ClUint8T*)CKPT_SID_NAME
};

int running = 1;
int exiting = 0;
ClAmsHAStateT  ha_state = CL_AMS_HA_STATE_NONE;

/**********************************************************************
 *  INIT: The below function initializes the checkpoint service client 
 *  and opens a collocated checkpoint in read, write mode. This function 
 *  should be invoked from the AppInitialize of the application before 
 *  doing a clCpmRegister
 **********************************************************************/
ClRcT checkpoint_initialize()
{
    ClRcT      rc = CL_OK;
    ClVersionT ckpt_version = {'B', 1, 1};
    ClNameT    ckpt_name = { strlen(CKPT_NAME), CKPT_NAME };
    ClCkptCheckpointCreationAttributesT create_atts = {
        .creationFlags     = CL_CKPT_WR_ACTIVE_REPLICA_WEAK |
                             CL_CKPT_CHECKPOINT_COLLOCATED,
        .checkpointSize    = sizeof(ClUint32T),
        .retentionDuration = (ClTimeT)0,
        .maxSections       = 2,              /* Default section, 
                                                plus section we create  */
        .maxSectionSize    = sizeof(ClUint32T),
        .maxSectionIdSize  = (ClSizeT)64
    };


    clOsalPrintf("Initializing the checkpoint\n");

    /* Initialize checkpointing service instance */
    rc = clCkptInitialize(&ckpt_svc_handle, /* Checkpoint service handle */
                          NULL,             /* Optional callbacks table  */
                          &ckpt_version);   /* Required verison number   */
    if (rc != CL_OK)
    {
        clOsalPrintf("clCkptInitialize failed with rc 0x%x\n",rc);
        return rc;
    }

    clOsalPrintf("Checkpoint service initialized [handle=0x%x]\n",
                  ckpt_svc_handle);

    /* Create the checkpoint for read and write. */
    rc = clCkptCheckpointOpen(ckpt_svc_handle, /* Service handle         */
                              &ckpt_name,      /* Checkpoint name        */
                              &create_atts,    /* Optional creation attr.*/
                              (CL_CKPT_CHECKPOINT_READ |
                               CL_CKPT_CHECKPOINT_WRITE |
                               CL_CKPT_CHECKPOINT_CREATE),
                              (ClTimeT)-1,     /* No timeout             */
                              &ckpt_handle);   /* Checkpoint handle      */
    if (rc != CL_OK)
    {
        clOsalPrintf("clCkptCheckpointOpen failed with [rc=0x%x]\n",rc);
        clCkptFinalize(ckpt_svc_handle);
        return rc;
    }
    clOsalPrintf("Checkpoint opened [Checkpoint handle=0x%x]\n", 
                  ckpt_handle);

    return CL_OK;
}

/************************************************************************
 *  Finalize: The below function closes the checkpoint and finalizes the 
 *  checkpoint svc handle. This should be called from AppTerminate function
 *  of the application.
 ************************************************************************/
ClRcT checkpoint_finalize(void)
{
    ClRcT rc;

    rc = clCkptCheckpointClose(ckpt_handle);
    if (rc != CL_OK)
    {
        clOsalPrintf("Checkpoint close failed with rc 0x%x\n",rc);
    }
    rc = clCkptFinalize(ckpt_svc_handle);
    if (rc != CL_OK)
    {
        clOsalPrintf("Checkpoint Finalize failed with rc 0x%x\n",rc);
    }
    return rc;
}

/*************************************************************************
 *  active_replica_set: This function sets the local checkpoint db as the
 *  active replica. This will be initially called in the section_create 
 *  function before creating the section into the checkpoint. However, 
 *  this function also needs to be explicitly invoked by the application 
 *  as soon as it takes over from Standby state to Active State.
 *************************************************************************/
ClRcT   active_replica_set()
{
    ClRcT rc = CL_OK;
    rc = clCkptActiveReplicaSet(ckpt_handle);
    if (rc != CL_OK)
    {
        clOsalPrintf("Ckpt Active replica set failed with [rc = 0x%x\n",rc);
        return rc;
    }
    return rc;
}


/*************************************************************************
 *  section_create: This function creates a section into the checkpoint.
 ************************************************************************/
ClRcT   checkpoint_section_create()
{
    /*
      Try to create a section so that updates can operate by overwriting
      the section over and over again.
     */
    ClRcT rc = CL_OK;
    ClUint8T initData = 0;
    ClCkptSectionCreationAttributesT section_atts = {
        .sectionId = &ckpt_sid,
        .expirationTime = CL_TIME_END      /* Setting an infinite time  */
    };


    active_replica_set();
    /* Create the section */
    rc = clCkptSectionCreate(ckpt_handle,         /* Checkpoint handle  */
                             &section_atts,       /* Section attributes */
                             &initData,           /* Initial data       */
                             (ClSizeT)sizeof(initData));
                                                  /* Size of data       */
    if (rc != CL_OK && (CL_GET_ERROR_CODE(rc) != CL_ERR_ALREADY_EXIST))
    {
        clOsalPrintf("CkptSectionCreate failed with rc 0x%x\n",rc);
        clCkptCheckpointClose(ckpt_handle);
        clCkptFinalize(ckpt_svc_handle);
        return rc;
    }
    else if (rc != CL_OK && (CL_GET_ERROR_CODE(rc) == CL_ERR_ALREADY_EXIST))
    {
        /* Section already exists. So read the checkpointed value and
         * continue to write from the point where it is left */
        rc = checkpoint_read_seq(&seq);
        if (rc != CL_OK)
        {
            clOsalPrintf("Checkpoint read failed with rc 0x%x\n",rc);
            clCkptCheckpointClose(ckpt_handle);
            clCkptFinalize(ckpt_svc_handle);
            return rc;
        }
        clOsalPrintf("Sequence Number read from chekpoint %lu\n",seq);
    }
    else
    {
        clOsalPrintf("Section created successful\n");
    }

    return rc;
}


/*************************************************************************
 *  READ: This function reads the checkpointed data and stores
 *        in the global seq variable
 *************************************************************************/
ClRcT   checkpoint_read_seq(ClUint32T *seq)
{
    ClRcT rc = CL_OK;
    ClUint32T err_idx; /* Error index in ioVector */
    ClUint32T seq_no = 0xffffffff;
    ClCkptIOVectorElementT iov = {
        .sectionId  = ckpt_sid,
        .dataBuffer = (ClPtrT)&seq_no,
        .dataSize   = sizeof(ClUint32T),
        .dataOffset = (ClOffsetT)0,
        .readSize   = sizeof(ClUint32T)
    };

    rc = clCkptCheckpointRead(ckpt_handle, &iov, 1, &err_idx);
    if (rc != CL_OK)
    {
        clOsalPrintf("CkptRead ERROR [rc = 0x%x]\n",rc);
    }

    *seq = ntohl(seq_no);
    clOsalPrintf("CheckpointRead: seq = %lu\n", *seq); 
    fflush(stdout);

    return rc;
}

/*************************************************************************
 *  WRITE: The below function writes the seq no into the checkpoint.
 *************************************************************************/
ClRcT   checkpoint_write_seq(ClUint32T seq)
{
    ClRcT rc = CL_OK;
    ClUint32T seq_no;

    seq_no = htonl(seq);
    clOsalPrintf("CkptWrite: seq = %lu\n", seq);
    fflush(stdout);

    /* Write checkpoint */
    rc = clCkptSectionOverwrite(ckpt_handle,
                                &ckpt_sid,
                                &seq_no,
                                sizeof(ClUint32T));
    if (rc != CL_OK)
    {
        clOsalPrintf("CheckpointSectionOverWrite failed with rc 0x%x\n",rc);
    }
    else
    {
        /* If write is successful, then synchronise the checkpoints on all
           replicas */
        rc = clCkptCheckpointSynchronize(ckpt_handle, CL_TIME_END );
        if (rc != CL_OK)
        {
            clOsalPrintf("Failed [0x%x] to synchronize the checkpoint\n", 
                          rc);
        }
    }

    return rc;
}


/*************************************************************************
 *  LOOP: The below function is the critical part of the code. This 
 *  function needs to be invoked at the end of the AppInitialize function 
 *  of the application. On the active application,this function keeps
 *  writing the incremented sequence number into the checkpoint. Note that 
 *  the seq no is a global variable. During the switchover, when the standby
 *  takes over as new active it first reads the latest value from the 
 *  checkpoint into the global seq no, and then marks the ha_state variable 
 *  to CL_AMS_HA_STATE_ACTIVE.This will make the below loop on the active 
 *  application to start writing checkpoint with the new value.
 *************************************************************************/
ClRcT get_into_loop()
{
    ClRcT   rc = CL_OK;
    while (!exiting)
    {
        if (running && ha_state == CL_AMS_HA_STATE_ACTIVE)
        {
            /* Checkpoint new sequence number */
            rc = checkpoint_write_seq(seq);
            if (rc != CL_OK)
            {
                printf("Checkpoint write failed... Exiting..\n");
                break;
            }
            seq++;
        }
        sleep(1);
    }
    return rc;
}

/*************************************************************************
 * AppInit: Following code needs to be put into the AppInitialize function
 *          of the application
 *************************************************************************/
{/*START*/
    /* Initialize the checkpoint */
    checkpoint_initialize();

    /* Create the sections */
    checkpoint_section_create();

    /*
       ---END_APPLICATION_CODE---
     */
    get_into_loop();
}/*END*/

/*************************************************************************
 * StateChange: Following code needs to be put into the CSI Set function
 *          of the application. Please note that the other part of the
 *          auto generated code in the application SHOULD NOT be altered
 *************************************************************************/
case CL_AMS_HA_STATE_ACTIVE:
{
    /* Set this local checkpoint as active replica */
    active_replica_set();

    /* Read the value in the section so that u can start
       from where it is left */
    checkpoint_read_seq(&seq);
    ha_state = haState;
}

case CL_AMS_HA_STATE_STANDBY:
{
    ha_state = haState;
    /*
      ---END_APPLICATION_CODE---
     */
}

/*************************************************************************
 * Header File: Below code needs to be put into ckptTest.h file under 
 *              same directory and this also needs to be included in 
 *              the clCompAppMain.c file.
 *************************************************************************/

#include <clCkptApi.h>
#include <clCommon.h>
#include <clOsalApi.h>
#include <clIocServices.h>

/*
   ASP Client Includes.
 */

#include <clRmdApi.h>
#include <clDebugApi.h>
#include <clOmApi.h>
#include <clOampRtApi.h>
#include <clProvApi.h>
#include <clAlarmApi.h>

#include <clEoApi.h>
#include <clCpmApi.h>
#include <clIdlApi.h>
#include <string.h>
#include <netinet/in.h>


extern ClUint32T      seq;              /* The sequence no which will be
                                           written into the checkpoint   */
extern int running;

extern int exiting;

extern ClAmsHAStateT  ha_state;

extern ClRcT checkpoint_initialize();

extern ClRcT checkpoint_finalize(void);

extern ClRcT   checkpoint_section_create();

extern ClRcT   checkpoint_read_seq(ClUint32T *seq);

extern ClRcT   checkpoint_write_seq(ClUint32T seq);

extern ClRcT get_into_loop();

extern ClRcT    active_replica_set();

\endcode

*/
 
//-----------------------------------------------------------
 
/**

\addtogroup ckpt_glossary
\brief Glossary of OpenClovis Checkpoint Service Terms.

\par Checkpoint
A checkpoint is an entity used by applications to store their states 
and related information, so that the same can be retrieved in a failover, 
switchover, or restart scenario.

\par Dataset
Each checkpoint is structured as datasets in File/Library-based Checkpointing. 
A dataset is a part of checkpoint, that can be modified or read independently 
from other datasets. It is similar to sections, used in Server-based 
Checkpointing.

\par Serializer
A user-defined function that is called to pack the user-data before it is 
stored in the persistent memory.

\par Deserializer
A user-defined function that unpacks the stored data. It is invoked when data 
is read from persistent memory.

\par Element
Elements are data of similar types stored within a dataset.

\par Sections
Each checkpoint is structured as sections in Server-based Checkpointing. 
A section is a part of a checkpoint, that can be modified/read independently 
from other sections.

\par Synchronous checkpoint
When a checkpoint is created with synchronous update option (Synchronous 
checkpoint), all the \c writes and checkpoint management calls return only 
after the checkpoint replicas are updated.

\par Asynchronous checkpoint
When a checkpoint is created with asynchronous update option (Asynchronous 
checkpoint), all the \c writes and checkpoint management calls return after 
the active replicas of the checkpoint are updated. Other replicas are updated 
asynchronously.

\par Asynchronous non-collocated checkpoint
The type of an asynchronous checkpoint, where the active replica is selected 
by CPS.

\par Asynchronous collocated checkpoint
The type of an asynchronous checkpoint, where the active replica is selected 
by the user.

\par Replica/Checkpoint replica
A copy of the data that is stored in a checkpoint.

\par Active replica
The replica that is updated first or read from an asynchronous checkpoint. 
There can be a maximum of one active replica at any given time.

\par Local replica
A replica located on the node where the checkpoint is opened.

\par Synchronization
The process of synchronizing the data of a checkpoint across all replicas.

\par Retention duration
Duration for which a checkpoint is retained after the users have closed it 
(or users are not using it).

\par Section expiry time
Duration after which the section is deleted and becomes unuseable.

\par Default section
If the maximum sections specified by the user is equal to 1, when the 
checkpoint is created, CPS provides this section by default.
The expiry time of this default section is infinite.

\par Section identifier
The identifier of the section that is unique within a checkpoint.

\par Section iteration
The process of iterating through all the sections of a checkpoint, to find 
sections that match a criteria specified by the user.
 
*/
  
 
 
 
 
 
