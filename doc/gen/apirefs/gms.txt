/**
 *  \defgroup gms Group Membership Service
 *  \brief The OpenClovis Group Membership Service (GMS) is a high availability
 *  infrastructure component that allows a set of nodes to form a cluster and 
 *  provide track notifications to registered applications. GMS is implemented 
 *  in compliance with the Cluster Membership Service (CLM) as defined by SA 
 *  Forum. It also provides a generalized feature of CLM, where individual applications
 *  can also form a group and provide tracking functionality on the process
 *  group.
 *
 *  Apart from the services defined by SA Forum CLM specification, GMS 
 *  provides following services:
 *  \arg Leader election among the cluster nodes.
 *  \arg Formation of process groups and their management along with track 
 *   notification.
 *
 *  In this document, the Process Group functionality of GMS is indicated as 
 *  "Process Group Service", and the SAF CLM implementation is indicated as 
 *  "CLM Service". The following sections describe the functionalities, the 
 *  usage scenarios, and the various service interfaces provided for each of 
 *  these services.
 */
 
/**
 *  \defgroup gms_intro Functional Description
 *  \brief Description of the Group Membership Service.
 *  \ingroup gms
 * 
 */

/**
 *  \defgroup gms_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup gms
 * 
 */

/**
 *  \defgroup gms_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup gms
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting GMS 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_GMS "GMS Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_gms
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

/**
 *  \defgroup gms_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions. 
 *  \ingroup gms
 */

/**
 *  \defgroup gms_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup gms
 */

//-----------------------------------------------------------
//-----------------------------------------------------------

/**

\addtogroup gms_intro
\brief Description of the Group Management Service.

\section sec_gms_intro_1 CLM Service

CLM Service manages the membership of the cluster with specified cluster configuration,
for the nodes that are administratively configured to be part of it. It provides a consistent
view of the cluster across all nodes of the cluster.

A node must be member of the cluster to host high availability applications on it. CLM
Service allows a node to be a member of a cluster only if the node is healthy and is
well-connected to the cluster.

When ASP is started, Component Manager (CPM) sends a request to GMS for the
membership of the node for the cluster. GMS processes the request and decides upon the
membership of the node. It also elects a leader and a deputy node for the cluster based on
the leadership credentials and the node ID of the member nodes. If the cluster join from CPM
followed by the leader election are successful, GMS provides a track notification to the 
registered members with the view of the cluster along with the leader and deputy information.
CPM being one of the registered users for cluster track, it gets the above said
notification from GMS after a successful join.
 
An application can register for track notifications with GMS using the
clGmsClusterTrack() APIs. After registration, GMS notifies the application for any changes 
in the cluster membership such as when a node joins, leaves the cluster or a node is 
reconfigured. The application continues to receive such notifications until it invokes
the clGmsClusterTrackStop() API.

GMS provides the following functions for the clustering service:
\arg Allows a node to join a cluster using clGmsClusterJoin() IPI.
\arg Allows a member node to leave the cluster using clGmsClusterLeave() IPI.
\arg Manages cluster membership of the nodes based on their health and 
     communication within the cluster. In other words, the communication
     failure with a node or the node goind down for any other reason
     automatically trigger the other nodes to remove the faulty node from the
     cluster.
\arg Allows user to track a cluster using clGmsClusterTrack() API. It provids consistent view 
     of the cluster across nodes and notifies the changes to the registered
     application through ClGmsClusterTrackCallbackT callback.
\arg Allows user to stop receiving track notifications using clGmsClusterTrackStop() API.
\arg Elects a leader and a deputy node automatically for a cluster whenever the cluster
     configuration changes.
\arg Provides information about a member of a cluster using clGmsClusterMemberGet()
     and clGmsClusterMemberGetAsync() APIs.
\arg Initiates an explicit leader election process on the cluster nodes using
     clGmsClusterLeaderElect() API.
\arg Removes a member from the cluster using clGmsClusterMemberEject().

<b>Note</b>: In the ASP framework, joining or leaving a cluster is generally managed by CPM. 
The applications should not clGmsClusterJoin() and clGmsClusterLeave() IPIs as
it would lead to incosistent state of the cluster.

\section sec_gms_intro_2 Process Group Service

GMS generalizes the CLM Service by allowing a set of applications or processes in the
cluster to form a group and manage such groups. This service, referred to as the Process
Group Service, also allows user to track the group by providing a consistent view of the
group and notifies about the changes in the membership of the group.

The Process Group Service provides the following functionalities:
\arg Creates a group using clGmsGroupCreate() API.
\arg Deletes or destroys a group using clGmsGroupDestroy() API.
\arg Allows a process in the cluster to join a group using clGmsGroupJoin() API.
\arg Allows a member to leave the group using clGmsGroupLeave() API.
\arg Manages membership of the group based on the health of the member processes
     and the containing node. In other words, a node leaving the cluster or
     the application death are handled by GMS service by removing the
     correspnding group members from the group membership, thus by providing a
     consistent and reliable view.
\arg Allows you to track a group using clGmsGroupTrack() API. It provids consistent 
     view of of the group across nodes and notifies the changes to the registered
     application through ClGmsGroupTrackCallbackT.
\arg Allows you to stop receiving track notifications for a given group using
     clGmsGroupTrackStop() API.
\arg Provides a list of meta information on all the groups at any given time using
     clGmsGroupsInfoListGet() API.
\arg Provides the meta information on any given group using clGmsGetGroupInfo() API.

\section sec_gms_intro_3 Usage Scenario

\subsection sec_gms_intro_31 CLM Service

The main objective of CLM service is to provide high availability of services in
co-ordination with AMF and CPM. These ASP services register with GMS for track
notification on the cluster. So at any given time, AMF running on each node is aware of
the leader (or master System Controller node) in the cluster.
        
If the master System Controller node is terminated, GMS instance informs all the
nodes and applications through the track notifications. Based on this information, AMF
makes the standby System Controller as Active. The other applications like
Checkpointing Server can take necessary actions to move their Checkpoint Master
Server on the newly active System Controller node.

\subsection sec_gms_intro_32 Process Group Service
      
The main objective of Process Group Service is to allow a set of processes, implementing a
distributed component, service, or application to form a group in order to share data or to
co-ordinate access to shared resources. Generally these processes are multiple
instances of the same code running on different nodes.
   
For example, a Name Service (NS) implementation will depend on a local NS daemon
running on every node in a system. An NS entry created by an application on a node is
registered with the local NS daemon. The other nodes can view this entry by allowing
the NS daemons to form a group and using group communication to disseminate
information among them.

This can be achieved in two possible ways. Both the solutions require that the current
group view is available to all members.

\arg By using a leader that is a dedicated member and holds the primary repository of
     the NS database, or
\arg In a distributed fashion where each member owns its local data and multicasts the
     changes in the data to other members of the group.

\section sec_gms_intro_4 Interaction with other components
     
GMS depends on CPM for component management and uses RMD infrastructure between
the GMS client and the server instances. Also it uses the event service to find out if any of
the components that are member of the group goes down. This component death event is
given by CMP service, and GMS would remove this member from all the groups of which it
was member.

\section sec_gms_intro_5 Configuration

GMS provides a set of the configurable parameters. You can configure the values of these
parameters through the <code>clGmsConfig.xml</code> file located in the <code>$ASP_CONFIG</code> 
directory.

<ol>

<li><b>clusterName</b>: Name of the cluster being formed.

<li><b>linkName</b>: Name of the IP network interface of the machine on which GMS instance will bind.

<li><b>multicastAddress</b>: Multicast IP address to which GMS Server binds and exchanges its
    information (such as handshake messages with other GMS instances in the cluster).

<li><b>multicastPort</b>: Port number to be used to bind for the multicast socket. This socket is
    used along with the MulticastAddress to exchange internal information with other GMS
    instances in the cluster.

<li><b>maxNoOfGroups</b>: Maximum number of process groups allowed to be formed in a cluster.

<li><b>openAisLoggingOption</b>: This options controls the log output from
OpenAis software used by GMS. This tag can take the value 'file', 'stderr',
'syslog' and 'none'. The default value is 'none'. Note that this option is
useful while debugging issues with GMS. Also note that, if the option is
'syslog', then local5 channel is used. So user needs to configure this channel
in syslog.conf. And if the option is set to 'file', then a log file with name
'OpenAis.log' under $ASP_LOGDIR directory.

</ol>

<b>Note 1</b>: In order for the GMS to work properly, the values of <code>MulticastAddress</code> 
and the <code>MulticastPortT</code> parameters should be identical on all the nodes that are part
of the same cluster.

<b>Note 2</b>: GMS runs on top of IP multicast. It uses the multicast address
and the multicast port number specified in the configuration given above and
forms a multicast group. This way it know when a new member joins a group and
leaves a group. Please note that multicast has certain dependencies such as
the firewall should be disabled on the machine using "iptables -F" command,
etc.

*/
 
//-----------------------------------------------------------

/**
 *  \addtogroup gms_usage
 *  \brief Code Examples.
 *
 *  Example illustrating a simple svn initialize/finalize cycle for gms client
 *  \code
 *  
 *  /* SVC handle which will be populated by GMS client */  
 *  static ClGmsHandleT   handle = 0;
 * 
 *  /* Current version supported by gms */
 *  static ClVersionT  correct_version = {'B',1,1};
 *
 *  /* Callbacks to be provided by user. Since we are using any of
 *   * these functionality here, we will set all of them to NULL
 *   */
 *  static ClGmsCallbacksT callbacks = {
 *        .clGmsClusterTrackCallback      = NULL,
 *        .clGmsClusterMemberGetCallback  = NULL,
 *        .clGmsGroupTrackCallback        = NULL,
 *        .clGmsGroupMemberGetCallback    = NULL
 *  };
 *
 *
 *  ClRcT simple_init_finalize_cycle()
 *  {
 *       ClRcT   rc = CL_OK;
 *
 *       /* Calling gms intialize with proper values */
 *       rc = clGmsInitialize(&handle, &callbacks, &correct_version);
 *       if (rc != CL_OK)
 *       {
 *          printf("GMS Initialize failed with rc [0x%x]\n",rc);
 *          return rc;
 *       }
 *
 *       /* Calling finalize on the handle */
 *       rc = clGmsFinalize(handle);
 *       if (rc != CL_OK)
 *       {
 *          printf("GMS finalize failed with rc [0x%x]\n",rc);
 *          return rc;
 *       }
 *
 *       return CL_OK;
 *  }
 *  \endcode
 *
 *  Example showing cluster track and track stop functionality
 *  \code
 *  /* SVC handle which will be populated by GMS client */
 *  static ClHandleT   handle = 0;
 *  
 *  /* Current version supported by gms */
 *  static ClVersionT  correct_version = {'B',1,1};
 *  
 *  /* Callbacks to be provided by user. Since we are using any of
 *   * these functionality here, we will set all of them to NULL
 *   */
 *  
 *  /* Flag to indicate whether callback was invoked or not */
 *  static ClBoolT     callback_invoked = CL_FALSE;
 *  
 *  static void clGmsClusterTrackCallbackFuntion (
 *          CL_IN const ClGmsClusterNotificationBufferT *notificationBuffer,
 *          CL_IN ClUint32T             numberOfMembers,
 *          CL_IN ClRcT                 rc)
 *  {
 *      callback_invoked = CL_TRUE;
 *      printf("Inside cluster track callback function. \n");
 *  }
 *  
 *  static ClGmsCallbacksT callbacks_non_null = {
 *      .clGmsClusterTrackCallback      = clGmsClusterTrackCallbackFuntion,
 *      .clGmsClusterMemberGetCallback  = NULL,
 *      .clGmsGroupTrackCallback        = NULL,
 *      .clGmsGroupMemberGetCallback    = NULL
 *  };
 *  
 *  
 *  ClRcT track_changes_and_changes_only_flag_test()
 *  {
 *      ClRcT       rc = CL_OK;
 *  
 *      /* Initialize svc client handle */
 *      rc = clGmsInitialize(&handle,&callbacks_non_null,&correct_version);
 *      if (rc != CL_OK)
 *      {
 *          printf("GMS Initialize failed with rc 0x%x\n",rc);
 *          return rc;
 *      }
 *          
 *      /* Set the flag to false before triggering the event */
 *      callback_invoked = CL_FALSE;
 *  
 *      /* Register for cluster track */
 *      rc = clGmsClusterTrack(handle,CL_GMS_TRACK_CHANGES,NULL);
 *      if (rc != CL_OK)
 *      {
 *          printf("GMS cluster track failed with rc 0x%x\n",rc);
 *          return rc;
 *      }
 *  
 *  
 *      /* NOTE: In the below wait period, bring down a node or bringup a node 
 *      *  in the cluster. This will trigger the invocation of the callback.*/
 *      /* Wait and see if the callback is called */
 *      sleep(10);
 *  
 *      if (callback_invoked != CL_TRUE)
 *      {
 *          printf("Cluster track callback is not invoked\n");
 *          return CL_OK;
 *      }
 *  
 *      callback_invoked = CL_FALSE;
 *  
 *      /* Now change the flag to TRACK_CHANGES_ONLY flag */
 *      rc = clGmsClusterTrack(handle,CL_GMS_TRACK_CHANGES_ONLY,NULL);
 *      if (rc != CL_OK)
 *      {
 *          printf("clGmsClusterTrack with TRACK_CHANGES_ONLY flag failed with "
 *                 "rc = 0x%x",rc);
 *          return rc;
 *      }
 *  
 *      /* Trigger an event by killing a node or bringing up another node
 *       * in the cluster */
 *      sleep(10);
 *  
 *      if (callback_invoked != CL_TRUE)
 *      {
 *          printf("Cluster track callback is not invoked\n");
 *          return CL_OK;
 *      }
 *  
 *      /* Track stop */
 *      rc = clGmsClusterTrackStop(handle);
 *      if (rc != CL_OK)
 *      {
 *          printf("clGmsClusterTrackStop failed with rc = 0x%x",rc);
 *          return rc;
 *      }
 *  
 *      /* Finalize */
 *      rc = clGmsFinalize(handle);
 *      if (rc != CL_OK)
 *      {
 *          printf("finalize failed with rc = 0x%x",rc);
 *          return rc;
 *      }
 *  }
 *  \endcode
 */ 

//-----------------------------------------------------------

