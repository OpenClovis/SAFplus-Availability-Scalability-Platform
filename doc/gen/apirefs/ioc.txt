/**
 *  \defgroup ioc Intelligent Object Communication
 *  \brief  The OpenClovis IOC component provides efficient transport for 
 *  communication between Clovis Objects. It supports both Reliable and 
 *  Unreliable modes of communication. The IOC layer works either on top 
 *  of UDP or on TIPC.
 */

/**
 *  \defgroup ioc_intro Functional Description
 *  \brief Description of IOC.
 *  \ingroup ioc
 */

/**
 *  \defgroup ioc_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup ioc
 */

/**
 *  \defgroup ioc_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup ioc
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting IOC 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_IOC "IOC Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_ioc
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

/**
 *  \defgroup ioc_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup ioc
 */

//-----------------------------------------------------------
//-----------------------------------------------------------
 
/**
 *  \addtogroup ioc_intro 
 *  \brief Description of IOC.
 *
 *  \section  ioc_intro_1 Overview
 *
 *  The OpenClovis IOC component provides efficient transport for communication
 *  between Clovis Objects. The IOC layer works either on top of UDP or on TIPC. 
 *  In case of IOC over UDP only Unreliable communication mode is supported and
 *  in case of IOC over TIPC both Reliable and Unreliable modes are supported.
 *  To enable all the functionalities of IOC, IOC needs broadcast enabled
 *  environment and all the nodes should be directly connected. 
 *
 *  Applications wanting to communicate over IOC need to open communication
 *  ports with IOC and then using these communication ports the applications
 *  can send and receive data.
 *
 *  IOC has the capability to determine routes to reach any clovis objects
 *  in the system, that are residing on blades and the blades may or may not
 *  be connected to each other directly. If the nodes have more than one
 *  links(physical connections to other nodes) then the IOC select the
 *  appropriate link depending on the priority of the links. Once a link is
 *  selected the ARP module gives the link level address to send the message
 *  out.
 *
 *  \par Blocking and Non-blocking Receive
 *  IOC supports Blocking and Non-blocking receive.
 *  In case of blocking receive it blocks the receiver thread inside
 *  the receive call waiting for a message to arrive or till the receive
 *  times out.
 *  IOC provides Non-blocking receive, which returns immediately and the
 *  application might have to poll on the communication port to figure out 
 *  the data availability.
 *
 *  \par Non-blocking Send
 *  IOC send hands over the message underlying transport and return immediately.
 *
 *  \par Priorites
 *  IOC supports sending of messages of different priority. If a message sent is
 *  a high priority message and there are lower priority messages already in the
 *  queue, which are yet to be sent then the higher priority message is sent first.
 *  On the receive side also the higher priority message is delivered first.
 *
 *  \par Routing
 *  The IOC also provides Routing services. That is, the IOC has a
 *  routing engine to enable it  to select the a path to reach the
 *  destination IOC  address for a packet. Only one route per destination
 *  is supported in current IOC. The route entries can be added at the boot
 *  time statically, if broadcast ie enabled then the route is learnt.
 *  In this release only direct routes are supported.
 *
 *  \par Heartbeating
 *  IOC provides link level heartbeating support. If any of the link goes down
 *  then the IOC takes care of the on going communication and switchs to the
 *  other link. Whenever a send request to the failed node comes, an
 *  error is returned to the caller.
 *
 *  \par Neighbor Discovery
 *  IOC supports a mechanism of automatical identifying all the ASP nodes
 *  present in the system and immediately establishes links with them for
 *  communicating with the clovis object on that nodes.
 *
 *  \par Port Unreachable errors
 *  If a sender is trying to reach an object of a node which does not exist
 *  then IOC of the receiving node sends an IOC port unreachable message
 *  to the sending end.
 *
 *  \par Fragmentation and Reassembly
 *  IOC supports send and receive of any size of messages. The fragmentation
 *  and reassembly is implemented in IOC which takes care of messages of any
 *  size.
 *
 *  \par Physical Addressing
 *  Every ASP component that wants to communicate with other component in the
 *  network has to have a physical address. The Physical address is composed
 *  of the Node address, which is unique for each node in the system, and
 *  commponent port number, which is unique in a node.
 *
 *  \par Transparent Addressing
 *  IOC supports transparent addressing. An application can register a
 *  logical address and its physical address with the IOC. A sender which wants
 *  to reach this application can use the logical address to communicate instead
 *  of the physical address. If the receiver moves to a new a new location the
 *  sender is not affected.
 *  Two types of communications are possible with logical addresses: 
 *  \arg Session based: In this case, on issuing a send to a logical address,
 *  the IOC determines the physical address of that logical address and then
 *  sends the message to it. The subsequent sends to the same logical address
 *  will goto the same physical location. If the receiver moves somewhere else
 *  then the error is returned to the sending application. 
 *  \arg Session Less: Here each send to a logical address trigers the logical
 *  to physical address lookup, if the receiver moves to a new location the next
 *  call transparently goes to the new location and no error is returned to the user.
 *
 *  \par Multicast Addressing
 *  IOC supports multicating facility. This means that the clovis objects which
 *  are interested in joining a group have to register their physical address
 *  with IOC. The group will be having a multicast address. The messages received 
 *  on that multicast address will be sent to all the clovis objects which
 *  have registered for that group.
 *
 *  \par Interaction with other components
 *  The IOC depends on Buffer Manager (BM) for efficient message handling.
 *  Besides BM, it also depends on the Clovis Operating System Abstraction
 *  Layer (OSAL) for the following operations: 
 *  \arg Task creation
 *  \arg Interprocess synchronization
 *  IOC also depends on Clovis Utilities like Heap, Containers,  and Timer.
 *
 */

//-----------------------------------------------------------

/**
 *  \addtogroup ioc_usage
 *  \brief Code Examples.
 *
 *  The following example shows how to create a commport, sending and
 *  receiving messages on it and then deleting it.
 *
 *  As a first step, a communication port is created. For creating a commport we 
 *  can specify a required communication port id, if the commport is going to
 *  serve as a well known server. This can be chosen from clIocServices.h
 *  file. If 0 is passed for commPortId then the IOC will chose one
 *  commomuincation port id for the application. For sending and
 *  receiving through this communication port the communication handle
 *  should be used.
 *
 *  \code
 *  ClRcT retCode = CL_OK;
 *  ClIocCommPortHandleT commPortHandle; // This will filled and returned
 *                                       // on successful creation of
 *                                       // communication port.
 *
 *  ClUint32T commPortId = 0x8888; // It can be any port number within the
 *                                 // range specified in clIocServices.h.
 *  ClUint32T commMode = CL_IOC_RELIABLE_MESSAGING;
 *
 *  retCode = clIocCommPortCreate(commPortId, commMode, &commPortHandle );
 *  if(CL_OK != retCode) {
 *      // Most of the times the error will occur due to Less memory OR
 *      // If the port is already being used by some other component.
 *      // Cannot do any send and receive with this communication port in
 *      // this application.
 *  } 
 *  \endcode
 *
 *
 *  Here we can see how a message can be sent to a destination. The
 *  protocol field is a must for sending a packet, and it should be chosen
 *  from clIocProtocols.h file. The data to be sent should be passed as a
 *  buffer message. And the receiver address can be a physical, logical or
 *  a multicast address.
 *
 *  \code  
 *  ClBufferHandleT         sendBuffer = 0;
 *  ClUint32T               protocol;
 *  ClIocAddressT           receiverAddress ;
 *  ClIocSendOptionT        sendOption = {0};
 *
 *  // Create and fill the sendBuffer here.
 *  // Fill the receiverAddress here.
 *
 *  protocol = USER_PROTOCOL; // This is information for the receiver
 *                            // to analyse the sendBuffer. This should
 *                            // be within the proper range specified in
 *                            // clIocProtocol.h file.
 *  sendOption.priority = 0;  // You can specify the priority of the
 *                            // message.
 *  sendOption.timeout = CL_IOC_TIMEOUT_FOREVER; // Send will return if
 *                            // it is able to send the whole message or
 *                            // if the timeout occurs, whiever is the
 *                            // earliest.
 *
 *  retCode = clIocSend(commPortHandle, 
 *                              sendBuffer, 
 *                              protocol,
 *                              &receiverAddress,
 *                              &sendOption);
 *  if(CL_OK != retCode)
 *  {
 *      // IOC send failed with error code in "retCode"
 *  }
 *  \endcode  
 *
 *  The clIocReceive() call will block on the commport for receiving a
 *  message. The call expects a valid buffer message handle to receive the
 *  data. On receiving some data the IOC unblocks the receiver thread,
 *  which is blocked on the commport. All the information relating to the
 *  message received( like sender info, length of the message, protocol
 *  for analysing the message), will be present in recvParam.
 *
 *  \code  
 *  ClIocRecvOptionT recvOption;
 *  ClIocRecvParamT  recvParam;
 *
 *  // Create a recvBuffer for holding the receiver message.
 *
 *  recvOption.timeout = CL_IOC_TIMEOUT_FOREVER; // Timeout within which
 *                            // the IOC should unblock the receiver
 *                            // thread with or without a message.
 *
 *  retCode = clIocReceive(commPortHandle,
 *                         recvOption,
 *                         recvBuffer,
 *                         recvParam);
 *
 *  if(CL_OK != retCode)
 *  {
 *      // IOC receive failed with error code in "retCode"
 *  }
 *
 *  // - recvParam.priority is the priority of the with which the sender
 *  // sent the message.
 *  // - recvParam.protoType is the protocol of the message with which the
 *  // send and the receiver are communicating.
 *  // - recvParam.length is the length of the received message.
 *  // - recvParam.srcAddr is the address of the sender of the message.
 *  
 *  \endcode
 *
 *
 *  For deleting a commport a valid commPortHandle must be passed. And
 *  before calling this API we need make sure that no thread is waiting
 *  for any data on this commport.
 * 
 *  \code
 *  retCode = clIocCommPortDelete(commPortHandle);
 *  if(CL_OK != retCode)
 *  {
 *      //Communication deletion failed.
 *  }
 *  \endcode
 */
 
//-----------------------------------------------------------
