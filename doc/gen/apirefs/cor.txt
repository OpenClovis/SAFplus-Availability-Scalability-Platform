/**
 *  \defgroup cor Clovis Object Repository (COR)
 *  \brief Clovis Object Repository (COR) is an in-memory object oriented 
 *  distributed database. It implements data management capabilities such as 
 *  object creation, deletion, query, indexing, distribution, transaction and 
 *  recovery. COR is a mechanism by which the Information Model pertaining to a 
 *  Telecommunication or Data Communication system is captured. The Clovis 
 *  Object repository is updated in the active System Controller instance and 
 *  an exact replica is maintained (synchronized) in the System Controller 
 *  StandBy to provide High Availability. In addition COR provides persistence 
 *  storage of the repository to provide HA across restart scenarios.
 *
 */

//-----------------------------------------------------------
 
/**
 *  \defgroup cor_intro Functional Description
 *  \brief Description of COR and its functionalities.
 *  \ingroup cor
 * 
 */

//-----------------------------------------------------------

/**
 *  \defgroup cor_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup cor
 * 
 */

//-----------------------------------------------------------

/**
 *  \defgroup cor_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup cor
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting COR generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_COR "COR Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_cor
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

//-----------------------------------------------------------

/**
 *  \defgroup cor_class API Classification
 *  \brief Classification of COR APIs. 
 *  \ingroup cor
 *  
 *  \section cor_class_1 COR APIs
 *   Clovis Object Repository consists of the following groups of APIs:
 *
 *  \subsection cor_class_11 Library Life Cycle APIs:
 *  The COR bundle functionality is used to read the attribute values from the OIs. The bundle is created 
 *  using Bundle Initialize API and it exists till all the values are read from the OIs.
 *           \arg clCorBundleInitialize()
 *           \arg clCorBundleFinalize()
 *
 *  \subsection cor_class_12 Object Management Data Structures and APIs:
 *  A transaction consists of one or more object Create/Set/Delete operations or a combination 
 *  of these operations. A transaction-id is created by COR for all the transaction requests.
 *  The transaction can be a SIMPLE transaction or COMPLEX transaction. In a SIMPLE transaction 
 *  only one job can be added and in the COMPLEX transaction more than one job can be added using 
 *  the same Transaction-Id.  These jobs are linked together in the COR-job-list.  
 *  \subsubsection cor_class_121 Typedefs
 *      \arg ::ClCorTxnIdT
 *      \arg ::ClCorTxnJobIdT
 *      \arg ::ClCorTxnFuncT
 *      \arg ::ClCorTxnSessionIdT
 *      \arg ::ClCorBundleCallbackPtrT
 *      \arg ::ClCorBundleHandleT
 *  \subsubsection cor_class_122 Functions
 *      \arg clCorObjectCreateAndSet()
 *      \arg clCorObjectCreate()
 *      \arg clCorObjectAttributeSet()
 *      \arg clCorObjectDelete()
 *      \arg clCorUtilMoAndMSOCreate()
 *      \arg clCorObjectAttributeGet()
 *      \arg clCorObjectHandleGet()
 *      \arg clCorObjectHandleToTypeGet()
 *      \arg clCorObjectHandleToMoIdGet()
 *      \arg clCorTxnSessionCommit()
 *      \arg clCorTxnSessionCancel()
 *      \arg clCorTxnSessionFinalize()
 *      \arg clCorTxnFailedJobGet()
 *      \arg clCorBundleObjectGet()
 *      \arg clCorBundleApply()
 *      \arg clCorBundleApplyAsync()
 *
 *  \subsection cor_class_13 Object Addressing Data Structures and APIs:
 *  COR Provides uniform mechanism to perform operations on MO objects across all Node
 *  Instances via MOID. It therefore, enables multiple components to participate in life-cycle events of an MO
 *  (Creation/Deletion/State). COR also provides notification mechanism that publishes an event when a MO is
 *  created/deleted or state-change occurs.
 *
 *  \subsubsection cor_class_131 Typedefs
 *      \arg ::ClCorMOServiceIdT
 *      \arg ::ClCorAddrT
 *      \arg ::ClCorAddrPtrT
 *      \arg ::ClCorMOIdT
 *      \arg ::ClCorMOIdPtrT
 *      \arg ::ClCorObjectHandleT
 *      \arg ::ClCorAttrPathT
 *      \arg ::ClCorAttrPathPtrT
 *
 *  \subsubsection cor_class_132 Enumerations
 *      \arg ::ClCorServiceIdT
 *      \arg ::ClCorObjTypesT
 *      \arg ::ClCorMoIdClassGetFlagsT
 *      \arg ::ClCorMoPathQualifierT
 *  \subsubsection cor_class_133 Functions
 *      \arg clCorMoIdInitialize()
 *      \arg clCorMoIdFree()
 *      \arg clCorMoIdSet()
 *      \arg clCorMoIdAppend()
 *      \arg clCorMoIdDepthGet()
 *      \arg clCorMoIdShow()
 *      \arg clCorMoIdClone()
 *      \arg clCorMoIdCompare()
 *  \subsubsection cor_class_134 Defines
 *      \arg ::CL_COR_CLASS_WILD_CARD
 *      \arg ::CL_COR_INSTANCE_WILD_CARD
 *
 *  \subsection cor_class_14 Object Search Data Structures and APIs:
 *  COR provides the capability to retrieve objects matching a particular criterion. 
 *  This criterion is called the filter. Two types of search can be done using 
 *  the following APIs - Object Based Search and Attribute Based Search.
 *  \subsubsection cor_class_141 Typedefs
 *      \arg ::ClCorObjectWalkFunT
 *      \arg ::ClCorObjAttrWalkFilterT
 *      \arg ::ClCorObjAttrWalkFuncT
 *  \subsubsection cor_class_142 Enumerations
 *      \arg ::ClCorAttrWalkOpT
 *      \arg ::ClCorObjWalkFlagsT
 *      \arg ::ClCorAttrCmpFlagT
 *  \subsubsection cor_class_143 Functions
 *      \arg clCorMoIdFirstInstanceGet()
 *      \arg clCorMoIdNextSiblingGet()
 *      \arg clCorObjectWalk()
 *      \arg clCorObjectAttributeWalk()
 *
 *  \subsection cor_class_15 MoId Manipulation APIs:
 *  The MOID which is used to address a MO uniquely in COR can be manipulated by using the 
 *  following APIs. The Service Id of the MoId is used to distinguish between MO and MSO objects.
 *  \subsubsection cor_class_151 Functions
 *      \arg clCorMoIdToClassGet()
 *      \arg clCorMoIdNameToMoIdGet()
 *      \arg clCorMoIdToMoIdNameGet()
 *      \arg clCorMoIdToInstanceGet()
 *      \arg clCorMoIdToMoClassPathGet()
 *      \arg clCorMoIdServiceGet()
 *      \arg clCorMoIdServiceSet()
 *      \arg clCorMoIdInstanceSet()
 *      \arg clCorMoIdConcatenate()
 *
 *  \subsection cor_class_16 COR Event APIs:
 *  COR generates an event for every object creation/deletion/set operation. 
 *  The applications can subscribe for these events and manipulate the event data by using the following APIs.
 *  \subsubsection cor_class_161 Functions
 *      \arg clCorEventSubscribe()
 *      \arg clCorEventUnsubscribe()
 *      \arg clCorEventHandleToCorTxnIdGet()
 *      \arg clCorTxnIdTxnFree()
 *      \arg clCorTxnJobWalk()
 *      \arg clCorTxnJobMoIdGet()
 *      \arg clCorTxnJobSetParamsGet()
 *      \arg clCorTxnJobOperationGet()
 *
 *  \subsection cor_class_17 OI Related APIs:
 *  Components require to participate in the life cycle of an MO and know
 *  when an Object is created or deleted or when its attribute changes. Applications 
 *  can achieve this by adding themselves into the route-list corresponding to an MO/MSO. 
 *  Whenever a life cycle management function is invoked on an MO, all the participating 
 *  components are notified via the invocation of specific component functions.  
 *  COR provides functions to  add/remove components from route list.
 *  \subsubsection cor_class_171 Functions
 *       \arg clCorOIRegister()
 *       \arg clCorOIUnregister()
 *       \arg clCorPrimaryOISet()
 *       \arg clCorPrimaryOIGet()
 *       \arg clCorPrimaryOIClear()
 *
 *  \subsection cor_class_18 Class Type Data Structures:
 *  \subsubsection cor_class_181 Typedefs
 *      \arg ::ClCorClassTypeT
 *      \arg ::ClCorInstanceIdT
 *      \arg ::ClCorTypeT
 *      \arg ::ClCorAttrTypeT
 *      \arg ::ClCorAttrIdT
 *      \arg ::ClCorAttrFlagT
 *  \subsubsection cor_class_182 Enumerations
 *      \arg ::ClCorOpsT
 *  \subsubsection cor_class_183 Defines
 *      \arg ::CL_COR_INVALID_ATTR_ID
 *      \arg ::CL_COR_INVALID_ATTR_IDX
 *      \arg ::CL_COR_ATTR_CACHED
 *      \arg ::CL_COR_ATTR_PERSISTENT
 *      \arg ::CL_COR_ATTR_CONFIG
 *      \arg ::CL_COR_ATTR_RUNTIME
 */


//-----------------------------------------------------------

/**
 *  \defgroup cor_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions. 
 *  \ingroup cor
 */ 

//-----------------------------------------------------------

/**
 *  \defgroup cor_glossary Glossary
 *  \brief Glossary of COR related Terms.
 *  \ingroup cor
 */

//-----------------------------------------------------------

/**
 *  \defgroup cor_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup cor
 */

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
\addtogroup cor_intro
\brief Description of COR and its functionalities.

The ASP COR service is an object-oriented, distributed object repository used for representing the system model. It is used for storing information about the network elements to be managed from any system management application. 

\image html cor4.jpg 
\image latex cor4.jpg "System Management Redundancy Architecture" width=\textwidth

The network elements are modeled as Managed Object(MO) Classes in COR. The attributes of these MO classes are properties of these network elements. The instances of these classes, called as Managed Objects, contains the information about the actual network elements. The COR service provides interfaces to access, modify and manage the life cycle of objects. These objects are called Managed Objects as they contain management information about network elements such as a Chassis. They are used to exchange information between system management applications and applications running on network elements. The applications running on a network element use or produce management information.  Managed Objects and metadata associated with them are located in an in-memory object storage as well as in the persistent database.  

System Management Applications(SNMP, CLI, etc) reside outside the network element and use the services of a local management agent to interface with COR. These local agents are
referred to as Object Managers (OM).

Applications in a network element that use or produce the management information are referred to as Object Implementers (OI). An ASP Service can act as an Object Implementer for an object of interest.

Object Manager and Object Implementer are roles performed by applications. In the current implementation of COR, COR is unaware of Object 
Manager and Object Implementer roles and does not enforce any semantics related to these roles. It is assumed that the OM and OI roles
are maintained by careful application design.        


\section sec_cor_intro_1 Usage model

Applications can model their network elements and represent them as COR Information Model. These applications can use MO classes and the 
containment relationship in COR to interpret the relationship between various network elements.

\par Management Applications (North-bound)
Management application can perform CREATE, DELETE or SET operations on Managed Objects for configuration purposes. Management applications can also subscribe
to CREATE, DELETE or MODIFY notifications on Managed Objects. Such Managed Objects reflect the status of associated network elements.

\par Object Implementor
An Object Implementer (OI) implements the configuration supplied by the north bound. An OI can also perform CREATE, DELETE, and MODIFY operations 
on Managed Objects to reflect its run-time status. 

\section sec_cor_intro_2 Managed Object Class Characteristics

\subsection sec_cor_intro_21 COR MO-Class and MSO-Class 

A MO COR-class is a collection of attributes. Each class has a name and an integral identifier. An MO-class has two services associated with it:
- Provisioning service 
- Alarm service
.

COR groups related attributes of these two services in two different Managed Service Object Class (also called MSO class).
Thus, an MO class has two different MSO classes. One corresponding to Provision-able attributes and the other corresponding to Alarm 
attributes. The MSO class also has a name and a list of attributes.

ASP Alarm service determines the structure of the Alarm MSO class and uses this class to model alarms. 

The Provision-able MSO class structure is defined by the application. From the modeling perspective, it is only the PROV MSO class that is of interest 
to the application. For example, a GigePort class can have a group of provisionable attributes (MTU size) and a group of alarms (such as LOS, LOF
and so on).
COR considers these two groups as two distinct MSO classes associated with GigePort class. An MSO class is identified by an MO class and its Service ID 
The Service ID indicates if the MSO is Provisionable or corresponding to Alarm. The enumeration, \p ClCorServiceIdT, specifies the service ID of a class.

\subsection sec_cor_intro_22 MO tree and Containment

All Managed Objects in COR are organized in a tree hierarchy called the MO tree. The relationship of an MO to its parent MO in the hierarchy is referred 
to as its "containment" relationship. An MO can only be contained in MOs belonging to other MO classes. The rules related to permitted containment relations are part of the definition of an MO Class.

The containment relationship allows COR to organize all MOs in a tree and is therefore mandatory from COR's perspective.
Containment relationship is of no other significance to COR. However, it can have some special significance to management applications as some OIs 
can be interested in a group of related objects (in a subtree). For example, a subtree could reflect the containment of the 
Availability Management Service (AMS) related objects and this containment can have special significance to AMS.

\subsection sec_cor_intro_23 Blueprint for the MO Tree

The MO Class definitions and the permitted containment relations in COR are also referred to as the "blueprint" for the MO tree. This blueprint 
refers to the complete set of object metadata associated with a COR instance. COR permits objects to be created and attached to a tree according to the 
blueprint. This blueprint can be constructed using the OpenClovis Integrated
Development Environment (IDE). The blueprint is exported in IDE generated XML
file  clCorMOClass.xml and imported by COR when it is initialized for the
first time. The blueprint is kept in the COR's persistent storage. COR obtains the blueprint from the persistent storage during its subsequent startup. 

\section sec_cor_intro_3 MO Attributes

\subsection sec_cor_intro_31 Attribute Characteristics
Each MO attribute has the following characteristics:
- Name
- Type associated with attribute values
- Default value
- Qualifier
- Sub qualifiers

The qualifiers supported are:
- Config
- Run-time

The sub-qualifiers supported are:
- Cached
- Persistent
- Initialized
- Writable

\subsection sec_cor_intro_32 Attribute Types Supported

\par Integer and String Types
The supported types are signed and unsigned integers of various sizes. Arrays of these integer types are also supported.  For integer types, 
a maximum, minimum, and default value can be specified.


\subsection sec_cor_intro_33 Caching and Persistence of COR objects

All COR metadata and objects are persisted in the COR-DB. However, the attribute values are not always persisted. This control can be exercised at 
the object attribute level. Persisted object attributes are restored in a COR instance automatically after a GMS-Cluster reboot.
 
COR stores the values of attribute in the memory. This is referred to as caching. Caching results in better read access times for cached attributes. Caching of 
data is not required when the cached data can quickly become stale. Controls are provided to prevent caching of this type of data. These are explained in
subsequent sections.  

\subsection sec_cor_intro_34 Attribute Qualifiers

Every attribute must be qualified as a CONFIG, run-time or KEY. These qualifiers are mutually exclusive.

\par Configuration Attributes
A configuration attribute is always persisted and cached. Configuration attributes contain data provided by the Object Managers. They are read-only from
the perspective of the Object Implementer.

\par Run-time Attributes
A run-time attribute is not persisted or cached by default. The following sub-qualifiers (either singly or in any combination) can be associated with a 
run-time attribute:
- Persistent - This sub-qualifier for run-time attributes indicates that the attribute must be made persistent by the COR Service.
- Cached - This sub-qualifier for run-time attribute indicates that the attribute must be cached by the COR service.
.
Run-time attributes are used for data provided by Object Implementers. They are read only from an Object Manager's perspective.
A run-time attribute that is cached is updated by the Object Implementer when the value changes. When a read request is made on such a run-time attribute, 
COR reads the value from the cache.
A read request on a run-time attribute that is not cached triggers a synchronous request to the Object Implementer that returns with the value of the
attribute.
\par
For examples:
\code run-time + cached\endcode  
Attribute showing Application log stream file name implemented by the Log service.
\code run-time + cached + persistent \endcode 
Administrative state of a service unit implemented by AMF.
\code run-time + multi-valued \endcode 
List of Service Instances currently assigned to a Service Unit, 
implemented by AMF.

\section sec_cor_intro_4 Object Addressing
\subsection sec_cor_intro_41 MOID 

Every object in the COR MO tree has a unique ID referred to as the MOID (Managed Object ID).
Every object has a \p relative_ID that is formed from the tuple, \p class_ID and \p instance_ID, where:
\arg class_ID - uniquely identifies the MO class of which this object is an instance
\arg instance_ID - uniquely identifies this instance of the object from other instances having the same parent.

The MOID of an object is formed from the tuple, MOID of the parent and \p relative_ID of the object.
For example, an AMF Service Unit instance can have the following MOID (shown here in two lines, 
it has to be a string with no space): 
\code 
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1/
SERVICE_UNITCLASS_ID:3
\endcode

COR provides APIs to manage the life cycle of an object and to read or modify its attributes. 
The user is required to know the MOID of the object or its parents.

A MOID uniquely identifies an object in COR tree. However, a variant of the MOID is also used to specify ranges of objects. These are called wild card 
MOIDs. A wild card \p class_ID can represent any class and a wild card \p instance_ID can represent any instance. The wild card MOID 
is used for OI subscription and for specifying an MO instance search criteria. Following are some of the examples of a wild card MOID:

\arg 
\code
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1/
SERVICE_UNITCLASS_ID:* 
\endcode
Specifies all the MO instances of \p SERVICE_UNITCLASS_ID  class under the hierarchy. 
\code
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1
\endcode

\arg
\code COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1/*:*
\endcode
Specifies all the MO instance of any class under the hierarchy.
\code COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1
\endcode

\arg
\code COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:*/*:*
\endcode
Specifies all the MO instance of any class under the subtree \code COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:*.
\endcode
The subtree specified by \code
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:*
\endcode
covers all the MO instances of \p SERVICE_GROUP_CLASS_ID under \code COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/  \endcode


\section sec_cor_intro_5 Object Management Interfaces

\subsection sec_cor_intro_51 OI and Primary OI

An Object Implementer performs several distinct operations in relation to changes in objects that include: 
- Permits or denies an object creation or deletion request.
- Permits or denies changes to a configuration attribute value.
- Implements a change in a configuration attribute when the change has 
  occurred in COR.
- Synchronously updates a cached runtime attribute in COR as and when the
  related variable changes internally.
- Synchronously provides the value of a (non cached) run-time attribute when   
  requested by COR.

Every object can have one or more Object Implementers. While multiple OIs can perform the first three activities, there can be only one OI that is 
allowed to perform the last two activities and this OI is referred as the Primary OI.

\subsection sec_cor_intro_52 OI Registration

A component can act as an OI for an MO as specified in a wild card MOID. For example,
- An MO Instance specified through its MoID. For example, the MoID can be (one string with no space):
\code
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1/
SERVICE_UNITCLASS_ID:1/
\endcode
- Instances of a particular MO Class hanging from a particular hierarchy. 
\code 
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:1/
SERVICE_UNITCLASS_ID:*
\endcode
- A complete subtree. A Component can specify itself as the OI for the wild card
\code
COR_ROOT_CLASS_ID:0/APPLICATION_CLASS_ID:0/SERVICE_GROUP_CLASS_ID:*/
SERVICE_UNITCLASS_ID:*
\endcode

As a component can act as an OI for multiple MO instances corresponding to different MO classes, COR provides a mechanism to associate an OI callback 
APIs for each MO class.

The OI and MO association is performed during modeling. The following table provides a list of OI callback APIs provided by COR.

<TABLE>
   <TR> 
      <TD><b>No.</b></TD>
      <TD><b>OI Callback Function </b></TD>
      <TD><b>Description</b></TD>
   </TR>
   <TR> 
      <TD> 1 </TD>
      <TD> Constructor </TD>
      <TD> COR invokes this function when an MO is required to be created.  
           An application can embed its custom logic to implement MO creation.
           Currently, MO creation/deletion does not have a validate callback
           function. </TD>
   </TR>
   <TR> 
      <TD> 2 </TD>
      <TD> Destructor</TD>
      <TD> COR invokes this callback when an MO is required to be deleted.  
           An application can embed its custom logic to implement MO deletion.
           Currently, MO creation/deletion does not have a validate callback
           function. </TD>
           function. </TD>
   </TR>
   <TR> 
      <TD> 3 </TD>
      <TD> Validate</TD>
      <TD> COR invokes this callback to validate the attribute that is bein SET.
           The callback either permits or denies the application containing this
           attribute. The semantics of validation is specific to the OI. An OI
           can acquire resources (such as memory) required to APPLY this
           attribute to ensure that the APPLY operation is successful.
           This pre-acquisition reduces the possibility of failure of APPLY
           operation. </TD>
   </TR>
   <TR> 
      <TD> 4 </TD>
      <TD> Rollback</TD>
      <TD> This callback is invoked when the validate operation fails on this
           attribute or validate fails on another attribute that is part of 
           the transaction. This callback allows the OI to free any
           pre-allocated resources, acquired in the validate phase. 
           The rollback API is called if any other operation that is part of
           this transaction fails to validate. </TD>
   </TR>
   <TR> 
      <TD> 5 </TD>
      <TD> Apply</TD>
      <TD> This function applies the attribute to the resource.</TD>
   </TR>
</TABLE>	

\subsection sec_cor_intro_53 COR Session Capability

The COR session capability provides a mechanism to execute a group of jobs (CREATE, DELETE and MODIFY operations on a MO) in an efficient manner by minimizing the number of RMD calls between the COR 
client, COR server, and Object Implementer. The COR session capability provides a mechanism to execute CREATE, SET, and DELETE operations on a group of MOs with
all-or-none semantics as described in this section.
The COR server performs a basic validation on these jobs. If one of the job validation fails, the session becomes invalid and no
operations are performed.

COR determines the OI for each participating MO, and invokes the validate callback of the OI. If the OIs successfully validate
their MO operation, COR invokes the apply APIality of the OI. COR also internally updates its database with these changes on the MOs. On successful
completion, COR sends a notification for the changed MOs.

If an OI fails validation, COR does not proceed with the apply. COR determines the set of OIs that have completed validation and calls 
the rollback APIs.

The following sequence diagrams describe the control flow between COR-client, COR-server, and OIs for the following two cases. 

\arg  A session is initiated by <em>comp1</em>. In the session <em><mod1,attr1></em> ,<em><moid2,attr2></em> and <em><moid3,attr3></em> are getting updated.

\arg
Both <em>comp1</em> and <em>comp2</em> are OIs for <em><moid1></em> ,<em><moid2></em>, and <em><moid2></em>.

\arg
All OIs have the same callback API name. The name of the validate, rollback, and apply callbacks are \p oiValidateFxn, \p oiRollbackFxn, and \p oiApplyFxn. 

\arg Case 1:
   - Both OIs validate <em><moid1,attr1></em>, <em><moid2,attr2></em>, and
     <em><moid3,attr3></em> successfuly.
   - Thus, the apply of these attributes is successful.

\image html  cor1.jpg
\image latex cor1.jpg "Sequence Diagram for Successful Attribute Set" width=\textwidth

\arg Case2:
   - <em>comp1</em> successfuly validates <em><moid1,attr1></em>, 
     <em><moid2,attr2></em>, and <em><moid3,attr3></em>.
   - <em>comp2</em> successfuly validates <em><moid1,attr1></em> and fails 
      validation in <em><moid2,attr2></em>. A rollback can now be called.
   - Rollback is called for <em>comp1</em> for the attributes:  
     <em><mod1,attr1></em>, <em><moid2,attr2></em>, and <em><moid3,attr3></em>.
   - Rollback is called for <em>comp2</em> for the attributes: 
     <em><moid1,attr1></em> and <em><moid2,attr2></em>.
   - No attributes are applied.

\image html  cor2.jpg
\image latex cor2.jpg "Sequence Diagram for Failed Attribute Set" width=\textwidth

\subsection sec_cor_intro_54 COR Bundle Capability

The COR bundle capability provides a mechanism to execute groups of attribute reads in an efficient manner by minimizing the number of RMD calls between 
COR client, COR server, and Object Implementer.  

A bundle is non-transactional in nature. A non-transactional bundle can contain attributes that are not successfully read. 

The bundle semantics of executing jobs is performed in four phases by the application:
-# Bundle Creation - A bundle is empty with no jobs associated when it is created. A bundle handle that identifies this bundle is returned.
-# Job Population -  In the next phase, jobs are added to the bundle. A job corresponds to an MO and list of attributes that needs to be read. 
Multiple jobs consisting of different MOs can be a part of a bundle. These jobs are queued at the COR client. Every job has a status and
a buffer descriptor. The buffer descriptor contains the value of the attribute to be \p set or \p get. The success or failure of jobs 
 execution is reflected in the status.
-# Bundle Apply - The application performs the APPLY operation synchronously when the population phase is completed. The bundle is submitted to the COR 
server that reads the value from the database or contacts the OI to obtain the value. The values are streamed back to the COR client at the end of 
this call.  
-# Bundle Finalize - This frees up the resources allocated in bundle operation.
The following sequence diagram explains the control flow between COR client, COR server and OIs for the given case. 
   - A bundle operation is initiated by <em>comp1</em>. The bundle contains
     jobs: <em><moid1, attr1></em>,<em><moid2,attr1></em>, and 
     <em><moid2,attr2></em>. <em><moid1, attr1></em>, <em><moid2,attr1> </em>
     are run-time attributes.  
   - These jobs are submitted by <em>comp1</em>.
   - COR determines the PrimaryOI for <em>moid1</em> and <em>moid2</em> as
     <em><CompOI1></em> and <em><CompOI2></em>.
   - COR obtains the values the run-time attributes of <em>CompOI1</em> and
     <em>CompOI2</em> for <em><moid1,attr1></em> and <em><moid2,attr1></em>.
   - COR obtains the Config attribute value from its database. 
   - COR returns back the value to <em>comp1</em>.

\image html  cor3.jpg
\image latex cor3.jpg "Sequence Diagram of Session Based Bulk Read" width=\textwidth

\subsection sec_cor_intro_55 COR Search Capability

COR provides the capability to retrieve objects matching a particular criterion. 
This criterion is called the filter and this is referred as search based object-walk. 
This search can be done by using the API clCorObjectWalk and following are the parameters for this search:

\arg Root MO The root from where search needs to commence. The root is specified as MOID. 
\arg Filter MO The subtree on which the search needs to be performed. This subtree is specified using wild card MOID. 
\arg Callback function - This is executed for each matched MO instance. 
\arg Cookie User provided information that will be passed to the callback function.

COR provides a mechanism to search objects based on the value of their attributes. This is 
referred as Search based attribute walk. This search is used in conjunction with 
object walk search. Object-walk returns all the MO instances that match a particular 
search criterion. Each of these instance can be searched based on a particular attribute 
and its value. This search can be done by using the API clCorObjectAttributeWalk(). This takes the following parameters.

\arg MO : The MO object on which the search has to be performed.
\arg Filter : Information about the attribute to be compared. The parameters of this filter can be seen in the description of type ClCorObjAttrWalkFilterT.
\arg Callback function : This function will be called for each of the matching attributes.
\arg Cookie : The user provided information that will be passed to the callback function.

\subsection sec_cor_intro_56 COR Event Generation and Subscription

COR generates an event for every object creation/deletion/set operation. The applications 
can subscribe for these events by using the API clCorEventSubscribe and they can narrow 
down the events of interest by specifying the following filters. 

\arg MoID - Specifies the set of objects which is of interest to the application. The MoID can be a wild card MoID.
\arg Operation - Specifies the operation(s) that is of interest to the application. 
An operation can be a combination of Object-create, Object-delete, and Object-set activities.
\arg AttributeId - This specifies the attribute of interest. An application callback 
is executed when an event matching the filter is detected. 

*/
 
//-----------------------------------------------------------

/**

\addtogroup cor_usage

\section sec_cor_usage_1 COR Object Manipulation Functions

While the necessary blue-print is created during OpenClovis ASP initialization,
COR object manipulation happens at run-time, and mainly through
through three functions:
\arg  clCorObjectCreate()
\arg  clCorObjectAttributeSet()
\arg  clCorObjectDelete()

These three functions use transactions to perform the desired object related operation(s).
After the MO class tree is created during COR initialization, you can create the MO/MSO,
set an attribute of that MO/MSO or delete an MO/MSO using these Object manipulation
functions. 

The object creation, attribute-set and object deletion can be queued in one transaction. These
operations when queued in the transaction are identified by a transaction ID. Each transaction
ID can have multiple transaction jobs operating on an MO/MSO which can be identified by
the object handle or \e moId and the \e attrPath (containment path). Once all COR object manipulations
have been performed, the clCorTxnSessionCommit() function is called. The COR client packs the transaction
jobs and makes an RMD to the server through the clCorTxnSessionCommit() function.
The transaction jobs are packed in the network format.

At the server side, the information of the components (for
which the transaction manager will initiate the transaction callbacks) is obtained from COR's route list.
This is a list of stations that need to be visited.
Also if the peer COR is up and running then it will also be a part of transaction.
After adding all the transaction jobs for the
transaction ID and its list of components, COR starts the transaction.

COR performs all the object-related operations in the commit phase of the transaction.
For a given transaction ID, all the transaction jobs are walked and specific operations are performed.
The clCorTxnJobWalk() function is called with a callback which performs the necessary operations based on the
\e opType obtained from each transaction job.

Sample Code for the Object Create/Set/Delete using single as well as complex transaction.

\code
// Object Manipulation APIs that will Create/Set/Delete an MO.
ClRcT cor_test_object_manipulation ()
{
  ClCorServiceIdT svcId;
  ClCorMOIdPtrT moId = NULL;
  ClCorObjectHandleT handle;
  ClRcT rc = CL_OK;
  
  // MoId Allocation.
  clCorMoIdAlloc(&moId);
  // MoId Append . \0x100:1
  clCorMoIdAppend(moId, 0x100, 1);

  // Simple transaction for object-create
  clCorObjectCreate(CL_COR_SIMPLE_TXN, moId, &handle);

  // Simple transaction for object-delete
  clCorObjectDelete(CL_COR_SIMPLE_TXN, handle);

  // Beginning a complex transaction. Initializing tid to zero,
  // which will be passed as first parameter to all the object
  // manipulation calls until the clCorTxnSessionCommit()
  // function is called.
  ClCorTxnSessionIdT tid = 0;
  clCorMoIdInitialize(moId);
  clCorMoIdAppend(moId, 0x100, 2);

  // MO creation queued in transaction.
  clCorObjectCreate(&tid, moId, &handle);

  clCorMoIdAppend(moId, 0x200, 1);
  // MO Creation queued in transaction.
  clCorObjectCreate(&tid, moId, &handle);

  clCorMoIdAppend(moId, 0x300, 1);

  // MO Creation queued in transaction.
  clCorObjectCreate(&tid, moId, &handle);

  clCorMoIdSet(moId, 3, 0x300, 2);
  // MO creation queued in transaction.
  clCorObjectCreate(&tid, moId, &handle);

  // MSO creation queued in transaction.
  clCorMoIdServiceSet(moId, CL_COR_SVC_ID_DUMMY_MANAGEMENT);
  clCorObjectCreate(&tid, moId, &handle);

  // Committing the complex transaction with the created MOs and MSOs.
  clCorTxnSessionCommit(tid);

  clCorMoIdInitialize(moId);
  clCorObjectHandleToMoIdGet(handle, moId, &serviceId);

  // TC2 : Multiple Sets
  ClUint16T  value16 = 0;
  ClUint32T  value32 = 0;
  ClUint64T  value64 = 0;

  ClUint32T  size16  = sizeof(ClUint16T);
  ClUint32T  size32  = sizeof(ClUint32T);
  ClUint32T  size64  = sizeof(ClUint64T);

  ClCorAttrPathPtrT pAttrPath;
  clCorAttrPathAlloc(&pAttrPath);

  value64 = 1;
  // Object Attribute set queued in transaction using simple transaction.
  rc = clCorObjectAttributeSet(CL_COR_SIMPLE_TXN, handle, NULL, 
                           0x301, -1, (void *)&value64, size64);

  value64 = 1;
  // About to begin one more complex transaction, hence setting 
  // the transaction ID as zero.
  tid = 0;
  // Object Attribute set queued in transaction.
  rc = clCorObjectAttributeSet(&tid, handle, NULL, 0x301, -1, 
                              (void *)&value64, size64);


  clCorAttrPathAppend(pAttrPath, 0x303, 0);
  value32 = 3;
  // Object Attribute set with containment path queued in transaction.
  clCorObjectAttributeSet(&tid, handle, pAttrPath, 0x201, -1, 
                          (void *)&value32, size32);

  // moId creating here is \0x100:2\0x200:1\0x300:1 for deletion.
  rc = clCorMoIdInitialize(moId);
  rc = clCorMoIdAppend(moId, 0x100, 2);
  rc = clCorMoIdAppend(moId, 0x200, 1);
  rc = clCorMoIdAppend(moId, 0x300, 1);
  rc = clCorObjectHandleGet(moId, &handle, &svcId);
  // Object-Delete function queued in transaction.
  rc = clCorObjectDelete(&tid, handle);
  // Committing a complex transaction having two attribute-set 
  // operations and one object-delete operation.
  rc = clCorTxnSessionCommit(tid);

  clCorMoIdFree(moId);
  clCorAttrPathFree(pAttrPath);
  return rc;
}
\endcode

\section cor_usage_2 COR Transaction APIs 
 
COR Transaction APIs are used by components that participate in a transaction.
A component participating in a transaction obtains a transaction handle ( \e txnHandle) through
the callback functions for validate,commit and rollback which can be used in the COR transaction APIs to validate the transaction.
A transaction can contain  various COR operations related to one or more Managed Objects (MO). The operations related to an
MO are considered as one transaction job. Within a transaction job there can be multiple COR operations which can be obtained by
using the COR-Transaction APIs.
 
A transaction can consist of one or more object-create/set/delete operations or a combination of these operations as well.
COR creates one COR-Transaction ID for a combination of MOID and \e attrpath. For a given COR-Transaction ID, COR creates one COR-Job ID for each
\e attributeId. (that is being set for a particular MOID + attrPath). These jobs are linked together in the COR-job-list. 
 
Following steps are performed to obtain COR-job-list and to perform a walk operation.
 
-# When a transaction validate/commit/rollback is called, the COR-job-list ID can be obtained from the COR-transaction ID via
   the API  clCorTxnJobHandleToCorTxnIdGet(). This function returns \e ClCorTxnIdT.           
-# clCorTxnJobWalk() function performs the walk operation corresponding to above COR-transaction ID. This function invokes a callback for every
   COR-job in the COR-job-list. 
-# The callback function takes in COR-Transaction ID and COR-job ID as parameters. COR provides a function to obtain information about the
   \e MOID if it is a create/delete operation. COR provides an API to obtain information about the attribute (\e MOID,\e attrpath.index, \e size,
   \e value) for a set operation, based on COR-Transaction ID and COR-job ID. For instance,  the API  clCorTxnJobSetParamsGet() 
   returns \e attrId, \e index, \e value and size corresponding to a COR-Transaction ID and COR-job ID. 

A sample validate function:
\code 
ClRcT
clTxnTestValidate( CL_IN     ClTxnTransactionHandleT txnHandle,
                 CL_IN       ClTxnJobDefnHandleT     jobDefn,
                 CL_IN       ClUint32T               jobDefnSize,
                 CL_INOUT    ClTxnAgentCookieT* pCookie )
{
  ClRcT           rc  = CL_OK;
  ClCorTxnIdT     corTxnId;

  CL_FUNC_ENTER();

  //  Obtain the COR-Transaction ID 
  rc = clCorTxnJobHandleToCorTxnIdGet(jobDefn, jobDefnSize, &corTxnId);

  // Perform a walk on all the COR-Jobs associated with this 
  // COR-Transaction ID.
  rc = clCorTxnJobWalk(corTxnId, clTxnTestJobWalk, 
                      (void *)CL_PROV_VALIDATE_STATE );

  //  Free the space corTxnId.
  clCorTxnIdTxnFree(corTxnId);

  CL_FUNC_EXIT();
  return rc;
}

ClRcT   clTxnTestJobWalk( ClCorTxnIdT     corTxnId,
                        ClCorTxnJobIdT  jobId,
                        void           *arg )
{
  ClRcT               rc          = CL_OK;
  ClCorMOIdT          moId;
  ClCorOpsT           corOp       = CL_COR_OP_RESERVED;
  ClCorAttrTypeT      attrType    = 0; 
  ClCorAttrIdT        attrId      = 0;    
  void*               pValue      = NULL;
  ClUint32T           valueSize   = 0;
  ClInt32T            index       = 0;
  ClCorAttrPathPtrT   attrPath    = NULL;


  //  Obtain the MOID corresponding to COR-Transaction ID
  rc = clCorTxnJobMoIdGet(corTxnId, &moId);
  // Obtain the Operation i.e. creation/deletion/Set associated 
  // with COR-Transaction and COR-Job ID.
  rc = clCorTxnJobOperationGet(corTxnId, jobId, &corOp);
  switch ( ( ClUint32T )corOp )
  {
    case CL_COR_OP_CREATE:
      break ;
    case CL_COR_OP_SET:

      // Obtain the AttrPath from the COR-Transaction ID and COR-Job ID
      rc = clCorTxnJobAttrPathGet(corTxnId, jobId, &attrPath);

      // Obtain the attrId,index, value, size  from the COR-Transaction 
      // ID and COR-Job ID
      rc = clCorTxnJobSetParamsGet(corTxnId, jobId, &attrId, &index, 
                                   &pValue, &valueSize);
      break ;
      
    case CL_COR_OP_DELETE:
      break ;
 }
  return CL_OK;
}
\endcode

\section cor_usage_3 COR Bundle Get

The COR bundle feature is used to perform get operation on multiple attributes in a single request
to COR. The bundle-get can take list of attributes belonging to the same or different MO. These 
attributes can either be configuration or the runtime attributes. The user need to add all the get 
requests in the same bundle which will be send to COR server as a single request. There it will 
populate the value for configuration attributes and for the value of runtime attributes it will get it 
from the primary OI. After getting the response the OIs it will aggregates the information and send 
the response.
    Here is a sample code to demonstrate both the synchronous and asynchronous version of bundle get.

\code 
ClUint32T val_1 = 0, val_2 = 0, val_3 = 0, val_4  = 0;
ClCorJobStatusT  jobStatus_1 = 0, jobStatus_2 = 0, 
                 jobStatus_3 = 0, jobStatus_4 = 0;

//The helper function to display the information obtained from server.
void clCorTestDataDisplay()
{
    if(jobStatus_1 != CL_OK)
        clOsalPrintf("The Value for the attribute 0x201 is [%d] \n", val_1);
    else
        clOsalPrintf("The get on attribute 0x201 failed with error [0x%x] \n", 
                      jobStatus_1);
      
    if(jobStatus_2 != CL_OK)
        clOsalPrintf("The Value for the attribute 0x202 is [%d] \n", val_2);
    else
        clOsalPrintf("The get on attribute 0x201 failed with error [0x%x] \n", 
                      jobStatus_2);

    if(jobStatus_3 != CL_OK)
        clOsalPrintf("The Value for the attribute 0x205 is [%d] \n", val_3);
    else
        clOsalPrintf("The get on attribute 0x203 failed with error [0x%x] \n", 
                      jobStatus_3);

    if(jobStatus_4 != CL_OK)
        clOsalPrintf("The Value for the attribute 0x302 is [%d] \n", val_4);
    else
        clOsalPrintf("The get on attribute 0x301 failed with error [0x%x] \n",
                      jobStatus_4);
}

 
 // The following code example assumes that the MO class tree and the 
 // object tree exists in COR.
ClRcT clCorTestPrepareBundle(ClCorBundleHandlePtrT pBundleHandle)
{
    ClRcT                   rc           = CL_OK;
    ClCorBundleConfigT      bundleConfig = {CL_COR_BUNDLE_NON_TRANSACTIONAL};
    ClCorAttrValueDescriptorListT attrList = {0};
    ClCorAttrValueDescriptorT     attrInfo[3] = {{0}}, attrInfo1 = {0};
    ClCorMOIdT                    moId;
    ClCorObjectHandleT            objH = {{0}};

    // Initializing the MOID.
    rc = clCorMoIdInitialize(&moId);   

    // Appending the MOID, /0x100:0
    rc = clCorMoIdAppend(&moId, 0x100, 0);
     
    // Appending the MOID, /0x100:0/0x200:3
    rc = clCorMoIdAppend(&moId, 0x200, 3);
     
    // Setting the service Id of the provisioning, we want to perform 
    // bundle get on provisioning attributes.
    rc = clCorMoIdServiceSet(&moId, CL_COR_SVC_ID_PROVISIONING_MANAGEMENT);
      
     // Get the object handle from the MOID obtained after appending 
     // the required classIds and instanceIds.
     rc = clCorObjectHandleGet(&moId, &objH);
     if (CL_OK != rc)  {
        // Handle the error appropriately.
        return rc;
     }
      
     // Initializing the bundle. This will give the bundle handle. 
     // The bundle here is a non-transactional bundle. 
     // The transactional bundle is not supported in this release.
     rc = clCorBundleInitialize(pBundleHandle, &bundleConfig);
     if(CL_OK != rc)
     {
         clLogError("COR", "GET", 
                    "Failed to initialize the bundle. rc[0x%x]", rc);
         return rc;
     }
 
     // Attribute Path is not support in this release. 
     // This should be NULL as of now.
     attrInfo[0].pAttrPath = NULL; 

     // First Attribute Id on which the get has to be done. 
     // This is a simple attribute of 32 bit.
     attrInfo[0].attrId = 0x201;

     // Index is the array index whose value is needed. 
     // It should be -1 for simple attribute.
     attrInfo[0].index = -1;

     // pointer to the value. This is made as global to be accessed 
     // in the bundle callback for async bundle.
     attrInfo[0].bufferPtr = &val_1;

     // Size of the attribute. This should be exactly equal to the 
     // actaul size of attribute.
     attrInfo[0].bufferSize = sizeof(ClUint32T);

     // This is the status of the job. This will be populated once 
     // the response is obtained from server.
     attrInfo[0].pJobStatus = &jobStatus_1;
 
     attrInfo[1].pAttrPath = NULL; 
     // This is an array attribute.
     attrInfo[1].attrId = 0x202;
     // The index is given as 3 to get the index 3 of the array.
     attrInfo[1].index = 3;
     attrInfo[1].bufferPtr = &val_2;
     attrInfo[1].bufferSize = sizeof(ClUint32T);
     attrInfo[1].pJobStatus = &jobStatus_2;

     attrInfo[2].pAttrPath = NULL; 
     // This is an array attribute.
     attrInfo[2].attrId = 0x205;
     // The index is given as 3 to get the index 3 of the array.
     attrInfo[2].index = -1;
     attrInfo[2].bufferPtr = &val_3;
     attrInfo[2].bufferSize = sizeof(ClUint32T);
     attrInfo[2].pJobStatus = &jobStatus_3;

     attrList.numOfDescriptor = 3;
     attrList.pAttrDescriptor = attrInfo;
     
     rc = clCorBundleObjectGet(*pBundleHandle, &this, &attrList);
     if(CL_OK != rc)
     {
         clLogError("COR", "GET", 
                    "Failed to add the job in the bundle. rc[0x%x]", 
                     rc);
         clCorBundleFinalize(*pBundleFinalize);
         goto handleError;
     }
 
     // Appending the MOID, /0x100:0/0x200:3/0x300:1
     rc = clCorMoIdAppend(&moId, 0x300, 1);
     if (CL_OK != rc)  {
        // Handle the error appropriately.
        clCorBundleFinalize(*pBundleFinalize);
        goto handleError;
     }
    
     attrInfo1.pAttrPath = NULL; 
     // This is an array attribute.
     attrInfo1.attrId = 0x302;
     // The index is given as 3 to get the index 3 of the array.
     attrInfo1.index = -1;
     attrInfo1.bufferPtr = &val_4;
     attrInfo1.bufferSize = sizeof(ClUint32T);
     attrInfo1.pJobStatus = &jobStatus_4;


     // Get the object handle from the MOID obtained after 
     // appending the required classIds and instanceIds.
     rc = clCorObjectHandleGet(&moId, &objH);
     if (CL_OK != rc)  
     {
        clCorBundleFinalize(*pBundleFinalize);
        goto handleError;
     }

     attrList.numOfDescriptor = 1;
     attrList.pAttrDescriptor = &attrInfo1;
     rc = clCorBundleObjectGet(*pBundleHandle, &this, &attrList);
     if(CL_OK != rc)
     {
         jobStatus = rc;
         clLogError("COR", "GET", 
                    "Failed to add the job in the bundle. rc[0x%x]", 
                     rc);
         clCorBundleFinalize(*pBundleFinalize);
         goto handleError;
     }

handleError:
    return rc;
}

ClRcT _clCorTestBundleCallback (ClCorBundleHandleT bundleHandle, 
                                ClPtrT cookie)
{
    ClRcT rc = CL_OK;

    clCorTestDataDisplay();
     
    // For the async bundle the finalize can happen in the callback 
    // if the same bundle is not needed anymore. Otherwise it can be 
    // done while component terminate.
    rc = clCorBundleFinalize(bundleHandle);
    if(CL_OK != rc)
    {
        clLogError("COR", "GET", 
                   "Failed while finalizing the bundle. rc[0x%x]", 
                    rc);
        return rc;
    }
    return rc;
}

ClRcT _clCorTestBundleGetAsync()
{
    ClRcT rc    = CL_OK;
    ClCorBundleHandleT bundleHandle = 0; 

    rc = clCorTestPrepareBundle(&bundleHandle);
    if (CL_OK != rc) {
        clLogError("COR", "GET", 
                   "Failed while preparing the bundle for get. rc[0x%x]",
                    rc);
        return rc;
    }
 
    //This is asynchronous version of bundle apply. This will register 
    //the callback which will be once the reponse for the server arrives 
    //after filling the data. 
    rc = clCorBundleApplyAsync(bundleHandle, _clCorTestBundleCallback, NULL);
    if(CL_OK != rc)
    {
        clLogError("COR", "GET", 
                   "Failed while applying the bundle. rc[0x%x]",
                    rc);
        goto handleError;
    }
     
    // Function to use the information returned by the bundle get api.
    _clCorTestDataDisplay()

handleError:
    // Finalize the bundle in case of an error while applying the bundle.
    rc = clCorBundleFinalize(bundleHandle);
    if(CL_OK != rc)
    {
        clLogError("COR", "GET", 
                   "Failed while finalizing the bundle. rc[0x%x]", 
                    rc);
        return rc;
    }
 
    CL_FUNC_EXIT();
    return rc;
}

ClRcT _clCorTestBundleGetSync()
{
    ClRcT rc    = CL_OK;
    ClCorBundleHandleT bundleHandle;

    rc = clCorTestPrepareBundle(&bundleHandle);
    if (CL_OK != rc) 
    {
        clLogError("COR", "GET", 
                   "Failed while preparing the bundle for get. rc[0x%x]", 
                    rc);
        return rc;
    }
  
    //Synchronous version of bundle apply. This will wait here till 
    //the response from the server arrives.
    rc = clCorBundleApply(bundleHandle);
    if(CL_OK != rc)
    {
        clLogError("COR", "GET", 
                   "Failed while applying the bundle. rc[0x%x]",
                    rc);
        goto handleError;
    }
     
    // Function to use the information returned by the bundle get api.
    _clCorTestDataDisplay()

handleError:
 
    rc = clCorBundleFinalize(bundleHandle);
    if(CL_OK != rc)
    {
        clLogError("COR", "GET", 
                   "Failed while finalizing the bundle. rc[0x%x]", 
                    rc);
        return rc;
    }
 
    CL_FUNC_EXIT();
    return rc;
}
\endcode

\section cor_usage_4 Cor Create and Set

The clCorObjectCreateAndSet() is an additional function to the COR session capability. This API should
be used to create the objects of the MO-Class which has intialized attributes modeled. The initialized
attributes are key attribute which should be provided while creating an instance of the class. Inorder
to create instance for this class, the API clCorObjectCreateAndSet() should be used which allows providing
the attribute list and their values while creating the object. This API can be used to create an object 
without any key attributes as well. As this function is part of COR's session capability, so all the 
features of session are applicable to this API as well.
Here is the sample code which shows the usage of this API.

\code
ClRcT _clCorTestCreateAndSetUsage()
{
    ClRcT rc = CL_OK; 
    ClCorObjectHandleT objH = {{0}}, objH1 = {{0}};
    ClCorAttributeValueT attrDesc[2] = {{0}};
    ClCorAttributeValueListT attrList = {0};
    ClCorMOIdT  moId ;
    ClCorTxnSessionIdT tid = 0;
    ClUint32T val_1 = 10, val_2 = 20;

    //Initializing the MOID 
    rc = clCorMoIdInitialize(&moId);
    
    // Appending the class and intance to MOId. 
    // The MOId has become /0x100:0     
    rc = clCorMoIdAppend(&moId, 0x100, 0); 

    // This class doesn't have any initialized attributes. 
    // So using the create and set api here.
    // This creation is done is a simple session manner.
    rc = clCorObjectCreateAndSet(CL_COR_TXN_MODE_SIMPLE, 
                                 &moId, NULL, &objH); 
   
    // The MOID now becomes /0x100:0/0x200:1    
    rc = clCorMoIdAppend(&moId, 0x200, 1);    

    // The creation of object can be done in a complex cor-transaction. 
    // This will create the transaction and add the first job in it. 
    rc = clCorObjectCreateAndSet(&tid, &moId, NULL, &objH);
     
    // The Moid now is /0x100:0/0x200:2    
    rc = clCorMoIdInstanceSet(&moId, 0x200, 2);    

    // This will add the second job to the transaction.    
    rc = clCorObjectCreateAndSet(&tid, &moId, NULL, &objH1);
 
    // Committing the complex transaction.    
    rc = clCorTxnSessionCommit(tid);
    if( CL_OK != rc)
    {
         // Handle the failure. Can get the failed jobs using 
         // clCorTxnFailedJobGet()    
         clCorTxnSessionFinalize(tid);    
          return rc;
    }    

    //The MOID is now /0x100:0/0x200:2/0x300:2.
    rc = clCorMoIdAppend(&moId, 0x300, 2);    

    // The class 0x300 has two initialized attributes: 0x301, 0x302. 
    // So filling the details for supplying it to create and set api. 
    attrDesc[0].pAttrPath = NULL;
    attrDesc[0].attrId = 0x301;
    attrDesc[0].index = -1;
    attrDesc[0].bufferPtr = &val_1;
    attrDesc[0].bufferSize = sizeof(ClUint32T);
   
    attrDesc[1].pAttrPath = NULL;
    attrDesc[1].attrId = 0x302;
    attrDesc[1].index = -1;
    attrDesc[1].bufferPtr = &val_2;
    attrDesc[1].bufferSize = sizeof(ClUint32T);

    attrList.numOfDescriptor = 2;
    attrList.pAttrDescriptor = attrInfo;
  
    // Calling create and set API for creating the object and setting 
    // the key attributes.    
    rc = clCorObjectCreateAndSet(CL_COR_TXN_MODE_SIMPLE, &moId, 
                                 &attrList, &objH);   
    if(CL_OK != rc) {
      //Handle the error appropriately.    
      return rc;    
    }    
    return rc;
}    
\endcode

*/

//-----------------------------------------------------------

/**
 *  
 *  \addtogroup cor_glossary
 *  \brief Glossary of COR related Terms.
 *  
 *  \par Bundle 
 *   A bundle is a group of jobs. A bundle enables efficient communication between 
 *   the COR client, COR server, and OI by limiting the number of RMD calls between 
 *   them. A bundle can either be operated as a transactional or a non transactional
 *   bundle. COR service ensures that all jobs in a transactional bundle are either 
 *   successful or unsuccessful (failures). A non transactional bundle does not 
 *   contain such restrictions and can contain unsuccessfully executed jobs due 
 *   to error conditions.
 *
 *  \par Class Tree
 *   The classes and the containment relationship between these resources 
 *   classes form a Class Tree. The above diagram is, therefore, a Class Tree representation.
 * 
 *  \par Data Manager (DM)
 *   Associated with an MO and MSO is a DM object. An MO and MSO each have an associated 
 *   DM object that contains the attributes. The DM object is referred via a \e ClasssId and \e InstanceId pair.
 *   The \e classId acts as a key to obtain respective DM class. The instance ID, serves as an index to 
 *   access the instance of the object.
 *
 *  \par Job
 *   A job is an entity that specifies a CREATE, DELETE, SET, or GET operation on 
 *   a MO. A job that specifies MO creation is called Create-Job. A job that
 *   specifies MO deletion is called Delete-Job. A job that represents a SET 
 *   operation on the MO is called Set-Job and a job that represents a GET operation
 *   is called a Get-Job. A Get-Job has an MO and a list of attributes that need 
 *   to be read. 
 * 
 *  \par Managed Object
 *   An instantiation of these resource classes
 *   is called a Managed Object (MO) and it represents the actual Resource Instance present in the
 *   system and the attributes associated with it. 
 * 
 *  \par Managed Object Tree
 *   Relationship between these resource instances is termed as
 *   MO tree (Managed Object tree).  A Managed Object is always associated with a resource instance. 
 *  
 *  \par Managed Service Object (MSO)
 *   The objects corresponding to Provisioning and Alarm 
 *   attributes are termed as MSOs. The MSOs corresponding to an MO are identified by an \e MOID (MO)
 *   and a Service ID, where \e serviceID identifies the type of attribute. (Alarm or provisioning) 
 *  
 *  \par MOID
 *   Each Resource Instance is identified with a unique path called \e MOID. \e MOID 
 *   depicts the containment relationship of a resource. For example, the \e MOID  
 *   \e Chassis:0/GigeBlade:1/GigeNode:2  represents the resource \e GigeNode:2 that is contained in the 
 *   zeroth instance of Chassis and the first instance of GigeBlade. 
 *   
 *  \par Object Implementer
 *   An ASP service or component that implements an object.
 * 
 *  \par Provisioning and Alarm MSO
 *   Associated with each Managed object are 
 *   'Provision-able Attributes', 'Alarm Attributes' and 'Private Attributes'. Each of these attributes
 *   is represented via an object of the corresponding kind. The object associated with 
 *   Provision attributes is called PROVISION MSO, and the object associated with Alarm attributes 
 *   is called ALARM MSO.
 *   
 *  \par Runtime Attribute
 *   Runtime attributes are also called transient attributes and are read-only. 
 *   They are owned by the Object Implementors. To read a runtime attribute the OI 
 *   needs to be contacted. The run-time objects and attributes form the descriptive
 *   part of the Information Model.}
 * 
 *  \par Station List 
 *   COR provides a mechanism through which components can participate in 
 *   creation/deletion/attribute  change associated with a MO/MSO. For each MO/MSO, COR maintains a 
 *   list of components that it needs to visit  when an operation is performed. These components are 
 *   termed as stations and the list of componets is termed as station List.
 * 
 *  \par Transaction
 *   COR implements Atomicity of operation via a two-phase transaction. As a part of a single
 *   transaction session, clients can supply multiple MO/MSO operations. These operations will 
 *   be executed atomically and efficiently (as multiple jobs are performed via one API call to COR server).
 *
 *
 */
