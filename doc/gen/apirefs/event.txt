/**
 *  \defgroup event Event Service
 *  \brief OpenClovis Event Service facilitates via a publish or subscribe a
 *  multipoint-to-multipoint communication mechanism that is based on the 
 *  concept of event channels, where a publisher communicates asynchronously 
 *  through events with one or more subscribers over an event channel.
 */
 
/**
 *  \defgroup event_intro Functional Description
 *  \brief Description of the Event Management.
 *  \ingroup event
 * 
 */

/**
 *  \defgroup event_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup event
 * 
 */
 
/**
 *  \defgroup event_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup event
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting Event Service 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_EVENTS "Event Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_event
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */ 

/**
 *  \defgroup event_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup event
 */

/**
 *  \defgroup event_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup event
 */
 
//-----------------------------------------------------------
//-----------------------------------------------------------

/**

\addtogroup event_intro
\brief Description of the Event Management.

The OpenClovis Event Service is a communication mechanism based on the concept 
of event channels. It is a publish and/or subscribe mechanism where a 
publisher can communicate with one or more subscribers asynchronously by 
publishing events over an event channel. The publishers and subscribers can be
any component residing anywhere in the cluster.

An Event has a standard header and zero or more bytes of publisher event data. 
Publishers and Subscribers can communicate over multiple event channels. 
Multiple publishers and multiple subscribers can communicate over a single 
event channel. Subscribers are anonymous, which means that they can join and 
leave an event channel at any time without involving the publisher(s). 
An Event publisher can also be an Event subscriber. 

The Event Service function does not impose a specific layout or format for the 
published event data. Publishers and subscribers on an event channel must 
agree on the structure of the data for events published on that event channel. 
They can use data marshalling, if support for heterogeneity is required. 
Conventions on the structure of the event data can vary from one event channel 
to another. 

\section sec_event_intro_1 Usage Model

A component can subscribe to receive events on an event channel using the 
clEventSubscribe() function. The Event Service delivers events to a subscribing
component using the clEvtEventDeliverCallback() function of that component. 
To stop receiving events for which it has registered, a subscriber can invoke 
the clEventUnsubscribe() function. If a component terminates abnormally, 
the Event Service closes all of its open event channels. 

\section sec_event_intro_2 Service Description

\subsection sec_event_intro_21 Events

An event consists of a standard set of event attributes (event header) and zero
or more bytes of event data. An event header is allocated using the 
clEventAllocate() function and is released using the clEventFree() function. 
The clEventAllocate() function returns a handle that can be used in subsequent 
invocations of the Event Service functions. The event attributes are written 
and read using {{SET}} and {{GET}} functions of the Event Service function. 
These attributes cannot be read and written directly. An event is published 
using the clEventPublish() function. The parameters to be specified for this 
function are event handle, additional information (optional), and event data 
contained in a data buffer. Thus, a published event consists of the event header
that contains the set of attributes and additional information (optional) 
contained in the data buffer. 

\subsection sec_event_intro_22 Event Channels

An event channel enables multiple publishers to communicate with multiple 
subscribers. It is global to a cluster and is identified by a unique name. 
To use the Event Service, a component must open an event channel using the 
clEventChannelOpen() or clEventChannelOpenAsync() function. The event channel 
is created, if it does not exist. A component can open an event channel to 
publish events and subscribe to receive events. Publishers can also act as 
subscribers on the same event channel. Event channels can be deleted using 
the clEventChannelUnlink() function. When an event is allocated for an event 
channel using the clEventAllocate() call, it can be published several times 
on the same event channel, by changing its attributes prior to each publication.
 
The OpenClovis Event Channel has the following features:

- <b>Best effort delivery</b>: The Event Service provides best effort delivery of 
  events to an anonymous set of subscribers. A published event can be lost or
  it can be delivered to a subset of the subscribers. Some subscribers receive 
  the event while others do not. For example, there is no guarantee that an
  event is delivered to all existing subscribers, if the publisher fails while 
  publishing the event. A subscriber may lose events, if the subscriber node
  is overwhelmed with events.

- <b>At most once delivery</b>: The Event Service does not deliver the same event 
  for a subscription of a subscriber multiple times.

- <b>Event priority</b>: Events are published with a certain priority. High 
  priority events are delivered ahead of low priority events. 

- <b>Event ordering</b>: For a given priority, events are received by subscribers 
  in the order in which the publisher published the events.

- <b>Retention time</b>: Events published with a non-zero retention period are 
  retained for a specified duration. This duration can be provided while 
  allocating an Event. This provides the opportunity for new subscribers to 
  obtain events that were published before their subscription to the event 
  channel. Processes can use the Event Service functions to remove events before 
  the retention time expires. 

- <b>Payload structure</b>: The Event Service function does not impose a specific 
  layout or format for the published event data or payload. Publishers and 
  subscribers on an event channel must agree on the structure of the data for 
  events published on that event channel and can use data marshalling support 
  for heterogeneity is required. Conventions on the structure of the event data 
  can vary from one event channel to another. 

- <b>Event Filtering</b>: The standard set of event attributes include an array of 
  event patterns. The values of these patterns are set by the event publisher 
  and are used to organize events into various categories. All users (publishers 
  and subscribers) of an event channel must share the same conventions regarding
  the number of patterns being used, their ordering, contents, and meaning. 
  For example, an event channel, used to notify changes made to a relational 
  database, can define events where only three patterns are used as follows: 
    -# The first pattern contains the name of the database being modified. 
    -# The second pattern contains the name of the table being modified. 
    -# The third pattern contains the primary key of the record being modified.
    .
  The event data can be used to provide a description of the modified fields 
  and the old/new values. Event patterns play an important role in the Event 
  Service, as they are the basis for filtering the events that must be 
  delivered to a particular subscriber. When subscribing on an event channel, 
  a component must specify the filters that need to be applied on published 
  events. Only events which satisfy the filters are delivered to the component. 
  Using the previous example of the database notifications published on an 
  event channel, a subscriber can provide a filter array indicating: 
     -# The name of a database required by the subscriber. 
     -# The name of a table required by the subscriber. 
     -# No filter for the primary key. If a filter is not specified, the 
        component will receive all notification events related to the 
        specified table, in the specified database for any primary key. 
     .

*/
 
//-----------------------------------------------------------

/**

\addtogroup event_usage
\brief Code Examples.

The Event Service invovles communincation between pulishers and subscribers
and this is accomplished over an event channel. Here we illustrate how a
typical subscriber and publisher would look like emphasizing on the various
API available with the Event Service.

The example is based on the event generation on a water mark hit in the
Execution Object(EO). The event generated has attributes like the EO name,
Library ID, Water Mark ID, Water Mark Type and Water Mark Value. The
publisher will publish with some specific values for each of these event
attributes. A subscriber  can choose the particular attributes it is
interested in say a particular  EO with the name "COR". In our example we
have take the NULL filter which ensures delivery of any event generated on
water mark hit irrespective of the attributes to the subscriber.
 
<b>Common defintions:</b>
The filter/pattern information should be shared between the subscriber and
publisher. These are passed as byte streams to Event Service and it is the
responsibility of application to ensure these are endian neurtal by using
marshalling (XDR) or some such mechanism. This would make it possible to
filter events across different platforms.

\code
typedef enum{
    CL_EO_LIB_ID_OSAL,
    CL_EO_LIB_ID_MEM,
    CL_EO_LIB_ID_HEAP,
    CL_EO_LIB_ID_BUFFER,
    CL_EO_LIB_ID_TIMER,
    CL_EO_LIB_ID_IOC,
    CL_EO_LIB_ID_RMD,
    CL_EO_LIB_ID_EO,
    CL_EO_LIB_ID_RES,
    CL_EO_LIB_ID_POOL  =  CL_EO_LIB_ID_RES,
    CL_EO_LIB_ID_CPM,
    CL_EO_LIB_ID_MAX 
} ClEoLibIdT;
\endcode

<b>Subscriber Side:</b>

Typical Event Service would provide with three different handles. The user
may want to group them up as below:

\code
typedef struct ClSubsEventInfo
{
    ClEventInitHandleT initHandle;
    ClEventChannelHandleT channelHandle;
    ClEventHandleT eventHandle;
} ClSubsEventInfoT; 

static ClSubsEventInfoT gSubsEventInfo;
\endcode

If the application chooses to open the channel asynchronously then it
needs to register a callback that shall be invoked on the creation of the
channel. A typical callback would contain the subcription calls or event
publish related calls. This has been illustrated in the publisher later.

\code
void clSubsAsyncChannelOpenCb(ClInvocationT invocation,
        ClEventChannelHandleT channelHandle, ClRcT retCode)
{
    ClRcT rc = CL_OK;

    clOsalPrintf("*******************************************************\n");
    clOsalPrintf("************* Async Channel Open Callback *************\n");
    clOsalPrintf("*******************************************************\n");
    clOsalPrintf("    Invocation        : %#X\n", invocation);
    clOsalPrintf("    Channel Handle    : %p\n", (ClPtrT)channelHandle);
    clOsalPrintf("    API Return Code   : %#X\n", retCode);
    clOsalPrintf("*******************************************************\n");

    /* Check if the Channel Open Asyn was successful */
    if(CL_OK != retCode)
    {
        goto failure;
    }

    rc = clEventSubscribe(channelHandle, 
         CL_EVENT_DEFAULT_SUBS_FILTER, UNIQUE_SUBSCRIPTION_ID, 
         "User Specified Argument (cookie) for the event delivery callback");
    if(CL_OK != rc)
    {
        goto failure;
    }

failure:
    return;
}
\endcode

The subscriber is required to register a callback during the Event
Library initialize which is to invoked when an event is delivered. For our
example the callback is as follows:

\code
static void clSubEoEventWaterMarkCb( ClEventSubscriptionIdT subscriptionId,
        ClEventHandleT eventHandle, ClSizeT eventDataSize )
{
    ClRcT rc = CL_OK;

    ClEventPriorityT priority = 0;
    ClTimeT retentionTime = 0;
    ClNameT publisherName = { 0 };
    ClEventIdT eventId = 0;
    ClEventPatternArrayT patternArray = { 0 };
    ClTimeT publishTime = 0;
    ClPtrT pCookie = NULL;

    ClPtrT pEventData = NULL;

    ClUint8T *pEventPayload = NULL;

    /* Allocate memory for the event payload.*/
    pEventData = clHeapAllocate(eventDataSize);
    if (pEventData == NULL)
    {
        clOsalPrintf("Allocation for event data failed. rc[%#X]\n", rc);
        goto failure;
    }

    /* Fetch the event payload. */
    rc = clEventDataGet (eventHandle, pEventData,  &eventDataSize);
    if (rc != CL_OK)
    {
        clOsalPrintf("Event Data Get failed. rc[%#X]\n", rc);
        goto failure;
    }

    pEventPayload = pEventData;

    /* Fetch the cookie specified during subscribe. */
    rc = clEventCookieGet(eventHandle, &pCookie);
    if (rc != CL_OK)
    {
        clOsalPrintf("Event Cookie Get failed. rc[%#X]\n", rc);
        goto failure;
    }

    /* Fetch the attributes of the event.*/
    rc = clEventAttributesGet(eventHandle, &patternArray, &priority,
                              &retentionTime, &publisherName, 
                              &publishTime, &eventId);
    if (rc != CL_OK)
    {
        clOsalPrintf("Event Attributes Get failed. rc[%#X]\n", rc);
        goto failure;
    }

    /* Free the allocated Event */
    rc = clEventFree(eventHandle);

    clOsalPrintf("-------------------------------------------------------\n");
    clOsalPrintf("!!!!!!!!!!!!!!! Event Delivery Callback !!!!!!!!!!!!!!!\n");
    clOsalPrintf("-------------------------------------------------------\n");
    clOsalPrintf("             Subscription ID   : %#X\n", subscriptionId);
    clOsalPrintf("             Event Priority    : %#X\n", priority);
    clOsalPrintf("             Retention Time    : 0x%llX\n",
                 retentionTime);
    clOsalPrintf("             Publisher Name    : %.*s\n",
                 publisherName.length, publisherName.value);
    clOsalPrintf("             EventID           : %#X\n", eventId);
    clOsalPrintf("             Event Payload     : %s\n", pEventPayload);
    clOsalPrintf("             Event Cookie      : %s\n", (ClUint8T*)pCookie);

    /*
     Display the Water Mark Details and Free the patterns.
     Note that each pattern needs to be freed and then the
     pattern array in that order.
    */

    clOsalPrintf("             EO Name           : %.*s\n",
                (ClInt32T)patternArray.pPatterns[0].patternSize, 
                (ClCharT *)patternArray.pPatterns[0].pPattern);
    clHeapFree(patternArray.pPatterns[0].pPattern);

    clOsalPrintf("             Library ID        : %#X\n",
                *(ClEoLibIdT *)patternArray.pPatterns[1].pPattern);
    clHeapFree(patternArray.pPatterns[1].pPattern);

    clOsalPrintf("             Water Mark ID     : %#X\n",
                *(ClWaterMarkIdT *)patternArray.pPatterns[2].pPattern);
    clHeapFree(patternArray.pPatterns[2].pPattern);

    clOsalPrintf("             Water Mark Type   : %s\n",
                (*(ClEoWaterMarkFlagT *)patternArray.pPatterns[3].pPattern == 
                 CL_WM_HIGH_LIMIT) ? "HIGH" : "LOW");
    clHeapFree(patternArray.pPatterns[3].pPattern);

    clOsalPrintf("             Water Mark Value  : %u\n",
                *(ClUint32T *)patternArray.pPatterns[4].pPattern);
    clHeapFree(patternArray.pPatterns[4].pPattern);

    clHeapFree(patternArray.pPatterns);

    clOsalPrintf("-------------------------------------------------------\n");

failure:
    return;
}
\endcode

Any component that wishes to be a subscriber has to initialize the Event
Library with appropriate arguments. The following code snippet shows how
Event Library is initialized and set for the subscription. Typically, the
following function would reside in the clCompAppInitialize() registered in
the clEoConfig structure of an EO. There could be multiple subscriptions
depending on the requirement each with a unique subscription id (unique
per initialization of Event Library).

\code
static ClRcT clSubsEventLibrayInitialize(void)
{
    ClRcT rc = CL_OK;

    ClVersionT version = CL_EVENT_VERSION;    
    ClNameT channelName = {sizeof(CL_EO_EVENT_CHANNEL_NAME)-1, 
                           CL_EO_EVENT_CHANNEL_NAME};

    const ClEventCallbacksT evtCallbacks = 
    {
        NULL, // clSubsAsyncChannelOpenCb for Async Channel Open
        clSubEoEventWaterMarkCb,  // Event Delivery Callback
    };
    ClEventChannelOpenFlagsT evtFlags = CL_EVENT_CHANNEL_SUBSCRIBER | 
                                        CL_EVENT_LOCAL_CHANNEL;

    rc = clEventInitialize(&gSubsEventInfo.initHandle, &evtCallbacks, 
                           &version);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventInitialize() failed [%#X]\n",rc);
        goto failure;
    }

    rc = clEventChannelOpen(gSubsEventInfo.initHandle, &channelName, 
            evtFlags, CL_RMD_DEFAULT_TIMEOUT, 
            &gSubsEventInfo.channelHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventChannelOpen() failed [%#X]\n",rc);
        goto init_done;
    }

    rc = clEventSubscribe(gSubsEventInfo.channelHandle, 
         CL_EVENT_DEFAULT_SUBS_FILTER, UNIQUE_SUBSCRIPTION_ID, 
         "User Specified Argument (cookie) for the event delivery callback");
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventSubscribe() failed [%#X]\n",rc);
        goto channel_opened;
    }

    return CL_OK;

channel_opened:
    clEventChannelClose(gSubsEventInfo.channelHandle);

init_done:
    clEventFinalize(gSubsEventInfo.initHandle);

failure:
    return rc;
}
\endcode

The Event Library is typically finalized from within clCompAppTerminate()
registered with the Component Manager (CPM). The following code snippet
illustrates the steps involved in finalization of a subscriber.

\code
static ClRcT clSubsEventLibrayFinalize(void)
{
    ClRcT rc = CL_OK;

    rc = clEventUnsubscribe(gSubsEventInfo.channelHandle, 
                            UNIQUE_SUBSCRIPTION_ID);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventUnsubscribe() failed [%#X]\n",rc);
    }

    rc = clEventChannelClose(gSubsEventInfo.channelHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventChannelClose() failed [%#X]\n",rc);
    }

    rc = clEventFinalize(gSubsEventInfo.initHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventFinalize() failed [%#X]\n",rc);
    }

    return CL_OK;
}
\endcode

<b>Publisher Side:</b>

The Publisher would unlike a subscriber allocate events, set their
attributes appropriately and publish them as illustrated below:

\code
static ClRcT clPubsTriggerEvent(ClEoLibIdT libId, ClWaterMarkIdT wmId, 
                         ClUint32T wmValue, ClEoWaterMarkFlagT wmFlag)
{
    ClRcT rc = CL_OK;

    ClEventIdT eventId = 0;
    ClNameT publisherName = {sizeof(CL_EVENT_PUBLISHER_NAME)-1, 
                             CL_EVENT_PUBLISHER_NAME};

    ClEventPatternT patterns[5] = {{0}};

    ClEventPatternArrayT patternArray = {
        0,
        CL_SIZEOF_ARRAY(patterns),
        patterns 
    };

    rc = clEventAllocate(gPubsEventInfo.channelHandle, 
                         &gPubsEventInfo.eventHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventAllocate() failed [%#X]\n",rc);
        goto failure;
    }

    patterns[0].patternSize = strlen(CL_EO_NAME);
    patterns[0].pPattern = (ClUint8T *)CL_EO_NAME;
    
    patterns[1].patternSize = sizeof(libId);
    patterns[1].pPattern = (ClUint8T *)&libId;
    
    patterns[2].patternSize = sizeof(wmId);
    patterns[2].pPattern = (ClUint8T *)&wmId;
    
    patterns[3].patternSize = sizeof(wmFlag);
    patterns[3].pPattern = (ClUint8T *)&wmFlag;
    
    patterns[4].patternSize = sizeof(wmValue);
    patterns[4].pPattern = (ClUint8T *)(&wmValue);
    
    rc = clEventAttributesSet(gPubsEventInfo.eventHandle, &patternArray, 
            CL_EVENT_HIGHEST_PRIORITY, 0, &publisherName);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventAttributesSet() failed [%#X]\n",rc);
        goto event_allocated;
    }

    rc = clEventPublish(gPubsEventInfo.eventHandle, 
            "Event Payload passed in endian neutral way", 
            sizeof("Event Payload passed in endian neutral way.")-1, 
            &eventId);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventPublish() failed [%#X]\n",rc);
        goto event_allocated;
    }

event_allocated:
    rc = clEventFree(gPubsEventInfo.eventHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventFree() failed [%#X]\n",rc);
    }

failure:
    return rc;
}
\endcode

Like in the subscriber the publisher needs to do the Event Library
Initialize as suggested before. In publisher we open the channel
asynchronously, the callback for which is as below:

\code
void clPubsAsyncChannelOpenCb(ClInvocationT invocation,
        ClEventChannelHandleT channelHandle, ClRcT retCode)
{
    ClRcT rc = CL_OK;

    clOsalPrintf("*******************************************************\n");
    clOsalPrintf("************* Async Channel Open Callback *************\n");
    clOsalPrintf("*******************************************************\n");
    clOsalPrintf("      Invocation        : %#X\n", invocation);
    clOsalPrintf("      Channel Handle    : %p\n", (ClPtrT)channelHandle);
    clOsalPrintf("      API Return Code   : %#X\n", retCode);
    clOsalPrintf("*******************************************************\n");

    /*
     Check if the Channel Open Asyn was successful
     */
    if(CL_OK != retCode)
    {
        clOsalPrintf("clEventChannelOpenAsync() failed [%#X]\n",rc);
        goto failure;
    }

    gPubsEventInfo.channelHandle = channelHandle;

    rc = clPubsTriggerEvent(CL_EO_LIB_ID_HEAP, CL_WM_HIGH, CL_WM_HIGH_LIMIT, 
                            CL_WM_LOW_LIMIT);
    if(CL_OK != rc)
    {
        clOsalPrintf("Publish trigger failed [%#X]\n",rc);
        goto channel_opened;
    }

channel_opened:
    clEventChannelClose(gPubsEventInfo.channelHandle);

failure:
    return;
}
\endcode

Much of the code is similar between the subscriber and publisher as can be
seen below. The only difference being a publisher may optionally choose to
be a subscriber also in which case it will need to register an event
delivery callback. Note that event publish related API that appear in
channel open callback above would appear right after the channel open if
it were synchrounous. The event can be allocated each time it is published
or it can be re-used with special care taken about protection in multi
threaded environment when the event handle is shared between the threads.

\code
typedef struct ClPubsEventInfo
{
    ClEventInitHandleT initHandle;
    ClEventChannelHandleT channelHandle;
    ClEventHandleT eventHandle;
} ClPubsEventInfoT; 

static ClPubsEventInfoT gPubsEventInfo;

static ClRcT clPubsEventLibrayInitialize(void)
{
    ClRcT rc = CL_OK;

    ClVersionT version = CL_EVENT_VERSION;    
    ClNameT channelName = {sizeof(CL_EO_EVENT_CHANNEL_NAME)-1, 
                           CL_EO_EVENT_CHANNEL_NAME};

    const ClEventCallbacksT evtCallbacks = 
    {
        clPubsAsyncChannelOpenCb, // Can be NULL if sync call is used
        NULL,                     // Since it is not a subscriber  
    };
    ClEventChannelOpenFlagsT evtFlags = CL_EVENT_CHANNEL_PUBLISHER | 
                                        CL_EVENT_LOCAL_CHANNEL;

    // To identify the callback
    ClInvocationT invocation = UNIQUE_INVOCATION_ID; 

    rc = clEventInitialize(&gPubsEventInfo.initHandle, 
                           &evtCallbacks, &version);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventInitialize() failed [%#X]\n",rc);
        goto failure;
    }

    rc = clEventChannelOpenAsync(gPubsEventInfo.initHandle, invocation, 
            &channelName, evtFlags);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventChannelOpen() failed [%#X]\n",rc);
        goto init_done;
    }

    return CL_OK;

init_done:
    clEventFinalize(gPubsEventInfo.initHandle);

failure:
    return rc;
}

static ClRcT clPubsEventLibrayFinalize(void)
{
    ClRcT rc = CL_OK;

    rc = clEventChannelClose(gPubsEventInfo.channelHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventChannelClose() failed [%#X]\n",rc);
    }

    rc = clEventFinalize(gPubsEventInfo.initHandle);
    if(CL_OK != rc)
    {
        clOsalPrintf("clEventFinalize() failed [%#X]\n",rc);
    }

    return CL_OK;
}
\endcode

*/

//-----------------------------------------------------------
