/**
 *  \defgroup fault Fault Manager
 *  \brief The OpenClovis Fault Manager provides a mechanism 
 *  for managing faults in a system and initiating actions as defined 
 *  by the user. It can handle various user-defined run-time faults,
 *  including hardware and software faults, and also provides a mechanism for
 *  fault escalation.
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup fault_intro Functional Description
 *  \brief Description of the Fault Management Service.
 *  \ingroup fault
 * 
 *  \section secfaultintro1 Overview 
 *  The OpenClovis Fault Manager infrastructure provides a mechanism for
 *  managing faults in a system and initiating actions as defined by the
 *  user.
 *  It can also handle various user-defined run-time faults, including 
 *  hardware and software faults, and also provides a mechanism for progressive fault 
 *  reporting based on "probation period" 
 *
 *  Non-service impacting alarms are defined as any alarm having severity below 
 *  ::CL_ALARM_SEVERITY_MAJOR. They are reported directly to the Fault Manager 
 *  located on the same node. The action to be taken on receiving a fault is
 *  defined by the user and is specific to alarm type and severity. 
 *  Typically when idetical faults are received within a configured probation period, 
 *  they get escalated.
 *
 *  Service impacting faults are defined as any alarm having severity 
 *  ::CL_ALARM_SEVERITY_MAJOR and above.The Fault Manager interacts with 
 *  the Availability Management Framework (AMF) while handling 
 *  service-impacting alarms. The AMF performs service recovery 
 *  and the Fault Manager takes repair actions as defined by the user. 
 *  Both AMF and Fault Manager entities are inter-dependent while taking actions 
 *  in a system during recovery and repair. 
 *
 *  The Fault Manager provides the following services:
 *  \arg Fault reporting
 *  \arg Repair action  
 *  
 *  The Fault Repair action should be done for service impacting alarms. Inorder 
 *  to do fault repair, the openClovis IDE generates callback functions 
 *  corresponding to each managed resource which is having alarm service 
 *  associated to it. Whenever an alarm is raised on the resource and if fault 
 *  repair action API is called then Fault Manager will call the callback function 
 *  registered for that resource. The user can do a customized action inside the 
 *  callback associated to the resource for repairing the fault. The callback 
 *  functions are generated in the file clFaultRepairHandler.c as a part of config 
 *  directory of the code generated by IDE.
 *   
 *  The Fault reporting is done by Alarm Server for the non-service impacting
 *  alarms. It is achieved using the matrix of callback functions. There are 
 *  five callback functions for an alarm category and severity combination. 
 *  There are five severity levels critical, major, minor, warning and 
 *  inderterminate. There are five categories that is communication, quality of 
 *  service, equipment, processing and enviornment.  
 *  For example : For the communication category and for each serverity there 
 *  can be five callback functions, one each for five escalation level. That is
 *  there can be twenty five callback functions for the communication category. 
 *  The callback functions definitions are present in clFaultReportHandler.c file 
 *  which is generated in the config directory of the model code generated by IDE.
 *  
 *  There is a probation period defined which is used as an escalation policy
 *  for fault reporting. When the fault is reported on a category plus severity 
 *  pair for the first time, then the callback function at the first level is
 *  called. If the fault occur again within the probation period, then the fault 
 *  escalation will happen and the callback on the second level is called. This 
 *  escalation will occur only till level five. So the execution of the callback 
 *  at the higher level denotes the increasing gravity of the problem for a 
 *  category plus severity pair.
 * 
 *  Before a component can use the clFaultReport() or clFaultRepairAction() 
 *  functions, it needs to:
 *  \arg Check the version compatibility - This can be performed using the clFaultVersionVerify()
 *  function. If the call returns CL-OK, the component is compatible with the fault client library.
 *  \arg Initialize the fault client library - This can be performed using the 
 *  clFaultSvcLibInitialize() function. After the library is successfully initialized,
 *  the fault report/repair functionality can be used. When the fault service is not required, 
 *  the fault library must be finalized. 
 *  Currently the clFaultSvcLibInitialize() API is empty and need not be called.
 *  This is being kept for consistency with other ASP libraries.
 */

//-----------------------------------------------------------

/**
 *   \defgroup fault_usage API Usage Examples
 *   \brief Code Examples.
 *   \ingroup fault
 *
 *   \section sec_fault_usage_1 Reporting fault
 *   Fault Manager provides a mechanism to report faults that occurred in the
 *   system through the following two APIs:
 *   \arg clFaultReport()
 *   \arg clFaultRepairAction()
 *  
 *   Alarm Manager uses clFaultReport() to report non-service impacting alarm to 
 *   Fault Manager which invokes the action configured 
 *   by the user corresponding to the alarm category and severity. The following 
 *   example shows the usage of clFaultReport(). 
 *   It reports fault for 
 *   MO \\Chassis:0\\TestSync2T1:0 belonging to category ::CL_ALARM_SEVERITY_MINOR.
 *   \code
 *
 *   ClRcT rc;
 *   ClRcT errorCode = CL_OK;
 *   ClNameT compName, moIdName;
 *   ClCorMOIdPtrT hMoId = NULL;
 *   ClAlarmCategoryTypeT category = CL_ALARM_CATEGORY_PROCESSING_ERROR;
 *   //The value of specificProblem can be anything.
 *   ClAlarmSpecificProblemT specificProblem = 1;
 *   ClAlarmSeverityTypeT severity = CL_ALARM_SEVERITY_MINOR;
 *   ClAlarmProbableCauseT cause = CL_ALARM_PROB_CAUSE_VERSION_MISMATCH;
 *   ClAlarmStateT alarmState = CL_ALARM_STATE_ASSERT;
 *   void *pData=NULL;
 *   ClUint32T len=0;
 *
 *
 *   strncpy(compName.value, "cntlrTi1Sys0", sizeof(compName.value));
 *   compName.length = strlen(compName.value);
 *
 *   strncpy(moIdName.value, "\\Chassis:0\\TestSync2T1:0", 
 *           sizeof(moIdName.value));
 *   moIdName.length = strlen(moIdName.value);
 *   rc = clCorMoIdNameToMoIdGet(&moIdName, hMoId);
 *   if(CL_OK != rc)
 *   {
 *       //Error occurred. Take appropriate action
 *       clLogError("FLT", "002",
 *                  "Error while getting MOId from MOId name, rc=[0x%x]", 
 *                  rc);
 *       return rc;
 *   }
 *   // Reports a fault on the compName
 *   errorCode =clFaultReport(&compName,
 *                   hMoId,
 *                   alarmState,
 *                   category,
 *                   specificProblem,
 *                   severity,
 *                   cause,
 *                   pData,
 *                   len);
 *   if(CL_OK != errorCode)
 *   {
 *       //Error occurred. Take appropriate action.
 *       clLogError("FLT", "002", 
 *                  "Reporting fault failed with error [0x%x]", rc);
 *       return rc;
 *   }
 *   \endcode
 *  
 *   For service impacting alarms, Alarm Manager(AM) publishes an event which is
 *   subscribed by Availability Management Framework(AMF). AMF does service
 *   recovery and informs Fault Manager(FM) to take appropriate action. 
 *   FM invokes the appropriate handler for the alarm. This handler is being 
 *   defined by the user during modeling of the system.
 *   Following example shows the usage of clFaultRepairAction()
 *
 *   \code 
 *   ClRcT   rc = CL_OK;
 *   ClIocAddressT iocAddress;
 *   // alarmHandle is obtained from the invocation of clAlarmRaise() 
 *   ClAlarmHandleT alarmHandle = *(ClAlarmHandleT *)arg;
 *
 *
 *   iocAddress.iocPhyAddress.nodeAddress = clIocLocalAddressGet();
 *   rc = clFaultRepairAction(iocAddress, 
 *                           alarmHandle, 
 *                           CL_AMS_RECOVERY_COMP_RESTART);
 *   if(CL_OK != rc)
 *   {
 *   //Error occurred. Take appropriate action.
 *      clLogError("FLT", "002", 
 *                 "Fault repair failed with error [0x%x]", rc);
 *      return rc;
 *   }
 *   return CL_OK;
 *      
 *   \endcode
 *
 *   \section sec_fault_usage_2 Version Checking 
 *   The following API checks for version compatibility of the Application.
 *   \arg clFaultVersionVerify()
 *   \code
 *   ClRcT errorCode = CL_OK;
 *   ClVersionT version;
 *   // fill the version information i.e available with the application
 *   errorCode = clFaultVersionVerify(&version);
 *   if(CL_OK != errorCode) 
 *   {
 *   // version mismatch has occurred 
 *   // The highest version supported by the client library is also
 *   // updated in the version field
 *       clLogError("FLT", "003",
 *       "Version mismatch. Returning the highest supported version, "
 *       "rc=[0x%x]", rc);
 *       return rc;
 *   }
 *   \endcode
 *
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup fault_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup fault
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting Fault Manager 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_FAULTS "Fault Manager Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_fault
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup fault_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup fault
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup fault_aspconsole ASP Console
 *  \brief ASP Console.
 *  \ingroup fault
 */

//-----------------------------------------------------------

