\hypertarget{group__group42}{
\chapter{Functional Overview}
\label{group__group42} \index{Functional Overview@{Functional Overview}} }


\begin{flushleft}
Computer programs use dynamic memory
allocation to access memory area whose size
is not known at compile time. The \begin{bf}OpenClovis heap library
\end{bf} provides the ability to optimize the performance and reduce
fragmentation of free memory. ASP components and applications
built on ASP can use this implementation for their dynamic memory
requirements.
\newline
\par
Applications can take ownership of a certain amount of memory using the {\tt{clHeapAllocate}}, {\tt{clHeapCalloc}} or
{\tt{clHeapRealloc}} functions. The ownership of the memory chunk
remains with the application until it is explicitly freed by
invoking {\tt{clHeapFree}} API. After the memory is freed, it can
be used for re-allocation.
\newline
\par
Using the heap library, an application can specify any of the following to be used for dynamic memory allocation:
\begin{itemize}
\item
Native 'C' implementation
\item
OpenClovis implementation
\item
Any other implementation
\end{itemize}

If the OpenClovis implementation is used, the heap library creates pools of memory chunks of one size.
Thus different pools for different chunk
sizes can be created within the same heap library. Each pool is created
with an initial size that can later grow until an upper limit on the
size of that pool or a process wide upper limit on dynamic memory is
reached.
\newline
\par
The pools grow in quantum of {\tt{incrementPoolSize}} parameter.
The size can be configured in the heap library during its initialization
using {\tt{clHeapLibInitialize}} function. The library must be
initialized before any call for dynamic memory allocation is made.
When the process is terminated, the heap library must be finalized
using {\tt{clHeapLibFinalize}} function. After finalizing the call, no
dynamic memory allocation or de-allocation of memory should be attempted. The OpenClovis
implementation also provides Notifications for conditions when the process
limit crosses certain values. This enables the resource managers to take
appropriate action.
\newline
\par
OpenClovis implementation of the heap utility helps the application developer
in detecting certain dynamic memory related issues. For example,
detection of double free of a chunk,  
writing over the upper limit of a chunk (overrun),  or 
writing below the lower limit of a chunk.
These facilities are provided by setting the debug level of the
library. It can also detect free memory chunk that is not
allocated from the heap library or any attempt to free a partial
chunk. An application can provide its own implementation of
dynamic memory allocation using
{\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}} while invoking the
{\tt{clHeapLibInitialize}} API. It can plug-in its own functions
for allocation, re-allocation, and de-allocation of memory. All ASP components linked to this application can use the
application registered functions for their own requirements.



\chapter{Service APIs}


\section{Type Definitions}

\subsection{ClHeapModeT}
\index{ClHeapModeT@{ClHeapModeT}}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef enum \{}\\
\>\>\>\>\textit{CL\_HEAP\_PREALLOCATED\_MODE,}\\
\>\>\>\>\textit{CL\_HEAP\_NATIVE\_MODE,}\\
\>\>\>\>\textit{CL\_HEAP\_CUSTOM\_MODE,}\\
\textit{\} ClHeapModeT;}\end{tabbing}
The enumeration, {\tt{ClHeapModeT}}, contains the heap allocation modes. The attributes of this enumeration are:
\begin{itemize}
\item
\textit{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE} - OpenClovis implementation of the memory management library.
\item
\textit{CL\_\-HEAP\_\-NATIVE\_\-MODE} - Native C mode. It maps to the memory APIs provided by {\tt{libc}}.
\item
\textit{CL\_\-HEAP\_\-CUSTOM\_\-MODE} - Custom pools. The application developer can plug in customized memory management library calls.
\end{itemize}




\subsection{ClHeapConfigT}
\index{ClHeapConfigT@{ClHeapConfigT}}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClHeapModeT mode;}\\
\>\>\>\>\textit{ClBoolT lazy;}\\
\>\>\>\>\textit{ClPoolConfigT *pPoolConfig;}\\
\>\>\>\>\textit{ClUint32T numPools;}\\
\textit{\} ClHeapConfigT;}
\end{tabbing} 
The structure, {\tt{ClHeapConfigT}}, contains the configuration of the heap library. The attributes of this structure are:
\begin{itemize}
\item
\textit{mode} - Allocation mode. This can be either {\tt{CL\_\-HEAP\_\-NATIVE\_\-MODE}}, {\tt{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE}}, or 
{\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}.
\item
\textit{lazy} - A pool can grow even after it exhausts its current allocation. This attribute configures a pool in lazy mode for pool expansion. 
There are two modes for configuring the pool:
\begin{itemize}
\item
Lazy mode - The incremented pool does not initialize until an allocation is made from the extended portion of the pool. Lazy mode 
speeds up the initialization of the application, but shifts the penalty of pool initialization to a later allocation.
\item
Normal mode- The incremented pool initializes as soon as it is acquired by the memory management library during the creation of the pool. 
\end{itemize}
\item
\textit{pPoolConfig} - Array of pool configurations.
\item
\textit{numPools} - Number of pools in the {\tt{pPoolConfig}} array.
\end{itemize}


\subsection{ClPoolConfigT}
\index{ClPoolConfigT@{ClPoolConfigT}}
\begin{Desc}
\item[Header File:]clPoolIpi.h\end{Desc}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClUint32T chunkSize;}\\
\>\>\>\>\textit{ClUint32T initialPoolSize;}\\
\>\>\>\>\textit{ClUint32T incrementPoolSize;}\\
\>\>\>\>\textit{ClUint32T maxPoolSize;}\\
\textit{\} ClPoolConfigT;}
\end{tabbing} The structure, {\tt{ClPoolConfigT}}, contains the configuration for a single
memory pool. A pool is a collection of memory chunks of same size as
mentioned in the {\tt{chunkSize}} parameter. The attributes of this structure are:
\begin{itemize}
\item \textit{chunkSize} - Size of each memory chunk in this pool specified in bytes.
\item \textit{initialPoolSize} - Initial size of this pool in bytes. This pool is created during {\tt{clHeapLibInitialize}}. It is a 
multiple of {\tt{incrementPoolSize}}.
\item \textit{incrementPoolSize} - 
When a pool exhausts all its memory chunks, it can grow by this amount to create new memory chunks, which can be allocated on subsequent requests. 
This size is specified in bytes and is a multiple of {\tt{chunkSize}}.
\item \textit{maxPoolSize} - Maximum size of the pool in bytes. The pool must not grow beyond this size. Allocation requests from this pool will fail
after the pool reaches this size and no memory chunk is available to be allocated. This is a multiple of {\tt{incrementPoolSize}}.
\end{itemize}


\subsection{ClPoolShrinkFlagsT}
\begin{Desc}
\item[Header File:]clPoolIpi.h\end{Desc}
\textit{typedef enum ClGmsTrackFlags \{}
\newline\textit{CL\_\-pool\_\-SHRINK\_\-DEFAULT, }
\newline\textit{CL\_\-pool\_\-SHRINK\_\-ONE, }
\newline\textit{CL\_\-pool\_\-SHRINK\_\-ALL  }
\newline\textit{\} ClPoolShrinkFlagsT;}
\newline
The enumeration, {\tt{ClPoolShrinkFlagsT}}, indicates the
choice you can make while shrinking a pool. For the purpose of shrinking, a concept of extended pool is defined. One extended pool is a memory block of 
{\tt{incrementPoolSize}} for that pool. The attributes of this enumeration are:
\begin{itemize}
\item
\textit{CL\_\-pool\_\-SHRINK\_\-DEFAULT} - Shrinks the pool so that
half of the free extended pools are released. Memory
chunk is not allocated from a free extended pool.
\item
\textit{CL\_\-pool\_\-SHRINK\_\-ONE} - Shrinks the pool by one extended pool, if a free extended pool is available.
\item
\textit{CL\_\-pool\_\-SHRINK\_\-ALL} - Shrinks the pool so that the free extended pools are released.
\end{itemize}




\subsection{ClPoolShrinkOptionsT}
\index{ClPoolShrinkOptionsT@{ClPoolShrinkOptionsT}}
\begin{Desc}
\item[Header File:]clPoolIpi.h\end{Desc}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClPoolShrinkFlagsT  shrinkFlags;}\\
\textit{\} ClPoolShrinkOptionsT;}
\end{tabbing} The structure, {\tt{ClPoolShrinkOptionsT}}, is used to specify the shrink options to the heap library.
\begin{itemize}
\item \textit{shrinkFlags} - Specifies the extent to which a pool can shrink.
\end{itemize}


\subsection{ClMemStatsT}
\index{ClMemStatsT@{ClMemStatsT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClUint32T   numAllocs;}\\
\>\>\>\>\textit{ClUint32T   numFrees;}\\
\>\>\>\>\textit{ClUint32T   currentAllocSize;}\\
\>\>\>\>\textit{ClUint32T   maxAllocSize;}\\
\>\>\>\>\textit{ClUint32T   numPools;}\\
\textit{\} ClMemStatsT;}
\end{tabbing} The structure, {\tt{ClMemStatsT}}, retrieves statistics from the heap library. The attributes of this structure are:
\begin{itemize}
\item \textit{numAllocs} - Total number of allocations (including {\tt{clHeapAllocate}}, {\tt{clHeapCalloc}} and {\tt{clHeapRealloc}}) since the 
initialization of heap library.
\item \textit{numFrees} - Specifies the number of frees (including {\tt{clHeapFree}} and {\tt{clHeapRealloc}} APIs) since the initialization of heap library.
\item \textit{currentAllocSize} - Specifies the total number of bytes currently allocated by heap library.
\item \textit{maxAllocSize} - Specifies the maximum value of {\tt{currentAllocSize}} as the initialization of heap library. It implies the maximum 
demand of memory (in bytes) experienced by this process.
\item \textit{numPools} - Specifies the total number of pools created by heap library. This value is supplied when
{\tt{clHeapLibInitialize}} is invoked.
\end{itemize}


\subsection{ClPoolStatsT}
\index{ClPoolStatsT@{ClPoolStatsT}}
\begin{Desc}
\item[Header File:]clPoolIpi.h\end{Desc}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClPoolConfigT   poolConfig;}\\
\>\>\>\>\textit{ClUint32T   numExtendedPools;}\\
\>\>\>\>\textit{ClUint32T   maxNumExtendedPools;}\\
\>\>\>\>\textit{ClUint32T   numAllocs;}\\
\>\>\>\>\textit{ClUint32T   numFrees;}\\
\>\>\>\>\textit{ClUint32T   maxNumAllocs;}\\
\textit{\} ClPoolStatsT;}
\end{tabbing} The structure, {\tt{ClPoolStatsT}}, is used to retrieve the statistics from the
heap library for a pool of memory chunks.
\begin{itemize}
\item \textit{poolConfig} - Configuration of this pool supplied during initialization of this library.
\item \textit{numExtendedPools} - Current number of extended pools. 
One extended pool is a memory block of {\tt{incrementPoolSize}} for the pool.
\item \textit{maxNumExtendedPools} - Maximum value of {\tt{numExtendedPools}} since the creation of the pool.
\item \textit{numAllocs} - Total number of allocations from this pool since the creation of the pool.
\item \textit{numFrees} - Total number of frees to this pool since the creation of this pool.
\item \textit{maxNumAllocs} - Maximum number of outstanding allocations of this pool. These outstanding allocations are those that have not been freed
since the creation of the pool.
\end{itemize}





\newpage

\section{library Life Cycle APIs}
\subsection{clHeapLibInitialize}
\index{clHeapLibInitialize@{clHeapLibInitialize}}
\hypertarget{pageheap101}{}\paragraph{clHeapLibInitialize}\label{pageheap101}
\begin{Desc}
\item[Synopsis:]Initializes the heap library.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}         ClRcT clHeapLibInitialize(
                                            CL_IN const ClHeapConfigT* pConfig);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em pConfig:}](in) Pointer to the configuration to be used by heap library.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]The API executed successfully.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}]{\tt{pConfig}} or {\tt{pPoolConfig}} (member of {\tt{pConfig}}) is NULL.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAMETER:}]{\tt{numPools}} (member of {\tt{pConfig}}) is 0.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY:}]Heap library is out of memory and cannot proceed further.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]
This function is used to initialize the heap library. It is called during the initialization of the EO (Execution Object).
The heap library must be initialized before it can be used to allocate memory.
The caller should allocate or free the {\tt{pConfig}} parameter. Any configuration provided
through this function to the heap library cannot be changed while the
process calling this function is executing. 
\par 
During the lifetime of a process, this function must be called only once, preferably during
process initialization. Subsequent calls to this function are ignored and it returns {\tt{CL\_\-OK}} without changing anything.

\end{Desc}
\begin{Desc}
\item[library File:]libClUtils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap102}{clHeapLibFinalize} \end{Desc}
\newpage

\subsection{clHeapLibFinalize}
\index{clHeapLibFinalize@{clHeapLibFinalize}}
\hypertarget{pageheap102}{}\paragraph{clHeapLibFinalize}\label{pageheap102}
\begin{Desc}
\item[Synopsis:]Finalizes the heap library.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}         ClRcT clHeapLibFinalize(void);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] None.
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]The API executed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] heap library is not initialized through a previous call to {\tt{clHeapLibInitialize}} or it is  
finalized through a call to {\tt{clHeapLibFinalize}}.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]
This function is used to finalize the heap library. After finalizing
the heap library, it must not be used to allocate any memory or free
previously allocated memory.
\end{Desc}
\begin{Desc}
\item[library File:]libClUtils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap101}{clHeapLibInitialize} \end{Desc}
\newpage



\section{Functional APIs}


\subsection{clHeapAllocate}
\index{clHeapAllocate@{clHeapAllocate}}
\hypertarget{pageheap128}{}\paragraph{cl\-heap\-Allocate}\label{pageheap128}
\begin{Desc}
\item[Synopsis:]Allocates memory of the requested size.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        void* clHeapAllocate(
                                    		CL_IN ClUint32T size);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em size}](in): Number of memory bytes to be allocated.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
 The function returns a valid pointer on success and returns NULL on memory allocation failure.
\end{Desc}
\begin{Desc}
\item[Description:]This function allocates memory of a specified size. The returned memory is aligned at an 8-byte boundary. 
When the heap library is configured to {\tt{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE}}, it returns memory of minimum size. This memory size is 
greater than or equal to the requested size. If size is specified as 0, the system returns a valid pointer pointing to a chunk of minimum size
that is previously configured.
If heap library is configured to {\tt{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE}}, failure
of {\tt{clHeapAllocate}} for one size of memory does not mean that
this function will fail for other sizes. For more information,
refer to man page of malloc(3). \end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap130}{clHeapCalloc}, \hyperlink{pageheap129}{clHeapFree}, \hyperlink{pageheap105}{clHeapRealloc} \end{Desc}
\newpage



\subsection{clHeapFree}
\index{clHeapFree@{clHeapFree}}
\hypertarget{pageheap129}{}\paragraph{cl\-heap\-Free}\label{pageheap129}
\begin{Desc}
\item[Synopsis:]Frees a pre-allocated memory.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        void clHeapFree(
                                   		CL_IN void* pAddress);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em pAddress}](in): Block of memory to be freed.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
None.
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to free memory. {\tt{pAddress}} should be a valid pointer allocated through a previous call to either
{\tt{clHeapAllocate}}, {\tt{clHeapRealloc}}, or
{\tt{clHeapCalloc}}. {\tt{pAddress}} should not be used after a
call to {\tt{clHeapFree}}. NULL is a valid value for
{\tt{pAddress}}. For more information, refer to man page of
free(3).\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap130}{clHeapCalloc}, \hyperlink{pageheap128}{clHeapAllocate},
\hyperlink{pageheap105}{clHeapRealloc} \end{Desc}
\newpage



\subsection{clHeapCalloc}
\index{clHeapCalloc@{clHeapCalloc}}
\hypertarget{pageheap130}{}\paragraph{cl\-heap\-Calloc}\label{pageheap130}
\begin{Desc}
\item[Synopsis:]Allocates memory for an array and initializes it to zero.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        void* clHeapCalloc(
                			        CL_IN ClUint32T numChunks,
                	                        CL_IN ClUint32T chunkSize);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em num\-Chunks}](in): Number of chunks to be allocated.
\item[{\em chunk\-Size}](in): Size of each chunk.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
 The function returns a valid pointer on success and returns NULL on memory allocation failure.
\end{Desc}
\begin{Desc}
\item[Description:]This function allocates memory of a specific size. The memory chunk, it returns, is aligned at an 8-byte boundary. 
If {\tt{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE}} is selected during heap
configuration, failure of {\tt{clHeapAllocate}} for one size of
memory does not mean that it will fail for other sizes also. For
more information, refer to man page, {\tt{malloc(3)}}. Also refer to man
page of {\tt{calloc(3)}}.\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap128}{clHeapAllocate}, \hyperlink{pageheap130}{clHeapFree}, \hyperlink{pageheap105}{clHeapRealloc} \end{Desc}
\newpage



\subsection{clHeapRealloc}
\index{clHeapRealloc@{clHeapRealloc}}
\hypertarget{pageheap105}{}\paragraph{cl\-heap\-Realloc}\label{pageheap105}
\begin{Desc}
\item[Synopsis:]Changes the size of the memory block (chunk).\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}
                		void *clHeapRealloc(
                		    CL_IN void *pAddress,
                		    CL_IN ClUint32T size);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Address:}](in) Original pointer to the memory block (chunk).
\item[{\em size:}](in) New size of the memory block (chunk).
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
 The function returns a valid pointer on success and returns NULL on memory allocation failure.
\end{Desc}
\begin{Desc}
\item[Description:] This function is used to change the size of the memory block pointed by {\tt{pAddress}} to {\tt{size}} in bytes. The new address
returned is aligned at an 8-byte boundary. The contents of the
returned memory block is unchanged to the minimum of the old and new
sizes. The contents of the memory over the size of the previous block of memory
is un initialized.
\begin{itemize}
\item If {\tt{pAddress}} is NULL, the call is equivalent to {\tt{clHeapAllocate}} (size).
\item If {\tt{size}} is zero, the call is equivalent to {\tt{clHeapFree(pAddress)}} and the function returns NULL.
\item If {\tt{pAddress}} is NULL and size is zero, it is still equal to {\tt{clHeapAllocate (0)}}.
\item If {\tt{pAddress}} is not NULL, it must have been returned by an earlier call to {\tt{clHeapAllocate/clHeapRealloc/clHeapCalloc}}.
\end{itemize}
\par
If {\tt{clHeapRealloc}} fails, the original memory block remains
untouched (if is not freed or moved). If {\tt{clHeapRealloc}}
succeeds, {\tt{pAddress}} should no longer be used. For more
information, refer to man page of {\tt{realloc(3)}}.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap128}{clHeapAllocate}, \hyperlink{pageheap130}{clHeapFree}, \hyperlink{pageheap130}{clHeapCalloc} \end{Desc}
\newpage


\subsection{clHeapShrink}
\index{clHeapShrink@{clHeapShrink}}
\hypertarget{pageheap107}{}\paragraph{cl\-heap\-Shrink}\label{pageheap107}
\begin{Desc}
\item[Synopsis:]Shrinks the pools of pre-allocated memory to enable other pools to grow.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}
                			ClRcT clHeapShrink(
                			    CL_IN const ClPoolShrinkOptionsT *pShrinkOptions);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em pShrinkOptions:}](in) {\tt{shrinkFlags}}, a member of this structure indicates to what extent the existing pools can be shrunk.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] The heap library is not initialized by a previous call to {\tt{clHeapInitialize}}.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to shrink the memory used by the pool of one {\tt{chunkSize}} so that pools of other {\tt{chunkSize}}
can grow without violating the wide upper limit of the process. These shrink options are used for all pools of heap library.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]None. \end{Desc}
\newpage




\subsection{clHeapModeGet}
\index{clHeapModeGet@{clHeapModeGet}}
\hypertarget{pageheap108}{}\paragraph{cl\-heap\-Mode\-Get}\label{pageheap108}
\begin{Desc}
\item[Synopsis:]Returns the mode set during configuration. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}
 				ClRcT clHeapModeGet(CL_OUT ClHeapModeT *pMode);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Mode:}](out) Configuration mode returned by the function.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] If this function is called before heap initialization through a {\tt{clHeapIntialize()}} function.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}] If {\tt{pMode}} is passed as NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function returns the configuration mode of the heap in the current process. It can be one of the following values:
{\tt{CL\_\-HEAP\_\-NATIVE\_\-MODE}}, {\tt{CL\_\-HEAP\_\-PREALLOCATED\_\-MODE}}, or {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]None. \end{Desc}
\newpage



\subsection{clHeapStatsGet}
\index{clHeapStatsGet@{clHeapStatsGet}}
\hypertarget{pageheap111}{}\paragraph{cl\-heap\-Stats\-Get}\label{pageheap111}
\begin{Desc}
\item[Synopsis:]Returns the statistics collected by heap module. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}
            			ClRcT clHeapStatsGet(
            			    CL_OUT ClMemStatsT *pHeapStats);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em pHeapStats:}](out) Pointer to the memory block where heap module will copy the statistics.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] Heap library is not initialized.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}] The parameter {\tt{pHeapStats}} is passed as NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function is used by heap to collect the statistics about its usage. Other components can invoke this function to access these
statistics.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]None. \end{Desc}
\newpage


\subsection{clHeapPoolStatsGet}
\index{clHeapPoolStatsGet@{clHeapPoolStatsGet}}
\hypertarget{pageheap129}{}\paragraph{cl\-heap\-pool\-Stats\-Get}\label{pageheap129}
\begin{Desc}
\item[Synopsis:]Returns the statistics collected by heap library for an individual pool.\end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        ClRcT clHeapPoolStatsGet(
                        			CL_IN ClUint32T numPools,
                        			CL_OUT ClUint32T *pPoolSize,
                        			CL_OUT ClPoolStatsT *pHeapPoolStats);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em num\-pools}](in): Number of pools for which the statistics are required. This is used as the size for {\tt{pPoolSize}} and 
\textit{pPoolStats}.
\item[{\em p\-pool\-Size}](out): Pointer to array which contains the sizes of various pools.
\item[{\em p\-heap\-pool\-Stats}](out): Pointer to array which contains the statistics of various pools.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] This function is called before initializing the heap library using the {\tt{clHeapIntialize()}} function.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}] Either {\tt{pPoolSize}} or {\tt{pPoolStats}} or both the parameters is NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]
This function is used by components to retrieve statistics about usage
of various pools and their current size. 
The heap module gathers this information.
\par
If {\tt{numPools}} is less than the number of pools configured in heap, the function returns the size and statistics
of the first pool arranged in increasing order of chunk sizes. 
If {\tt{numPools}} is greater than the number of pools configured, 
only first n entries of {\tt{pPoolSize}} and {\tt{pPoolStats}} are valid, where {\tt{n}} is the number of pools configured.

\end{Desc}
\begin{Desc}
\item[library File:]libClUtils\end{Desc}
\begin{Desc}
\item[Related Function(s):] None.
\end{Desc}
\newpage



\subsection{clHeapLibCustomInitialize}
\index{clHeapLibCustomInitialize@{clHeapLibCustomInitialize}}
\hypertarget{pageheap130}{}\paragraph{cl\-heap\-Lib\-Custom\-Initialize}\label{pageheap130}
\begin{Desc}
\item[Synopsis:]Customizes the initialization of heap library in {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}       ClRcT clHeapLibCustomInitialize(
                        			CL_IN const ClHeapConfigT* pConfig);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em pConfig}]: (in) Pointer to configuration information used by heap library.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}] Either {\tt{pConfig}} or {\tt{pPoolConfig}}, a member of {\tt{pConfig}} is passed as NULL.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY:}] Heap library is out of memory and cannot proceed further.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]
This function is used to customize the initialization of the heap library.
This is an open function and the application developer should implement this function.This is called only
when an application indicates that it needs to customize heap through
{\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. The function is
available in {\tt{ASP/models/<model-name>/config/clHeapCustom.c.}}
This function must call {\tt{clHeapHooksRegister()}} with the appropriate
function pointers to override the implementation of heap provided by
OpenClovis.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap101}{clHeapLibInitialize}, \hyperlink{pageheap131}{clHeapLibCustomFinalize}
\end{Desc}
\newpage




\subsection{clHeapLibCustomFinalize}
\index{clHeapLibCustomFinalize@{clHeapLibCustomFinalize}}
\hypertarget{pageheap131}{}\paragraph{cl\-heap\-Lib\-Custom\-Finalize}\label{pageheap131}
\begin{Desc}
\item[Synopsis:]Customizes the finalization of heap library in {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize
\begin{verbatim}          ClRcT clHeapLibCustomFinialize(void );

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] None.
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] Heap library is not initialized through a previous call to {\tt{clHeapLibInitialize()}} or it is  
finalized using {\tt{clHeapLibFinalize()}}.
\end{description}

\end{Desc}
\begin{Desc}
\item[Description:]
This function is used to customize the finalization of the heap library.
This is an open function and the application developer should implement this function. This is called only
when an application indicates that it needs to customize heap through
{\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. The function is
available in {\tt{ASP/models/<model-name>/config/clHeapCustom.c}}
This function must call {\tt{clHeapHooksRegister()}} with the appropriate
function pointers to override the implementation of heap provided by
OpenClovis.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap102}{clHeapLibFinalize}, \hyperlink{pageheap130}{clHeapLibCustomInitialize}
\end{Desc}
\newpage



\subsection{clHeapHooksRegister}
\index{clHeapHooksRegister@{clHeapHooksRegister}}
\hypertarget{pageheap112}{}\paragraph{cl\-heap\-Hooks\-Register}\label{pageheap112}
\begin{Desc}
\item[Synopsis:]Register functions to be used in {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize
\begin{verbatim} ClRcT clHeapHooksRegister(
			CL_IN void *(*allocHook) (ClUint32T),
                     	CL_IN void *(*reallocHook)(void *,ClUint32T),
                     	CL_IN void *(*callocHook)(ClUint32T,ClUint32T),
                     	CL_IN void (*freeHook)(void *)
                     	);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em alloc\-Hook:}](in) Function that allocates memory. This function is invoked when an application calls
{\tt{clHeapAllocate()}} function.
\item[{\em realloc\-Hook:}](in) Function that changes the size of the memory. 
This function is invoked when an application calls {\tt{clHeapRealloc()}} function.
\item[{\em calloc\-Hook:}](in) Function that allocates memory for an
array. This function is invoked when an application calls {\tt{clHeapCalloc()}} function.
\item[{\em free\-Hook:}](in) Function that frees the
memory. This function is invoked when an application calls {\tt{clHeapFree()}} function.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-INITIALIZED:}] Heap library is not initialized or it is finalized.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER:}] One of the input argument is a NULL pointer.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] In {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}, this function is used to register the hooks for memory
management. The application should override the default
implementation of {\tt{clHeapLibCustomInitialize()}} and
{\tt{clHeapLibCustomFinalize()}} functions present in
{\tt{ASP/models/<model-name>/config/clHeapCustom.c}}. This
function should be called from {\tt{clHeapLibCustomInitialize()}}. In
{\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}, no memory allocation should be made before registering these functions.
\par
During the life of a process, two different set of hooks for memory
allocation should not be used. Unless due care is taken, memory
allocated by one set of hooks cannot be freed using the other set
of hooks as it leads to corruption of meta data structures.

\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap113}{clHeapHooksDeregister}\end{Desc}
\newpage





\subsection{clHeapHooksDeregister}
\index{clHeapHooksDeregister@{clHeapHooksDeregister}}
\hypertarget{pageheap113}{}\paragraph{cl\-heap\-Hooks\-Deregister}\label{pageheap113}
\begin{Desc}
\item[Synopsis:]De-registers the hooks registered for {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. \end{Desc}
\begin{Desc}
\item[Header File:]clHeapApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}
            		ClRcT clHeapHooksDeregister(void);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
None.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}] Function completed successfully.
\item[{\em CL\_\-ERR\_\-INITIALIZED:}] Heap library is not finalized through a previous call to the {\tt{clHeapLibFinalize()}} function.
\item[{\em CL\_\-ERR\_\-NOT\_\-INITIALIZED:}] Hooks were not registered through a previous call to {\tt{clHeapHooksRegister()}} function.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function is used to De-register the hooks registered for memory management in {\tt{CL\_\-HEAP\_\-CUSTOM\_\-MODE}}. After a 
call to this function, the memory related calls cannot be made until
another call is made to {\tt{clHeapHooksRegister}}. This function
should be called during the finalization of {\tt{clHeapLibFinalize()}} through
a call to open function {\tt{clHeapLibCustomFinalize()}} present in
{\tt{ASP/models/<model-name>/config/clHeapCustom.c}}.
\end{Desc}
\begin{Desc}
\item[library File:]lib\-Cl\-Utils\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageheap112}{clHeapHooksRegister}\end{Desc}


\chapter{Service Management Information Model}
TBD

\chapter{Service Notifications}
TBD

\chapter{Configuration}
TBD


\chapter{Debug CLIs}
TBD

\end{flushleft}
