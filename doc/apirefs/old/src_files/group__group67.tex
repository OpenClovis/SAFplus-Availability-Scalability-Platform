\hypertarget{group__group26}{
\chapter{Functional Overview}
\label{group__group26}
\index{Log Service@{Log Service}}
}


\begin{flushleft}

Computer programs record various events during their execution for further analysis. ASP Log Service facilitates recording information 
about these events. Any application or ASP component in the cluster can use the Log Service to record information. The applications or 
ASP components which record their information are called clients. Log Service persists the recorded information so that it is available for consumption. 
\par
The consumer of these Log Records can be an Off-line consumer or an 
On-line consumer. An On-line consumer consumes the information as and when it is generated. An Off-line consumer consumes the information after it is generated. 
Log Service does not interpret the information recorded by its clients. It treats the information as an octet Stream and does not apply any semantic meaning
to it.
\par
Information related to an event is stored as individual units. This unit is called a Log Record. Log Records are grouped together based on
a theme defined by its client. These groups are called Log Streams. Log Streams can be shared by various components of a single 
application or of different applications. The theme and the users of a Log Stream are defined by the application. These Log Streams flow
into Handlers. There are two types of handlers.
\begin{itemize}
\item
File handler: Persists the Log Records into the Log File. 
\item
On-line Viewer: Used to view the Log Records as they are generated. 
\end{itemize}
An archiving utility can siphon off Log Records from the Log File to another storage unit. 
\par
Log Service provides interfaces for:
\begin{itemize}
\item
Creating a Log Stream.
\item
Opening an existing Log Stream.
\item
Recording an event into an open Log Stream.
\item
Closing a Log Stream. 
\item
Changing the properties of Log Streams.
\item
Setting filters on the Log Stream to filter events where they are generated. 
\item
Registering interest in receiving certain Log Streams.
\item
Receiving Log Streams.
\end{itemize}



\chapter{Service Model}
\section{Usage Model}
\index{Usage Model@{Usage Model}}
The usage model of the Log Service is similar to a Producer-Consumer model. Loggers are the producers of the Log Records and 
Log Stream Handlers are the consumers of these Log Records. 
\par
Multiple Loggers can log into a single Log Stream. Similarly, a single record can be consumed by many Log Stream Handlers simultaneously. 
The usage model can also be considered as a Publisher-Subscriber model as Loggers and Log Stream Handlers are unaware of each other and 
each Log Stream Handler receives all the logged records. One of the Log Stream Handlers becomes the Log File Handler that persists the Log 
Records in the Log File. Applications like Off-line Log Viewer and Archiver work with the Log File Handler.

\includegraphics{Log1.jpg}
Usage Model of Log Service


\section{Functional Description}
\index{Functional Description@{Functional Description}}
The purpose of the Log Service is to record the information provided by the Logger for future use. This information is provided in the form of Log
Records. Log Records flow through a Log Stream and are persisted by the Log Service in the Log File.
\par
The Logger uses {\tt{clLogWriteAsync()}} API to place a Log Record into a Log Stream. Before using the services of Log Service, the Logger has to 
initialize the Log Service by invoking {\tt{clLogInitialize()}} API. {\tt{clLogInitialize()}} returns a {\tt{logServiceHandle}} that is 
used in subsequent operations on the Log.
\par
When this handle not required, the association can be closed by invoking {\tt{clLogFinalize()}} API. 
After initializing the Log Service, the Logger gains access to the Log Stream by invoking {\tt{clLogStreamOpen()}}. 
{\tt{clLogStreamOpen()}} returns a {\tt{logStreamHandle}} that can be used in {\tt{clLogWriteAsync()}} API to identify the Log Stream. 
When a Log Stream is not required by a Logger, it can close the Stream by invoking {\tt{clLogStreamClose()}}. 
A Log Client can change the filter of a Log Stream by invoking {\tt{clLogStreamFilterSet()}}.

\begin{Desc}
\item[Types of Consumers]
\end{Desc}
Consumers are of three types: can access the Log Records in the following ways:
\begin{itemize}
\item
Those who read Log Records On-line through Log Service.
\item
Those who read Log Records Off-line through Log Service.
\item
Those who read Log Records directly from the Log File.
\end{itemize}

\begin{description}
\item [On-line Consumers]
\end{description}

The on-line consumers are called Log Stream Handlers as they retrieve records in a push mode. They continuously wait for records and 
process them as they get it. For example, Log File Handler and on-line viewer. These handlers initialize the Log Service by
invoking {\tt{clLogInitialize()}} and register their interest in a particular Log Stream by invoking {\tt{clLogHandlerRegister()}}. 
After registration, the handler starts receiving the records through a callback to {\tt{ClLogRecordsDeliverCallbackT}}, registered 
during {\tt{clLogInitialize()}}. When the handler is not interested in receiving the Log Records for a particular Log Stream, 
it can cancel its registration by invoking {\tt{clLogHandlerDeregister()}} API.

\begin{description}
\item [Off-line Consumers]
\end{description}

The second type of consumers are Off-line consumers. These consumers operate in the pull mode and they explicitly request the Log Service
for Log Records, if they are available. Another important difference is these consumers work on the Log File instead of the Log Stream. 
For example, the Log Reader and Archiver. These consumers initialize the Log Service by invoking {\tt{clLogInitialize()}} and open a 
Log File by invoking {\tt{clLogFileOpen()}}. When they need more records, they invoke {\tt{clLogFileGetRecords()}}. After completion, 
they close the file by invoking {\tt{clLogFileClose()}}.
\par
The third kind of consumer is the off-line consumer who may not be present in the cluster itself. These consumers are out of scope of Log Service. 
They operate directly on the Log File. For example, Off-line viewer. 

\begin{Desc}
\item[At-most Once Guarantee]
\end{Desc}
Log Service provides At-most Once guarantee and ensures Log Records are not lost. Log Records can be lost due to many reasons. Some of 
them are: 
\begin{enumerate}
\item
Log Files have limited space. If the Archiver is not configured correctly, the size of the Log File can reach its limit even before 
the Archiver can remove certain Log Records to create space for more. The Log Service overwrites the oldest records and these overwritten
records are lost. 
\item
Log Records are lost if a node fails before moving recently generated Log Records into the Log File Handler for persistence. 
\item
Log Records are lost if the speed of flushing of new Log Records is slower than the rate of generation of Log Records. The local memory of
the Log Service Element can reach its limit and overwrite oldest Log Records. Thus, the overwritten Log Records are lost.
\end{enumerate}

\begin{Desc}
\item[Log Stream Attributes]
\end{Desc}

Each Log Stream is characterized by a set of attributes. The attributes are specified when the Stream is created and cannot be modified
during the lifetime of the Stream. These attributes are specified through {\tt{ClLogStreamAttributesT}} structure.
The attributes of a log Stream are: 
\begin{itemize}
\item
Name of the Log File.
\item
Location of the Log File where the Log Stream is to be persisted.
\item
Size of each record in the Log Stream.
\item
Maximum number of records that can be stored in one physical file.
\item
Action to be taken when the Log File size reaches the maximum limit.
\item
Backup copy of the Log File.
\item
Frequency at which the Log Records must be cleared. 
\end{itemize}
Multiple Log Streams can be persisted into a single Log File. Local and Global Streams can be combined together in a single Log File.
To ensure this, the values of the Stream attributes other than {\tt{flushFreq}} and {\tt{flushInterval}} must be the same.



\begin{Desc}
\item[Log File]
\end{Desc}

Log File is a logical concept and a collection of physical files. Each physical file is called a Log File Unit. 
A Log File can contain only one Log File Unit if the action to be taken when the Log File 
reaches its maximum limit is set to {\tt{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-HALT}} or {\tt{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-WRAP}}.
A Log File can contain multiple Log File Units if the action to be taken when the Log File 
reaches its maximum limit is set {\tt{to CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-ROTATE}}.
\par
The size of a Log File Unit is specified in {\tt{maxFileSize}}. Maximum number of Log File Units in a Log File is governed by {\tt{maxFilesRotated}}
attribute of Log Stream. The Log File Unit naming convention is as follows: \par
{\tt{fileName\_\-<creationTime>}}
\par
{\tt{fileName}} is a Stream attribute and {\tt{<creationTime>}} is the
wall clock time when this Log File Unit is created. A file called {\tt{fileName.cfg}} is generated for every Log File that stores the 
configuration information of the Log File. The file {\tt{fileName.cfg}} contains the attributes of the Log Streams in that Log File and 
{\tt{StreamId}} to {\tt{StreamName}} mapping.






\chapter{Service APIs}

\section{Type Definitions}
\index{Type Definitions@{Type Definitions}}

\subsubsection{ClLogHandleT}
\index{ClLogHandleT@{ClLogHandleT}}
\textit{typedef ClHandleT ClLogHandleT;}
\newline
\newline
The type of the handle that Log Service provides to a process when the Log Service library is initialized. 
A process uses this handle when it invokes Log service functions so that the Log Service can recognize the process.


\subsubsection{ClLogStreamHandleT}
\index{ClLogStreamHandleT@{ClLogStreamHandleT}}
\textit{typedef ClHandleT ClLogStreamHandleT;}
\newline
\newline
The type of the handle of a Log Stream that the Log Service provides to a process that:
\begin{itemize}
\item
Has opened a Stream for Logging or 
\item
Has registered itself as a Handler for a Stream. 
\end{itemize}
A process uses this handle while invoking functions of Log Service API on a Log Stream.


\subsubsection{ClLogFileHandleT}
\index{ClLogFileHandleT@{ClLogFileHandleT}}
\textit{typedef ClHandleT ClLogFileHandleT;}
\newline
\newline
The type of the handle of a Log File that the Log Service provides to a process that has opened a Log File for consuming Log Records.
A process uses this handle while invoking functions of Log Service API on a Log File.



\subsubsection{ClLogCallbacksT}
\index{ClLogCallbacksT@{ClLogCallbacksT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClLogStreamOpenCallbackT    clLogStreamOpenCallback;}\\
\>\>\>\>\textit{ClLogFilterSetCallbackT          clLogFilterSetCallback;}\\
\>\>\>\>\textit{ClLogWriteLogCallbackT         clLogStreamOpenCallback;}\\
\>\>\>\>\textit{ClLogRecordDeliverCallbackT	clLogRecordDeliverCallback;}\\
\textit{\} ClLogCallbacksT;}\end{tabbing}
The callback structure that the process provides to the Log Service. Currently, 
{\tt{clLogWriteCallback}} attribute is not supported. 


\subsubsection{ClLogStreamScopeT}
\index{ClLogStreamScopeT@{ClLogStreamScopeT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef enum \{}\\
\>\>\>\>\textit{CL\_LOG\_Stream\_GLOBAL = 0,}\\
\>\>\>\>\textit{CL\_LOG\_Stream\_LOCAL = 1,}\\
\textit{\} ClLogStreamScopeT;}\end{tabbing}
The enumeration {\tt{ClLogStreamScopeT}} contains the scope of the Log Stream. You can specify the scope of a Log Stream using this 
enumeration. A Log Stream can be local to a node (Local Log Stream) or global to the cluster (Global Log Stream).


\subsubsection{ClLogFileFullActionT}
\index{ClLogFileFullActionT@{ClLogFileFullActionT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef enum\{}\\
\>\>\>\>\textit{CL\_LOG\_FILE\_FULL\_ACTION\_ROTATE = 0,}\\
\>\>\>\>\textit{CL\_LOG\_FILE\_FULL\_ACTION\_WRAP = 1,}\\
\>\>\>\>\textit{CL\_LOG\_FILE\_FULL\_ACTION\_HALT = 2,}\\
\textit{\} ClLogFileFullActionT;}\end{tabbing}
 Using this enumeration, you can specify the action Log Service must take when the size of the Log File reaches its limit.
\begin{itemize}
\item \textit{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-ROTATE} - Creates a new Log File Unit when the size of the Log File reaches its limit. 
The {\tt{maxFilesRotated}} attribute of the Log Stream specifies the number of maximum Log File Units that can simultaneously exist.
The Log service deletes the oldest Log File Unit and creates a new Log File Unit.
\item
\textit{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-WRAP} - Treats the Log File as a circular buffer. Log Service starts overwriting the oldest 
records when the size of the Log File reaches its limit.
\item
\textit{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-HALT} - Log Service stops inserting records into the Log File.
\end{itemize}




\subsubsection{ClLogStreamAttributesT}
\index{ClLogStreamAttributesT@{ClLogStreamAttributesT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct\{}\\
\>\>\>\>\textit{ClCharT		*fileName;}\\
\>\>\>\>\textit{ClCharT		*filePath;}\\
\>\>\>\>\textit{ClUint32T		maxFileSize;}\\
\>\>\>\>\textit{ClUint32T		recordSize;}\\
\>\>\>\>\textit{ClBoolT		haProperty;}\\
\>\>\>\>\textit{ClFileFullActionT	fileFullAction;}\\
\>\>\>\>\textit{ClUint32T		maxFilesRotated;}\\
\>\>\>\>\textit{ClUint32T		flushFreq;}\\
\>\>\>\>\textit{ClTimeT		flushInterval;}\\
\>\>\>\>\textit{ClWatermarkT	highWatermark;}\\
\textit{\} ClLogStreamAttributesT;}\end{tabbing}
The structure {\tt{ClLogStreamAttributesT}} contains the attributes of a Log Stream. The fields of this structure have the following interpretation.
	\begin{itemize}
	\item
	\textit{fileName} - Prefix for the names of the Log File Units. The format of the name of a Log File Unit is 
	\par
	{\tt{fileName\_\-<creationTime>}} 
	\par
	where creation time is the wall clock time when the File Unit is created. This name is also used to create the configuration file name, 
	{\tt{fileName.cfg}}.
	\item
	\textit{filePath} - Path where Log File Units and configuration files are stored. This is a string with the following format:
	\par
	{\tt{<nodeName>:<absolutePath>}}
	\par
	where the {\tt{<nodeName>}} is the logical node name in the cluster where the file is stored and 
	{\tt{<absolutePath>}} is the absolute path on that node. This path must be previously created as Log Service does not create any missing directories.
	\item
	\textit{maxFileSize} - Size of each Log File Unit for this Log Stream measured in bytes. 
	There is no previously defined limit on the size of the Log File Unit if {\tt{maxFileSize}} is set to zero, 
	\item
	\textit{recordSize} - Size of each Log Record in this Log Stream measured in bytes.
	\item
	\textit{haProperty} - If this attribute is set to {\tt{CL\_\-TRUE}}, the Log File where this Log Stream is stored must be persistent.
	 If it is set to {\tt{CL\_\-FALSE}} and if the node hosting this Log File fails, the Log File is not retained.
	\item
	\textit{fileFullAction} - Action that the Log Service must take when size of the Log File Unit reaches its limit. Refer to the enumeration 
	\textit{ClLogFileFullActionT} for details on this field.
	\item
	\textit{maxFileRotated} - Indicates the number of Log File Units in a Log File if the {\tt{fileFullAction}} is set to 
	{\tt{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-ROTATE}}. If {\tt{fileFullAction}} is set to any other value, this field is ignored. 
	A value of zero indicates no previously defined upper limit on the number of Log File Units in the Log File.
	\item
	\textit{flushFreq} - Number of Log Records after which the Log Stream must be cleared. This is the maximum number of records on a node which 
	are not persisted. Log Service guarantees that no more than {\tt{flushFreq}} number of records will be lost if a 
	node fails. A value of zero indicates that this field is ignored and Log Records are cleared based on {\tt{flushInterval}}.  
	{\tt{flushFreq}} or {\tt{flushInterval}} must have a non-zero value for a Log Stream.
\item
\textit{flushInterval} - Time in nanoseconds after which the Log Stream must be cleared. This is the maximum duration of time a Log Record can stay 
in a Log Stream without being persisted. Log Service guarantees that Log Records generated in {\tt{flushInterval}} time are not lost on a node failure. 
A value of zero indicates that this field is ignored and Log Records are cleared based on flushFreq. 
	{\tt{flushFreq}} or {\tt{flushInterval}} must have a non-zero value for a Log Stream.
\item
\textit{highWatermark} - If the Log File size reaches the higher value of this limit, an event is published and an alarm is issued. The Archiver 
combines the oldest Log Records into an archive to free up space in the Log File before the size of the Log File reaches its limit. No new event is 
generated until the Log File utilization goes below lower value of this limit. Both the values are specified in terms of percentage of Log File size.

\end{itemize}


\subsubsection{ClLogStreamOpenFlagsT}
\index{ClLogStreamOpenFlagsT@{ClLogStreamOpenFlagsT}}
\textit{typedef ClUint8T ClLogStreamOpenFlagsT;}
\newline
\newline
{\tt{ClLogStreamOpenFlagsT}} specifies the open attributes used in {\tt{clLogStreamOpen()}} and {\tt{clLogStreamOpenAsync()}} while opening a Log Stream
for Logging.
\newline 
\newline
\textit{\#define CL\_\-LOG\_\-Stream\_\-CREATE 0x1} - A value or parameter of type {\tt{ClLogStreamOpenFlagsT}}. It is either zero or bitwise OR of the 
following: 
\begin{itemize}
\item
\textit{CL\_\-LOG\_\-Stream\_\-CREATE} - This flag requests the creation of a Log Stream if the identified Log Stream does not exist.
\end{itemize}
	


\subsubsection{ClLogStreamInfoT}
\index{ClLogStreamInfoT@{ClLogStreamInfoT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct\{}\\
\>\>\>\>\textit{ClNameT			StreamName;}\\
\>\>\>\>\textit{ClLogStreamScopeT		StreamSope;}\\
\>\>\>\>\textit{ClCharT			*pNodeName;}\\
\>\>\>\>\textit{ClStreamAttributesT	StreamAttributes;}\\
\textit{\} ClLogStreamInfoT;}\end{tabbing}
The structure \textit{ClLogStreamInfoT} contains information about a Log Stream. The fields of this structure have the following interpretation:
\begin{itemize}
\item
\textit{StreamName} - Name of the Log Stream that is unique within its namespace.
\item
\textit{StreamScope} - Scope of the Stream. It can take the values specified in {\tt{ClLogStreamScopeT}}.
\item
\textit{pNodeName} - Name of the node on which the Log Stream exists. This is valid if the {\tt{StreamScope}} is set to {\tt{CL\_\-LOG\_\-Stream\_\-LOCAL}}. If 
{\tt{StreamScope}} is set to {\tt{CL\_\-LOG\_\-Stream\_\-GLOBAL}}, this field is ignored. It is a string that terminates with NULL.
\item
\textit{StreamAttributes} - Attributes of the Log Stream identified by 3-tuple {\tt{StreamName}}, {\tt{StreamScope}}, and {\tt{pNodeName}}.
\end{itemize}


\subsubsection{ClLogStreamHandlerFlagsT}
\index{ClLogStreamHandlerFlagsT@{ClLogStreamHandlerFlagsT}}
\textit{typedef ClUint8T ClLogStreamHandlerFlagsT;}
\newline
\newline
The following values specify the Log Handler options used in {\tt{clLogStreamregister()}} while registering as a handler for a Log Stream.
{\tt{\#define CL\_\-LOG\_\-HANDLER\_\-WILL\_\-ACK 0x1}} - A value or parameter of type {\tt{ClLogStreamHandlerFlagsT}}. It is either zero or bitwise 
OR of the following: 
\begin{itemize}
\item
\textit{CL\_\-LOG\_\-HANDLER\_\-WILL\_\-ACK} - This flag informs the Log Service that this handler acknowledges all the Log Records it receives.
\end{itemize}




\subsubsection{ClLogSeverityT}
\index{ClLogSeverityT@{ClLogSeverityT}}
\textit{typedef ClUint8T ClLogSeverityT;}
\newline
\newline
{\tt{ClLogSeverityT}} specifies the log severity levels supported by the Log Service. It can take one of the following values:
\begin{itemize}
\item \textit{\#define CL\_\-LOG\_\-SEV\_\-EMERGENCY 0x1}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-ALERT 0x2}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-CRITICAL 0x3}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-ERROR 0x4}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-WARNING 0x5}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-NOTICE 0x6}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-INFO 0x7}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-DEBUG 0x8}
	\item\textit{\#define CL\_\-LOG\_\-SEV\_\-MAX 0x15}
\end{itemize}	


\subsubsection{ClLogSeverityFilterT}
\index{ClLogSeverityFilterT@{ClLogSeverityFilterT}}
\textit{typedef ClUint16T ClLogSeverityFilterT;}
\newline
\newline
A variable of this type is used as a bitmap. Values from {\tt{ClLogSeverityT}} are used to set individual bits in this bitmap.




\subsubsection{ClLogFilterFlagsT}
\index{ClLogFilterFlagsT@{ClLogFilterFlagsT}}
\textit{typedef ClUint8T ClLogFilterFlagsT;}
\newline
\newline
{\tt{ClLogFilterFlagsT}} is used to determine if the new filter set is used to overwrite old filter or to
modify the old filter. It can take one of the following values:
\begin{itemize}
\item
\textit{\#define CL\_\-LOG\_\-FILTER\_\-ASSIGN 0x1} - Discards the old filter settings and uses the new settings.
\item
\textit{\#define CL\_\-LOG\_\-FILTER\_\-MERGE\_\-ADD	0x2} - Adds to the old filter settings as per filter settings provided by ORing 
the new filter with old filter.
\item
\textit{\#define CL\_\-LOG\_\-FILTER\_\-MERGE\_\-DELETE 0x3} - Deletes the old filter settings as per filter settings provided by 
clearing the new filter bits from old filter.
\end{itemize}	


\subsubsection{ClLogFilterT}
\index{ClLogFilterT@{ClLogFilterT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClLogSeverityFilterT	logSeverityFilter;}\\
\>\>\>\>\textit{ClUint16T			logMsgIdSetLength;}\\
\>\>\>\>\textit{ClUint8T			*pLogMsgIdSet;}\\
\>\>\>\>\textit{ClUint16T			logCompIdSetLength;}\\
\>\>\>\>\textit{ClUint8T			*pLogCompIdSet;}\\
\textit{\} ClLogFilterT;}\end{tabbing}
The structure contains the filter settings. The members of this structure have the following interpretation:
\begin{itemize}
\item
\textit{logSeverityFilter} - This field identifies the severity levels to be masked. Each severity level has a bit identified in this
bitmap. These bits identify the severity levels which must be masked or prevented from entering the Log Stream.
\item
\textit{logMsgIdSetLength} - Number of octets in the memory chunk pointed by {\tt{pLogMsgIdSet}} field.
\item
\textit{pLogMsgIdSet} - Pointer to the memory chunk which is treated as a bitmap. The bits set in this bitmap identify the message IDs to be masked. 
Bit numbers in this bitmap are the same as the message ID.
\item
\textit{logCompIdSetLength} - Number of octets in the memory chunk pointed by {\tt{pLogCompIdSet}} field.
\item
\textit{pLogCompIdSet} - Pointer to a memory chunk which is treated as a bitmap. The bits set in this bitmap identify the component IDs to be masked. 
The lower octet of the component ID identifies the class of the component and the higher octet identifies the node on which 
it is running. Log Service sets the filter on the class of the component and so, only the lower octet is used. The bit number maps to the lower
octet indicating the state of the Log Records from a class of components.
\end{itemize}	







\newpage
\section{Library Life Cycle Functions}
\subsubsection{clLogInitialize}
\index{clLogInitialize@{clLogInitialize}}
\hypertarget{pagelog101}{}\paragraph{cl\-Log\-Initialize}\label{pagelog101}
\begin{Desc}
\item[Synopsis:]Initializes the Log Service and ensures version compatibility.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}       
				ClRcT clLogInitialize(
					CL_OUT	ClLogHandleT	*phLog,
					CL_IN const ClLogCallbacksT	*pLogCallbacks,
					CL_INOUT	ClVersionT		*pVersion
						     );
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em phLog}]:(out) Handle returned by the Log Service. This handle is used by the calling process for subsequent invocation of Log Service APIs
so that Log Service can recognize the process.
\item[{\em plogCallbacks}]:(in) Pointer to {\tt{ClLogCallbacksT}} structure containing the callback functions that the Log Service can invoke on this
process. No callback is registered if {\tt{pLogCallbacks}} is set to NULL, . 
\item[{\em pVersion}]:(in/out) As an input parameter, it points to the required Log Service version. 
If used as an output parameter, it indicates the version supported by Log Service. The minor version field should not be filled as it is ignored by 
the Log Service. For details on this datatype, refer to the chapter, Common Type Definitions in the \textit{OpenClovis\_\-ApiRef\_\-Overview-2.3.pdf}.

\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The Log Service initialized successfully.
\item[{\em CL\_\-ERR\_\-VERSION\_\-MISMATCH}]: The supplied version is not supported by current implementation.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation defined timeout occurred before the call could complete.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service could not be provided at this time. The process may try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]:  The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER}]: {\tt{phLog}} or {\tt{pVersion}} is NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function performs the following:
\begin{itemize}
\item
Initializes the Log Service
\item
Performs version compatibility
\item
Checks and registers various callbacks. 
\end{itemize}
This function must be invoked before any other function of Log Service API can be used. The handle {\tt{phLog}} is returned as the reference to
association of the process with the Log Service. The process uses this handle in subsequent interactions with the Log Service.
\par
If the implementation supports the required {\tt{releaseCode}} (a member of {\tt{pVersion}}) and its {\tt{majorVersion}} is greater than or equal to the 
required {\tt{majorVersion}}, the functions returns {\tt{CL\_\-OK}} and {\tt{pVersion}} is set to:
\begin{itemize}
\item
\textit{releaseCode} - Required release code.
\item
\textit{majorVersion} - Highest major version supported for the required release code.
\item
\textit{minorVersion} - Highest minor version supported for the returned release code and major version.
\end{itemize}
If this condition is not met, the function returns {\tt{CL\_\-ERR\_\-VERSION\_\-MISMATCH}} and {\tt{pVersion}} is set to:
\begin{itemize}
\item
\textit{releaseCode:}
	\begin{itemize}
	\item
	required {\tt{releaseCode}}, if it is supported.
	\item
	Lowest {\tt{releaseCode}} higher than required {\tt{releaseCode}}, if the required {\tt{releaseCode}} is lower than any 
	supported {\tt{releaseCode}}.
	\item
	Highest {\tt{releaseCode}} lower than required {\tt{releaseCode}}, if the required {\tt{releaseCode}} is higher than any 
	supported {\tt{releaseCode}}.
	\end{itemize}
\item
\textit{majorVersion} = highest major version supported for returned {\tt{releaseCode}}.
\item
\textit{minorVersion} = highest minor version supported for returned {\tt{releaseCode}} and majorVersion.
\end{itemize}
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog104}{clLogFinalize()}\end{Desc}
\newpage



\subsubsection{clLogFinalize}
\index{clLogFinalize@{clLogFinalize}}
\hypertarget{pagelog102}{}\paragraph{cl\-Log\-Finalize}\label{pagelog102}
\begin{Desc}
\item[Synopsis:]Finalizes the Log Service and releases all the acquired resources.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
						ClRcT clLogFinalize(
           						CL_IN    ClLogHandleT        hLog
								   )
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. This handle identifies the association to be closed 
between the calling process and the Log Service.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The Log Service finalized successfully.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}} is not a valid handle obtained through a previous invocation to 
{\tt{clLogInitialize()}} or the association has already been closed by an invocation to {\tt{clLogFinalize()}}.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]:  The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation defined timeout occurred before the call could complete.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function closes the association between the Log Service and the invoking process (identified by the handle {\tt{hLog}}) and frees up
the resources acquired by this association. Functions of Log Service API function must not be invoked after a successful invocation to this 
function. For each successful invocation to {\tt{clLogInitialize()}}, the process must invoke {\tt{clLogFinalize()}} before shutting down gracefully. 
On successful completion, this function frees up all the resources acquired by this association. Opened Log Stream handles are closed, 
registrations for Log Stream Handling are unregistered, and opened Log File handles are closed. After a call to this function, the selection object 
becomes invalid.
\par
If a thread of this process has invoked {\tt{clLogDispatch()}} on the association with {\tt{CL\_\-DISPATCH\_\-BLOCKING}} flag and this function executes 
successfully, {\tt{clLogDispatch()}} function returns {\tt{CL\_\-OK}}. 
\par
On successful completion of this function, all pending callbacks referring to this {\tt{hLog}} are canceled. As the invocation of callbacks is an 
asynchronous operation, some callbacks may still be delivered after this invocation returns successfully.
If a process terminates without finalizing its association with Log Service, Log Service will implicitly finalize all such associations.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog103}{clLogSelectionObjectGet()}, \hyperlink{pagelog104}{clLogDispatch()}\end{Desc}
\newpage





\subsubsection{clLogSelectionObjectGet}
\index{clLogSelectionObjectGet@{clLogSelectionObjectGet}}
\hypertarget{pagelog103}{}\paragraph{cl\-Log\-Selection\-Object\-Get}\label{pagelog103}
\begin{Desc}
\item[Synopsis:] Returns an operating system object to wait for callbacks.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        	ClRcT clLogSelectionObjectGet(
           						CL_IN		ClLogHandleT		hLog,
							CL_OUT	ClSelectionObjectT*	pSelectionObject
							);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. This handle identifies the association between the 
calling process and the Log Service for which Selection Object is to be returned.
\item[{\em pselectionObject}]:(out) Pointer to Selection Object (operating system object). This object can be used to detect any pending callbacks.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: Selection Object executed successfully.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}} is not a valid handle obtained through a previous invocation to 
clLogInitialize() or the association has already been closed by another invocation to {\tt{clLogFinalize()}}.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or another module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER}]: {\tt{pSelectionObject}} is NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function returns an operating system object which can be used to detect any pending callbacks. When a pending callback is
detected, it is dispatched through an invocation to {\tt{clLogDispatch()}}. This Selection Object is specific to the association identified by 
{\tt{hLog}}. Returned Selection Object is valid until association identified by {\tt{hLog}} is closed through invocation to {\tt{clLogFinalize()}}.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so 
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog104}{clLogDispatch()}, \hyperlink{pagelog102}{clLogFinalize()}\end{Desc}
\newpage


\subsubsection{clLogDispatch}
\index{clLogDispatch@{clLogDispatch}}
\hypertarget{pagelog104}{}\paragraph{cl\-Log\-Dispatch}\label{pagelog104}
\begin{Desc}
\item[Synopsis:] Dispatches pending callbacks on the specified association.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	ClRcT clLogDispatch(
           					CL_IN    ClLogHandleT        hLog,
           					CL_IN    ClDispatchFlagsT    dispatchFlags
							   )
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. It identifies the association between the calling process and 
the Log Service for which pending callbacks are to be dispatched.
\item[{\em dispatchFlags}]:(in) Flags specifying the callback execution behavior of the {\tt{clLogDispatch()}} function. It can take the
following values: 
\begin{itemize}
\item
{\tt{CL\_\-DISPATCH\_\-ONE}}
\item
{\tt{CL\_\-DISPATCH\_\-ALL}} or 
\item
{\tt{CL\_\-DISPATCH\_\-BLOCKING}}
\end{itemize}
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The callbacks dispatched successfully. When the {\tt{dispatchFlags}} is set to {\tt{CL\_\-DISPATCH\_\-BLOCKING}}, and a subsequent
{\tt{clLogFinalize()}} is called, this function returns {\tt{CL\_\-OK}}.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}} is not a valid handle obtained through a previous invocation to 
{\tt{clLogInitialize()}} or the association has already been closed by another invocation to {\tt{clLogFinalize()}}.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: {\tt{dispatchFlags}} is set to a value other than {\tt{CL\_\-DISPATCH\_\-ONE, CL\_\-DISPATCH\_\-ALL}} and 
CL\_\-DISPATCH\_\-BLOCKING.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function invokes any pending callbacks on the association specified by {\tt{hLog}}. It is executed in the context of a 
calling thread. If {\tt{dispatchFlags}} is set to {\tt{CL\_\-DISPATCH\_\-ONE}}, the first pending callback is executed and the function returns. If 
{\tt{CL\_\-DISPATCH\_\-ALL}} is specified, all the pending callbacks are executed one after another. 
\par 
If {\tt{CL\_\-DISPATCH\_\-BLOCKING}} is specified, the thread calls all the pending callbacks one after another, waits for other callbacks, and calls
them when they become pending. The function does not return until the association is closed using {\tt{clLogFinalize()}}.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog103}{clLogSelectionObjectGet()}, 
\hyperlink{pagelog102}{clLogFinalize()}\end{Desc}
\newpage




\subsubsection{clLogStreamListGet}
\index{clLogStreamListGet@{clLogStreamListGet}}
\hypertarget{pagelog105}{}\paragraph{cl\-Log\-Stream\-List\-Get}\label{pagelog105}
\begin{Desc}
\item[Synopsis:] Retrieves the list of all Log Streams currently available in the cluster.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	ClRcT clLogStreamListGet(
						CL_IN		ClLogHandleT	hLog,
						CL_OUT	ClUint32T		*pNumStreams,
						CL_OUT	ClLogStreamInfoT	**ppLogStreams
					);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. It identifies the association between the calling process and 
the Log Service for which pending callbacks are to be dispatched.
\item[{\em *pNumStreams}]:(out) Number of Streams that are currently open in the cluster. This indicates the number of entries in {\tt{ppLogStreams}}.
Memory for {\tt{pNumStreams}} is allocated and freed by the calling process.
\item[{\em **ppLogStreams}]:(out) Pointer to a memory area where pointer to array of Log Stream information is stored. Each entry in this array 
corresponds to a Log Stream in the cluster. Memory for {\tt{ppLogStreams}} is allocated and freed by the calling process. Memory for {\tt{*ppLogStreams}} 
is allocated by the Log Service and freed by the calling process.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The callbacks dispatched successfully. When the {\tt{dispatchFlags}} is set to {\tt{CL\_\-DISPATCH\_\-BLOCKING}}, and a subsequent
{\tt{clLogFinalize()}} is called, this function returns {\tt{CL\_\-OK}}.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}} is not a valid handle obtained through a previous invocation to 
{\tt{clLogInitialize()}} or the association has already been closed by another invocation to {\tt{clLogFinalize()}}.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation defined timeout occurred before the call could complete.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER}]: Either {\tt{pNumStreams}} or {\tt{ppLogStreams}} are passed as NULL.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] The function returns information about the Log Streams in the cluster. It is used by Log Handlers to access Log Streams 
they are interested in.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog112}{clLogStreamRegister()}, 
\hyperlink{pagelog102}{clLogFinalize()}\end{Desc}
\newpage





\section{Functional APIs}
\subsubsection{clLogStreamOpen and clLogStreamOpenAsync}
\index{clLogStreamOpen, clLogStreamOpenAsync@{clLogStreamOpen, clLogStreamOpenAsync}}
\hypertarget{pagelog106}{}\paragraph{cl\-Log\-Stream\-Open}\label{pagelog106}
\begin{Desc}
\item[Synopsis:] Opens a Log Stream for logging.  \end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
					ClRcT clLogStreamOpen(
						CL_IN		ClLogHandleT		hLog,
						CL_IN		ClNameT			StreamName,
						CL_IN 		ClLogStreamScopeT		StreamScope,
						CL_IN		ClLogStreamAttributesT	*pStreamAttributes,
						CL_IN		ClLogStreamOpenFlagsT	StreamOpenFlags,
						CL_IN		ClTimeT			timeout,
						CL_OUT		ClLogStreamHandleT	*phStream
					);
					
					
					ClRcT clLogStreamOpenAsync(
						CL_IN		ClLogHandleT		hLog,
						CL_IN		ClNameT			StreamName,
						CL_IN 		ClLogStreamScopeT		StreamScope,
						CL_IN		ClLogStreamAttributesT	*pStreamAttributes,
						CL_IN		ClLogStreamOpenFlagsT	StreamOpenFlags,
						CL_IN		ClInvocationT		invocation
					);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. It identifies the association between the calling process and 
the Log Service for which pending callbacks are to be dispatched.
\item[{\em StreamName}]:(in) Name of the Log Stream to be opened for logging. It can be a pre-defined (modeled) Log Streams or a Log Stream that is being 
dynamically created.
\item[{\em StreamScope}]:(in) Scope of the Log Stream.
\item[{\em pStreamAttributes}]:(in) Attributes of the Log Stream that need to be opened. Refer to {\tt{ClLogStreamAttributesT}} in the Type Definitions 
chapter for details on this parameter. 
\par 
If a pre-defined Log Stream is being opened, this must be NULL. 
\par
If the intent is only to open an existing Log Stream (identified by {\tt{StreamName}} and {\tt{StreamScope}}) this value must be NULL. 
\par
If the intent is to open and create a new Log Stream, this parameter must have the attributes of the new Stream and {\tt{StreamOpenFlags}} must
be ORed with {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}}. 
\par
If the intent is to open and possibly create (if not already created) a Stream, this parameter must have 
the attributes of the new Stream. These attributes must match the attributes of the Stream if a Stream exists.


\item[{\em StreamOpenFlags}]:(in) It is the bitwise ORed value of the flags defined in {\tt{ClLogStreamHandlerFlagsT}}. 
{\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must be specified if the intention is to open and create a new Stream. If a pre-defined Streams is to be opened, 
{\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must not be specified.

\item[{\em timeout}]:(in) This is applicable for {\tt{clLogStreamOpen()}} operation. If the call does not complete in the timeout period, it is 
considered to have failed. The Log Stream is either opened and/or created, but the outcome cannot be determined. A value of zero indicates
no timeout period.

\item[{\em phStream}]:(out) Pointer to retrieve the Log Service generated handle for the Log Stream. This handle must be used for subsequent operations on 
the Log Stream.

\item[{\em invocation}]:(in) This is applicable only for {\tt{clLogStreamOpenAsync()}} and is used to correlate the response received through 
{\tt{ClLogStreamOpenCallbackT}}.

\end{description}
\end{Desc}

\begin{Desc}
\item[Return values:]
\begin{description}

\item[{\em CL\_\-OK}]: The Log Stream opened successfully.

\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}}, obtained through a previous invocation to 
{\tt{clLogInitialize()}}, is not a valid handle or the association is closed by an invocation to {\tt{clLogFinalize()}}.

\item[{\em CL\_\-ERR\_\-TIMEOUT}]: Log Stream could not be opened in the timeout period. This is applicable for {\tt{clLogStreamOpen()}} only.

\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.

\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: Some of the parameters are not valid. The conditions can be one of the following:

		\begin{itemize}
		\item
		The {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} parameter in {\tt{StreamOpenFlags}} is not set and {\tt{pStreamAttributes}} is not NULL.
		\item
		The {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} parameter in {\tt{StreamOpenFlags}} is set and {\tt{pStreamAttributes}} is NULL.
		\item
		Length field of {\tt{StreamName}} is set to zero.
		\item
		{\tt{filePath}}, member of {\tt{pStreamAttributes}}, does not follow the pattern defined in {\tt{ClLogStreamAttributesT}}.
		\item
		{\tt{maxFileSize}}, member of {\tt{pStreamAttributes}}, is not a multiple of {\tt{recordSize}}.
		\item
		{\tt{fileFullAction}}, member of {\tt{pStreamAttributes}}, does not have a value defined in {\tt{ClLogFileFullActionT}}.
		\item
		{\tt{Both flushFreq}} and {\tt{flushInterval}}, members of {\tt{pStreamAttributes}}, are set to zero.
		\item
		{\tt{highWatermark}}, member of {\tt{pStreamAttributes}}, has values outside 0-100 range.
		\item
		{\tt{StreamScope}} does not have the value defined in {\tt{ClLogStreamScopeT}}.
		\item
		{\tt{timeout}} is specified as a negative value.
		\end{itemize}

\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.

\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.

\item[{\em CL\_\-ERR\_\-NOT\_\-EXIST}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag of {\tt{StreamOpenFlags}} is not set and the Stream does not exist.

\item[{\em CL\_\-ERR\_\-ALREADY\_\-EXIST}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag of {\tt{StreamOpenFlags}} is set but the Stream exists
and is not created with attributes specified in {\tt{pStreamAttributes}}.

\item[{\em CL\_\-ERR\_\-BAD\_\-FLAGS}]: The bits in {\tt{StreamOpenFlags}} are not set as defined in {\tt{ClLogStreamHandlerFlagsT}}.

\item[{\em CL\_\-ERR\_\-NO\_\-CALLBACK}]: This is applicable for {\tt{clLogStreamOpenAsync()}} only. {\tt{pLogCallbacks}} or {\tt{clLogStreamOpenCallback}}
(member of {\tt{pLogCallbacks}}), is NULL in the previous invocation to {\tt{clLogInitialize()}} through which {\tt{hLog}} was obtained.

\end{description}
\end{Desc}

\begin{Desc}
\item[Description:] This function opens a Log Stream for logging operation. If the Log Stream is not a pre-defined Stream and if the application has to
create it, {\tt{pStreamAttributes}} must be specified and {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must be set in {\tt{StreamOpenFlags}}.
If {\tt{pStreamAttributes}} is not NULL, {\tt{flushFreq}} or {\tt{flushInterval}} (members of {\tt{pStreamAttributes}}), must also have non-zero values.
\par
Invocation to {\tt{clLogStreamOpen()}} is blocking. If the Log Stream is opened, the function returns a handle to the newly opened Stream. 
If the Log Stream is not opened, it returns an error.
\par
Call to the {\tt{clLogStreamOpenAsync()}} is non-blocking.  
{\tt{ClLogStreamOpenCallbackT}} (registered during {\tt{clLogInitialize()}}) is invoked when this function completes execution. {\tt{ClLogStreamOpenCallbackT}}
returns an {\tt{Invocation}} value to the calling process. This {\tt{Invocation}} value is used to correlate the invocation of {\tt{clLogStreamOpenAsync()}} with 
the invocation of {\tt{ClLogStreamOpenCallbackT()}}.
\par
The handle obtained through an invocation to these functions should be used for Logging operation only. It cannot be used as a consumer of Log Records.
An application can open a single Stream for logging multiple times and it obtains a new handle every time. A separate invocation to 
{\tt{clLogStreamClose()}} should be made for each successful invocation to these functions to avoid any leakage of resources.

\end{Desc}

\begin{Desc}
\item[Library File:] libClLog.so\newline
libClLog.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog108}{clLogStreamClose()}, \hyperlink{pagelog109}{ClLogStreamWriteAsync()},
\hyperlink{pagelog107}{ClLogStreamOpenCallbackT()}\end{Desc}
\newpage




\subsubsection{ClLogStreamOpenCallbackT}
\index{ClLogStreamOpenCallbackT@{ClLogStreamOpenCallbackT}}
\hypertarget{pagelog107}{}\paragraph{cl\-Log\-Stream\-Open\-CallbackT}\label{pagelog107}
\begin{Desc}
\item[Synopsis:] This functions is the response given to an asynchronous request for opening a Log Stream.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
					typedef void (*ClLogStreamOpenCallbackT)(
						CL_IN	ClInvocationT		invocation,
						CL_IN	ClLogStreamHandleT	hStream,
						CL_IN	ClRcT			rc
					);

\end{verbatim}
\normalsize
\end{Desc}

\begin{Desc}
\item[Parameters:] 
\begin{description}
\item[{\em invocation}]:(in) Parameter passed by the process during a previous invocation to {\tt{clLogStreamOpenAsync()}} and returned by Log Service.
This is used for correlating this response with the invocation of {\tt{clLogStreamOpenAsync()}}.
\item[{\em hStream}]:(in) Handle to the opened Log Stream. This handle is valid only if the value of {\tt{rc}} is {\tt{CL\_\-OK}}. This handle
must be used for subsequent operations on this Log Stream.
\item[{\em rc}]:(in) Return code of the open operation initiated by {\tt{clLogStreamOpenAsync()}}. Following are the return codes:
\item[{\em CL\_\-OK}]: The Log Stream opened successfully.
\item[{\em CL\_\-ERR\_\-BAD\_\-FLAGS}]: The bits in {\tt{StreamOpenFlags}} are not set as defined in {\tt{ClLogStreamHandlerFlagsT}}.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: Log Stream could not be opened within the timeout period.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NOT\_\-EXISTS}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag is not set in {\tt{StreamOpenFlags}} and the Stream does not exist
\item[{\em CL\_\-ERR\_\-ALREADY\_\-EXIST}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag is set in {\tt{StreamOpenFlags}} but the Stream already exists. 
The Stream is not created with attributes specified by {\tt{pStreamAttributes}}.
\end{description}
\end{Desc}

\begin{Desc}
\item[Return values:] 
This callback does not return any values.
\end{Desc}
\begin{Desc}
\item[Description:] The Log Service invokes this function when the operation initiated by the invocation of {\tt{clLogStreamOpenAsync()}} is completed.
If successful, {\tt{rc}} is set to {\tt{CL\_\-OK}} and a valid Stream handle is contained in {\tt{hStream}}. If the function fails, {\tt{rc}} is set to 
the appropriate error code.
\end{Desc}

\begin{Desc}
\item[Library File:] 
libClLog.so
\newline
libClLog.a
\end{Desc}

\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog106}{clLogStreamOpenAsync()}, \hyperlink{pagelog108}{clLogStreamClose()}, 
\hyperlink{pagelog109}{clLogStreamWriteAsync()}\end{Desc}	
\newpage



\subsubsection{clLogStreamClose}
\index{clLogStreamClose@{clLogStreamClose}}
\hypertarget{pagelog108}{}\paragraph{cl\-Log\-Stream\-Close}\label{pagelog108}
\begin{Desc}
\item[Synopsis:]Closes an open Log Stream. \end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
				ClRcT clLogStreamClose(
					CL_IN	ClLogStreamHandleT		hStream
						      );

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamOpen()}}. This handle identifies the Log Stream that 
is required to be closed.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The Log Stream closed successfully.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: The Log Stream handle is not valid. It is not received through a previous invocation to 
{\tt{clLogStreamOpen()}} or it is closed through an invocation to {\tt{clLogStreamClose()}}, or {\tt{hLog}} supplied to {\tt{clLogStreamOpen()}} or 
{\tt{clLogStreamOpenAsync()}} during opening of this Stream is previously finalized.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation specific timeout occurred before the call could be completed. Cannot determine if
the Log Stream is closed.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function closes a Log Stream identified by {\tt{hStream}}. {\tt{hStream}} is received through a previous invocation of  
{\tt{clLogStreamOpen()}} or {\tt{clLogStreamOpenAsync()}}. After a successful completion or a failure of this function, {\tt{hStream}} is no 
longer valid and must not be used for any other Stream related operations. If {\tt{hStream}} represents a Log Stream which is not pre-defined and 
is not opened by any process in the cluster, the Log Stream is deleted. When all persistent Log Streams in a Log File are deleted, the Log File is closed.
\par
Closing a Log Stream releases all the resources allocated by Log Service to this instance of opening. A process is responsible for closing the Log Streams 
it opens before termination. If the process does not close its Log Streams, the Log Service implicitly closes all such Log Streams.
\par
On successful completion of this call, all pending callbacks referring to this {\tt{hStream}} are canceled. As the invocation of callbacks is an 
asynchronous operation, some callbacks can be delivered after this call returns successfully.
\end{Desc}
\begin{Desc}
\item[Library File:] 
libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog106}{clLogStreamOpen()}, \hyperlink{pagelog106}{ClLogStreamOpenAsync()}, 
\hyperlink{pagelog107}{ClLogStreamOpenCallbackT()}, \hyperlink{pagelog109}{clLogStreamWriteAsync()}
\end{Desc}
\newpage



\subsubsection{clLogStreamWriteAsync and clLogStreamWriteAsync}
\index{clLogStreamWriteAsync, clLogStreamVWriteAsync@{clLogStreamWriteAsync, clLogStreamVWriteAsync}}
\hypertarget{pagelog109}{}\paragraph{cl\-Log\-Stream\-Write\-Async}\label{pagelog109}
\begin{Desc}
\item[Synopsis:] Logs a Log Record in the specified Log Stream.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
					ClRcT clLogStreamWriteAsync(
						CL_IN	ClLogStreamHandleT	hStream, 
						CL_IN	ClLogSeverityT		severity,
						CL_IN	ClUint16T			serviceId,
						CL_IN	ClUint32T			msgId,
						...
					);
					
					ClRcT clLogStreamWriteAsync(
						CL_IN	ClLogStreamHandleT	hStream, 
						CL_IN	ClLogSeverityT		severity,
						CL_IN	ClUint16T			serviceId,
						CL_IN	ClUint32T			msgId,
						CL_IN va_list			list
					);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamOpen()}}. This handle identifies the Log Stream in which the
Log Record is to be placed.
\item[{\em severity}]:(in) This field must be set to one of the values defined in {\tt{ClLogSeverityT}}. {\tt{ClLogSeverityT}} defines the severity level
of the Log Record.
\item[{\em serviceId}]:(in) Identifies the message to be Logged. This is an identifier for a string message which the viewer is aware of through any 
off-line mechanism. The arguments of this function are interpreted by the viewer based on this identifier. For application Log Streams, the values and 
scope of each value must be defined by the application developer. Following are the pre-defined values:
\begin{itemize}
\item
\textit{\#define CL\_\-LOG\_\-MSGID\_\-BUFFER		0x0}
\item
\textit{\#define CL\_\-LOG\_\-MSGID\_\-PRINTF\_\-FMT	     0x1}
\end{itemize}
If {\tt{msgId}} is set to {\tt{CL\_\-LOG\_\-MSGID\_\-BUFFER}}, it is followed by two parameters:
\begin{itemize}
\item
The first parameter is of type {\tt{ClUint32T}} representing the number of bytes in the buffer pointed by the second parameter.
\item
The second parameter is a pointer of type {\tt{ClPtrT}} to the buffer. The buffer can contain binary or ASCII data. The number of bytes of useful data is 
indicated by the previous parameter. If the buffer contains ASCII data and if the buffer is terminated with NULL, the length must include the NULL 
termination byte. The Log Service does not free this buffer.
\end{itemize}
If {\tt{msgId}} is set to {\tt{CL\_\-LOG\_\-MSGID\_\-PRINTF\_\-FMT}}, the next argument is treated as a format string of printf(3). The arguments are
interpreted according to this format string.
\par
For other values of {\tt{msgId}}, the arguments are treated as a set of 3-tuples. Each tuple is of the form {\tt{<Tag, Length, Value Pointer>}}. A tuple
of three arguments is interpreted as follows:
\begin{enumerate}
\item
{\tt{Tag}} is of type {\tt{ClUint16T}} that identifies the contents of the third argument in this tuple.
\item
{\tt{Length}} is of type {\tt{ClUint16T}}. It is the number of bytes in the buffer pointed by the third argument.
\item
{\tt{Value Pointer}} is of type {\tt{ClPtrT}}. The buffer can contain binary or ASCII data defined by {\tt{Tag}} (first argument in this tuple). Only 
the Log Consumer interprets this buffer and must be aware of the semantic meaning of its contents. It copies this buffer into a Log Record. If the buffer 
contains ASCII data and if the buffer is terminated with NULL, {\tt{Length}} must include the NULL termination byte. The Log Service does not free this
buffer.
\end{enumerate}
The end of this set of tuple is indicated by a special tag called {\tt{CL\_\-LOG\_\-TAG\_\-TERMINATE}}. The variable part of this argument list 
always has {\tt{3*n + 1}}, where {\tt{n}} is the number of parameters to be logged. Following tag values are defined by the Log Service and the 
remaining tags are defined by the application.
\begin{itemize}
\item
{\tt{\#define CL\_\-LOG\_\-TAG\_\-TERMINATE		0x0}}
\item
{\tt{\#define CL\_\-LOG\_\-TAG\_\-BASIC\_\-SIGNED		0x1}}
\item
{\tt{\#define CL\_\-LOG\_\-TAG\_\-BASIC\_\-UNSIGNED	0x2}}
\item
{\tt{\#define CL\_\-LOG\_\-TAG\_\-STRING		0x3}}
\end{itemize}

Log Service defines the following macros for ease in using this function:
{\tt{\#define CL\_\-LOG\_\-TLV\_\-UINT8(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-UNSIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-INT8(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-SIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-UINT16(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-UNSIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-INT16(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-SIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-UINT32(var)}}	\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-UNSIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-INT32(var)}}		\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-SIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-UINT64(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-UNSIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-INT64(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-BASIC\_\-SIGNED, sizeof( var ), \&(var)}}\\
{\tt{\#define CL\_\-LOG\_\-TLV\_\-STRING(var)}}				\\
{\tt{CL\_\-LOG\_\-TAG\_\-STRING, (strlen( var ) + 1), var}}

\item[{\em list}]:(in) This parameter is a replacement of variable length argument and valid only for {\tt{clLogStreamVWriteAsync()}}.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The Log Record is successfully recorded. A successful recording of the Log Record may not imply that the record is also persisted
in the Log File.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: 
The Log Stream handle is not valid. It is not received through a previous invocation to 
{\tt{clLogStreamOpen()}} or it is closed through an invocation to {\tt{clLogStreamClose()}}, or {\tt{hLog}} supplied to {\tt{clLogStreamOpen()}} or 
{\tt{clLogStreamOpenAsync()}} during opening of this Stream is previously finalized.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation specific timeout occurred before the call could complete. Cannot determine if
the Log Record is recorded.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: Some of parameters are invalid. The conditions are:
\begin{itemize}
\item
{\tt{Severity}} does not have a value defined in {\tt{ClLogSeverityT}}.
\item
CL\_\-LOG\_\-ERR\_\-FILE\_\-FULL: The size of the Log File has reached its limit. The Log Stream identified by {\tt{hStream}} is created with 
the value of enumeration {\tt{fileFullAction}}, set to {\tt{CL\_\-LOG\_\-FILE\_\-FULL\_\-ACTION\_\-HALT}}. Thus, no Log Records can be logged into 
this Stream and the Stream must be closed.
\end{itemize}
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER}]: One of the pointers is NULL.

\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function writes a Log Record into the Log Stream identified by {\tt{hStream}}. An invocation to this function is non-blocking. This 
function guarantees that the record is recorded into Log Stream, but the record may not be persisted in the Log File. Timing of 
persistence of Log Records in the Log File depends on the {\tt{flushFreq}} and {\tt{flushInterval}} attributes of the Log Stream.
\par

This function accepts variable number of arguments. The number of arguments and their types depend on the {\tt{msgId}} parameter. If the value
of {\tt{msgId}} is set to {\tt{CL\_\-LOG\_\-MSGID\_\-BUFFER}}, two arguments are required:
\begin{itemize}
\item
Length of buffer.
\item
Pointer to the buffer.
\end{itemize}
If the value of {\tt{msgId}} is set to{\tt{CL\_\-LOG\_\-MSGID\_\-PRINTF\_\-FMT}}, the next argument is treated as a C printf style format string and the
remaining arguments are interpreted as per the format string. For all other values, the variable number of arguments are treated as a set of 3-tuples. 
They should be in the form of {\tt{3*n+1}}, where {\tt{n}} is the number of parameters to be logged along with {\tt{msgId}}. For each such parameter the 
following values must be passed:
\begin{itemize}
\item
Tag identifying the type of the parameter.
\item
Length denoting number of bytes in the parameter and 
\item
Pointer to the parameter. 
\end{itemize}
The last argument must be a special tag {\tt{CL\_\-LOG\_\-TAG\_\-TERMINATE}}. Values of {\tt{msgId}} and tags, 
other than those defined by Log Service are not interpreted and the data is copied into the Log Record. It is the responsibility of the Log Consumer 
to understand the semantic meaning and interpret the Log Records.
\par
Information such as Log Timestamp and Component Id are also recorded into the Log Records by the Log Service. Log Timestamp is the wall clock 
time when this function is invoked on the host where the Logger is running. Component Id is the unique identifier identifying this 
instance of the application. This is issued by the Component Manager and remains unchanged through a process restart or cluster restart.
Log Records are written into Log Streams in an atomic manner. Thus, the Log service handles concurrent recording by multiple threads of a single process 
or multiple processes in a cluster.
\par
the Logger frees the buffers passed to this function.
Pointers to stack variables can also be passed as pointers to this function without causing any fallouts.

\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so\newline
libClLog.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog106}{clLogStreamOpen()}, \hyperlink{pagelog106}{clLogStreamOpenAsync()},
\hyperlink{pagelog108}{clLogStreamClose()}\end{Desc}
\newpage	








\subsubsection{clLogFilterSet}
\index{clLogFilterSet@{clLogFilterSet}}
\hypertarget{pagelog110}{}\paragraph{cl\-Log\-Filter\-Set}\label{pagelog110}
\begin{Desc}
\item[Synopsis:]Changes the filter settings of a Log Stream.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			ClRcT clLogFilterSet(
				CL_IN	ClLogStreamHandleT	hStream,
				CL_IN	ClLogFilterFlagsT	logFilterFlags,
				CL_IN	ClLogFilterT		filter
					    );
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamOpen()}}. This handle identifies the Log Stream whose filter 
settings have to be changed.
\item[{\em logFilterFlags}]:(in) Specifies how the filter parameter must be used. This filter can overwrite any previous
filter settings or it can be used to modify a previous filter. To clear a previous filter, this field must be set to 
{\tt{CL\_\-LOG\_\-FILTER\_\-ASSIGN}} and all other fields must be set to zero.
\item[{\em filter}]:(in) Filter settings to be applied.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The filter is set successfully.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: The Log Stream handle is not valid. It is not received through a previous invocation to 
{\tt{clLogStreamOpen()}} or it is closed through an invocation to {\tt{clLogStreamClose()}} or {\tt{hLog}} is finalized, or 
{\tt{clLogStreamOpenAsync()}} is finalized during opening of this Stream.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation specific timeout occurred before the call could complete. Cannot determine if
the Log Filter is set.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: The filter has an invalid configuration:
	\begin{itemize}
	\item
	{\tt{logFilterFlags}} does not contain values specified in {\tt{ClLogFilterFlagsT}}.
	\item
	{\tt{logSeverityFilter}} does not contain bits specified in {\tt{ClLogSeverityT}}.
	\end{itemize}
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function sets the filter on the Stream identified by {\tt{hStream}}. This filter can be used to overwrite, clear, or modify a
previously set filter. The {\tt{logFilterFlags}} parameter is used to identify the correct operation. The {\tt{logSeverityFilter}} (field of filter parameter) 
is used to set the filter setting based on severity of the Log Record. All Log Records with severity bits set in the filter and maintained by Log Service 
on a per Log Stream basis are masked and do not enter the Log Stream. Similarly, {\tt{pLogMsgIdSet}} and {\tt{pLogCompIdSet}} is used to specify the filter
based on message ID and component ID respectively.
\par
To clear a previously set filter, all the fields of filter should be set to zero and {\tt{logFilterFlags}} should be set to 
{\tt{CL\_\-LOG\_\-FILTER\_\-ASSIGN}}.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog106}{clLogStreamOpen()}, \hyperlink{pagelog109}{clLogStreamWriteAsync()},
\hyperlink{pagelog108}{clLogStreamClose()}, \hyperlink{pagelog111}{ClLogFilterSetCallbackT()}\end{Desc}
\newpage



\subsubsection{ClLogFilterSetCallbackT}
\index{ClLogFilterSetCallbackT@{ClLogFilterSetCallbackT}}
\hypertarget{pagelog111}{}\paragraph{cl\-Log\-Filter\-Set\-CallbackT}\label{pagelog111}
\begin{Desc}
\item[Synopsis:] Informs the Logger about the change in filter settings of a Log Stream opened by this Logger.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			typedef void (*ClLogFilterSetCallbackT)(
					CL_IN	ClLogStreamHandleT	hStream,
					CL_IN	ClLogFilterT		filter
								);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamOpen()}}. This handle identifies the Log Stream whose filter 
settings have to be changed.
\item[{\em filter}]:(in) Indicates the filter settings required to be applied. This is a consolidated filter maintained by Log Service and not 
a change in filter as with {\tt{clLogFilterSet()}}.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
This callback does not return anything.
\end{Desc}
\begin{Desc}
\item[Description:] The Log Service invokes this function when the filter associated with a Log Stream changes. The change can be made by a
Logger (Logger must open the Log Stream to make any changes) or north-bound interface. 
\par
The Logger is not informed about changes in filter settings if 
{\tt{pLogCallbacks}} is set to NULL during {\tt{clLogInitialize()}} 
or is {\tt{clLogFilterSetCallback}} is set to NULL. 
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog111}{clLogFilterSet()},
\hyperlink{pagelog106}{clLogStreamOpen()}
\end{Desc}
\newpage



\section{Log Handler APIs}
\subsubsection{clLogStreamRegister}
\index{clLogStreamRegister@{clLogStreamRegister}}
\hypertarget{pagelog112}{}\paragraph{cl\-Log\-Stream\-Register}\label{pagelog112}
\begin{Desc}
\item[Synopsis:] Registers the calling process as a handler for the specified Stream.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			ClRcT clLogStreamRegister(
				CL_IN		ClLogHandleT			hLog,
				CL_IN		ClNameT				StreamName,
				CL_IN		ClLogStreamScopeT		StreamScope,
				CL_IN		ClCharT				*pNodeName,
				CL_IN		ClLogStreamHandlerFlagsT	handlerFlags,
				CL_OUT		ClLogStreamHandleT		*phStream
						);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous invocation to {\tt{clLogInitialize()}}. This handle identifies the association between the 
calling process and Log Service.
\item[{\em StreamName}]:(in) Name of the Stream for which this process wants to become a handler.
\item[{\em StreamScope}]:(in) Scope of the Stream identified by {\tt{StreamName}}.
\item[{\em *pNodeName}]:(in) Name of the node where the Log Stream exists. This parameter is a string that terminates with NULL. It is valid only if 
{\tt{StreamScope}} is set to {\tt{CL\_\-LOG\_\-SCOPE\_\-LOCAL}}. If StreamScope is set to {\tt{CL\_\-LOG\_\-SCOPE\_\-GLOBAL}}, this parameter must be NULL.
\item[{\em handlerFlags}]:(in) It is the bitwise ORed value of flags defined in {\tt{ClLogStreamHandlerFlagsT}}. 
{\tt{CL\_\-LOG\_\-HANDLER\_\-WILL\_\-ACK}} must be specified if the handler wants to explicitly acknowledge the receipt of Log Records. 
The Log File Handler, which is part of Log Service uses this flag. Other handlers must set the value of this parameter to zero.
\item[{\em *phStream}]:(out) Pointer to the memory area where the handle to the Log Stream is returned. This handle must be used for further operations 
on this Stream.
\end{description}
\end{Desc}
\begin{Desc}

\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The calling process is registered as a handler for the specified Stream.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: The Log Service handle is not valid. It is not received through a previous invocation to
{\tt{clLogInitialize()}} or it is finalized through an invocation to {\tt{clLogFinalize()}}.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation specific timeout occurred before the call could be completed. Cannot determine if 
the handler is registered or not.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NULL\_\-POINTER}]: {\tt{pNodeName}} or {\tt{phStream}} parameter is NULL.
\item[{\em CL\_\-ERR\_\-NOT\_\-EXISTS}]: The Log Stream identified by 3-tuple of {\tt{StreamName}}, {\tt{StreamScope}} and 
{\tt{pNodeName}} does not exist.
\item[{\em CL\_\-ERR\_\-BAD\_\-FLAG}]: {\tt{handlerFlags}} is not set as described in {\tt{ClLogStreamHandlerFlagsT}} or StreamScope is not set as
described in {\tt{ClLogStreamScopeT}}.
\item[{\em CL\_\-ERR\_\-NO\_\-CALLBACK}]: {\tt{pLogCallbacks}} or {\tt{clLogRecordDeliverCallback}} (member of {\tt{pLogCallbacks)}} is NULL in the 
previous invocation to {\tt{clLogInitialize()}}.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: Some of the parameters contain invalid values. One of the possible reasons is:
Size field in {\tt{StreamName}} is zero.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function registers an interest of the calling process in handling the Log Stream. The 
calling process starts receiving {\tt{clLogRecordDeliverCallback}} when the interest is registered. Memory for {\tt{pNodeName}} 
and {\tt{phStream}} is allocated and freed by the calling process.
\par
If this function is called multiple times on a single Stream with a single Log Service handle {\tt{hLog}}, a new Log Stream handle 
{\tt{hStream}} is issued every time. During the delivery of Log Records, the callback is called once for every handle issued.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog113}{ClLogRecordDeliverCallbackT()},
\hyperlink{pagelog115}{clLogStreamDeregister()}
\end{Desc}
\newpage



\subsubsection{ClLogRecordDeliverCallbackT}
\index{ClLogRecordDeliverCallbackT@{ClLogRecordDeliverCallbackT}}
\hypertarget{pagelog113}{}\paragraph{cl\-Log\-Record\-Deliver\-CallbackT}\label{pagelog113}
\begin{Desc}
\item[Synopsis:] Callback function to receive Log Records from Log Streams of interest.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			void (*ClLogRecordDeliverCallbackT)(
				CL_IN ClLogStreamHandleT hStream,
				CL_IN ClUint32T sequenceNumber,
				CL_IN ClUint32T numRecords,
				CL_IN ClPtrT logRecords
				);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] 
\begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamRegister()}}. This handle identifies the registration of handler 
for a Stream for which the Log Records are being delivered.
\item[{\em sequenceNumber}]:(in) A monotonically increasing no to detect the duplicate delivery of a set of Log Records.
\item[{\em numRecords}]:(in) Number of records in the buffer pointer by {\tt{logRecords}}.
\item[{\em *logRecords}]:(in) Pointer to a buffer that contains {\tt{numRecords}} number of Log Records from a Stream identified by 
{\tt{hStream}}.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
This callback does not return anything.
\end{Desc}
\begin{Desc}
\item[Description:] This callback delivers a set of new Log Records to the handlers which will not be available in the Log Stream.
\par
This callback can be invoked multiple times for a single set of Log Records, which can be detected by the same {\tt{sequenceNumber}}.
\par
Memory for {\tt{logRecords}} is allocated by the Log Service and must be freed by the Handler.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog112}{clLogStreamRegister()},
\hyperlink{pagelog102}{clLogFinalize()}, \hyperlink{pagelog115}{clLogStreamDeregister()}
\end{Desc}
\newpage




\subsubsection{clLogStreamRecordAck}
\index{clLogStreamRecordAck@{clLogStreamRecordAck}}
\hypertarget{pagelog114}{}\paragraph{cl\-Log\-Stream\-Record\-Ack}\label{pagelog114}
\begin{Desc}
\item[Synopsis:] Acknowledges a set of records received through {\tt{ClLogRecordDeliverCallbackT}}. \end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			ClRcT clLogStreamRecordAck(
					CL_IN	ClLogStreamHandleT	hStream,
					CL_IN	ClUint32T		sequenceNumber
						);


\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] 
\begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamRegister()}}. This handle identifies the 
registration of handler for a Stream for which the records are acknowledged.
\item[{\em sequenceNumber}]:(in) The number identifying the set of Log Records to be acknowledged. This is received during a previous
invocation of callback {\tt{ClLogRecordDeliverCallbackT}}.
\end{description}
\end{Desc}


\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The acknowledgement was sent successfully.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: The Log Stream handle is not valid. It is not received through a previous invocation to
{\tt{clLogStreamRegister()}} or it is unregistered through an invocation to {\tt{clLogStreamDeregister()}} or {\tt{hLog}} supplied to 
{\tt{clLogStreamRegister()}} during registration of the handler is finalized.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: This handler is not registered itself with the Log Stream identified by {\tt{hStream}}, as a
handler for which the records are acknowledged. A handler can register itself by setting the 
{\tt{handlerFlags}} to {\tt{CL\_\-LOG\_\-HANDLER\_\-WILL\_\-ACK}} during the invocation of {\tt{clLogStreamRegister()}}.
\end{description}
\end{Desc}



\begin{Desc}
\item[Description:] This function acknowledges the receipt of a set of Log Records for the Log Stream identified by {\tt{hStream}}. The set of Log 
Records are identified by {\tt{sequenceNumber}}. This function only dispatches the acknowledgement. Thus, it is not possible to validate the sequence
number supplied.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog112}{clLogStreamRegister()},
\hyperlink{pagelog102}{clLogFinalize()}, \hyperlink{pagelog115}{clLogStreamDeregister()}, \hyperlink{pagelog113}{ClLogRecordDeliverCallbackT()}
\end{Desc}
\newpage


\subsubsection{clLogStreamDeregister}
\index{clLogStreamDeregister@{clLogStreamDeregister}}
\hypertarget{pagelog115}{}\paragraph{cl\-Log\-Stream\-Deregister}\label{pagelog115}
\begin{Desc}
\item[Synopsis:] Deregisters the calling process as handler for the specified Stream.\end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
			ClRcT clLogStreamDeregister(
				CL_IN	ClLogStreamHandleT	hStream
			);

\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:] \begin{description}
\item[{\em hStream}]:(in) Handle obtained through a previous invocation to {\tt{clLogStreamRegister()}}. This handle identifies the registration of 
a handler for a Stream.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK}]: The calling process is unregistered as a handler for the specified Stream.
\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: The Log Stream handle is not valid. It is not received through a previous invocation to 
{\tt{clLogStreamRegister()}} or it is unregistered through an invocation to {\tt{clLogStreamDeregister()}} or 
{\tt{hLog}} supplied to {\tt{clLogStreamRegister()}} during registration of the handler is previously finalized.
\item[{\em CL\_\-ERR\_\-TIMEOUT}]: An implementation specific timeout occurred before the call could complete. Cannot determine if the
handler is registered.
\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.
\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.
\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:] This function unregisters the interest of the calling process in handling the Log Stream. After the interest is unregistered, 
the calling process does not receive {\tt{clLogRecordDeliverCallback()}}. This call cancels all pending 
{\tt{clLogRecordDeliverCallback}} callbacks. As 
callback invocation is asynchronous, the process can receive some pending callbacks. After completion of this function, {\tt{hStream}} is no longer valid.
If the handler process terminates without un registering its interest, Log Service implicitly unregisters the process. If the Log Service handle 
{\tt{hLog}}, used during {\tt{clLogStreamRegister}} invocation, is finalized without explicitly un registering the interest in handling the Stream, 
Log Service implicitly unregisters the process.
\end{Desc}
\begin{Desc}
\item[Library File:] libClLog.so
\newline
libClLog.a
\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog101}{clLogInitialize()}, \hyperlink{pagelog113}{ClLogRecordDeliverCallbackT()},
\hyperlink{pagelog112}{clLogStreamRegister()}, \hyperlink{pagelog102}{clLogFinalize()}
\end{Desc}
\newpage


\section{File Handler APIs}
\subsubsection{clLogFileOpen}
\index{clLogFileOpen@{clLogFileOpen}}
\hypertarget{pagelog106}{}\paragraph{cl\-Log\-Stream\-Open}\label{pagelog106}
\begin{Desc}
\item[Synopsis:] Opens a Log Stream for logging.  \end{Desc}
\begin{Desc}
\item[Header File:] clLogApi.h \end{Desc}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
					ClRcT clLogStreamOpen(
						CL_IN		ClLogHandleT		hLog,
						CL_IN		ClNameT			StreamName,
						CL_IN 		ClLogStreamScopeT	StreamScope,
						CL_IN		ClLogStreamAttributesT	*pStreamAttributes,
						CL_IN		ClLogStreamOpenFlagsT	StreamOpenFlags,
						CL_IN		ClTimeT			timeout,
						CL_OUT		ClLogStreamHandleT	*phStream
					);
					
					
					ClRcT clLogStreamOpenAsync(
						CL_IN		ClLogHandleT		hLog,
						CL_IN		ClNameT			StreamName,
						CL_IN 		ClLogStreamScopeT	StreamScope,
						CL_IN		ClLogStreamAttributesT	*pStreamAttributes,
						CL_IN		ClLogStreamOpenFlagsT	StreamOpenFlags,
						CL_IN		ClInvocationT		invocation
					);

\end{verbatim}
\normalsize
\end{Desc}


\begin{Desc}
\item[Parameters:] 
\begin{description}
\item[{\em hLog}]:(in) Handle obtained through a previous call to {\tt{clLogInitialize()}}. It identifies the association between the calling process and 
the Log Service for which pending callbacks are to be dispatched.
\item[{\em StreamName}]:(in) Name of the Log Stream to be opened for logging. It can be a pre-defined (modeled) Log Streams or a Log Stream that is being 
dynamically created.
\item[{\em StreamScope}]:(in) Scope of the Log Stream.
\item[{\em pStreamAttributes}]:(in) Attributes of the Log Stream that need to be opened. Refer to {\tt{ClLogStreamAttributesT}} in the Type Definitions 
chapter for details on this parameter. 
\par 
If a pre-defined Log Stream is being opened, this must be NULL. 
\par
If the intent is only to open an existing Log Stream (identified by {\tt{StreamName}} and {\tt{StreamScope}}) this value must be NULL. 
\par
If the intent is to open and create a new Log Stream, this parameter must have the attributes of the new Stream and {\tt{StreamOpenFlags}} must
be ORed with {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}}. 
\par
If the intent is to open and possibly create (if not already created) a Stream, this parameter must have 
the attributes of the new Stream. These attributes must match the attributes of the Stream if a Stream exists.


\item[{\em StreamOpenFlags}]:(in) It is the bitwise ORed value of the flags defined in {\tt{ClLogStreamHandlerFlagsT}}. 
{\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must be specified if the intention is to open and create a new Stream. If a pre-defined Streams is to be opened, 
{\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must not be specified.

\item[{\em timeout}]:(in) This is applicable for {\tt{clLogStreamOpen()}} operation. If the call does not complete in the timeout period, it is 
considered to have failed. The Log Stream is either opened and/or created, but the outcome cannot be determined. A value of zero indicates
no timeout period.

\item[{\em phStream}]:(out) Pointer to retrieve the Log Service generated handle for the Log Stream. This handle must be used for subsequent operations on 
the Log Stream.

\item[{\em invocation}]:(in) This is applicable only for {\tt{clLogStreamOpenAsync()}} and is used to correlate the response received through 
{\tt{ClLogStreamOpenCallbackT}}.

\end{description}
\end{Desc}

\begin{Desc}



\item[Return values:]
\begin{description}

\item[{\em CL\_\-OK}]: The Log Stream opened successfully.

\item[{\em CL\_\-ERR\_\-INVALID\_\-HANDLE}]: {\tt{hLog}}, obtained through a previous invocation to 
{\tt{clLogInitialize()}}, is not a valid handle or the association is closed by an invocation to {\tt{clLogFinalize()}}.

\item[{\em CL\_\-ERR\_\-TIMEOUT}]: Log Stream could not be opened in the timeout period. This is applicable for {\tt{clLogStreamOpen()}} only.

\item[{\em CL\_\-ERR\_\-TRY\_\-AGAIN}]: The service cannot be provided at this time. The process can try later.

\item[{\em CL\_\-ERR\_\-INVALID\_\-PARAM}]: Some of the parameters are not valid. The conditions can be one of the following:

		\begin{itemize}
		\item
		The {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} parameter in {\tt{StreamOpenFlags}} is not set and {\tt{pStreamAttributes}} is not NULL.
		\item
		The {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} parameter in {\tt{StreamOpenFlags}} is set and {\tt{pStreamAttributes}} is NULL.
		\item
		Length field of {\tt{StreamName}} is set to zero.
		\item
		{\tt{filePath}}, member of {\tt{pStreamAttributes}}, does not follow the pattern defined in {\tt{ClLogStreamAttributesT}}.
		\item
		{\tt{maxFileSize}}, member of {\tt{pStreamAttributes}}, is not a multiple of {\tt{recordSize}}.
		\item
		{\tt{fileFullAction}}, member of {\tt{pStreamAttributes}}, does not have a value defined in {\tt{ClLogFileFullActionT}}.
		\item
		{\tt{Both flushFreq}} and {\tt{flushInterval}}, members of {\tt{pStreamAttributes}}, are set to zero.
		\item
		{\tt{highWatermark}}, member of {\tt{pStreamAttributes}}, has values outside 0-100 range.
		\item
		{\tt{StreamScope}} does not have the value defined in {\tt{ClLogStreamScopeT}}.
		\item
		{\tt{timeout}} is specified as a negative value.
		\end{itemize}

\item[{\em CL\_\-ERR\_\-NO\_\-MEMORY}]: The Log Service library or another module of Log Service is out of memory. The service cannot 
be provided at this time and this may be a transient problem.

\item[{\em CL\_\-ERR\_\-NO\_\-RESOURCE}]: The Log Service library or some other module of Log Service is out of resources 
(other than memory). The service cannot be provided at this time and this may be a transient problem.

\item[{\em CL\_\-ERR\_\-NOT\_\-EXIST}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag of {\tt{StreamOpenFlags}} is not set and the Stream does not exist.

\item[{\em CL\_\-ERR\_\-ALREADY\_\-EXIST}]: {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} flag of {\tt{StreamOpenFlags}} is set but the Stream exists
and is not created with attributes specified in {\tt{pStreamAttributes}}.

\item[{\em CL\_\-ERR\_\-BAD\_\-FLAGS}]: The bits in {\tt{StreamOpenFlags}} are not set as defined in {\tt{ClLogStreamHandlerFlagsT}}.

\item[{\em CL\_\-ERR\_\-NO\_\-CALLBACK}]: This is applicable for {\tt{clLogStreamOpenAsync()}} only. {\tt{pLogCallbacks}} or {\tt{clLogStreamOpenCallback}}
(member of {\tt{pLogCallbacks}}), is NULL in the previous invocation to {\tt{clLogInitialize()}} through which {\tt{hLog}} was obtained.

\end{description}
\end{Desc}

\begin{Desc}
\item[Description:] This function opens a Log Stream for logging operation. If the Log Stream is not a pre-defined Stream and if the application has to
create it, {\tt{pStreamAttributes}} must be specified and {\tt{CL\_\-LOG\_\-Stream\_\-CREATE}} must be set in {\tt{StreamOpenFlags}}.
If {\tt{pStreamAttributes}} is not NULL, {\tt{flushFreq}} or {\tt{flushInterval}} (members of {\tt{pStreamAttributes}}), must also have non-zero values.
\par
Invocation to {\tt{clLogStreamOpen()}} is blocking. If the Log Stream is opened, the function returns a handle to the newly opened Stream. 
If the Log Stream is not opened, it returns an error.
\par
Call to the {\tt{clLogStreamOpenAsync()}} is non-blocking.  
{\tt{ClLogStreamOpenCallbackT}} (registered during {\tt{clLogInitialize()}}) is invoked when this function completes execution. {\tt{ClLogStreamOpenCallbackT}}
returns an {\tt{Invocation}} value to the calling process. This {\tt{Invocation}} value is used to correlate the invocation of {\tt{clLogStreamOpenAsync()}} with 
the invocation of {\tt{ClLogStreamOpenCallbackT()}}.
\par
The handle obtained through an invocation to these functions should be used for Logging operation only. It cannot be used as a consumer of Log Records.
An application can open a single Stream for logging multiple times and it obtains a new handle every time. A separate invocation to 
{\tt{clLogStreamClose()}} should be made for each successful invocation to these functions to avoid any leakage of resources.

\end{Desc}

\begin{Desc}
\item[Library File:] libClLog.so\newline
libClLog.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pagelog108}{clLogStreamClose()}, \hyperlink{pagelog109}{ClLogStreamWriteAsync()},
\hyperlink{pagelog107}{ClLogStreamOpenCallbackT()}\end{Desc}
\newpage






\chapter{Service Management Information Model}
Log Service controls two types of objects maintained by OpenClovis COR service. First type of object is the Log Stream Object used for
exposing all Log Streams in the cluster to the North Bound Interface. Second type of object is the Log Stream Object used for configuring certain
Log Streams in the system. An application is not required to create these Streams. They are available and can be 
opened with specifying creation attributes or without having to locate them.



\section{Log Stream Object}
\subsubsection{Run-time Attributes}

\subsubsection{clLogStreamName}
\index{clLogStreamName@{clLogStreamName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamName: clNameT [1] {RUNTIME, CACHED}
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Description:]
Name of the Log Stream.
\end{Desc}



\subsubsection{clLogStreamScope}
\index{clLogStreamScope@{clLogStreamScope}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamScope: clLogStreamScopeT [1] {RUNTIME, CACHED}
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Description:]
Scope of the Log Stream. Refer section {\tt{clLogStreamScopeT}}.
\end{Desc}


\subsubsection{clLogStreamNodeName}
\index{clLogStreamNodeName@{clLogStreamNodeName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamNodeName: clStringT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
	\end{Desc}
\begin{Desc}
\item[Description:]

Name of the node where the Log Stream is available. It is empty if {\tt{clLogStreamScope}} is set to {\tt{CL\_\-LOG\_\-Stream\_\-GLOBAL}}.
\end{Desc}


\subsubsection{clLogStreamFileName}
\index{clLogStreamFileName@{clLogStreamFileName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamFileName: clStringT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}
\begin{Desc}
\item[Description:]
Name of the Log File where this Log Stream is persisted. This is the prefix for the OS file names.
\end{Desc}


\subsubsection{clLogStreamFilePath}
\index{clLogStreamFilePath@{clLogStreamFilePath}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFilePath: clStringT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize

\end{Desc}

\begin{Desc}
\item[Description:]
Path of the Log File where this Log Stream is persisted. The path can be specified as
\newline
{\tt{<nodeName>:<absolutePath>}}
\newline
where the {\tt{<nodeName>}} is the logical node name in the cluster and {\tt{<absolutePath>}} is the absolute path where the file should be 
stored on that node.
\end{Desc}


\subsubsection{clLogStreamMaxFileSize}
\index{clLogStreamMaxFileSize@{clLogStreamMaxFileSize}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamMaxFileSize: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
\item[Description:]
Maximum size of a Log File Unit measured in bytes. There is no pre-defined limit on
Log File Unit size if this attribute is set to zero.
\end{Desc}


\subsubsection{clLogStreamRecordSize}
\index{clLogStreamRecordSize@{clLogStreamRecordSize}}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        	

	clLogStreamRecordSize: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}
\begin{Desc}
\item[Description:]
Size of a Log Record in this Log Stream measured in bytes.
\end{Desc}


\subsubsection{clLogStreamHaProperty}
\index{clLogStreamHaProperty@{clLogStreamHaProperty}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamHaProperty: clBoolT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
\item[Description:]
If set to {\tt{CL\_\-TRUE}}, the Log Stream is persisted in the Log File. This ensures replication of Log Files.
\end{Desc}



\subsubsection{clLogStreamFileFullAction}
\index{clLogStreamFileFullAction@{clLogStreamFileFullAction}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFileFullAction: clLogFileFullActionT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

 \begin{Desc}
 \item[Description:]
Action that the Log Service should take when the size of the Log File Unit reaches its limit.
\end{Desc}


\subsubsection{clLogStreamMaxFilesRotated}
\index{clLogStreamMaxFilesRotated@{clLogStreamMaxFilesRotated}}
\begin{Desc}
\item[Syntax:]
\end{Desc}
\footnotesize\begin{verbatim}        	

	clLogStreamMaxFilesRotated: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize

 \begin{Desc}
 \item[Description:]
\end{Desc}
Number of Log File Unit in the Log File where this Log Stream is persisted.



\subsubsection{clLogStreamFlushFreq}
\index{clLogStreamFlushFreq@{clLogStreamFlushFreq}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFlushFreq: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Number of Log Records after which the Log Stream must be cleared. This indicates the maximum number of records on a node which are not persisted at any 
given point of time.
\end{Desc}



\subsubsection{clLogStreamFlushInterval}
\index{clLogStreamFlushInterval@{clLogStreamFlushInterval}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFlushInterval: clTimeT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Time in nanoseconds after which the Log Stream must be cleared. This is the maximum time for which Log Records can remain in the local memory
before it is persisted.
\end{Desc}



\subsubsection{clLogStreamHighWatermark}
\index{clLogStreamHighWatermark@{clLogStreamHighWatermark}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamHighWatermark: clUint8T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
High limit of the watermark measured in percentage of Log File size. An event is published and an alarm is issued when this limit is reached.
\end{Desc}



\subsubsection{clLogStreamLowWatermark}
\index{clLogStreamLowWatermark@{clLogStreamLowWatermark}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamLowWatermark: clUint8T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Low limit of the watermark measured in percentage of Log File size. No event
is published or alarm is issued until this low limit is reached and high limit is reached again.
\end{Desc}



\subsubsection{clLogStreamCreationTimestamp}
\index{clLogStreamCreationTimestamp@{clLogStreamCreationTimestamp}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamCreationTimestamp: clTimeT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Creation time of this Log Stream.
\end{Desc}



\subsubsection{clLogStreamSeverityFilter}
\index{clLogStreamSeverityFilter@{clLogStreamSeverityFilter}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamSeverityFilter: clLogSeverityT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Current filter settings of this Log Stream.
\end{Desc}


\subsubsection{clLogStreamNumOpeners}
\index{clLogStreamNumOpeners@{clLogStreamNumOpeners}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamNumOpeners: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Number of Loggers who have currently opened this Log Stream.
\end{Desc}


\subsubsection{Management Interfaces}

\subsubsection{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER}
\index{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER@{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER}}
\begin{Desc}
\item[Parameters:] 
\begin{description}
\item[{\em operationId}]:(in) CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER
\item[{\em objectName}]:(in) A 3-tuple consisting of <StreamName>, <StreamScope> and <StreamNodeName>. This should be set to clLogStreamName, 
clLogStreamScope and clLogStreamNodeName runtime attributes of this object.
\item[{\em param}]:(in) A structure of clLogFilterT indicating new filter settings.
\end{description}
\end{Desc}
\begin{Desc}
 \item[Description:]
\end{Desc}
This is an administrative operation that changes the value of the filter setting of the specified Log Stream. Thus, only the Log Records 
meeting this criterion are allowed to enter the Log Stream.




\section{Pre-created Log Stream Object}
\subsection{Configuration Attributes}


\subsubsection{clLogStreamName}
\index{clLogStreamName@{clLogStreamName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamName: clNameT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Scope of Log Stream. Refer to {\tt{ClLogStreamScopeT}} in the Type Definitions section.
\end{Desc}


\subsubsection{clLogStreamNodeName}
\index{clLogStreamNodeName@{clLogStreamNodeName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamNodeName: clStringT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Name of the node where the Log Stream is available. It remains empty if {\tt{clLogStreamScope}} is set to 
{\tt{CL\_\-LOG\_\-Stream\_\-GLOBAL}}.
\end{Desc}


\subsubsection{clLogStreamFileName}
\index{clLogStreamFileName@{clLogStreamFileName}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFileName: clStringT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Name of the Log File where this Log Stream is being persisted. This is the prefix for OS file names.
\end{Desc}


\subsubsection{clLogStreamFilePath}
\index{clLogStreamFilePath@{clLogStreamFilePath}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFilePath: clStringT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Path of the Log File where this Log Stream is persisted. The path can be specified as
\newline
{\tt{<nodeName>:<absolutePath>}}
\newline
where the {\tt{<nodeName>}} is the logical node name in the cluster and {\tt{<absolutePath>}} is the absolute path where the file should be stored
on that node.
\end{Desc}



\subsubsection{clLogStreamMaxFileSize}
\index{clLogStreamMaxFileSize@{clLogStreamMaxFileSize}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamMaxFileSize: clUint32T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Maximum size of a Log File Unit measured in bytes. There is no pre-defined limit on
Log File Unit size if this attribute is set to zero.
\end{Desc}



\subsubsection{clLogStreamRecordSize}
\index{clLogStreamRecordSize@{clLogStreamRecordSize}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamRecordSize: clUint32T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Size of each Log Record in this Log Stream. This is measured in bytes.
\end{Desc}


\subsubsection{clLogStreamHaProperty}
\index{clLogStreamHaProperty@{clLogStreamHaProperty}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamHaProperty: clBoolT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
If set to {\tt{CL\_\-TRUE}}, it implies that the Log Stream is persisted in the Log File. This ensures replication og Log Files.
\end{Desc}



\subsubsection{clLogStreamFileFullAction}
\index{clLogStreamFileFullAction@{clLogStreamFileFullAction}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFileFullAction: clLogFileFullActionT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Action that the Log Service should take when the size of the Log File Unit reaches its limit.
\end{Desc}



\subsubsection{clLogStreamFileFullAction}
\index{clLogStreamFileFullAction@{clLogStreamFileFullAction}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamMaxFilesRotated: clUint32T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Number of Log File Units in the Log File where this Log Stream is being persisted.
\end{Desc}



\subsubsection{clLogStreamFlushFreq}
\index{clLogStreamFlushFreq@{clLogStreamFlushFreq}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFlushFreq: clUint32T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Number of Log Records after which the Log Stream must be cleared. This is the maximum number of records on a node which are not persisted at any 
given point of time.
\end{Desc}


\subsubsection{clLogStreamFlushInterval}
\index{clLogStreamFlushInterval@{clLogStreamFlushInterval}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamFlushInterval: clTimeT [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Time in nanoseconds after which the Log Stream must be cleared. This is the maximum time for which Log Records can remain in the local memory before
it is persisted.
\end{Desc}


\subsubsection{clLogStreamHighWatermark}
\index{clLogStreamHighWatermark@{clLogStreamHighWatermark}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamHighWatermark: clUint8T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
High limit of the watermark measured in percentage of Log File size. An event is published and an alarm is issued when this limit is reached.
\end{Desc}

\subsubsection{clLogStreamLowWatermark}
\index{clLogStreamLowWatermark@{clLogStreamLowWatermark}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	
	clLogStreamLowWatermark: clUint8T [1] {CONFIG}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
\end{Desc}
Lower limit of the watermark measured in percentage of Log File size. No event
is published or alarm is issued until this low limit is reached and high limit is reached again.



\subsection{Runtime Attributes}
\subsubsection{clLogStreamCreationTimestamp}
\index{clLogStreamCreationTimestamp@{clLogStreamCreationTimestamp}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamCreationTimestamp: clTimeT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Creation time of this Log Stream.
\end{Desc}



\subsubsection{clLogStreamSeverityFilter}
\index{clLogStreamSeverityFilter@{clLogStreamSeverityFilter}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamSeverityFilter: clLogSeverityT [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Current filter settings of this Log Stream.
\end{Desc}

\subsubsection{clLogStreamNumOpeners}
\index{clLogStreamNumOpeners@{clLogStreamNumOpeners}}
\begin{Desc}
\item[Syntax:]
\footnotesize\begin{verbatim}        	

	clLogStreamNumOpeners: clUint32T [1] {RUNTIME, CACHED}
	\end{verbatim}
	\normalsize
\end{Desc}

\begin{Desc}
 \item[Description:]
Number of Loggers who have currently opened this Log Stream.
\end{Desc}


\subsection{Management Interfaces}
\subsubsection{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER}
\index{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER@{CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER}}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em operationId}]:(in) CL\_\-LOG\_\-ADMIN\_\-CHANGE\_\-FILTER
\item[{\em objectName}]:(in) A 3-tuple consisting of {\tt{<StreamName>}}, {\tt{<StreamScope>}} and {\tt{<StreamNodeName>}}. This should be set
to {\tt{clLogStreamName}}, {\tt{clLogStreamScope}}, and {\tt{clLogStreamNodeName}} runtime attributes of this object.
\item[{\em param}]:(in) A structure of {\tt{clLogFilterT}} indicating new filter settings.
\end{description}
\end{Desc}
\begin{Desc}
 \item[Description:]
\end{Desc}
This is an administrative operation that changes the value of the filter setting of the specified Log Stream. Thus, only the Log Records 
meeting this criterion are allowed to enter the Log Stream.





\chapter{Service Notifications}
\index{Service Notifications@{Service Notifications}}
This section is currently not applicable. It will become applicable once MGM-MDW-001 feature of PRD is implemented.
This section describes notifications other than the callbacks invoked on Log Service Clients. These are issued by Log Service to convey important 
information regarding its operational and functional state an administrator or a management system.



\section{Alarms}
\subsection{Log Service Impaired}
\begin{Desc}
\item[Description:]
The Log Service is currently not able to provide service or is in degraded state because of certain issues with memory, resource, communication or 
other constraints.
\end{Desc}
\begin{Desc}
\item[Clearing Method:]
\begin{itemize}
\item
Manually after taking appropriate administrative action or
\item
Log Service has recovered itself or with the help of AMF and explicitly clears the alarm.
\end{itemize}
\end{Desc}
\begin{Desc}
\item[Payload:]
Currently no payload is sent with this alarm.
\end{Desc}



\subsection{Watermark}
\begin{Desc}
\item[Description:]
One of the Log File maintained by Log Service has reached the high watermark configured for the Log Streams being persisted in that Log File.
\end{Desc}
\begin{Desc}
\item[Clearing Method:]
\begin{itemize}
\item
Manually after taking appropriate administrative action or
\item
An external Archiver has siphoned off oldest Log Records and now the Log File utilization has fallen below the low watermark.\end{itemize}
\end{Desc}
\begin{Desc}
\item[Payload:]
Currently no payload is sent with this alarm.
\end{Desc}

\section{Other Notifications}
Currently ASP does not have a different notification service, thus all the notifications are published as events only. This will change once the 
notification service is implemented.


\subsection{Stream Creation}
\begin{Desc}
\item[Description:]
This notification announces the creation of a Log Stream. It also identifies the scope and attributes of the Log Stream. This notification alerts 
the administrator and other applications in the cluster that Log Records are being written into this Stream and are available for inspection. Administrators,
if required, can change the filter associated with this Stream. Stream Handlers can register themselves for handling the Log Records of this Log Stream.
\end{Desc}
\begin{Desc}
\item[Channel Name:]
CL\_\-LOG\_\-EVENT\_\-CHANNEL
\end{Desc}
\begin{Desc}
\item[Pattern:]
The first pattern is of type ClUint32T and set to following value.\par
\#define CL\_\-LOG\_\-Stream\_\-CREATED	0x1
\end{Desc}
\begin{Desc}
\item[Payload:]
An object of type {\tt{ClLogStreamInfoT}} marshaled for endian and architecture safety is the payload of this notification.
\end{Desc}


\subsection{Stream Closure}
\begin{Desc}
\item[Description:]
This notification announces the last closure of a Log Stream. It marks the deletion of the Log Stream. Application cannot write Log Records into this 
Stream beyond this point. This notification alerts the administrator and other applications in the cluster that Log Stream is ready for final 
archiving. Stream Handlers can cancel their registration themselves for handling the Log Records of this Log Stream.
\end{Desc}
\begin{Desc}
\item[Channel Name:]
CL\_\-LOG\_\-EVENT\_\-CHANNEL
\end{Desc}
\begin{Desc}
\item[Pattern:]
The first pattern is of type {\tt{ClUint32T}} and set to following value:
\par
\#define CL\_\-LOG\_\-Stream\_\-CLOSED	0x2
\end{Desc}
\begin{Desc}
\item[Payload:]
Members of this payload are marshaled for endian and architecture safety. Following are the members of this payload in the order given here:
\begin{enumerate}
\item
{\tt{StreamName}} of type {\tt{ClNameT}} identifying the name of the Log Stream.
\item
{\tt{StreamScope}} of type {\tt{ClLogStreamScopeT}} identifying the scope of the Log Stream.
\item
{\tt{pNodeName}} of type {\tt{ClCharT*}}, a NULL terminated string identifying the node on which this Stream was available. This is not empty only if
{\tt{StreamScope}} is set to {\tt{CL\_\-LOG\_\-Stream\_\-LOCAL}}.
\end{enumerate}
\end{Desc}



\subsection{File Creation}
\begin{Desc}
\item[Description:]
This notification announces the creation of a Log File. It also identifies the location of the Log Stream. This notification alerts the administrator
and other applications in the cluster that Log File is created and is available for inspection. File Handlers can register themselves for handling
the Log Records of all the Log Streams being persisted in this Log File.
\end{Desc}
\begin{Desc}
\item[Channel Name:]
CL\_\-LOG\_\-EVENT\_\-CHANNEL
\end{Desc}
\begin{Desc}
\item[Pattern:]
The first pattern is of type {\tt{ClUint32T}} and set to following value.\par
\#define CL\_\-LOG\_\-FILE\_\-CREATED	0x3
\end{Desc}
\begin{Desc}
\item[Payload:]
All the members of this payload are marshaled for endian and architecture safety. Following are the members of this payload in the order given here:
\begin{enumerate}
\item
{\tt{fileName}} of type {\tt{ClCharT*}}, a NULL terminated string, identifying the prefix for the Log File Unit names.
\item
{\tt{filePath}} of type {\tt{ClCharT*}}, a NULL terminated string, identifying the node name and absolute path name on that string for all the Log File 
Units.
\end{enumerate}
\end{Desc}


\subsection{File Closure}
\begin{Desc}
\item[Description:]
This notification announces the closure of a Log File. It marks the deletion of the last Log Stream being persisted in this Log File. This notification
alerts the administrator and other applications in the cluster that Log File is ready for final archiving. File Handlers may unregister themselves for 
handling the Log Records of all the Log Streams being persisted in this Log File.
\end{Desc}
\begin{Desc}
\item[Channel Name:]
CL\_\-LOG\_\-EVENT\_\-CHANNEL
\end{Desc}
\begin{Desc}
\item[Pattern:]
The first pattern is of type ClUint32T and set to following value.\par
\#define CL\_\-LOG\_\-FILE\_\-CLOSED	0x4
\end{Desc}
\begin{Desc}
\item[Payload:]
All the members of this payload are marshaled for endian and architecture safety. Following are the members of this payload in the order given here:
\begin{enumerate}
\item
{\tt{fileName}} of type {\tt{ClCharT*}}, a NULL terminated string, identifying the prefix for the Log File Unit names.
\item
{\tt{filePath}} of type {\tt{ClCharT*}}, a NULL terminated string, identifying the node name and absolute path name on that string for all the Log File
Units.
\end{enumerate}
\end{Desc}

\chapter{Configuration}

Till the time all configuration data goes in COR, following configuration will be used. This must be available in {\tt{clLogCfg.xml}} in
{\tt{/ASP/<model-name>/config directory}}.
\footnotesize\begin{verbatim}        	

<log:BootConfig xmlns:log="log.ecore">
<logStream
name="firstStream"
StreamScope="local"
nodeName="PayLoad0">
<logStreamAttributes
	fileName="sawtooth"
	filePath="SCN0:/etc/asp/logs/"
	maxFileSize="4MB"
	recordSize="211"
	haProperty="CL_TRUE"
	fileFullAction="CL_LOG_FILE_FULL_ACTION_ROTATE"
	maxFilesRotated="13"
	flushFreq="5"
	flushInterval="10s"/>
<logStreamWatermark high="85" low="75"/>
</logStream>
</log:BootConfig>

\end{verbatim}
\normalsize

Semantics of all these parameters is explained in section {\tt{ClLogStreamInfoT}} in the Type Definitions chapter. Attributes {\tt{maxFileSize}} and 
{\tt{recordSize}} can take numerical arguments with suffix B (bytes), KB (KiloBytes), MB (MegaBytes), GB (GigaBytes) also. If no suffix is provided, 
bytes is taken as the suffix. Attribute {\tt{haProperty}} must take values, {\tt{CL\_\-TRUE}} or {\tt{CL\_\-FALSE}}. Attribute {\tt{fileFullAction}} 
can take any value defined in {\tt{ClLogFileFullActionT}}. Attribute {\tt{flushInterval}} can take numerical arguments with 
suffix m (minutes), s (seconds), ms (milliseconds), us (microseconds), ns (nanoseconds). If no suffix is provided, nanoseconds is taken as the suffix. 
Attributes high and low takes numerical arguments and treated as percentages of file size.








\chapter*{Glossary}
\index{Glossary@{Glossary}}
\begin{Desc}
\item[Glossary of Log Service Terms:]
\end{Desc}
\par
\par
\begin{description}

\item[Log Service] ASP Service that provides logging facility to various applications/ASP components in the cluster.
\end{description}

\begin{description}

\item[Logger] A component using the Log Service to record its events of interest.
\end{description}


\begin{description}

\item[Log Record] A unit of an ordered set of information related to an event. Log Record has two parts - Header and User data. Header contains 
meta-information about the event and the data contains the information.
\end{description}

\begin{description}

\item[Log Stream] A conceptual flow of Log Records. Every Log Stream has a theme to help the consumer decide if the Stream contains the event which 
the consumer is interested in. Streams have names which can be used for addressing.
\end{description}

\begin{description}

\item[Local Log Stream] A Log Stream local to a single node. This Stream is not visible for Logging on any other node in the system. Components running 
on the a single node only can log into this Stream. But consumers on any node can consume this Log Stream.
\end{description}


\begin{description}
\item[Global Log Stream] A Log Stream visible in the cluster. Any component in the cluster can log into this Stream.
\end{description}

\begin{description}
\item[Log File] Destination for Log Stream and persistent storage for Log Records. A collection of Log Streams flow into one Log File for the ease of 
management of data.
\end{description}


\begin{description}
\item[Log Configuration File] Persistent storage that contains the configuration information of a Log File. 
\end{description}

\begin{description}
\item[Log File Unit] A Log File is a logical collection of Log File Units, where a Log File Unit maps to a physical file on disc.
\end{description}

\begin{description}
\item[Log Client] Interfaces the Log Service with the Logger. 
\end{description}


\begin{description}
\item[Log Service Element] A process in an ASP enabled node (in the cluster) that contributes to the functionality of the Log Service. All the Log 
Service Elements along with Log Clients form the Log Service. This element is the owner for all the Local Log Streams on its node.
\end{description}


\begin{description}
\item[Master Log Service Element] Log Service Element running on the System Controller node. This element is the owner of all the Global Log Streams 
in the cluster.
\end{description}

\begin{description}
\item[Log Stream Handler] An application that has registered for receiving Log Records in real-time mode from the Log Service Element. These records 
are available to the Log Stream Handler in push mode. Only the Log File Handler is part of the Log Service.
\end{description}

\begin{description}
\item[Log File Handler] Log File Handler is a Log Stream Handler which receives the Log Records from the Log Stream and persists them in a Log File. 
This is the only handler that is part of the Log Service.
\end{description}


\begin{description}
\item[Log Viewer] An application used for viewing the logged records. This is not part of the Log Service. The viewers are of two types: Off-line viewer
and On-line viewer. Off-line viewer interacts with either the Log File Handler or archived files to display Log Records. On-line viewer registers
itself as a Log Stream Handler and displays the records in real-time.
\end{description}


\begin{description}
\item[Archiver] Application used for siphoning off the logged records to some other form of persistent storage. This is not part of Log Service.
\end{description}

\begin{description}
\item[Log Reader] Application that programmatically consumes the logged records. Most readers are applications looking for missing 
Notifications/Events.
\end{description}


\begin{description}
\item[Filter] A pattern that controls the logging of records. Only the Log Records matching this pattern are logged into the Log Stream.
\end{description}






\end{flushleft}