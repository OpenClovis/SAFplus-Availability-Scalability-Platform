
\hypertarget{group__group24}{
\chapter{Functional Overview}
\label{group__group24}
}

\begin{flushleft}
OpenClovis ASP is a middleware that provides high availability and system manageability solutions in a distributed system. The components on various 
nodes interact with each other to provide the required services. Thus, it is imperative to provide a simple and efficient means of communication between
components, which has to be agnostic to platform architecture issues and native data formats (32/64 bit architecture). 
\par
To provide such a communication process, a message passing mechanism with Remote Procedure Call (RPC) semantics is necessary. RPC provides the ability to 
call functions that are spread across remote components as if the functions are local. This functionality is provided by the OpenClovis service called 
Remote Method Dispatch (RMD).
\par
RMD has an engine that provides the ability to send messages from the source component to a destination component. The source component, where the call 
originates, is called the Client and the destination component is called the Server. The RMD engine provides an interface to send and receive messages. 
Typically, the application is responsible for handling cross-platform issues such as endianness and function calling semantics such as synchronous calls, 
asynchronous calls, and function identification. 
\par
The OpenClovis Interface Definition Language (IDL) service, generates a code that handles cross-platform issues, function calling semantics, and uses 
RMD to send and receive messages. The IDL generator accepts the functions or interface exposed by a component, relevant programmer-defined data type 
definitions in XML format, and generates the code which can be used by the applications.

\chapter{Service Model}
\section{Usage Model}
TBD
\section{Functional Description}

The IDL Library provides an IDL handle that defines the communication semantics and provides APIs that perform the following: 
\begin{itemize}
\item
Initialize the handle with RMD parameters
\item
Update the handle
\item
Finalize the handle
\end{itemize}

While initializing the IDL library, you must specify the structure, {\tt{ClIdlHandleObjT}}. This contains the RMD parameters such as RMD options, 
destination address, and flags. The IDL engine is a Python script that takes two arguments and generates the code. The arguments are:
\begin{itemize}
\item
XML file - Provides a specification of the interface exposed by the components and data structures. The interface is a set of operations that a client
can invoke.
\item
Directory - Contains the generated client, server, and xdr routines.
\end{itemize}

IDL generates a Makefile. The server, client, and XDR libraries are generated when the Makefile is run. You have to link the code with the client 
and XDR libraries and include the client and XDR headers in the code, to invoke remote functions. At the server-side, you have to provide function 
definitions corresponding to the specification in the XML file. You must install the server stubs so that the client application can use them and 
uninstall them after they are used. 
\par
The directory contains subdirectory for every service specified in the XML file, which in turn contains the following:
\begin{itemize}
\item
Top level Makefile - This recursively descends into the client, server, and XDR directories.
\item
XDR - This directory contains:
\begin{itemize}
\item
.h file generated for every user-defined data structure in the XML file. 
\item
{\tt{xdr<type name>Marshall.c}} and {\tt{xdr<type name>Unmarshall.c}} files generated for every user-defined data type. 
\item
Makefile that generates a library from the files in this XDR directory.
\end{itemize}
\item
Client - 
This directory contains:
\begin{itemize}
\item
.c and .h files generated for every service defined in the XML file.
\item
Definition and declaration of the synchronous and asynchronous functions defined in the XML file.
\item
Definition and declaration of the asynchronous callback function defined in the XML file.
\item
Makefile that generates a library from the files in this Client directory.
\end{itemize}
\item
Server - This directory contains:

\begin{itemize}
\item
.c and.h files generated for every service defined in the XML file. 
\item
Definition and declaration of a server function for every operation defined in the XML file. 
\item
Makefile that generates a library from the files in this Server directory.
\item
{\tt{responseSend}} function for every server stub defined.
\item
{\tt{cl<Eo>IdlSyncDefer}} function, which is generated in the {\tt{<Eo>server.h}} and {\tt{<Eo>server.c file}}.
\end{itemize}

\end{itemize}
\end{flushleft}


\newpage
\begin{figure}[htp]
\centering
\includegraphics{IDL.jpg}
\caption{IDL Directory Structure}
\end{figure}
\begin{flushleft}
The IDL uses XDR to store data in a message. This is called marshalling of data. 
XDR stands for eXternal Data Representation Standard (described in RFC 1832). It is used to store data in a
machine independent format.
The reverse process of retrieving data from the message into the native
format is called unmarshalling of data.  IDL recognizes the following data types:
\begin{itemize}
\item
{\tt{ClCharT}}
\item
{\tt{ClInt8T}}
\item
{\tt{ClUint8T}}
\item
{\tt{ClInt16T}}
\item
{\tt{ClUint16T}}
\item
{\tt{ClInt32T}}
\item
{\tt{ClUint32T}}
\item
{\tt{ClInt64T}}
\item
{\tt{ClUint64T}}
\item
{\tt{ClNameT}}
\item
{\tt{ClVersionT}}
\item
{\tt{struct}} formed from other data types
\item
{\tt{union}} formed from other data types
\item
enum
\item
Pointers and arrays of the mentioned data types.
\end{itemize}

All data structures map to relevant C structures except for {\tt{union}}. A union is implemented as a structure that aggregates the respective C-style
{\tt{union}} and a member called discriminant that has the appropriate values for every member of the C-style {\tt{union}}.\par

\subsubsection{Relevant XDR Details}
In XDR, data is stored as multiples of 4 bytes (by padding, if required) in the network byte order (big endian) format. A byte is padded with 3
bytes and the 4-byte word is converted to big endian, if required.
\par
Arrays are stored as a sequence of N elements. The sequence is then padded and converted to the network byte order.
\par
Pointers are stored as 4-byte length of the number of elements being pointed to, followed by a sequence of elements (padded as required) in the 
network byte order.
\par
Structures are stored as an aggregation of the individual members. They are always multiples of 4-bytes.
\par
Unions are stored as a 4-byte discriminant (an identification of the member of the union being stored) and the member being used.
\par
If there are pointers present inside structures, they must be allocated from the heap. When the heap is used for allocation/de-allocation, destruction 
of variables becomes non-trivial as arbitrary levels of nesting for data structures are allowed. It is logical to embed the code for the destruction of 
structures in the marshalling code. Thus, marshalling code can also be used for destroying variables, if required.
\par
The algorithm for marshalling/unmarshalling arrays and pointers is separate from the data structure to which the array/pointer belongs. 
Marshalling/unmarshalling functions for arrays and pointers are wrappers which call the marshalling/unmarshalling functions for the relevant data type 
multiple times.
\subsubsection{Design of XDR APIs}
The marshalling API requires the following information:
\begin{itemize}
\item
Reference to the data structure to marshall, with relevant information such as discriminant, length variable, and so on.
\item
Message, in which the marshalled data is to be stored.
\item
Flag that indicates if a variable needs to be destroyed.
\end{itemize}
Thus the API signature is as follows:
\par
{\tt{ClRcT clXdrMarshall<Struct>(void* pGenVar, ClBufferMessageHandleT msg, ClUint32T isDelete)}}
where:
\begin{itemize}
\item
{\tt{pGenVar}} is the reference to the data structure to be marshalled.
\item
{\tt{msg}} is the message in which the marshalled data is stored (marshalling is performed only if msg != 0).
\item
{\tt{isDelete}} is the flag that indicates if {\tt{pGenVar}} should be destroyed.
\end{itemize}

The corresponding unmarshalling API is:\par
{\tt{ClRcT clXdrUnmarshall<Struct>(ClBufferMessageHandleT msg, void* pGenVar)}}
where:
\begin{itemize}
\item
{\tt{pGenVar}} is the reference to the data structure, where the marshalled data is to be stored.
\item
{\tt{msg}} is the message that is to be unmarshalled. 
\end{itemize}
This ensures that the individual elements of a data structure are handled appropriately. However, pointers or arrays must be handled differently. 
The marshalling/unmarshalling algorithms for a structure containing pointers/arrays are:\par
{\tt{\#define clXdrMarshallArray<Struct>(pointer, multiplicity, msg, isDelete) clXdrMarshallArray((pointer), sizcomponentf(<Struct>), (multiplicity), 
clXdrMarshall<Struct>, (msg), (isDelete))}}\par

{\tt{\#define clXdrUnmarshallArray<Struct>(pointer, multiplicity, msg) clXdrUnmarshallArray((pointer), sizcomponentf(<Struct>), (multiplicity), 
clXdrUnmarshall<Struct>, (msg))}}\par

{\tt{\#define clXdrMarshallPointer<Struct>(pointer, multiplicity, msg, isDelete) clXdrMarshallPointer((pointer), sizcomponentf(<Struct>), (multiplicity), 
clXdrMarshall<Struct>, (msg), (isDelete))}}\par

{\tt{\#define clXdrUnmarshallPointer<Struct>(msg,pointer)    clXdrUnmarshallPointer(msg, sizcomponentf(<Struct>), clXdrUnmarshall<Struct>, pointer)}}\par

To marshall pointers/arrays, it is not enough to pass the pointer to the data structure alone. It is necessary to pass the multiplicity of the elements 
being pointed to. These generic algorithms call the element marshalling/unmarshalling algorithms appropriately, after performing the necessary 
work on pointers/arrays.

\subsubsection{XDR Algorithms}

\begin{Desc}
\item
[Marshalling Algorithms]
\end{Desc}
In all marshalling algorithms, the message is written only if it is non-zero. The message should be 0, if the variable under consideration needs to be 
deleted. Data is converted to the network byte order before it is written to the message.

\textbf{Pointer:}\par
parameters:\par
{\tt{void* pointer,}}\par
{\tt{ClUint32T typeSize,}}\par
{\tt{ClUint32T multiplicity,}}\par
{\tt{ClXdrMarshallFuncT func,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
{\tt{ClUint32T isDelete}}\par
Algorithm
\begin{enumerate}
\item
Write the {\tt{multiplicity}} into {\tt{msg}}
\item
Return, if {\tt{multiplicity}} is zero
\item
Call the array algorithm with relevant parameters such as {\tt{pointer}}, {\tt{typeSize}}, {\tt{multiplicity}}, {\tt{func}}, {\tt{msg}}, and 
{\tt{isDelete}}.
\item
If {\tt{isDelete}}, delete the memory being pointed to
\end{enumerate}

\textbf{Array:}\par
parameters:\par
{\tt{void* array,}}\par
{\tt{ClUint32T typeSize,}}\par
{\tt{ClUint32T multiplicity,}}\par
{\tt{ClXdrMarshallFuncT func,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
{\tt{ClUint32T isDelete}}\par
Algorithm
\begin{enumerate}
\item
Return if {\tt{multiplicity}} is 0
\item
Call {\tt{func}} for every element in {\tt{array}}
\item
Increment array by {\tt{typeSize}}.
\end{enumerate}

\textbf{Struct:}\par
parameters:\par
{\tt{void* struct,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
{\tt{ClUint32T isDelete}}\par
Algorithm
\begin{enumerate}
\item
Call the appropriate marshalling functions ({\tt{andstruct-><member>, msg, isDelete}}) for every member of the structure. 
\end{enumerate}

\textbf{Union:}\par
parameters:\par
{\tt{void* union,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
{\tt{ClUint32T isDelete}}\par
Algorithm
\begin{enumerate}
\item
The {\tt{union->discriminant}} is written to {\tt{msg}}
\item
Call the marshalling function ({\tt{andunion-><union>.<member>, msg, isDelete}}) based on {\tt{union->discriminant}}.
\end{enumerate}

The marshalling function for basic types is predefined and writes the variable into the message. The functions for array and pointer to data types, that 
are smaller than 4 bytes, are also predefined as they require additional effort of padding.

\begin{Desc}
\item
[Unmarshalling Algorithms]
\end{Desc}

In unmarshalling algorithms, the message should always be non-zero. Data is converted to the host order before it is read from a message.
\par
\textbf{Pointer:}\par
parameters:\par
{\tt{void** pointer,}}\par
{\tt{ClUint32T typeSize,}}\par
{\tt{ClXdrUnmarshallFuncT func,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
Algorithm
\begin{enumerate}
\item
Read the {\tt{multiplicity}} from {\tt{msg}}
\item
If {\tt{multiplicity}} is zero, set {\tt{*pointer}} to NULL and return
\item
Allocate {\tt{*pointer}} as per {\tt{multiplicity}} from heap
\item
Call the array algorithm with relevant parameters such as {\tt{*pointer}}, {\tt{multiplicity}}, {\tt{func}}, and {\tt{msg}}.
\end{enumerate}

\textbf{Array:}\par
parameters:\par
{\tt{void* array,}}\par
{\tt{ClUint32T typeSize,}}\par
{\tt{ClUint32T multiplicity,}}\par
{\tt{ClXdrMarshallFuncT func,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
Algorithm
\begin{enumerate}
\item
Return if {\tt{multiplicity}} is 0
\item
Call {\tt{func}} for every element in {\tt{array}}
\item
Increment array by {\tt{typesize}}
\end{enumerate}

\textbf{Struct:}\par
parameters:\par
{\tt{void* struct,}}\par
{\tt{ClBufferMessageHandleT msg,}}\par
Algorithm
\begin{enumerate}
\item
Call the appropriate unmarshalling functions ({\tt{andstruct-><member>, msg}}), for every member of the structure.
\end{enumerate}

\textbf{Union:}\par
parameters:\par
{\tt{void* union,}}\par
{\tt{ClBufferMessageHandleT msg}}\par
Algorithm
\begin{enumerate}
\item
The {\tt{union->discriminant}} is read from {\tt{msg}}
\item
Call the unmarshalling function ({\tt{andunion-><union>.<member>, msg, isDelete}}) based on {\tt{union->discriminant}} 
\end{enumerate}

The unmarshalling function for basic types is predefined and reads the variable from the message. The functions for arrays and pointers to sub-4-byte 
data types are also predefined as they require the additional effort of padding.

\subsection{IDL Stubs}
IDL generates the following for every function installed in the component interface:
\begin{itemize}
\item
Synchronous client stub
\item
Asynchronous client stub
\item
Server stub
\item
Asynchronous callback
\end{itemize}

In addition, it generates two functions to install and uninstall the server functions into the component. A client function is defined by it's arguments.
Arguments or parameters are marshalled into a message that is passed to the functions residing on the server and vice versa. It is 
necessary to understand the type of arguments that can be available and how marshalling/unmarshalling can be performed. 
The arguments can be classified as follows:
\par
Classification based on direction of transfer:
\begin{itemize}
\item
{\tt{CL\_\-IN}} - These are provided as an input to a function. They are sent to the server through an input message.
\item
{\tt{CL\_\-OUT}} - These are used to return results to the caller. These parameters are sent from the server to the client in the output message.
\item
{\tt{CL\_\-INOUT}} - These act as both input and output arguments. Consequently, they are sent in both directions
\end{itemize}

Classification based on passing parameters by reference or by value:\begin{itemize}
\item
By value - This is passed as a copy. The original variable is not modified.
\item
By reference - This is passed as an address. The original variables are modified. As IDL marshalls/unmarshalls the parameters, these are 
further categorized as:
\begin{itemize}
\item
Without count - When pointers are passed without a count (size of the array), they are assumed to point to a single element.
\item
With count - When a reference is passed with a count variable (an input basic type parameter), the count variable is assumed to contain the 
number of elements being pointed to.
\end{itemize}
\end{itemize}

An argument can be classified into one of the following categories:
\begin{itemize}
\item
{\tt{CL\_\-IN}}, by value (as {\tt{CL\_\-INOUT}} and {\tt{CL\_\-OUT}} type parameters returns results to the caller, they must be passed by reference.)
\item

{\tt{CL\_\-IN}}, by reference without count
\item

{\tt{CL\_\-IN}}, by reference with count
\item

{\tt{CL\_\-INOUT}}, by reference without count
\item

{\tt{CL\_\-INOUT}}, by reference with count
\item

{\tt{CL\_\-OUT}}, by reference without count
\item

{\tt{CL\_\-OUT}}, by reference with count

\end{itemize}


\subsection{IDL Synchronous Client Stub}

The IDL synchronous client stub is generated from the component definition provided in the XML file. A stub is generated for every function installed in the
client component. 
The first argument of the stub is always the handle that contains RMD parameters and the IDL handle needs to be preinitialized. \par
the signature of the IDL synchronous client stub is as specified in the XML file with the exception that a rearrangement of parameters in {\tt{CL\_\-IN}}, {\tt{CL\_\-INOUT}} and 
{\tt{CL\_\-OUT}} order is performed.\par
Guidelines for designing synchronous client stub are:
\begin{itemize}
\item
{\tt{in}} parameters must not be deleted. These parameters are marshalled into a message. The prototype for marshalling these parameters is:\par
{\tt{clXdrMarshall<Struct>(param, inmsg, 0);}}
\item
{\tt{inout}} parameters must be destroyed and prepared to return values. The prototype for marshalling these parameters is:\par
{\tt{clXdrMarshall<Struct>(param, inmsg, 1);}}
\item
After the call, the {\tt{inout/out}} parameters are populated with the {\tt{outmsg}}. The prototype for unmarshalling these parameters is:\par
{\tt{clXdrUnmarshall<Struct>(param, outmsg);}}
\item
{\tt{out}} parameters can be assumed to be devoid of heap pointers. {\tt{inout}} parameters are made devoid of heap pointers during the marshaling call.
\item
Parameters by reference are passed to marshalling functions as is.
\item
Parameters by value are passed by reference.
\end{itemize}

\begin{Desc}
\item
[Error handling]
\end{Desc}
It is the caller's responsibility to manage the variables. Variables are deleted when as error is detected and the call returns immediately.

\begin{Desc}
\item
[Handling Name Address]
\end{Desc}

RMD recognizes numeric addresses. Hence, it is the responsibility of IDL stub to convert the name address to  a numeric address. This is performed at 
the beginning of the stub when it detects that the address passed is a name address.

\par
\textbf{Algorithm}
\begin{enumerate}
\item
Resolve address, if it is of type name.
\item
Create input message, if {\tt{in/inout}} parameters are present.
\item
Marshall {\tt{in}} parameters into input message.
\item
Marshall {\tt{inout}} parameters with destruction flag into input message.
\item
Create output message, if {\tt{out/inout}} parameters are present.
\item
Call RMD synchronously.
\item
Unmarshall {\tt{inout}} parameters from output message.
\item
Unmarshall {\tt{out}} parameters from output message.
\item
Return.
\end{enumerate}

For a function {\tt{<func>}}, client stub {\tt{<func>SyncClient}} is generated. The client header will contains:\par

{\tt{\#define <func> <func>SyncClient}}

\par
The application can now make a call to {\tt{<func>}} and if the application includes the client header, it is replaced with 
{\tt{<func>SyncClient}}.


\subsection{IDL Asynchronous Client Stub}

The asynchronous stub is similar to the sync stub with the following exceptions:
\begin{itemize}
\item
There are two additional arguments at the end of the argument list:
\begin{itemize}
\item
{\tt{void *cookie}} - Pointer provided by the application and returned to it in the callback
\item
{\tt{<component><func>AsyncCallbackT func}} - Pointer to the callback function that must be invoked when the server returns.
\end{itemize}
\item
The RMD call is an asynchronous RMD call.
\item
The output message does not contain the {\tt{out/inout}} arguments after the RMD call.
\item
The stub allocates a cookie of it's own from the heap, stores the application's cookie and the callback, and passes a reference to this cookie (stub cookie)
to the RMD call.
\item
It is named {\tt{<func>AsyncClient}} and has to be invoked likewise with the two additional parameters.
\end{itemize}

\textbf{Algorithm}
\begin{enumerate}
\item
Resolve address, if it is of type name.
\item
Create input message, if {\tt{in/inout}} parameters are present.
\item
Marshall {\tt{in}} parameters into input message.
\item
Marshall {\tt{inout}} parameters with destruction variable into input message.
\item
Create output message, if {\tt{out/inout}} parameters are present.
\item
Allocate IDL cookie and store user's cookie and callback into the IDL cookie.
\item
Call the RMD function asynchronously with IDL cookie and IDL callback as asynchronous options.
\end{enumerate}

\subsubsection{IDL Asynchronous Callback}

This is the function that is called when an asynchronous call is made and the context from the server returns. It is similar to synchronous client stub 
that is present after the synchronous RMD call returns. This function is invoked from the context of RMD. It's signature is:\par
{\tt{void <func>AsyncCallback(ClRcT rc, void *pIdlCookie, ClBufferMessageHandleT inMsgHdl, ClBufferMessageHandleT outMsgHdl)}}
Where:
\begin{itemize}
\item
{\tt{rc}} - Return value of the server function.
\item
{\tt{pIdlCookie}} - Cookie passed by the asynchronous IDL client call.
\item
{\tt{inMsgHdl}} - Message containing the input, {\tt{inout}} parameters (XDR'ed).
\item
{\tt{outMsgHdl}} - Message containing the {\tt{inout}}, output parameters (XDR'ed).
\end{itemize}

\begin{Desc}
\item
[Error Handling]
\end{Desc}
It is the responsibility of the callback to destroy the variables it creates. When an error is detected, the function returns only after destroying the 
variables it created as part of the unmarshalling operation. The call to destroy variables is:
\par
{\tt{clXdrMarshall<Struct>(param, 0, 1);}}
\par
The variable is destroyed by creating a system of {\tt{goto}} labels. When a failure is detected at any point, the {\tt{goto}} takes the code execution to an 
alternate point in the function from where all variables that were created are destroyed.
For example:
\par
{\tt{rc = createVar v1;
if (error) goto L0;\par
rc = createVar v2;
if (error) goto L1;\par
---\par
return;
/*end of normal flow*/\par
---\par
/*error flow*/\par
L1: delete v2;\par
L0: delete v1;\par
return;}}
\par
The callback function obtains the following and invokes the application's callback.
\begin{itemize}
\item
Cookie provided by the application
\item
Callback from the IDL cookie 
\end{itemize}
It unmarshalls the input parameters from the input message and the {\tt{inout}} and output parameters from the output message before calling the 
application's callback.

\textbf{Algorithm}\par
\begin{enumerate}
\item
Set all local variables to be passed to the application's callback to 0.
\item
Unmarshall {\tt{in}} parameters from input message.
\item
Unmarshall {\tt{inout}} parameters from output message.
\item
Unmarshall {\tt{out}} parameters from output message.
\item
Return.
\end{enumerate}

\subsection{IDL Server-side Code}

\subsubsection{Server Stubs}

The IDL server stub is invoked by RMD server library in response to a request from the client. This stub is installed in the client component's tables.
This stub performs a reverse operation compared to that of the sync client stub. It extracts the {\tt{in}} and {\tt{inout}} parameters from the input message and calls 
the actual server function with these parameters. When the function returns, it packs the {\tt{inout}} and {\tt{out}} parameters in the output message and destroys the 
variables it created.

\begin{Desc}
\item
[Error handling]
\end{Desc}

This is complex than the callback stub. Error handling can be viewed from the following perspectives:
\begin{itemize}
\item
Errors can occur when variables are being unmarshalled. All variables created have to be destroyed. This is achieved through the 
{\tt{goto}} system.
\item
Errors can occur after the server function is called while unmarshalling the variables. Unmarshalled/undeleted variables
have to be destroyed. This can be achieved through stack unrolling simulated by multiple labels and the {\tt{goto}} system.
\end{itemize}

\textbf{Algorithm}
\begin{enumerate}
\item
{\tt{memset}} all local variables to be passed to the server function to 0.
\item
Unmarshall input and {\tt{inout}} variables from the input message.
\item
Call the server function.
\item
Marshall {\tt{inout}} variables into output message.
\item
Marshall {\tt{out}} variables into output message.
\item
Destroy the {\tt{in}} variables.
\item
Return.

\end{enumerate}

\subsubsection{New Functions}
{\tt{ClRcT cl<service>IdlSyncDefer(ClIdlHandleT *phDefer);}}
\par
This call is used to defer the response from a function call. For example, a client makes a call to server A, to complete that request the server A 
needs to make calls to servers, B and C. These inter-server calls cannot be made synchronous as they would block the server. Hence, these calls need to be 
asynchronous, but we do not know when the response will be received. Server A cannot return to the client if synchronous call is made from the client 
or invoke the callback if an asynchronous call is made from the client.
\par
So, server A needs to defer the response it sends to the client. It can do this by making as a call to the function, 
{\tt{cl<service>IdlSyncDefer(ClIdlHandleT *phDefer)}}. This function populates the defer handle that is used later to send a response to the 
client. The response to the client is deferred and should be sent explicitly through the {\tt{clIdlSyncResponseSend()}} function.
\par

{\tt{ClRcT clIdlSyncResponseSend();}}

\par	
	When the response to a function is deferred, it should be sent explicitly through this function.
This function is generated for every server function. The first argument of this function is the {\tt{IdlHandle}} returned from a call to 
{\tt{SyncDefer}}, the second argument is the return code of the server function invoked by the client. Following this are the {\tt{INOUT}} and {\tt{OUT}}
parameters of the server function for which this {\tt{clIdlSyncResponseSend()}} function is generated.\par
	Where the client receives this call depends on the method the client used to invoke the server function. If the call was synchronous, the client 
	is unblocked only when the server executes the {\tt{clIdlSyncResponseSend()}} function. If the call was asynchronous with callback, the callback is invoked only when the ResponseSend 
	is executed.




\subsection{Clean-up}

\textbf{For Asynchronous Methods}
\begin{itemize}
\item
All the {\tt{CL\_\-IN}} parameters that are dynamically
                 allocated can be deleted after a call to the asynchronous method.
                 This cannot be performed during the callback as the argument
                 passed here is dummy (not allocated from the heap). The
                 caller must use the free function, that is equivalent to
                 the allocation function used for allocating this memory. For example,
                 if {\tt{clHeapAllocate}}, {\tt{clHeapCalloc}}, or {\tt{clHeapRealloc}}
                 was used to allocate these variables, {\tt{clHeapFree}}
                 must be used. If {\tt{malloc/realloc/calloc}} was used to
                 allocate, {\tt{free()}} must be used. 
                 \item
              All the {\tt{CL\_\-INOUT}} parameters that are dynamically
                 allocated must be deleted only in the callback function.
                 For freeing these variables, only {\tt{clHeapFree()}} must be
                 irrespective of what was used to allocate those
                 variables. 
                      \item
              All the {\tt{CL\_\-OUT}} parameters that are dynamically
                 allocated must be deleted only in the callback function.
                 For freeing these variables, only {\tt{clHeapFree()}} must be
                 used irrespective of what was used to allocate those
                 variables. 
                 \end{itemize}
 \textbf{For Synchronous Methods}

 All the dynamically allocated variables can be freed after the call and the function that performs this are {\tt{clHeapFree}} and {\tt{free()}}.
 




\chapter{Service APIs}



\section{Type Definitions}

\subsection{ClIdlHandleT}
\index{ClIdlHandleT@{ClIdlHandleT}}
\textit{typedef ClHandleT ClIdlHandleT;}
\newline
\newline
The type of handle supplied by IDL to a process or component when it is initialized. This handle is used in successive calls to IDL library functions 
so that the process can be recognized.

\subsection{ClIdlHandleObjT}
\index{ClIdlHandleObjT@{ClIdlHandleObjT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClIdlAddressT address;}\\
\>\>\>\>\textit{ClUint32T flags;}\\
\>\>\>\>\textit{ClRmdOptionsT options;}\\
\textit{\} ClIdlHandleObjT;}\end{tabbing}
The structure, {\tt{ClIdlHandleObjT}}, represents the IDL handle object. This object contains the details passed by the component during 
{\tt{clIdlHandleInitialize()}}. 
This structure is used in all IDL functions. The attributes of this structure are: 
\begin{itemize}
 \item
\textit{address} - Specifies if the address is of type name or IOC. It is
the destination address of the server side stub.
\item
\textit{flags} - Flags that can be passed to IDL.
\item
\textit{options} - RMD options such as {\tt{retries}}, {\tt{timeout}}, and {\tt{priority}}. 
 \end{itemize}
 


\subsection{ClIdlAddressT}
\index{ClIdlAddressT@{ClIdlAddressT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct \{}\\
\>\>\>\>\textit{ClUint32T                 addressType;}\\
\>\>\>\>\textit{ClIdlAddressTypeT  address;}\\
\textit{\} ClIdlAddressT;}\end{tabbing}
The structure, {\tt{ClIdlAddressT}}, contains the address passed to IDL. This is the address where the server can be found.
The structure has two attributes: 
\begin{itemize}
 \item
\textit{addressType} - Type of the address that can be one of the following:
\begin{itemize}
 \item
CL\_\-IDL\_\-ADDRESSTYPE\_\-IOC:  IOC address.
\item
CL\_\-IDL\_\-ADDRESSTYPE\_\-NAME: Name service address.
\end{itemize}
\item
\textit{address} - This is the placeholder for the address that contains the actual value of the address. 
 \end{itemize}


\subsection{ClIdlAddressTypeT}
\index{ClIdlAddressTypeT@{ClIdlAddressTypeT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef union ClIdlAddressTypeT \{}\\
\>\>\>\>\textit{ClIocAddressT           iocAddress;}\\
\>\>\>\>\textit{ClIdlNameAddressT  nameAddress;}\\
\textit{\} ClIdlAddressTypeT;} \end{tabbing}
This is the union that contains the IDL address. IDL accepts either IOC address or a name service address. The address currently in use, if defined by the addressType 
variable, is contained in the {\tt{ClIdlAddressT}} structure. This union has two attributes:
\begin{itemize}
\item
\textit{iocAddress} - A union that contains the physical, logical, or multicast address. Refer to the Service Description and API Reference for IOC Service 
document for details about {\tt{ClIocAddressT}}.
\item
\textit{nameAddress} - The name service address. 
 \end{itemize}


\subsection{ClIdlNameAddressT}
\index{ClIdlNameAddressT@{ClIdlNameAddressT}}
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
\textit{typedef struct ClIdlNameAddressT \{}\\
\>\>\>\>\textit{ClUint32T contextCookie;}\\
\>\>\>\>\textit{ClNameT name;}\\
\>\>\>\>\textit{ClUint32T attrCount;}\\
\>\>\>\>\textit{ClNameSvcAttrEntryT   attr[CL\_NS\_MAX\_NO\_ATTR];}\\
\textit{\} ClIdlNameAddressT;} \end{tabbing}
This structure, {\tt{ClIdlNameAddressT}}, contains the name service address. This address needs to be resolved through the name service. This structure contains four attributes:
\begin{itemize}
\item
\textit{contextCookie} - This is the context cookie that Name Service expects to be passed.
\item
\textit{name} - The name of the service requested.
\item
\textit{attrCount} - The number of attributes being passed
\item
\textit{attr} - The attributes being passed.
 \end{itemize}


\newpage

\section{Library Life Cycle APIs}
\subsection{clIdlHandleInitialize}
\index{clIdlHandleInitialize@{clIdlHandleInitialize}}
\hypertarget{pageidl201}{}\paragraph{cl\-Idl\-Handle\-Initialize}\label{pageidl201}
\begin{Desc}
\item[Synopsis:]Initializes the IDL handle with the RMD parameters and the server destination. \end{Desc}
\begin{Desc}
\item[Header File:]clIdlApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        ClRcT clIdlHandleInitialize(
                                		CL_IN  ClIdlHandlcomponentbj *pIdlObj,
                		                CL_OUT ClIdlHandleT   *pHandle);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Idl\-Obj:}](in) Object of the IDL handle. This contains information required to communicate with the destination component.
\item[{\em p\-Handle:}](out) Handle of the IDL object used in subsequent calls to IDL.\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]IDL initialized successfully.
\item[{\em CL\_\-IDL\_\-RC(CL\_\-ERR\_\-NULL\_\-POINTER):}]{\tt{pIdlObj}} or {\tt{pHandle}} contains a NULL pointer.
\item[{\em CL\_\-IDL\_\-RC(CL\_\-ERR\_\-NO\_\-MEMORY):}]IDL or a module of IDL is out of memory. Thus, the service cannot be provided at this time. 
This can be a transient problem.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to initialize the IDL handle with various RMD parameters. After it is initialized, a handle is returned that is 
used for all subsequent calls to IDL API functions. RMD options such as server address and flags are set to the values passed in this
function.
\end{Desc}
\begin{Desc}
\item[Library File:]lib\-Cl\-Idl.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageidl204}{cl\-Idl\-Handle\-Finalize}, \hyperlink{pageidl202}{cl\-Idl\-Handle\-Update}. \end{Desc}
\newpage

\subsection{clIdlHandleFinalize}
\index{clIdlHandleFinalize@{clIdlHandleFinalize}}
\hypertarget{pageidl204}{}\paragraph{cl\-Idl\-Handle\-Finalize}\label{pageidl204}
\begin{Desc}
\item[Synopsis:]Removes the IDL handle and frees all the resources allocated during initialization of IDL handle. \end{Desc}
\begin{Desc}
\item[Header File:]clIdlApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        ClRcT clIdlHandleFinalize(
                          			CL_IN ClIdlHandleT handle );
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em handle:}](in) Handle of the IDL object. This handle is obtained from a previous call to the {\tt{clIdlInitialize()}} function.\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]The function executed successfully. The handle is destroyed and cannot be used.\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to destroy the IDL handle. This deletes the handle created by the library and frees the resources allocated to it
during initialization.\end{Desc}
\begin{Desc}
\item[Library File:]lib\-Cl\-Idl.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageidl201}{cl\-Idl\-Handle\-Initialize}. \end{Desc}

\newpage

\section{Functional APIs}
\subsection{clIdlHandleUpdate}
\index{clIdlHandleUpdate@{clIdlHandleUpdate}}
\hypertarget{pageidl202}{}\paragraph{cl\-Idl\-Handle\-Update}\label{pageidl202}
\begin{Desc}
\item[Synopsis:]Updates the IDL handle. This function can be used to change the address of the server stub, RMD options, or RMD flags.\end{Desc}
\begin{Desc}
\item[Header File:]clIdlApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}        ClRcT clIdlHandleUpdate(
                            			CL_IN ClIdlHandleT    handle,
                		                CL_IN ClIdlHandlcomponentbj *pIdlObj);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Handle:}](in) Handle of the IDL object obtained from a previous call to the {\tt{clIdlInitialize()}} function.
\item[{\em p\-Idl\-Obj:}] (in) Object of the IDL handle used in subsequent calls to IDL. \end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]The function executed successfully and the handle is updated with the new IDL object.
\item[{\em CL\_\-IDL\_\-RC(CL\_\-ERR\_\-NULL\_\-POINTER):}]{\tt{pIdlObj}} contains a NULL pointer.
\item[{\em CL\_\-IDL\_\-RC(CL\_\-ERR\_\-NO\_\-MEMORY):}]IDL or a module of IDL is out of memory. Thus, the service cannot be provided at this time. 
This can be a transient problem.
\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to update the IDL handle with various IDL parameters. \end{Desc}
\begin{Desc}
\item[Library File:]lib\-Cl\-Idl.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]\hyperlink{pageidl201}{cl\-Idl\-Handle\-Initialize}, \hyperlink{pageidl204}{cl\-Idl\-Handle\-Finalize}. \end{Desc}
\newpage


\subsection{clIdlVersionCheck}
\index{clIdlVersionCheck@{clIdlVersionCheck}}
\hypertarget{pageidl203}{}\paragraph{cl\-Idl\-Version\-Check}\label{pageidl203}
\begin{Desc}
\item[Synopsis:]Verifies if the current version of IDL service is the version expected by the client.\end{Desc}
\begin{Desc}
\item[Header File:]clIdlApi.h\end{Desc}
\begin{Desc}
\item[Syntax:]

\footnotesize\begin{verbatim}   ClRcT clIdlVersionCheck(
                           		CL_INOUT     ClVersionT  *pVersion);
\end{verbatim}
\normalsize
\end{Desc}
\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p\-Version:}](in/out) As an input parameter, this acts as a pointer to the required IDL Service version. As an output parameter, it contains 
the version of IDL service supported by current implementation of OpenClovis ASP.
\end{description}
\end{Desc}
\begin{Desc}
\item[Return values:]
\begin{description}
\item[{\em CL\_\-OK:}]The function executed successfully. 
\item[{\em CL\_\-IDL\_\-RC(CL\_\-ERR\_\-NULL\_\-POINTER):}]{\tt{pVersion}} contains a NULL pointer.\end{description}
\end{Desc}
\begin{Desc}
\item[Description:]This function is used to check the version of the IDL library. If it is invalid, the function returns the supported version.\end{Desc}
\begin{Desc}
\item[Library File:]lib\-Cl\-Idl.a\end{Desc}
\begin{Desc}
\item[Related Function(s):]None. \end{Desc}

\chapter{Service Management Information Model}
TBD

\chapter{Service Notifications}
TBD

\chapter{Configuration}
TBD

\chapter{Debug CLI}
TBD


\end{flushleft}