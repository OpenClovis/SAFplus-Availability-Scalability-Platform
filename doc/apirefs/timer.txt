/**
 *  \defgroup timer Timer
 *  \brief The Timer library allows O(10000) time interval based callbacks.
 */
 
//-----------------------------------------------------------

/**
 *  \defgroup timer_intro Functional Description
 *  \brief Description of the Timer Library.
 *  \ingroup timer
 *
 *  The basic POSIX timer signal is woefully inadaquate for any non-trivial
 *  interval timing application, such as protocol timers, aging of
 *  data structures, or periodic activities like polling.
 *
 *  The Timer library creates an efficient means to schedule
 *  tens of thousands of timers of short or long duration, limited
 *  only by available memory, and CPU speed.
 */

//-----------------------------------------------------------

/**

\defgroup timer_usage API Usage Examples
\brief Code Examples.  
\ingroup timer
 
\code

//Initialize the timer library 
//Timer library will be initialized by EO infrastructure, 
//if the basic eo libs for timer is turned on.
 rc = clTimerLibInitialize();
 //Create a one shot timer which expires after 2 seconds.
 //timer callback will be invoked from new thread.
 ClTimerTimeOutT  timeout = {.tsSec = 2, .tsMilliSec = 0};
 ClTimerTypeT     timerType = CL_TIMER_ONE_SHOT;
 ClTimerContextT  timerContext = CL_TIMER_SEPARATE_CONTEXT;
 ClTimeXXXT       *pCookie     = NULL;
 ClTimerHandleT   timerHandle  = CL_HANDLE_INVALID_VALUE;

 pCookie = clHeapCalloc(sizeof(ClTimeXXXT), sizeof(ClCharT));
 if( NULL == pCookie )
{
    //no memory error should be returned and cleanup should be done.
}
*pCookie = YYYY;
 rc = clTimerCreateAndStart(&timeout, timerType, timerContext,
                            clTstTimerCallback, &timerCookie,
                            &timerHandle);
// timer callback which will be invoked from timer library
ClRcT clTstTimerCallback(void *pCookie)
{
    /*
     *  Once the timer expired based on the context, this particular callback
     * will be invoked
     */
     return CL_OK;
}
// Just creating repetitive timer for 2 seconds
 ClTimerTimeOutT  timeout = {.tsSec = 2, .tsMilliSec = 0};
 ClTimerTypeT     timerType    = CL_TIMER_REPETITIVE;
 ClTimerContextT  timerContext = CL_TIMER_SEPARATE_CONTEXT;
 ClTimeXXXT       *pCookie     = NULL;
 ClTimerHandleT   timerHandle  = CL_HANDLE_INVALID_VALUE;

 pCookie = clHeapCalloc(sizeof(ClTimeXXXT), sizeof(ClCharT));
 if( NULL == pCookie )
{
    //no memory error should be returned and cleanup should be done.
}
*pCookie = YYYY;
 rc = clTimerCreate(&timeout, timerType, timerContext,
                    clTstTimerCallback, &timerCookie,
                    &timerHandle);
if( CL_OK != rc )
{
    //Error occured, proper action should be taken
}
// The above step has just created the timer, so need to start timer.  
// Once the timer expires the callback will be invoked repetitively with span
// of 3 seconds.
rc  = clTimerStart(&timerHandle);
if( CL_OK != rc )
{
    // Error occcured, proper cleanup and action should be taken 
}
//Updating the timer, while it is running.
ClTimerTypeT  newTimeout = {.tsSec = 3, .tsMilliSec = 0};

rc = clTimerUpdate(timerHandle, &newTimeout); 
if( CL_OK != rc )
{
    //Error occured, please take apporiate action
}
//Stopping the timer
rc = clTimerStop(timerHandle);
if( CL_OK != rc )
{
    //Error occured, please take appropriate action
}
//Deleting the timer
rc = clTimerDelete(timerHandle);
if( CL_OK != rc )
{
    //Error occured, please take appropriate action
}
//Finalized again it will be done by EO infrastructure,if you have not explicitly
//initialized.
rc = clTimerLibFinalize();
if( CL_OK != rc )
{
    //Error occured, please take appropriate again
}

\endcode

*/

//-----------------------------------------------------------

/**
 *  \defgroup timer_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup timer
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting Timer 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_TIMER "Timer Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_timer
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

//-----------------------------------------------------------

/**
 *  \defgroup timer_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup timer
 */

//-----------------------------------------------------------

