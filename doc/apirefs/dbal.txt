/**
 *  \defgroup dbal Database Abstraction Layer (DBAL)
 *  \brief The OpenClovis Database Abstraction Layer (DBAL) provides a standard
 *  interface for any OpenClovis ASP infrastructure component or application 
 *  to interface with the commonly used relational database.
 */

//-----------------------------------------------------------
 
/**
 *  \defgroup dbal_intro Functional Description
 *  \brief Description of DBAL.
 *  \ingroup dbal
 *  The OpenClovis Database abstraction layer is an application programming 
 *  interface which unifies the communication between a computer application
 *  and databases. Traditionally, all database vendors provide their own 
 *  interface tailored to their products which leaves it to the application
 *  programmer to implement code for all database interfaces he would like 
 *  to support.
 *
 *  OpenClovis Database abstraction layer reduces the amount of work by 
 *  providing a consistent API to the developer and hide the database 
 *  specifics behind this interface as much as possible.
 *
 *  The OpenClovis Database Abstraction Layer (DBAL) provides a standard 
 *  interface for any OpenClovis ASP infrastructure component or application 
 *  to interface with the commonly used relational database.
 *  OpenClovis ASP R3.0 currently supports the following databases:
 *
 *  \arg  SQLite Database
 *  \arg  GNU Database Manager
 *  \arg  Berkeley Database
 *
 *  OpenClovis DBAL Library can be used by any software component that requires
 *  huge data storage. As an abstraction layer, it interacts with different 
 *  databases. The underlying database can be changed to one of the supported 
 *  databases by modifying DBAL configuration file clDbalConfig.xml present in
 *  the ASP config directory.
 *
 *  This interface can be used for operations like dumping information to a 
 *  database, reading back information from a database, etc for either persistent 
 *  storage or offline processing. DBAL is also a standalone library with no 
 *  dependencies on any other OpenClovis ASP components.
 *
 */

//-----------------------------------------------------------

/**
 *  \defgroup dbal_usage API Usage Examples
 *  \brief Code Examples.
 *  \ingroup dbal
 *  Global Data which are nedded for the code examples
 *  \code
 * 
 *  #define NUMBER_OF_ITEMS 10 
 * 
 *  typedef struct exampleData{  
 *      ClCharT key[3];  
 *      ClCharT data[30];  
 *  }ExampleDataT;  
 *
 *  ExampleDataT exmp[] = { {"1","Ravi Kumar Singh"},  
 *                          {"2","Har Gagan Sahai"},  
 *                          {"3","Deepak B"},  
 *                          {"4","Karthic A R"},  
 *                          {"5","Amit Gourgonda"},  
 *                          {"6","Vikram"},  
 *                          {"7","Jnanesh Kumar"},  
 *                          {"8","Naveen"},  
 *                          {"9","Mayank Rungta"},  
 *                          {"10","Ramesh"}  
 *                      };  
 *                               
 *  \endcode
 *                               
 *  \b Example 1 - Normal Database operation (without transaction support) :
 *
 *  Open or create a Database instance. In the following example, dbFlag can 
 *  take one of the following values : CL_DB_CREAT, CL_DB_OPEN, CL_DB_APPEND
 *  \code 
 *
 *  ClDBHandleT dbHandle    = CL_HANDLE_INVALID_VALUE; 
 *  ClDBFileT   dbFile      = "/tmp/my_db_file";
 *  ClDBNameT   dbName      = "/tmp/myDB.db";
 *  ClUint32T   maxKeySize  = 5;
 *  ClUint32T   maxRecSize  = 30;
 *  ClDBFlagT   dbFlag      = CL_DB_CREAT;
 *
 *  rc = clDbalOpen(dbName, dbFile, dbFlag, maxKeySize, 
 *                  maxRecSize, &dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Create: could not create database. rc = [0x %x]", 
 *             CL_GET_ERROR_CODE(rc));  
 *      return rc;
 *  }  
 *  \endcode 
 *
 *  Add ten records into the database
 *  \code
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {    
 *      rc = clDbalRecordInsert(dbHandle, 
 *                              (ClDBKeyHandleT)exmp[i].key, 
 *                              strlen(exmp[i].key)+1,
 *                              (ClDBRecordHandleT)exmp[i].data, 
 *                              strlen(exmp[i].data)+1);  
 *                            
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not add record into DB, rc = [0x %x]", 
 *                 CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully added %s:%s", exmp[i].key, exmp[i].data);  
 *      }  
 *  }  
 *  \endcode
 * 
 *  Retrieve all ten records which were added earlier.
 *  \code
 *
 *  ClCharT     *data       = NULL;
 *  ClUint32T   dataSize    = 0;
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++)
 *  {   
 *      rc = clDbalRecordGet(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                           strlen(exmp[i].key)+1,  
 *                           (ClDBRecordHandleT*)&data, 
 *                           &dataSize);  
 *      if(CL_OK != rc)
 *      {  
 *          printf("Could not get record from DB. rc = [0x %x]", 
 *                 CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully retrieved record with key=%s:%s", 
 *                  exmp[i].key, data);  
 *          clDbalRecordFree(dbHandle, (ClDBRecordHandleT)data);
 *      }  
 *  }  
 *  \endcode
 * 
 *  Replace the ten records which were added earlier.
 *  \code
 * 
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalRecordReplace(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                       strlen(exmp[i].key)+1,  
 *                       (ClDBRecordHandleT)exmp[NUMBER_OF_ITEMS-i-1].data, 
 *                       strlen(exmp[NUMBER_OF_ITEMS-i-1].data)+1);  
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not replace record into DB. rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *        printf("Successfully replaced %s:%s", exmp[i].key, 
 *                exmp[NUMBER_OF_ITEMS-i-1].data);  
 *      }  
 *  }  
 *  \endcode
 * 
 * 
 *  Traverse through the database and get the records :
 * 
 *  [1] Return the first record  
 *  \code
 *
 *  ClCharT     *firstKey           = NULL;
 *  ClUint32T   firstKeySize        = 0;
 *  ClCharT     *firstData          = NULL;
 *  ClUint32T   firstDataSize       = 0;
 *
 *  rc = clDbalFirstRecordGet(dbHandle, (ClDBKeyHandleT*)&firstKey, 
 *                            &firstKeySize, (ClDBRecordHandleT*)&firstData, 
 *                            &firstDataSize);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not retrieve the first record. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;  
 *  }  
 *  else 
 *  {  
 *      printf("Retrieved record %s:%s", key, data);  
 *      clDbalKeyFree(dbHandle, (ClDBKeyHandleT)firstKey);
 *      clDbalRecordFree(dbHandle, (ClDBRecordHandleT)firstData);
 *  }  
 *  \endcode
 * 
 *  [2] Get the next nine records.
 *  \code
 * 
 *  /* Get the 'firstKey' using call to clDbalFirstRecordGet() */
 *  ClCharT *curkey  = firstKey;
 * 
 *  for(i = 1; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalNextRecordGet(dbHandle, (ClDBKeyHandleT)curKey, curKeySize, 
 *                               (ClDBKeyHandleT*)&nextKey, &nextKeySize,  
 *                               (ClDBRecordHandleT*)&nextData, &dataSize);  
 *      if(CL_OK != rc) 
 *      {  
 *        printf("Could not retrieve the next record. rc = 	%d", 
 *                CL_GET_ERROR_CODE(rc));  
 *        return rc;  
 *      }  
 *      else
 *      {  
 *          printf("Retrieved record %s:%s", nextKey, nextData);  
 *          clDbalKeyFree(dbHandle, (ClDBKeyHandleT)curKey);
 *          clDbalRecordFree(dbHandle, (ClDBRecordHandleT)nextData);
 *          curKey = nextKey;
 *      }  
 *  }  
 *  /*Free The last key */
 *  clDbalKeyFree(dbHandle, (ClDBKeyHandleT)curKey);
 *  \endcode
 * 
 *  Delete all ten records added earlier 
 *  \code
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalRecordDelete(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                              strlen(exmp[i].key)+1);  
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not delete record from DB. rc = [0x %x]", 
 *                 CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully deleted record with key=%s", exmp[i].key);  
 *      }  
 *  }  
 *  \endcode
 * 
 *  Close the Database   
 *  \code
 *  rc = clDbalClose(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not close the database");  
 *      return rc;  
 *  }  
 *  \endcode
 * 
 *
 *  \b Example 2 - Database operation with transaction support :
 *
 *  Note : In case of GDBM and SQLite, transaction APIs are not supported.  
 *
 *  Open or create a Database instance with transaction support.
 *  \code 
 *
 *  ClDBHandleT dbHandle    = CL_HANDLE_INVALID_VALUE; 
 *  ClDBFileT   dbFile      = "/tmp/my_db_file";
 *  ClDBNameT   dbName      = "/tmp/myDB.db";
 *  ClUint32T   maxKeySize  = 5;
 *  ClUint32T   maxRecSize  = 30;
 *  ClDBFlagT   dbFlag      = CL_DB_CREAT;
 *
 *  rc = clDbalTxnOpen(dbName, dbFile, dbFlag, maxKeySize, maxRecSize, 
 *                     &dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Create: could not create database. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;
 *  }  
 *  \endcode 
 *
 *  Begins a transaction if transaction protection is needed.  
 *  In case of GDBM, transaction APIs are not supported.  
 *
 *  \code
 *  rc = clDbalTransactionBegin(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not begin transaction. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;
 *  }  
 *  \endcode
 *
 *  Add ten records into the database
 *  \code
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {    
 *      rc = clDbalRecordInsert(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                              strlen(exmp[i].key)+1,
 *                              (ClDBRecordHandleT)exmp[i].data, 
 *                              strlen(exmp[i].data)+1);  
 *                            
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not add record into DB, rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully added %s:%s", exmp[i].key, exmp[i].data);  
 *      }  
 *  }  
 *  \endcode
 * 
 *  Retrieve all ten records which were added earlier.
 *  \code
 *
 *  ClCharT     *data       = NULL;
 *  ClUint32T   dataSize    = 0;
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++)
 *  {   
 *      rc = clDbalRecordGet(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                           strlen(exmp[i].key)+1,  
 *                           (ClDBRecordHandleT*)&data, 
 *                           &dataSize);  
 *      if(CL_OK != rc)
 *      {  
 *          printf("Could not get record from DB. rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully retrieved record with key=%s:%s", 
 *                  exmp[i].key, data);  
 *          clDbalRecordFree(dbHandle, (ClDBRecordHandleT)data);
 *      }  
 *  }  
 *  \endcode
 * 
 *  Replace the ten records which were added earlier.
 *  \code
 * 
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalRecordReplace(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                       strlen(exmp[i].key)+1,  
 *                       (ClDBRecordHandleT)exmp[NUMBER_OF_ITEMS-i-1].data, 
 *                       strlen(exmp[NUMBER_OF_ITEMS-i-1].data)+1);  
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not replace record into DB. rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *        printf("Successfully replaced %s:%s", exmp[i].key, 
 *                exmp[NUMBER_OF_ITEMS-i-1].data);  
 *      }  
 *  }  
 *  \endcode
 * 
 * 
 *  Traverse through the database and get the records :
 * 
 *  [1] Return the first record  
 *  \code
 *
 *  ClCharT     *firstKey           = NULL;
 *  ClUint32T   firstKeySize        = 0;
 *  ClCharT     *firstData          = NULL;
 *  ClUint32T   firstDataSize       = 0;
 *
 *  rc = clDbalFirstRecordGet(dbHandle, (ClDBKeyHandleT*)&firstKey, 
 *                            &firstKeySize, 
 *                            (ClDBRecordHandleT*)&firstData, 
 *                            &firstDataSize);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not retrieve the first record. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;  
 *  }  
 *  else 
 *  {  
 *      printf("Retrieved record %s:%s", key, data);  
 *      clDbalKeyFree(dbHandle, (ClDBKeyHandleT)firstKey);
 *      clDbalRecordFree(dbHandle, (ClDBRecordHandleT)firstData);
 *  }  
 *  \endcode
 * 
 *  [2] Get the next nine records.
 *  \code
 * 
 *  /* Get the 'firstKey' using call to clDbalFirstRecordGet() */
 *  ClCharT *curkey  = firstKey;
 * 
 *  for(i = 1; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalNextRecordGet(dbHandle, (ClDBKeyHandleT)curKey, curKeySize, 
 *                               (ClDBKeyHandleT*)&nextKey, &nextKeySize,  
 *                               (ClDBRecordHandleT*)&nextData, &dataSize);  
 *      if(CL_OK != rc) 
 *      {  
 *        printf("Could not retrieve the next record. rc = 	%d", 
 *                CL_GET_ERROR_CODE(rc));  
 *        return rc;  
 *      }  
 *      else
 *      {  
 *          printf("Retrieved record %s:%s", nextKey, nextData);  
 *          clDbalKeyFree(dbHandle, (ClDBKeyHandleT)curKey);
 *          clDbalRecordFree(dbHandle, (ClDBRecordHandleT)nextData);
 *          curKey = nextKey;
 *      }  
 *  }  
 *  /*Free The last key */
 *  clDbalKeyFree(dbHandle, (ClDBKeyHandleT)curKey);
 *  \endcode
 * 
 *  Delete all ten records added earlier 
 *  \code
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {   
 *      rc = clDbalRecordDelete(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                              strlen(exmp[i].key)+1);  
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not delete record from DB. rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully deleted record with key=%s", exmp[i].key);  
 *      }  
 *  }  
 *  \endcode
 * 
 *  Commit the transaction. Committing a transaction will result in saving 
 *  all the changes done upto this point to the database.
 *  \code
 * 
 *  rc = clDbalTransactionCommit(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not commit transaction. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;  
 *  }  
 *  else 
 *  {  
 *      printf("Successfully commited transaction");  
 *  }  
 *  \endcode
 *
 *  You need to begin the new transaction by calling clDbalTransactionBegin()
 *  after every commit or abort.
 *
 *  \code
 *  rc = clDbalTransactionBegin(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not begin transaction. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;
 *  }  
 *  \endcode
 *
 *  Add ten records into the database in the new transaction
 *  \code
 *
 *  for(i = 0; i < NUMBER_OF_ITEMS; i++) 
 *  {    
 *      rc = clDbalRecordInsert(dbHandle, (ClDBKeyHandleT)exmp[i].key, 
 *                              strlen(exmp[i].key)+1,
 *                              (ClDBRecordHandleT)exmp[i].data, 
 *                              strlen(exmp[i].data)+1);  
 *                            
 *      if(CL_OK != rc) 
 *      {  
 *          printf("Could not add record into DB, rc = [0x %x]", 
 *                  CL_GET_ERROR_CODE(rc));  
 *          return rc;  
 *      }  
 *      else 
 *      {  
 *          printf("Successfully added %s:%s", exmp[i].key, exmp[i].data);  
 *      }  
 *  }  
 *  \endcode
 * 
 *  Abort the transaction. Aborting a transaction will result in a rollback
 *  upto the point where the transaction was started.  
 *  \code
 * 
 *  rc = clDbalTransactionAbort(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not abort transaction. rc = [0x %x]", 
 *              CL_GET_ERROR_CODE(rc));  
 *      return rc;  
 *  }  
 *  else 
 *  {  
 *      printf("Successfully aborted transaction");  
 *  }  
 *  \endcode
 * 
 *  Close the Database   
 *  \code
 *  rc = clDbalClose(dbHandle);  
 *  if(CL_OK != rc) 
 *  {  
 *      printf("Could not close the database");  
 *      return rc;  
 *  }  
 *  \endcode
 */

//-----------------------------------------------------------

/**
 *  \defgroup dbal_error Error/Return Codes
 *  \brief Common and Component specific Error Codes.
 *  \ingroup dbal
 *
 *  The majority of ASP API functions return a <b>Return Code</b> as their return value. 
 *  A zero return code (CL_OK) always indicates success. Non-zero return codes 
 *  always carry two types of information, masked into one single value: 
 *  a <b>Component Identifier</b> and an <b>Error Code</b>. The component 
 *  identifier identifies the component (or software layer) in which the problem 
 *  occurred, while the error code describes the nature of the problem. 
 *  Some error codes are common across all components, while others are 
 *  component specific. 
 *
 *  The format of the Return Codes is 0xCCNNNN (given in hex),
 *  where 0xCC is the ASP Component Identifier and 0xNNNN is the Error Code.
 *
 *  \note <b>Only the Error Codes are listed as Return values 
 *  in the Function Documentation of the API Reference pages. The real 
 *  return value also contains the Component Identifier!</b> 
 *
 *  The following links are useful while interpreting DBAL 
 *  generated return codes:
 *  - \ref apirefs_errorcodes_compid_CL_CID_DBAL "DBAL Component Identifier"
 *  - \ref apirefs_errorcodes_common
 *  - \ref apirefs_errorcodes_dbal
 *
 *  For further details and information about all error/return codes visit 
 *  page \ref apirefs_errorcodes.
 */

//-----------------------------------------------------------
 
/**
 *  \defgroup dbal_apis API Reference Pages
 *  \brief Defines, Structures, Typedefs, Functions.
 *  \ingroup dbal
 */

//-----------------------------------------------------------
